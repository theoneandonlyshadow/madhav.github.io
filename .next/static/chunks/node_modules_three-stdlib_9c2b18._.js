(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_three-stdlib_9c2b18._.js", {

"[project]/node_modules/three-stdlib/misc/MorphBlendMesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MorphBlendMesh": (()=>MorphBlendMesh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class MorphBlendMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(geometry, material){
        super(geometry, material);
        this.animationsMap = {};
        this.animationsList = [];
        const numFrames = Object.keys(this.morphTargetDictionary).length;
        const name = "__default";
        const startFrame = 0;
        const endFrame = numFrames - 1;
        const fps = numFrames / 1;
        this.createAnimation(name, startFrame, endFrame, fps);
        this.setAnimationWeight(name, 1);
    }
    createAnimation(name, start, end, fps) {
        const animation = {
            start,
            end,
            length: end - start + 1,
            fps,
            duration: (end - start) / fps,
            lastFrame: 0,
            currentFrame: 0,
            active: false,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: false,
            mirroredLoop: false
        };
        this.animationsMap[name] = animation;
        this.animationsList.push(animation);
    }
    autoCreateAnimations(fps) {
        const pattern = /([a-z]+)_?(\d+)/i;
        let firstAnimation;
        const frameRanges = {};
        let i = 0;
        for(const key in this.morphTargetDictionary){
            const chunks = key.match(pattern);
            if (chunks && chunks.length > 1) {
                const name = chunks[1];
                if (!frameRanges[name]) frameRanges[name] = {
                    start: Infinity,
                    end: -Infinity
                };
                const range = frameRanges[name];
                if (i < range.start) range.start = i;
                if (i > range.end) range.end = i;
                if (!firstAnimation) firstAnimation = name;
            }
            i++;
        }
        for(const name in frameRanges){
            const range = frameRanges[name];
            this.createAnimation(name, range.start, range.end, fps);
        }
        this.firstAnimation = firstAnimation;
    }
    setAnimationDirectionForward(name) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.direction = 1;
            animation.directionBackwards = false;
        }
    }
    setAnimationDirectionBackward(name) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.direction = -1;
            animation.directionBackwards = true;
        }
    }
    setAnimationFPS(name, fps) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.fps = fps;
            animation.duration = (animation.end - animation.start) / animation.fps;
        }
    }
    setAnimationDuration(name, duration) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.duration = duration;
            animation.fps = (animation.end - animation.start) / animation.duration;
        }
    }
    setAnimationWeight(name, weight) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.weight = weight;
        }
    }
    setAnimationTime(name, time) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.time = time;
        }
    }
    getAnimationTime(name) {
        let time = 0;
        const animation = this.animationsMap[name];
        if (animation) {
            time = animation.time;
        }
        return time;
    }
    getAnimationDuration(name) {
        let duration = -1;
        const animation = this.animationsMap[name];
        if (animation) {
            duration = animation.duration;
        }
        return duration;
    }
    playAnimation(name) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.time = 0;
            animation.active = true;
        } else {
            console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
        }
    }
    stopAnimation(name) {
        const animation = this.animationsMap[name];
        if (animation) {
            animation.active = false;
        }
    }
    update(delta) {
        for(let i = 0, il = this.animationsList.length; i < il; i++){
            const animation = this.animationsList[i];
            if (!animation.active) continue;
            const frameTime = animation.duration / animation.length;
            animation.time += animation.direction * delta;
            if (animation.mirroredLoop) {
                if (animation.time > animation.duration || animation.time < 0) {
                    animation.direction *= -1;
                    if (animation.time > animation.duration) {
                        animation.time = animation.duration;
                        animation.directionBackwards = true;
                    }
                    if (animation.time < 0) {
                        animation.time = 0;
                        animation.directionBackwards = false;
                    }
                }
            } else {
                animation.time = animation.time % animation.duration;
                if (animation.time < 0) animation.time += animation.duration;
            }
            const keyframe = animation.start + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
            const weight = animation.weight;
            if (keyframe !== animation.currentFrame) {
                this.morphTargetInfluences[animation.lastFrame] = 0;
                this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
                this.morphTargetInfluences[keyframe] = 0;
                animation.lastFrame = animation.currentFrame;
                animation.currentFrame = keyframe;
            }
            let mix = animation.time % frameTime / frameTime;
            if (animation.directionBackwards) mix = 1 - mix;
            if (animation.currentFrame !== animation.lastFrame) {
                this.morphTargetInfluences[animation.currentFrame] = mix * weight;
                this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
            } else {
                this.morphTargetInfluences[animation.currentFrame] = weight;
            }
        }
    }
}
;
 //# sourceMappingURL=MorphBlendMesh.js.map
}}),
"[project]/node_modules/three-stdlib/misc/MD2CharacterComplex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MD2CharacterComplex": (()=>MD2CharacterComplex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MD2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/MD2Loader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$MorphBlendMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/MorphBlendMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
class MD2CharacterComplex {
    constructor(){
        this.scale = 1;
        this.animationFPS = 6;
        this.transitionFrames = 15;
        this.maxSpeed = 275;
        this.maxReverseSpeed = -275;
        this.frontAcceleration = 600;
        this.backAcceleration = 600;
        this.frontDecceleration = 600;
        this.angularSpeed = 2.5;
        this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
        this.meshBody = null;
        this.meshWeapon = null;
        this.controls = null;
        this.skinsBody = [];
        this.skinsWeapon = [];
        this.weapons = [];
        this.currentSkin = void 0;
        this.onLoadComplete = function() {};
        this.meshes = [];
        this.animations = {};
        this.loadCounter = 0;
        this.speed = 0;
        this.bodyOrientation = 0;
        this.walkSpeed = this.maxSpeed;
        this.crouchSpeed = this.maxSpeed * 0.5;
        this.activeAnimation = null;
        this.oldAnimation = null;
    }
    enableShadows(enable) {
        for(let i = 0; i < this.meshes.length; i++){
            this.meshes[i].castShadow = enable;
            this.meshes[i].receiveShadow = enable;
        }
    }
    setVisible(enable) {
        for(let i = 0; i < this.meshes.length; i++){
            this.meshes[i].visible = enable;
            this.meshes[i].visible = enable;
        }
    }
    shareParts(original) {
        this.animations = original.animations;
        this.walkSpeed = original.walkSpeed;
        this.crouchSpeed = original.crouchSpeed;
        this.skinsBody = original.skinsBody;
        this.skinsWeapon = original.skinsWeapon;
        const mesh = this._createPart(original.meshBody.geometry, this.skinsBody[0]);
        mesh.scale.set(this.scale, this.scale, this.scale);
        this.root.position.y = original.root.position.y;
        this.root.add(mesh);
        this.meshBody = mesh;
        this.meshes.push(mesh);
        for(let i = 0; i < original.weapons.length; i++){
            const meshWeapon = this._createPart(original.weapons[i].geometry, this.skinsWeapon[i]);
            meshWeapon.scale.set(this.scale, this.scale, this.scale);
            meshWeapon.visible = false;
            meshWeapon.name = original.weapons[i].name;
            this.root.add(meshWeapon);
            this.weapons[i] = meshWeapon;
            this.meshWeapon = meshWeapon;
            this.meshes.push(meshWeapon);
        }
    }
    loadParts(config) {
        const scope = this;
        function loadTextures(baseUrl, textureUrls) {
            const textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"]();
            const textures = [];
            for(let i = 0; i < textureUrls.length; i++){
                textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete);
                textures[i].mapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UVMapping"];
                textures[i].name = textureUrls[i];
                if ("colorSpace" in textures[i]) textures[i].colorSpace = "srgb";
                else textures[i].encoding = 3001;
            }
            return textures;
        }
        function checkLoadingComplete() {
            scope.loadCounter -= 1;
            if (scope.loadCounter === 0) scope.onLoadComplete();
        }
        this.animations = config.animations;
        this.walkSpeed = config.walkSpeed;
        this.crouchSpeed = config.crouchSpeed;
        this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;
        const weaponsTextures = [];
        for(let i = 0; i < config.weapons.length; i++)weaponsTextures[i] = config.weapons[i][1];
        this.skinsBody = loadTextures(config.baseUrl + "skins/", config.skins);
        this.skinsWeapon = loadTextures(config.baseUrl + "skins/", weaponsTextures);
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MD2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MD2Loader"]();
        loader.load(config.baseUrl + config.body, function(geo) {
            const boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
            boundingBox.setFromBufferAttribute(geo.attributes.position);
            scope.root.position.y = -scope.scale * boundingBox.min.y;
            const mesh = scope._createPart(geo, scope.skinsBody[0]);
            mesh.scale.set(scope.scale, scope.scale, scope.scale);
            scope.root.add(mesh);
            scope.meshBody = mesh;
            scope.meshes.push(mesh);
            checkLoadingComplete();
        });
        const generateCallback = function(index, name) {
            return function(geo) {
                const mesh = scope._createPart(geo, scope.skinsWeapon[index]);
                mesh.scale.set(scope.scale, scope.scale, scope.scale);
                mesh.visible = false;
                mesh.name = name;
                scope.root.add(mesh);
                scope.weapons[index] = mesh;
                scope.meshWeapon = mesh;
                scope.meshes.push(mesh);
                checkLoadingComplete();
            };
        };
        for(let i = 0; i < config.weapons.length; i++){
            loader.load(config.baseUrl + config.weapons[i][0], generateCallback(i, config.weapons[i][0]));
        }
    }
    setPlaybackRate(rate) {
        if (this.meshBody) this.meshBody.duration = this.meshBody.baseDuration / rate;
        if (this.meshWeapon) this.meshWeapon.duration = this.meshWeapon.baseDuration / rate;
    }
    setWireframe(wireframeEnabled) {
        if (wireframeEnabled) {
            if (this.meshBody) this.meshBody.material = this.meshBody.materialWireframe;
            if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialWireframe;
        } else {
            if (this.meshBody) this.meshBody.material = this.meshBody.materialTexture;
            if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialTexture;
        }
    }
    setSkin(index) {
        if (this.meshBody && this.meshBody.material.wireframe === false) {
            this.meshBody.material.map = this.skinsBody[index];
            this.currentSkin = index;
        }
    }
    setWeapon(index) {
        for(let i = 0; i < this.weapons.length; i++)this.weapons[i].visible = false;
        const activeWeapon = this.weapons[index];
        if (activeWeapon) {
            activeWeapon.visible = true;
            this.meshWeapon = activeWeapon;
            if (this.activeAnimation) {
                activeWeapon.playAnimation(this.activeAnimation);
                this.meshWeapon.setAnimationTime(this.activeAnimation, this.meshBody.getAnimationTime(this.activeAnimation));
            }
        }
    }
    setAnimation(animationName) {
        if (animationName === this.activeAnimation || !animationName) return;
        if (this.meshBody) {
            this.meshBody.setAnimationWeight(animationName, 0);
            this.meshBody.playAnimation(animationName);
            this.oldAnimation = this.activeAnimation;
            this.activeAnimation = animationName;
            this.blendCounter = this.transitionFrames;
        }
        if (this.meshWeapon) {
            this.meshWeapon.setAnimationWeight(animationName, 0);
            this.meshWeapon.playAnimation(animationName);
        }
    }
    update(delta) {
        if (this.controls) this.updateMovementModel(delta);
        if (this.animations) {
            this.updateBehaviors();
            this.updateAnimations(delta);
        }
    }
    updateAnimations(delta) {
        let mix = 1;
        if (this.blendCounter > 0) {
            mix = (this.transitionFrames - this.blendCounter) / this.transitionFrames;
            this.blendCounter -= 1;
        }
        if (this.meshBody) {
            this.meshBody.update(delta);
            this.meshBody.setAnimationWeight(this.activeAnimation, mix);
            this.meshBody.setAnimationWeight(this.oldAnimation, 1 - mix);
        }
        if (this.meshWeapon) {
            this.meshWeapon.update(delta);
            this.meshWeapon.setAnimationWeight(this.activeAnimation, mix);
            this.meshWeapon.setAnimationWeight(this.oldAnimation, 1 - mix);
        }
    }
    updateBehaviors() {
        const controls = this.controls;
        const animations = this.animations;
        let moveAnimation, idleAnimation;
        if (controls.crouch) {
            moveAnimation = animations["crouchMove"];
            idleAnimation = animations["crouchIdle"];
        } else {
            moveAnimation = animations["move"];
            idleAnimation = animations["idle"];
        }
        if (controls.jump) {
            moveAnimation = animations["jump"];
            idleAnimation = animations["jump"];
        }
        if (controls.attack) {
            if (controls.crouch) {
                moveAnimation = animations["crouchAttack"];
                idleAnimation = animations["crouchAttack"];
            } else {
                moveAnimation = animations["attack"];
                idleAnimation = animations["attack"];
            }
        }
        if (controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight) {
            if (this.activeAnimation !== moveAnimation) {
                this.setAnimation(moveAnimation);
            }
        }
        if (Math.abs(this.speed) < 0.2 * this.maxSpeed && !(controls.moveLeft || controls.moveRight || controls.moveForward || controls.moveBackward)) {
            if (this.activeAnimation !== idleAnimation) {
                this.setAnimation(idleAnimation);
            }
        }
        if (controls.moveForward) {
            if (this.meshBody) {
                this.meshBody.setAnimationDirectionForward(this.activeAnimation);
                this.meshBody.setAnimationDirectionForward(this.oldAnimation);
            }
            if (this.meshWeapon) {
                this.meshWeapon.setAnimationDirectionForward(this.activeAnimation);
                this.meshWeapon.setAnimationDirectionForward(this.oldAnimation);
            }
        }
        if (controls.moveBackward) {
            if (this.meshBody) {
                this.meshBody.setAnimationDirectionBackward(this.activeAnimation);
                this.meshBody.setAnimationDirectionBackward(this.oldAnimation);
            }
            if (this.meshWeapon) {
                this.meshWeapon.setAnimationDirectionBackward(this.activeAnimation);
                this.meshWeapon.setAnimationDirectionBackward(this.oldAnimation);
            }
        }
    }
    updateMovementModel(delta) {
        function exponentialEaseOut(k) {
            return k === 1 ? 1 : -Math.pow(2, -10 * k) + 1;
        }
        const controls = this.controls;
        if (controls.crouch) this.maxSpeed = this.crouchSpeed;
        else this.maxSpeed = this.walkSpeed;
        this.maxReverseSpeed = -this.maxSpeed;
        if (controls.moveForward) this.speed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.speed + delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);
        if (controls.moveBackward) this.speed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.speed - delta * this.backAcceleration, this.maxReverseSpeed, this.maxSpeed);
        const dir = 1;
        if (controls.moveLeft) {
            this.bodyOrientation += delta * this.angularSpeed;
            this.speed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);
        }
        if (controls.moveRight) {
            this.bodyOrientation -= delta * this.angularSpeed;
            this.speed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed);
        }
        if (!(controls.moveForward || controls.moveBackward)) {
            if (this.speed > 0) {
                const k = exponentialEaseOut(this.speed / this.maxSpeed);
                this.speed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.speed - k * delta * this.frontDecceleration, 0, this.maxSpeed);
            } else {
                const k = exponentialEaseOut(this.speed / this.maxReverseSpeed);
                this.speed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(this.speed + k * delta * this.backAcceleration, this.maxReverseSpeed, 0);
            }
        }
        const forwardDelta = this.speed * delta;
        this.root.position.x += Math.sin(this.bodyOrientation) * forwardDelta;
        this.root.position.z += Math.cos(this.bodyOrientation) * forwardDelta;
        this.root.rotation.y = this.bodyOrientation;
    }
    // internal
    _createPart(geometry, skinMap) {
        const materialWireframe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]({
            color: 16755200,
            wireframe: true,
            morphTargets: true,
            morphNormals: true
        });
        const materialTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]({
            color: 16777215,
            wireframe: false,
            map: skinMap,
            morphTargets: true,
            morphNormals: true
        });
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$MorphBlendMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MorphBlendMesh"](geometry, materialTexture);
        mesh.rotation.y = -Math.PI / 2;
        mesh.materialTexture = materialTexture;
        mesh.materialWireframe = materialWireframe;
        mesh.autoCreateAnimations(this.animationFPS);
        return mesh;
    }
}
;
 //# sourceMappingURL=MD2CharacterComplex.js.map
}}),
"[project]/node_modules/three-stdlib/misc/ConvexObjectBreaker.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ConvexObjectBreaker": (()=>ConvexObjectBreaker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ConvexGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/ConvexGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
const _v1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const ConvexObjectBreaker = /* @__PURE__ */ (()=>{
    class ConvexObjectBreaker2 {
        constructor(minSizeForBreak = 1.4, smallDelta = 1e-4){
            this.minSizeForBreak = minSizeForBreak;
            this.smallDelta = smallDelta;
            this.tempLine1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line3"]();
            this.tempPlane1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
            this.tempPlane2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
            this.tempPlane_Cut = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
            this.tempCM1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempCM2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_P0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_P1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_P2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_N0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_N1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_AB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempVector3_CB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.tempResultObjects = {
                object1: null,
                object2: null
            };
            this.segments = [];
            const n = 30 * 30;
            for(let i = 0; i < n; i++)this.segments[i] = false;
        }
        prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {
            const userData = object.userData;
            userData.mass = mass;
            userData.velocity = velocity.clone();
            userData.angularVelocity = angularVelocity.clone();
            userData.breakable = breakable;
        }
        /*
     * @param {int} maxRadialIterations Iterations for radial cuts.
     * @param {int} maxRandomIterations Max random iterations for not-radial cuts
     *
     * Returns the array of pieces
     */ subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {
            const debris = [];
            const tempPlane1 = this.tempPlane1;
            const tempPlane2 = this.tempPlane2;
            this.tempVector3.addVectors(pointOfImpact, normal);
            tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);
            const maxTotalIterations = maxRandomIterations + maxRadialIterations;
            const scope = this;
            function subdivideRadial(subObject, startAngle, endAngle, numIterations) {
                if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {
                    debris.push(subObject);
                    return;
                }
                let angle = Math.PI;
                if (numIterations === 0) {
                    tempPlane2.normal.copy(tempPlane1.normal);
                    tempPlane2.constant = tempPlane1.constant;
                } else {
                    if (numIterations <= maxRadialIterations) {
                        angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;
                        scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);
                        tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);
                    } else {
                        angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;
                        scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);
                        scope.tempVector3_3.copy(normal).add(subObject.position);
                        tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);
                    }
                }
                scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);
                const obj1 = scope.tempResultObjects.object1;
                const obj2 = scope.tempResultObjects.object2;
                if (obj1) {
                    subdivideRadial(obj1, startAngle, angle, numIterations + 1);
                }
                if (obj2) {
                    subdivideRadial(obj2, angle, endAngle, numIterations + 1);
                }
            }
            subdivideRadial(object, 0, 2 * Math.PI, 0);
            return debris;
        }
        cutByPlane(object, plane, output) {
            const geometry = object.geometry;
            const coords = geometry.attributes.position.array;
            const normals = geometry.attributes.normal.array;
            const numPoints = coords.length / 3;
            let numFaces = numPoints / 3;
            let indices = geometry.getIndex();
            if (indices) {
                indices = indices.array;
                numFaces = indices.length / 3;
            }
            function getVertexIndex(faceIdx, vert) {
                const idx = faceIdx * 3 + vert;
                return indices ? indices[idx] : idx;
            }
            const points1 = [];
            const points2 = [];
            const delta = this.smallDelta;
            const numPointPairs = numPoints * numPoints;
            for(let i = 0; i < numPointPairs; i++)this.segments[i] = false;
            const p0 = this.tempVector3_P0;
            const p1 = this.tempVector3_P1;
            const n0 = this.tempVector3_N0;
            const n1 = this.tempVector3_N1;
            for(let i = 0; i < numFaces - 1; i++){
                const a1 = getVertexIndex(i, 0);
                const b1 = getVertexIndex(i, 1);
                const c1 = getVertexIndex(i, 2);
                n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);
                for(let j = i + 1; j < numFaces; j++){
                    const a2 = getVertexIndex(j, 0);
                    const b2 = getVertexIndex(j, 1);
                    const c2 = getVertexIndex(j, 2);
                    n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);
                    const coplanar = 1 - n0.dot(n1) < delta;
                    if (coplanar) {
                        if (a1 === a2 || a1 === b2 || a1 === c2) {
                            if (b1 === a2 || b1 === b2 || b1 === c2) {
                                this.segments[a1 * numPoints + b1] = true;
                                this.segments[b1 * numPoints + a1] = true;
                            } else {
                                this.segments[c1 * numPoints + a1] = true;
                                this.segments[a1 * numPoints + c1] = true;
                            }
                        } else if (b1 === a2 || b1 === b2 || b1 === c2) {
                            this.segments[c1 * numPoints + b1] = true;
                            this.segments[b1 * numPoints + c1] = true;
                        }
                    }
                }
            }
            const localPlane = this.tempPlane_Cut;
            object.updateMatrix();
            ConvexObjectBreaker2.transformPlaneToLocalSpace(plane, object.matrix, localPlane);
            for(let i = 0; i < numFaces; i++){
                const va = getVertexIndex(i, 0);
                const vb = getVertexIndex(i, 1);
                const vc = getVertexIndex(i, 2);
                for(let segment = 0; segment < 3; segment++){
                    const i0 = segment === 0 ? va : segment === 1 ? vb : vc;
                    const i1 = segment === 0 ? vb : segment === 1 ? vc : va;
                    const segmentState = this.segments[i0 * numPoints + i1];
                    if (segmentState) continue;
                    this.segments[i0 * numPoints + i1] = true;
                    this.segments[i1 * numPoints + i0] = true;
                    p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);
                    p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);
                    let mark0 = 0;
                    let d = localPlane.distanceToPoint(p0);
                    if (d > delta) {
                        mark0 = 2;
                        points2.push(p0.clone());
                    } else if (d < -delta) {
                        mark0 = 1;
                        points1.push(p0.clone());
                    } else {
                        mark0 = 3;
                        points1.push(p0.clone());
                        points2.push(p0.clone());
                    }
                    let mark1 = 0;
                    d = localPlane.distanceToPoint(p1);
                    if (d > delta) {
                        mark1 = 2;
                        points2.push(p1.clone());
                    } else if (d < -delta) {
                        mark1 = 1;
                        points1.push(p1.clone());
                    } else {
                        mark1 = 3;
                        points1.push(p1.clone());
                        points2.push(p1.clone());
                    }
                    if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {
                        this.tempLine1.start.copy(p0);
                        this.tempLine1.end.copy(p1);
                        let intersection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                        intersection = localPlane.intersectLine(this.tempLine1, intersection);
                        if (intersection === null) {
                            console.error("Internal error: segment does not intersect plane.");
                            output.segmentedObject1 = null;
                            output.segmentedObject2 = null;
                            return 0;
                        }
                        points1.push(intersection);
                        points2.push(intersection.clone());
                    }
                }
            }
            const newMass = object.userData.mass * 0.5;
            this.tempCM1.set(0, 0, 0);
            let radius1 = 0;
            const numPoints1 = points1.length;
            if (numPoints1 > 0) {
                for(let i = 0; i < numPoints1; i++)this.tempCM1.add(points1[i]);
                this.tempCM1.divideScalar(numPoints1);
                for(let i = 0; i < numPoints1; i++){
                    const p = points1[i];
                    p.sub(this.tempCM1);
                    radius1 = Math.max(radius1, p.x, p.y, p.z);
                }
                this.tempCM1.add(object.position);
            }
            this.tempCM2.set(0, 0, 0);
            let radius2 = 0;
            const numPoints2 = points2.length;
            if (numPoints2 > 0) {
                for(let i = 0; i < numPoints2; i++)this.tempCM2.add(points2[i]);
                this.tempCM2.divideScalar(numPoints2);
                for(let i = 0; i < numPoints2; i++){
                    const p = points2[i];
                    p.sub(this.tempCM2);
                    radius2 = Math.max(radius2, p.x, p.y, p.z);
                }
                this.tempCM2.add(object.position);
            }
            let object1 = null;
            let object2 = null;
            let numObjects = 0;
            if (numPoints1 > 4) {
                object1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ConvexGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConvexGeometry"](points1), object.material);
                object1.position.copy(this.tempCM1);
                object1.quaternion.copy(object.quaternion);
                this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);
                numObjects++;
            }
            if (numPoints2 > 4) {
                object2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ConvexGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConvexGeometry"](points2), object.material);
                object2.position.copy(this.tempCM2);
                object2.quaternion.copy(object.quaternion);
                this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);
                numObjects++;
            }
            output.object1 = object1;
            output.object2 = object2;
            return numObjects;
        }
        static transformFreeVector(v, m) {
            const x = v.x, y = v.y, z = v.z;
            const e = m.elements;
            v.x = e[0] * x + e[4] * y + e[8] * z;
            v.y = e[1] * x + e[5] * y + e[9] * z;
            v.z = e[2] * x + e[6] * y + e[10] * z;
            return v;
        }
        static transformFreeVectorInverse(v, m) {
            const x = v.x, y = v.y, z = v.z;
            const e = m.elements;
            v.x = e[0] * x + e[1] * y + e[2] * z;
            v.y = e[4] * x + e[5] * y + e[6] * z;
            v.z = e[8] * x + e[9] * y + e[10] * z;
            return v;
        }
        static transformTiedVectorInverse(v, m) {
            const x = v.x, y = v.y, z = v.z;
            const e = m.elements;
            v.x = e[0] * x + e[1] * y + e[2] * z - e[12];
            v.y = e[4] * x + e[5] * y + e[6] * z - e[13];
            v.z = e[8] * x + e[9] * y + e[10] * z - e[14];
            return v;
        }
        static transformPlaneToLocalSpace(plane, m, resultPlane) {
            resultPlane.normal.copy(plane.normal);
            resultPlane.constant = plane.constant;
            const referencePoint = ConvexObjectBreaker2.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);
            ConvexObjectBreaker2.transformFreeVectorInverse(resultPlane.normal, m);
            resultPlane.constant = -referencePoint.dot(resultPlane.normal);
        }
    }
    return ConvexObjectBreaker2;
})();
;
 //# sourceMappingURL=ConvexObjectBreaker.js.map
}}),
"[project]/node_modules/three-stdlib/misc/GPUComputationRenderer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GPUComputationRenderer": (()=>GPUComputationRenderer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class GPUComputationRenderer {
    constructor(sizeX, sizeY, renderer){
        this.variables = [];
        this.currentTextureIndex = 0;
        let dataType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"];
        const scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        const camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Camera"]();
        camera.position.z = 1;
        const passThruUniforms = {
            passThruTexture: {
                value: null
            }
        };
        const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](2, 2), passThruShader);
        scene.add(mesh);
        this.setDataType = function(type) {
            dataType = type;
            return this;
        };
        this.addVariable = function(variableName, computeFragmentShader, initialValueTexture) {
            const material = this.createShaderMaterial(computeFragmentShader);
            const variable = {
                name: variableName,
                initialValueTexture,
                material,
                dependencies: null,
                renderTargets: [],
                wrapS: null,
                wrapT: null,
                minFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"],
                magFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"]
            };
            this.variables.push(variable);
            return variable;
        };
        this.setVariableDependencies = function(variable, dependencies) {
            variable.dependencies = dependencies;
        };
        this.init = function() {
            if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has("OES_texture_float") === false) {
                return "No OES_texture_float support for float textures.";
            }
            if (renderer.capabilities.maxVertexTextures === 0) {
                return "No support for vertex shader textures.";
            }
            for(let i = 0; i < this.variables.length; i++){
                const variable = this.variables[i];
                variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
                variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
                this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);
                this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);
                const material = variable.material;
                const uniforms = material.uniforms;
                if (variable.dependencies !== null) {
                    for(let d = 0; d < variable.dependencies.length; d++){
                        const depVar = variable.dependencies[d];
                        if (depVar.name !== variable.name) {
                            let found = false;
                            for(let j = 0; j < this.variables.length; j++){
                                if (depVar.name === this.variables[j].name) {
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                return "Variable dependency not found. Variable=" + variable.name + ", dependency=" + depVar.name;
                            }
                        }
                        uniforms[depVar.name] = {
                            value: null
                        };
                        material.fragmentShader = "\nuniform sampler2D " + depVar.name + ";\n" + material.fragmentShader;
                    }
                }
            }
            this.currentTextureIndex = 0;
            return null;
        };
        this.compute = function() {
            const currentTextureIndex = this.currentTextureIndex;
            const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;
            for(let i = 0, il = this.variables.length; i < il; i++){
                const variable = this.variables[i];
                if (variable.dependencies !== null) {
                    const uniforms = variable.material.uniforms;
                    for(let d = 0, dl = variable.dependencies.length; d < dl; d++){
                        const depVar = variable.dependencies[d];
                        uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;
                    }
                }
                this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);
            }
            this.currentTextureIndex = nextTextureIndex;
        };
        this.getCurrentRenderTarget = function(variable) {
            return variable.renderTargets[this.currentTextureIndex];
        };
        this.getAlternateRenderTarget = function(variable) {
            return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
        };
        this.dispose = function() {
            mesh.geometry.dispose();
            mesh.material.dispose();
            const variables = this.variables;
            for(let i = 0; i < variables.length; i++){
                const variable = variables[i];
                if (variable.initialValueTexture) variable.initialValueTexture.dispose();
                const renderTargets = variable.renderTargets;
                for(let j = 0; j < renderTargets.length; j++){
                    const renderTarget = renderTargets[j];
                    renderTarget.dispose();
                }
            }
        };
        function addResolutionDefine(materialShader) {
            materialShader.defines.resolution = "vec2( " + sizeX.toFixed(1) + ", " + sizeY.toFixed(1) + " )";
        }
        this.addResolutionDefine = addResolutionDefine;
        function createShaderMaterial(computeFragmentShader, uniforms) {
            uniforms = uniforms || {};
            const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
                uniforms,
                vertexShader: getPassThroughVertexShader(),
                fragmentShader: computeFragmentShader
            });
            addResolutionDefine(material);
            return material;
        }
        this.createShaderMaterial = createShaderMaterial;
        this.createRenderTarget = function(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {
            sizeXTexture = sizeXTexture || sizeX;
            sizeYTexture = sizeYTexture || sizeY;
            wrapS = wrapS || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
            wrapT = wrapT || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
            minFilter = minFilter || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            magFilter = magFilter || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            const renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](sizeXTexture, sizeYTexture, {
                wrapS,
                wrapT,
                minFilter,
                magFilter,
                format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
                type: dataType,
                depthBuffer: false
            });
            return renderTarget;
        };
        this.createTexture = function() {
            const data = new Float32Array(sizeX * sizeY * 4);
            const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"](data, sizeX, sizeY, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]);
            texture.needsUpdate = true;
            return texture;
        };
        this.renderTexture = function(input, output) {
            passThruUniforms.passThruTexture.value = input;
            this.doRenderTarget(passThruShader, output);
            passThruUniforms.passThruTexture.value = null;
        };
        this.doRenderTarget = function(material, output) {
            const currentRenderTarget = renderer.getRenderTarget();
            const currentXrEnabled = renderer.xr.enabled;
            const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
            const currentOutputColorSpace = renderer.outputColorSpace;
            const currentToneMapping = renderer.toneMapping;
            renderer.xr.enabled = false;
            renderer.shadowMap.autoUpdate = false;
            if ("outputColorSpace" in renderer) renderer.outputColorSpace = "srgb-linear";
            else renderer.encoding = 3e3;
            renderer.toneMapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoToneMapping"];
            mesh.material = material;
            renderer.setRenderTarget(output);
            renderer.render(scene, camera);
            mesh.material = passThruShader;
            renderer.xr.enabled = currentXrEnabled;
            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
            renderer.outputColorSpace = currentOutputColorSpace;
            renderer.toneMapping = currentToneMapping;
            renderer.setRenderTarget(currentRenderTarget);
        };
        function getPassThroughVertexShader() {
            return "void main()	{\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n";
        }
        function getPassThroughFragmentShader() {
            return "uniform sampler2D passThruTexture;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n	gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n";
        }
    }
}
;
 //# sourceMappingURL=GPUComputationRenderer.js.map
}}),
"[project]/node_modules/three-stdlib/misc/Gyroscope.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Gyroscope": (()=>Gyroscope)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _translationObject = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _quaternionObject = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
const _scaleObject = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _translationWorld = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _quaternionWorld = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
const _scaleWorld = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class Gyroscope extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(){
        super();
    }
    updateMatrixWorld(force) {
        this.matrixAutoUpdate && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent !== null) {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                this.matrixWorld.decompose(_translationWorld, _quaternionWorld, _scaleWorld);
                this.matrix.decompose(_translationObject, _quaternionObject, _scaleObject);
                this.matrixWorld.compose(_translationWorld, _quaternionObject, _scaleWorld);
            } else {
                this.matrixWorld.copy(this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        for(let i = 0, l = this.children.length; i < l; i++){
            this.children[i].updateMatrixWorld(force);
        }
    }
}
;
 //# sourceMappingURL=Gyroscope.js.map
}}),
"[project]/node_modules/three-stdlib/misc/MorphAnimMesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MorphAnimMesh": (()=>MorphAnimMesh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class MorphAnimMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(geometry, material){
        super(geometry, material);
        this.type = "MorphAnimMesh";
        this.mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](this);
        this.activeAction = null;
    }
    setDirectionForward() {
        this.mixer.timeScale = 1;
    }
    setDirectionBackward() {
        this.mixer.timeScale = -1;
    }
    playAnimation(label, fps) {
        if (this.activeAction) {
            this.activeAction.stop();
            this.activeAction = null;
        }
        const clip = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"].findByName(this, label);
        if (clip) {
            const action = this.mixer.clipAction(clip);
            action.timeScale = clip.tracks.length * fps / clip.duration;
            this.activeAction = action.play();
        } else {
            throw new Error("THREE.MorphAnimMesh: animations[" + label + "] undefined in .playAnimation()");
        }
    }
    updateAnimation(delta) {
        this.mixer.update(delta);
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](this);
        return this;
    }
}
;
 //# sourceMappingURL=MorphAnimMesh.js.map
}}),
"[project]/node_modules/three-stdlib/misc/RollerCoaster.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RollerCoasterGeometry": (()=>RollerCoasterGeometry),
    "RollerCoasterLiftersGeometry": (()=>RollerCoasterLiftersGeometry),
    "RollerCoasterShadowGeometry": (()=>RollerCoasterShadowGeometry),
    "SkyGeometry": (()=>SkyGeometry),
    "TreesGeometry": (()=>TreesGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class RollerCoasterGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(curve, divisions){
        super();
        const vertices = [];
        const normals = [];
        const colors = [];
        const color1 = [
            1,
            1,
            1
        ];
        const color2 = [
            1,
            1,
            0
        ];
        const up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
        const forward = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const right = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        const prevQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const prevPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        prevPoint.copy(curve.getPointAt(0));
        const step = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-0.225, 0, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, -0.05, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, -0.175, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, -0.05, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0.225, 0, 0),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, -0.175, 0)
        ];
        const PI2 = Math.PI * 2;
        let sides = 5;
        const tube1 = [];
        for(let i = 0; i < sides; i++){
            const angle = i / sides * PI2;
            tube1.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));
        }
        sides = 6;
        const tube2 = [];
        for(let i = 0; i < sides; i++){
            const angle = i / sides * PI2;
            tube2.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));
        }
        const vector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        function drawShape(shape, color) {
            normal.set(0, 0, -1).applyQuaternion(quaternion);
            for(let j = 0; j < shape.length; j++){
                vector.copy(shape[j]);
                vector.applyQuaternion(quaternion);
                vector.add(point);
                vertices.push(vector.x, vector.y, vector.z);
                normals.push(normal.x, normal.y, normal.z);
                colors.push(color[0], color[1], color[2]);
            }
            normal.set(0, 0, 1).applyQuaternion(quaternion);
            for(let j = shape.length - 1; j >= 0; j--){
                vector.copy(shape[j]);
                vector.applyQuaternion(quaternion);
                vector.add(point);
                vertices.push(vector.x, vector.y, vector.z);
                normals.push(normal.x, normal.y, normal.z);
                colors.push(color[0], color[1], color[2]);
            }
        }
        const vector1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        function extrudeShape(shape, offset2, color) {
            for(let j = 0, jl = shape.length; j < jl; j++){
                const point1 = shape[j];
                const point2 = shape[(j + 1) % jl];
                vector1.copy(point1).add(offset2);
                vector1.applyQuaternion(quaternion);
                vector1.add(point);
                vector2.copy(point2).add(offset2);
                vector2.applyQuaternion(quaternion);
                vector2.add(point);
                vector3.copy(point2).add(offset2);
                vector3.applyQuaternion(prevQuaternion);
                vector3.add(prevPoint);
                vector4.copy(point1).add(offset2);
                vector4.applyQuaternion(prevQuaternion);
                vector4.add(prevPoint);
                vertices.push(vector1.x, vector1.y, vector1.z);
                vertices.push(vector2.x, vector2.y, vector2.z);
                vertices.push(vector4.x, vector4.y, vector4.z);
                vertices.push(vector2.x, vector2.y, vector2.z);
                vertices.push(vector3.x, vector3.y, vector3.z);
                vertices.push(vector4.x, vector4.y, vector4.z);
                normal1.copy(point1);
                normal1.applyQuaternion(quaternion);
                normal1.normalize();
                normal2.copy(point2);
                normal2.applyQuaternion(quaternion);
                normal2.normalize();
                normal3.copy(point2);
                normal3.applyQuaternion(prevQuaternion);
                normal3.normalize();
                normal4.copy(point1);
                normal4.applyQuaternion(prevQuaternion);
                normal4.normalize();
                normals.push(normal1.x, normal1.y, normal1.z);
                normals.push(normal2.x, normal2.y, normal2.z);
                normals.push(normal4.x, normal4.y, normal4.z);
                normals.push(normal2.x, normal2.y, normal2.z);
                normals.push(normal3.x, normal3.y, normal3.z);
                normals.push(normal4.x, normal4.y, normal4.z);
                colors.push(color[0], color[1], color[2]);
                colors.push(color[0], color[1], color[2]);
                colors.push(color[0], color[1], color[2]);
                colors.push(color[0], color[1], color[2]);
                colors.push(color[0], color[1], color[2]);
                colors.push(color[0], color[1], color[2]);
            }
        }
        const offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 1; i <= divisions; i++){
            point.copy(curve.getPointAt(i / divisions));
            up.set(0, 1, 0);
            forward.subVectors(point, prevPoint).normalize();
            right.crossVectors(up, forward).normalize();
            up.crossVectors(forward, right);
            const angle = Math.atan2(forward.x, forward.z);
            quaternion.setFromAxisAngle(up, angle);
            if (i % 2 === 0) {
                drawShape(step, color2);
            }
            extrudeShape(tube1, offset.set(0, -0.125, 0), color2);
            extrudeShape(tube2, offset.set(0.2, 0, 0), color1);
            extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);
            prevPoint.copy(point);
            prevQuaternion.copy(quaternion);
        }
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(vertices), 3));
        this.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(normals), 3));
        this.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(colors), 3));
    }
}
class RollerCoasterLiftersGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(curve, divisions){
        super();
        const vertices = [];
        const normals = [];
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        const up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const tangent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const tube1 = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0.05, -0.05),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0.05, 0.05),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, -0.05, 0)
        ];
        const tube2 = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-0.05, 0, 0.05),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-0.05, 0, -0.05),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0.05, 0, 0)
        ];
        const tube3 = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0.05, 0, -0.05),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0.05, 0, 0.05),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-0.05, 0, 0)
        ];
        const vector1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        function extrudeShape(shape, fromPoint2, toPoint2) {
            for(let j = 0, jl = shape.length; j < jl; j++){
                const point1 = shape[j];
                const point2 = shape[(j + 1) % jl];
                vector1.copy(point1);
                vector1.applyQuaternion(quaternion);
                vector1.add(fromPoint2);
                vector2.copy(point2);
                vector2.applyQuaternion(quaternion);
                vector2.add(fromPoint2);
                vector3.copy(point2);
                vector3.applyQuaternion(quaternion);
                vector3.add(toPoint2);
                vector4.copy(point1);
                vector4.applyQuaternion(quaternion);
                vector4.add(toPoint2);
                vertices.push(vector1.x, vector1.y, vector1.z);
                vertices.push(vector2.x, vector2.y, vector2.z);
                vertices.push(vector4.x, vector4.y, vector4.z);
                vertices.push(vector2.x, vector2.y, vector2.z);
                vertices.push(vector3.x, vector3.y, vector3.z);
                vertices.push(vector4.x, vector4.y, vector4.z);
                normal1.copy(point1);
                normal1.applyQuaternion(quaternion);
                normal1.normalize();
                normal2.copy(point2);
                normal2.applyQuaternion(quaternion);
                normal2.normalize();
                normal3.copy(point2);
                normal3.applyQuaternion(quaternion);
                normal3.normalize();
                normal4.copy(point1);
                normal4.applyQuaternion(quaternion);
                normal4.normalize();
                normals.push(normal1.x, normal1.y, normal1.z);
                normals.push(normal2.x, normal2.y, normal2.z);
                normals.push(normal4.x, normal4.y, normal4.z);
                normals.push(normal2.x, normal2.y, normal2.z);
                normals.push(normal3.x, normal3.y, normal3.z);
                normals.push(normal4.x, normal4.y, normal4.z);
            }
        }
        const fromPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const toPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 1; i <= divisions; i++){
            point.copy(curve.getPointAt(i / divisions));
            tangent.copy(curve.getTangentAt(i / divisions));
            const angle = Math.atan2(tangent.x, tangent.z);
            quaternion.setFromAxisAngle(up, angle);
            if (point.y > 10) {
                fromPoint.set(-0.75, -0.35, 0);
                fromPoint.applyQuaternion(quaternion);
                fromPoint.add(point);
                toPoint.set(0.75, -0.35, 0);
                toPoint.applyQuaternion(quaternion);
                toPoint.add(point);
                extrudeShape(tube1, fromPoint, toPoint);
                fromPoint.set(-0.7, -0.3, 0);
                fromPoint.applyQuaternion(quaternion);
                fromPoint.add(point);
                toPoint.set(-0.7, -point.y, 0);
                toPoint.applyQuaternion(quaternion);
                toPoint.add(point);
                extrudeShape(tube2, fromPoint, toPoint);
                fromPoint.set(0.7, -0.3, 0);
                fromPoint.applyQuaternion(quaternion);
                fromPoint.add(point);
                toPoint.set(0.7, -point.y, 0);
                toPoint.applyQuaternion(quaternion);
                toPoint.add(point);
                extrudeShape(tube3, fromPoint, toPoint);
            } else {
                fromPoint.set(0, -0.2, 0);
                fromPoint.applyQuaternion(quaternion);
                fromPoint.add(point);
                toPoint.set(0, -point.y, 0);
                toPoint.applyQuaternion(quaternion);
                toPoint.add(point);
                extrudeShape(tube3, fromPoint, toPoint);
            }
        }
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(vertices), 3));
        this.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(normals), 3));
    }
}
class RollerCoasterShadowGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(curve, divisions){
        super();
        const vertices = [];
        const up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
        const forward = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        const prevQuaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const prevPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        prevPoint.copy(curve.getPointAt(0));
        prevPoint.y = 0;
        const vector1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 1; i <= divisions; i++){
            point.copy(curve.getPointAt(i / divisions));
            point.y = 0;
            forward.subVectors(point, prevPoint);
            const angle = Math.atan2(forward.x, forward.z);
            quaternion.setFromAxisAngle(up, angle);
            vector1.set(-0.3, 0, 0);
            vector1.applyQuaternion(quaternion);
            vector1.add(point);
            vector2.set(0.3, 0, 0);
            vector2.applyQuaternion(quaternion);
            vector2.add(point);
            vector3.set(0.3, 0, 0);
            vector3.applyQuaternion(prevQuaternion);
            vector3.add(prevPoint);
            vector4.set(-0.3, 0, 0);
            vector4.applyQuaternion(prevQuaternion);
            vector4.add(prevPoint);
            vertices.push(vector1.x, vector1.y, vector1.z);
            vertices.push(vector2.x, vector2.y, vector2.z);
            vertices.push(vector4.x, vector4.y, vector4.z);
            vertices.push(vector2.x, vector2.y, vector2.z);
            vertices.push(vector3.x, vector3.y, vector3.z);
            vertices.push(vector4.x, vector4.y, vector4.z);
            prevPoint.copy(point);
            prevQuaternion.copy(quaternion);
        }
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(vertices), 3));
    }
}
class SkyGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(){
        super();
        const vertices = [];
        for(let i = 0; i < 100; i++){
            const x = Math.random() * 800 - 400;
            const y = Math.random() * 50 + 50;
            const z = Math.random() * 800 - 400;
            const size = Math.random() * 40 + 20;
            vertices.push(x - size, y, z - size);
            vertices.push(x + size, y, z - size);
            vertices.push(x - size, y, z + size);
            vertices.push(x + size, y, z - size);
            vertices.push(x + size, y, z + size);
            vertices.push(x - size, y, z + size);
        }
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(vertices), 3));
    }
}
class TreesGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(landscape){
        super();
        const vertices = [];
        const colors = [];
        const raycaster = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Raycaster"]();
        raycaster.ray.direction.set(0, -1, 0);
        const _color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        for(let i = 0; i < 2e3; i++){
            const x = Math.random() * 500 - 250;
            const z = Math.random() * 500 - 250;
            raycaster.ray.origin.set(x, 50, z);
            const intersections = raycaster.intersectObject(landscape);
            if (intersections.length === 0) continue;
            const y = intersections[0].point.y;
            const height = Math.random() * 5 + 0.5;
            let angle = Math.random() * Math.PI * 2;
            vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
            vertices.push(x, y + height, z);
            vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
            angle += Math.PI / 2;
            vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
            vertices.push(x, y + height, z);
            vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
            const random = Math.random() * 0.1;
            for(let j = 0; j < 6; j++){
                _color.setRGB(0.2 + random, 0.4 + random, 0, "srgb");
                colors.push(_color.r, _color.g, _color.b);
            }
        }
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(vertices), 3));
        this.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(colors), 3));
    }
}
;
 //# sourceMappingURL=RollerCoaster.js.map
}}),
"[project]/node_modules/three-stdlib/misc/MD2Character.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MD2Character": (()=>MD2Character)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MD2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/MD2Loader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class MD2Character {
    constructor(){
        this.scale = 1;
        this.animationFPS = 6;
        this.root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
        this.meshBody = null;
        this.meshWeapon = null;
        this.skinsBody = [];
        this.skinsWeapon = [];
        this.weapons = [];
        this.activeAnimation = null;
        this.mixer = null;
        this.onLoadComplete = function() {};
        this.loadCounter = 0;
    }
    loadParts(config) {
        const scope = this;
        function createPart(geometry, skinMap) {
            const materialWireframe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]({
                color: 16755200,
                wireframe: true,
                morphTargets: true,
                morphNormals: true
            });
            const materialTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]({
                color: 16777215,
                wireframe: false,
                map: skinMap,
                morphTargets: true,
                morphNormals: true
            });
            const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, materialTexture);
            mesh.rotation.y = -Math.PI / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.materialTexture = materialTexture;
            mesh.materialWireframe = materialWireframe;
            return mesh;
        }
        function loadTextures(baseUrl, textureUrls) {
            const textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"]();
            const textures = [];
            for(let i = 0; i < textureUrls.length; i++){
                textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete);
                textures[i].mapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UVMapping"];
                textures[i].name = textureUrls[i];
                if ("colorSpace" in textures[i]) textures[i].colorSpace = "srgb";
                else textures[i].encoding = 3001;
            }
            return textures;
        }
        function checkLoadingComplete() {
            scope.loadCounter -= 1;
            if (scope.loadCounter === 0) scope.onLoadComplete();
        }
        this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;
        const weaponsTextures = [];
        for(let i = 0; i < config.weapons.length; i++)weaponsTextures[i] = config.weapons[i][1];
        this.skinsBody = loadTextures(config.baseUrl + "skins/", config.skins);
        this.skinsWeapon = loadTextures(config.baseUrl + "skins/", weaponsTextures);
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MD2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MD2Loader"]();
        loader.load(config.baseUrl + config.body, function(geo) {
            const boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
            boundingBox.setFromBufferAttribute(geo.attributes.position);
            scope.root.position.y = -scope.scale * boundingBox.min.y;
            const mesh = createPart(geo, scope.skinsBody[0]);
            mesh.scale.set(scope.scale, scope.scale, scope.scale);
            scope.root.add(mesh);
            scope.meshBody = mesh;
            scope.meshBody.clipOffset = 0;
            scope.activeAnimationClipName = mesh.geometry.animations[0].name;
            scope.mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](mesh);
            checkLoadingComplete();
        });
        const generateCallback = function(index, name) {
            return function(geo) {
                const mesh = createPart(geo, scope.skinsWeapon[index]);
                mesh.scale.set(scope.scale, scope.scale, scope.scale);
                mesh.visible = false;
                mesh.name = name;
                scope.root.add(mesh);
                scope.weapons[index] = mesh;
                scope.meshWeapon = mesh;
                checkLoadingComplete();
            };
        };
        for(let i = 0; i < config.weapons.length; i++){
            loader.load(config.baseUrl + config.weapons[i][0], generateCallback(i, config.weapons[i][0]));
        }
    }
    setPlaybackRate(rate) {
        if (rate !== 0) {
            this.mixer.timeScale = 1 / rate;
        } else {
            this.mixer.timeScale = 0;
        }
    }
    setWireframe(wireframeEnabled) {
        if (wireframeEnabled) {
            if (this.meshBody) this.meshBody.material = this.meshBody.materialWireframe;
            if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialWireframe;
        } else {
            if (this.meshBody) this.meshBody.material = this.meshBody.materialTexture;
            if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialTexture;
        }
    }
    setSkin(index) {
        if (this.meshBody && this.meshBody.material.wireframe === false) {
            this.meshBody.material.map = this.skinsBody[index];
        }
    }
    setWeapon(index) {
        for(let i = 0; i < this.weapons.length; i++)this.weapons[i].visible = false;
        const activeWeapon = this.weapons[index];
        if (activeWeapon) {
            activeWeapon.visible = true;
            this.meshWeapon = activeWeapon;
            this.syncWeaponAnimation();
        }
    }
    setAnimation(clipName) {
        if (this.meshBody) {
            if (this.meshBody.activeAction) {
                this.meshBody.activeAction.stop();
                this.meshBody.activeAction = null;
            }
            const action = this.mixer.clipAction(clipName, this.meshBody);
            if (action) {
                this.meshBody.activeAction = action.play();
            }
        }
        this.activeClipName = clipName;
        this.syncWeaponAnimation();
    }
    syncWeaponAnimation() {
        const clipName = this.activeClipName;
        if (this.meshWeapon) {
            if (this.meshWeapon.activeAction) {
                this.meshWeapon.activeAction.stop();
                this.meshWeapon.activeAction = null;
            }
            const action = this.mixer.clipAction(clipName, this.meshWeapon);
            if (action) {
                this.meshWeapon.activeAction = action.syncWith(this.meshBody.activeAction).play();
            }
        }
    }
    update(delta) {
        if (this.mixer) this.mixer.update(delta);
    }
}
;
 //# sourceMappingURL=MD2Character.js.map
}}),
"[project]/node_modules/three-stdlib/misc/ProgressiveLightmap.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ProgressiveLightMap": (()=>ProgressiveLightMap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$potpack$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/potpack/index.mjs [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module '../_polyfill/uv1.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
class ProgressiveLightMap {
    constructor(renderer, res = 1024){
        this.renderer = renderer;
        this.res = res;
        this.lightMapContainers = [];
        this.compiled = false;
        this.scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        this.scene.background = null;
        this.tinyTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](1, 1);
        this.buffer1Active = false;
        this.firstUpdate = true;
        this.warned = false;
        const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"];
        this.progressiveLightMap1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](this.res, this.res, {
            type: format
        });
        this.progressiveLightMap2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](this.res, this.res, {
            type: format
        });
        this.uvMat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]();
        this.uvMat.uniforms = {};
        this.uvMat.onBeforeCompile = (shader)=>{
            shader.vertexShader = "#define USE_LIGHTMAP\n" + shader.vertexShader.slice(0, -1) + `	gl_Position = vec4((${UV1} - 0.5) * 2.0, 1.0, 1.0); }`;
            const bodyStart = shader.fragmentShader.indexOf("void main() {");
            shader.fragmentShader = `varying vec2 v${UV1 === "uv1" ? UV1 : "Uv2"};
` + shader.fragmentShader.slice(0, bodyStart) + "	uniform sampler2D previousShadowMap;\n	uniform float averagingWindow;\n" + shader.fragmentShader.slice(bodyStart - 1, -1) + `
vec3 texelOld = texture2D(previousShadowMap, v${UV1 === "uv1" ? UV1 : "Uv2"}).rgb;
				gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);
			}`;
            shader.uniforms.previousShadowMap = {
                value: this.progressiveLightMap1.texture
            };
            shader.uniforms.averagingWindow = {
                value: 100
            };
            this.uvMat.uniforms = shader.uniforms;
            this.uvMat.userData.shader = shader;
            this.compiled = true;
        };
    }
    /**
   * Sets these objects' materials' lightmaps and modifies their uv1's.
   * @param {Object3D} objects An array of objects and lights to set up your lightmap.
   */ addObjectsToLightMap(objects) {
        this.uv_boxes = [];
        const padding = 3 / this.res;
        for(let ob = 0; ob < objects.length; ob++){
            const object = objects[ob];
            if (object.isLight) {
                this.scene.attach(object);
                continue;
            }
            if (!object.geometry.hasAttribute("uv")) {
                console.warn("All lightmap objects need UVs!");
                continue;
            }
            if (this.blurringPlane == null) {
                this._initializeBlurPlane(this.res, this.progressiveLightMap1);
            }
            object.material.lightMap = this.progressiveLightMap2.texture;
            object.material.dithering = true;
            object.castShadow = true;
            object.receiveShadow = true;
            object.renderOrder = 1e3 + ob;
            this.uv_boxes.push({
                w: 1 + padding * 2,
                h: 1 + padding * 2,
                index: ob
            });
            this.lightMapContainers.push({
                basicMat: object.material,
                object
            });
            this.compiled = false;
        }
        const dimensions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$potpack$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.uv_boxes);
        this.uv_boxes.forEach((box)=>{
            const uv1 = objects[box.index].geometry.getAttribute("uv").clone();
            for(let i = 0; i < uv1.array.length; i += uv1.itemSize){
                uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w;
                uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h;
            }
            objects[box.index].geometry.setAttribute(UV1, uv1);
            objects[box.index].geometry.getAttribute(UV1).needsUpdate = true;
        });
    }
    /**
   * This function renders each mesh one at a time into their respective surface maps
   * @param {Camera} camera Standard Rendering Camera
   * @param {number} blendWindow When >1, samples will accumulate over time.
   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring
   */ update(camera, blendWindow = 100, blurEdges = true) {
        if (this.blurringPlane == null) {
            return;
        }
        const oldTarget = this.renderer.getRenderTarget();
        this.blurringPlane.visible = blurEdges;
        for(let l = 0; l < this.lightMapContainers.length; l++){
            this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;
            this.scene.attach(this.lightMapContainers[l].object);
        }
        if (this.firstUpdate) {
            this.renderer.setRenderTarget(this.tinyTarget);
            this.renderer.render(this.scene, camera);
            this.firstUpdate = false;
        }
        for(let l = 0; l < this.lightMapContainers.length; l++){
            this.uvMat.uniforms.averagingWindow = {
                value: blendWindow
            };
            this.lightMapContainers[l].object.material = this.uvMat;
            this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;
            this.lightMapContainers[l].object.frustumCulled = false;
        }
        const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;
        const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;
        this.renderer.setRenderTarget(activeMap);
        this.uvMat.uniforms.previousShadowMap = {
            value: inactiveMap.texture
        };
        this.blurringPlane.material.uniforms.previousShadowMap = {
            value: inactiveMap.texture
        };
        this.buffer1Active = !this.buffer1Active;
        this.renderer.render(this.scene, camera);
        for(let l = 0; l < this.lightMapContainers.length; l++){
            this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;
            this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;
            this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);
        }
        this.renderer.setRenderTarget(oldTarget);
    }
    /** DEBUG
   * Draw the lightmap in the main scene.  Call this after adding the objects to it.
   * @param {boolean} visible Whether the debug plane should be visible
   * @param {Vector3} position Where the debug plane should be drawn
   */ showDebugLightmap(visible, position = void 0) {
        if (this.lightMapContainers.length == 0) {
            if (!this.warned) {
                console.warn("Call this after adding the objects!");
                this.warned = true;
            }
            return;
        }
        if (this.labelMesh == null) {
            this.labelMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
                map: this.progressiveLightMap1.texture,
                side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"]
            });
            this.labelPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](100, 100);
            this.labelMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](this.labelPlane, this.labelMaterial);
            this.labelMesh.position.y = 250;
            this.lightMapContainers[0].object.parent.add(this.labelMesh);
        }
        if (position != void 0) {
            this.labelMesh.position.copy(position);
        }
        this.labelMesh.visible = visible;
    }
    /**
   * INTERNAL Creates the Blurring Plane
   * @param {number} res The square resolution of this object's lightMap.
   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.
   */ _initializeBlurPlane(res, lightMap = null) {
        const blurMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]();
        blurMaterial.uniforms = {
            previousShadowMap: {
                value: null
            },
            pixelOffset: {
                value: 1 / res
            },
            polygonOffset: true,
            polygonOffsetFactor: -1,
            polygonOffsetUnits: 3
        };
        blurMaterial.onBeforeCompile = (shader)=>{
            shader.vertexShader = "#define USE_UV\n" + shader.vertexShader.slice(0, -1) + "	gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";
            const bodyStart = shader.fragmentShader.indexOf("void main() {");
            shader.fragmentShader = "#define USE_UV\n" + shader.fragmentShader.slice(0, bodyStart) + "	uniform sampler2D previousShadowMap;\n	uniform float pixelOffset;\n" + shader.fragmentShader.slice(bodyStart - 1, -1) + `	gl_FragColor.rgb = (
			  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +
			  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +
			  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +
			  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;
		}`;
            shader.uniforms.previousShadowMap = {
                value: lightMap.texture
            };
            shader.uniforms.pixelOffset = {
                value: 0.5 / res
            };
            blurMaterial.uniforms = shader.uniforms;
            blurMaterial.userData.shader = shader;
            this.compiled = true;
        };
        this.blurringPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](1, 1), blurMaterial);
        this.blurringPlane.name = "Blurring Plane";
        this.blurringPlane.frustumCulled = false;
        this.blurringPlane.renderOrder = 0;
        this.blurringPlane.material.depthWrite = false;
        this.scene.add(this.blurringPlane);
    }
}
;
 //# sourceMappingURL=ProgressiveLightmap.js.map
}}),
"[project]/node_modules/three-stdlib/math/ConvexHull.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ConvexHull": (()=>ConvexHull),
    "Face": (()=>Face),
    "HalfEdge": (()=>HalfEdge),
    "VertexList": (()=>VertexList),
    "VertexNode": (()=>VertexNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const Visible = 0;
const Deleted = 1;
const _v1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _line3 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line3"]();
const _plane = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
const _closestPoint = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _triangle = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Triangle"]();
class ConvexHull {
    constructor(){
        this.tolerance = -1;
        this.faces = [];
        this.newFaces = [];
        this.assigned = new VertexList();
        this.unassigned = new VertexList();
        this.vertices = [];
    }
    setFromPoints(points) {
        if (points.length >= 4) {
            this.makeEmpty();
            for(let i = 0, l = points.length; i < l; i++){
                this.vertices.push(new VertexNode(points[i]));
            }
            this.compute();
        }
        return this;
    }
    setFromObject(object) {
        const points = [];
        object.updateMatrixWorld(true);
        object.traverse(function(node) {
            const geometry = node.geometry;
            if (geometry !== void 0) {
                const attribute = geometry.attributes.position;
                if (attribute !== void 0) {
                    for(let i = 0, l = attribute.count; i < l; i++){
                        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                        point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                        points.push(point);
                    }
                }
            }
        });
        return this.setFromPoints(points);
    }
    containsPoint(point) {
        const faces = this.faces;
        for(let i = 0, l = faces.length; i < l; i++){
            const face = faces[i];
            if (face.distanceToPoint(point) > this.tolerance) return false;
        }
        return true;
    }
    intersectRay(ray, target) {
        const faces = this.faces;
        let tNear = -Infinity;
        let tFar = Infinity;
        for(let i = 0, l = faces.length; i < l; i++){
            const face = faces[i];
            const vN = face.distanceToPoint(ray.origin);
            const vD = face.normal.dot(ray.direction);
            if (vN > 0 && vD >= 0) return null;
            const t = vD !== 0 ? -vN / vD : 0;
            if (t <= 0) continue;
            if (vD > 0) {
                tFar = Math.min(t, tFar);
            } else {
                tNear = Math.max(t, tNear);
            }
            if (tNear > tFar) {
                return null;
            }
        }
        if (tNear !== -Infinity) {
            ray.at(tNear, target);
        } else {
            ray.at(tFar, target);
        }
        return target;
    }
    intersectsRay(ray) {
        return this.intersectRay(ray, _v1) !== null;
    }
    makeEmpty() {
        this.faces = [];
        this.vertices = [];
        return this;
    }
    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
    addVertexToFace(vertex, face) {
        vertex.face = face;
        if (face.outside === null) {
            this.assigned.append(vertex);
        } else {
            this.assigned.insertBefore(face.outside, vertex);
        }
        face.outside = vertex;
        return this;
    }
    // Removes a vertex from the 'assigned' list of vertices and from the given face
    removeVertexFromFace(vertex, face) {
        if (vertex === face.outside) {
            if (vertex.next !== null && vertex.next.face === face) {
                face.outside = vertex.next;
            } else {
                face.outside = null;
            }
        }
        this.assigned.remove(vertex);
        return this;
    }
    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
    removeAllVerticesFromFace(face) {
        if (face.outside !== null) {
            const start = face.outside;
            let end = face.outside;
            while(end.next !== null && end.next.face === face){
                end = end.next;
            }
            this.assigned.removeSubList(start, end);
            start.prev = end.next = null;
            face.outside = null;
            return start;
        }
    }
    // Removes all the visible vertices that 'face' is able to see
    deleteFaceVertices(face, absorbingFace) {
        const faceVertices = this.removeAllVerticesFromFace(face);
        if (faceVertices !== void 0) {
            if (absorbingFace === void 0) {
                this.unassigned.appendChain(faceVertices);
            } else {
                let vertex = faceVertices;
                do {
                    const nextVertex = vertex.next;
                    const distance = absorbingFace.distanceToPoint(vertex.point);
                    if (distance > this.tolerance) {
                        this.addVertexToFace(vertex, absorbingFace);
                    } else {
                        this.unassigned.append(vertex);
                    }
                    vertex = nextVertex;
                }while (vertex !== null)
            }
        }
        return this;
    }
    // Reassigns as many vertices as possible from the unassigned list to the new faces
    resolveUnassignedPoints(newFaces) {
        if (this.unassigned.isEmpty() === false) {
            let vertex = this.unassigned.first();
            do {
                const nextVertex = vertex.next;
                let maxDistance = this.tolerance;
                let maxFace = null;
                for(let i = 0; i < newFaces.length; i++){
                    const face = newFaces[i];
                    if (face.mark === Visible) {
                        const distance = face.distanceToPoint(vertex.point);
                        if (distance > maxDistance) {
                            maxDistance = distance;
                            maxFace = face;
                        }
                        if (maxDistance > 1e3 * this.tolerance) break;
                    }
                }
                if (maxFace !== null) {
                    this.addVertexToFace(vertex, maxFace);
                }
                vertex = nextVertex;
            }while (vertex !== null)
        }
        return this;
    }
    // Computes the extremes of a simplex which will be the initial hull
    computeExtremes() {
        const min = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const max = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const minVertices = [];
        const maxVertices = [];
        for(let i = 0; i < 3; i++){
            minVertices[i] = maxVertices[i] = this.vertices[0];
        }
        min.copy(this.vertices[0].point);
        max.copy(this.vertices[0].point);
        for(let i = 0, l = this.vertices.length; i < l; i++){
            const vertex = this.vertices[i];
            const point = vertex.point;
            for(let j = 0; j < 3; j++){
                if (point.getComponent(j) < min.getComponent(j)) {
                    min.setComponent(j, point.getComponent(j));
                    minVertices[j] = vertex;
                }
            }
            for(let j = 0; j < 3; j++){
                if (point.getComponent(j) > max.getComponent(j)) {
                    max.setComponent(j, point.getComponent(j));
                    maxVertices[j] = vertex;
                }
            }
        }
        this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
        return {
            min: minVertices,
            max: maxVertices
        };
    }
    // Computes the initial simplex assigning to its faces all the points
    // that are candidates to form part of the hull
    computeInitialHull() {
        const vertices = this.vertices;
        const extremes = this.computeExtremes();
        const min = extremes.min;
        const max = extremes.max;
        let maxDistance = 0;
        let index = 0;
        for(let i = 0; i < 3; i++){
            const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);
            if (distance > maxDistance) {
                maxDistance = distance;
                index = i;
            }
        }
        const v0 = min[index];
        const v1 = max[index];
        let v2;
        let v3;
        maxDistance = 0;
        _line3.set(v0.point, v1.point);
        for(let i = 0, l = this.vertices.length; i < l; i++){
            const vertex = vertices[i];
            if (vertex !== v0 && vertex !== v1) {
                _line3.closestPointToPoint(vertex.point, true, _closestPoint);
                const distance = _closestPoint.distanceToSquared(vertex.point);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    v2 = vertex;
                }
            }
        }
        maxDistance = -1;
        _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);
        for(let i = 0, l = this.vertices.length; i < l; i++){
            const vertex = vertices[i];
            if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
                const distance = Math.abs(_plane.distanceToPoint(vertex.point));
                if (distance > maxDistance) {
                    maxDistance = distance;
                    v3 = vertex;
                }
            }
        }
        const faces = [];
        if (_plane.distanceToPoint(v3.point) < 0) {
            faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));
            for(let i = 0; i < 3; i++){
                const j = (i + 1) % 3;
                faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));
                faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
            }
        } else {
            faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));
            for(let i = 0; i < 3; i++){
                const j = (i + 1) % 3;
                faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));
                faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
            }
        }
        for(let i = 0; i < 4; i++){
            this.faces.push(faces[i]);
        }
        for(let i = 0, l = vertices.length; i < l; i++){
            const vertex = vertices[i];
            if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
                maxDistance = this.tolerance;
                let maxFace = null;
                for(let j = 0; j < 4; j++){
                    const distance = this.faces[j].distanceToPoint(vertex.point);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        maxFace = this.faces[j];
                    }
                }
                if (maxFace !== null) {
                    this.addVertexToFace(vertex, maxFace);
                }
            }
        }
        return this;
    }
    // Removes inactive faces
    reindexFaces() {
        const activeFaces = [];
        for(let i = 0; i < this.faces.length; i++){
            const face = this.faces[i];
            if (face.mark === Visible) {
                activeFaces.push(face);
            }
        }
        this.faces = activeFaces;
        return this;
    }
    // Finds the next vertex to create faces with the current hull
    nextVertexToAdd() {
        if (this.assigned.isEmpty() === false) {
            let eyeVertex, maxDistance = 0;
            const eyeFace = this.assigned.first().face;
            let vertex = eyeFace.outside;
            do {
                const distance = eyeFace.distanceToPoint(vertex.point);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    eyeVertex = vertex;
                }
                vertex = vertex.next;
            }while (vertex !== null && vertex.face === eyeFace)
            return eyeVertex;
        }
    }
    // Computes a chain of half edges in CCW order called the 'horizon'.
    // For an edge to be part of the horizon it must join a face that can see
    // 'eyePoint' and a face that cannot see 'eyePoint'.
    computeHorizon(eyePoint, crossEdge, face, horizon) {
        this.deleteFaceVertices(face);
        face.mark = Deleted;
        let edge;
        if (crossEdge === null) {
            edge = crossEdge = face.getEdge(0);
        } else {
            edge = crossEdge.next;
        }
        do {
            const twinEdge = edge.twin;
            const oppositeFace = twinEdge.face;
            if (oppositeFace.mark === Visible) {
                if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
                    this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
                } else {
                    horizon.push(edge);
                }
            }
            edge = edge.next;
        }while (edge !== crossEdge)
        return this;
    }
    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
    addAdjoiningFace(eyeVertex, horizonEdge) {
        const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
        this.faces.push(face);
        face.getEdge(-1).setTwin(horizonEdge.twin);
        return face.getEdge(0);
    }
    //  Adds 'horizon.length' faces to the hull, each face will be linked with the
    //  horizon opposite face and the face on the left/right
    addNewFaces(eyeVertex, horizon) {
        this.newFaces = [];
        let firstSideEdge = null;
        let previousSideEdge = null;
        for(let i = 0; i < horizon.length; i++){
            const horizonEdge = horizon[i];
            const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
            if (firstSideEdge === null) {
                firstSideEdge = sideEdge;
            } else {
                sideEdge.next.setTwin(previousSideEdge);
            }
            this.newFaces.push(sideEdge.face);
            previousSideEdge = sideEdge;
        }
        firstSideEdge.next.setTwin(previousSideEdge);
        return this;
    }
    // Adds a vertex to the hull
    addVertexToHull(eyeVertex) {
        const horizon = [];
        this.unassigned.clear();
        this.removeVertexFromFace(eyeVertex, eyeVertex.face);
        this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
        this.addNewFaces(eyeVertex, horizon);
        this.resolveUnassignedPoints(this.newFaces);
        return this;
    }
    cleanup() {
        this.assigned.clear();
        this.unassigned.clear();
        this.newFaces = [];
        return this;
    }
    compute() {
        let vertex;
        this.computeInitialHull();
        while((vertex = this.nextVertexToAdd()) !== void 0){
            this.addVertexToHull(vertex);
        }
        this.reindexFaces();
        this.cleanup();
        return this;
    }
}
const Face = /* @__PURE__ */ (()=>{
    class Face2 {
        constructor(){
            this.normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.midpoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.area = 0;
            this.constant = 0;
            this.outside = null;
            this.mark = Visible;
            this.edge = null;
        }
        static create(a, b, c) {
            const face = new Face2();
            const e0 = new HalfEdge(a, face);
            const e1 = new HalfEdge(b, face);
            const e2 = new HalfEdge(c, face);
            e0.next = e2.prev = e1;
            e1.next = e0.prev = e2;
            e2.next = e1.prev = e0;
            face.edge = e0;
            return face.compute();
        }
        getEdge(i) {
            let edge = this.edge;
            while(i > 0){
                edge = edge.next;
                i--;
            }
            while(i < 0){
                edge = edge.prev;
                i++;
            }
            return edge;
        }
        compute() {
            const a = this.edge.tail();
            const b = this.edge.head();
            const c = this.edge.next.head();
            _triangle.set(a.point, b.point, c.point);
            _triangle.getNormal(this.normal);
            _triangle.getMidpoint(this.midpoint);
            this.area = _triangle.getArea();
            this.constant = this.normal.dot(this.midpoint);
            return this;
        }
        distanceToPoint(point) {
            return this.normal.dot(point) - this.constant;
        }
    }
    return Face2;
})();
class HalfEdge {
    constructor(vertex, face){
        this.vertex = vertex;
        this.prev = null;
        this.next = null;
        this.twin = null;
        this.face = face;
    }
    head() {
        return this.vertex;
    }
    tail() {
        return this.prev ? this.prev.vertex : null;
    }
    length() {
        const head = this.head();
        const tail = this.tail();
        if (tail !== null) {
            return tail.point.distanceTo(head.point);
        }
        return -1;
    }
    lengthSquared() {
        const head = this.head();
        const tail = this.tail();
        if (tail !== null) {
            return tail.point.distanceToSquared(head.point);
        }
        return -1;
    }
    setTwin(edge) {
        this.twin = edge;
        edge.twin = this;
        return this;
    }
}
class VertexNode {
    constructor(point){
        this.point = point;
        this.prev = null;
        this.next = null;
        this.face = null;
    }
}
class VertexList {
    constructor(){
        this.head = null;
        this.tail = null;
    }
    first() {
        return this.head;
    }
    last() {
        return this.tail;
    }
    clear() {
        this.head = this.tail = null;
        return this;
    }
    // Inserts a vertex before the target vertex
    insertBefore(target, vertex) {
        vertex.prev = target.prev;
        vertex.next = target;
        if (vertex.prev === null) {
            this.head = vertex;
        } else {
            vertex.prev.next = vertex;
        }
        target.prev = vertex;
        return this;
    }
    // Inserts a vertex after the target vertex
    insertAfter(target, vertex) {
        vertex.prev = target;
        vertex.next = target.next;
        if (vertex.next === null) {
            this.tail = vertex;
        } else {
            vertex.next.prev = vertex;
        }
        target.next = vertex;
        return this;
    }
    // Appends a vertex to the end of the linked list
    append(vertex) {
        if (this.head === null) {
            this.head = vertex;
        } else {
            this.tail.next = vertex;
        }
        vertex.prev = this.tail;
        vertex.next = null;
        this.tail = vertex;
        return this;
    }
    // Appends a chain of vertices where 'vertex' is the head.
    appendChain(vertex) {
        if (this.head === null) {
            this.head = vertex;
        } else {
            this.tail.next = vertex;
        }
        vertex.prev = this.tail;
        while(vertex.next !== null){
            vertex = vertex.next;
        }
        this.tail = vertex;
        return this;
    }
    // Removes a vertex from the linked list
    remove(vertex) {
        if (vertex.prev === null) {
            this.head = vertex.next;
        } else {
            vertex.prev.next = vertex.next;
        }
        if (vertex.next === null) {
            this.tail = vertex.prev;
        } else {
            vertex.next.prev = vertex.prev;
        }
        return this;
    }
    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
    removeSubList(a, b) {
        if (a.prev === null) {
            this.head = b.next;
        } else {
            a.prev.next = b.next;
        }
        if (b.next === null) {
            this.tail = a.prev;
        } else {
            b.next.prev = a.prev;
        }
        return this;
    }
    isEmpty() {
        return this.head === null;
    }
}
;
 //# sourceMappingURL=ConvexHull.js.map
}}),
"[project]/node_modules/three-stdlib/math/SimplexNoise.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SimplexNoise": (()=>SimplexNoise)
});
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
class SimplexNoise {
    /**
   * You can pass in a random number generator object if you like.
   * It is assumed to have a random() method.
   */ constructor(r = Math){
        __publicField(this, "grad3", [
            [
                1,
                1,
                0
            ],
            [
                -1,
                1,
                0
            ],
            [
                1,
                -1,
                0
            ],
            [
                -1,
                -1,
                0
            ],
            [
                1,
                0,
                1
            ],
            [
                -1,
                0,
                1
            ],
            [
                1,
                0,
                -1
            ],
            [
                -1,
                0,
                -1
            ],
            [
                0,
                1,
                1
            ],
            [
                0,
                -1,
                1
            ],
            [
                0,
                1,
                -1
            ],
            [
                0,
                -1,
                -1
            ]
        ]);
        __publicField(this, "grad4", [
            [
                0,
                1,
                1,
                1
            ],
            [
                0,
                1,
                1,
                -1
            ],
            [
                0,
                1,
                -1,
                1
            ],
            [
                0,
                1,
                -1,
                -1
            ],
            [
                0,
                -1,
                1,
                1
            ],
            [
                0,
                -1,
                1,
                -1
            ],
            [
                0,
                -1,
                -1,
                1
            ],
            [
                0,
                -1,
                -1,
                -1
            ],
            [
                1,
                0,
                1,
                1
            ],
            [
                1,
                0,
                1,
                -1
            ],
            [
                1,
                0,
                -1,
                1
            ],
            [
                1,
                0,
                -1,
                -1
            ],
            [
                -1,
                0,
                1,
                1
            ],
            [
                -1,
                0,
                1,
                -1
            ],
            [
                -1,
                0,
                -1,
                1
            ],
            [
                -1,
                0,
                -1,
                -1
            ],
            [
                1,
                1,
                0,
                1
            ],
            [
                1,
                1,
                0,
                -1
            ],
            [
                1,
                -1,
                0,
                1
            ],
            [
                1,
                -1,
                0,
                -1
            ],
            [
                -1,
                1,
                0,
                1
            ],
            [
                -1,
                1,
                0,
                -1
            ],
            [
                -1,
                -1,
                0,
                1
            ],
            [
                -1,
                -1,
                0,
                -1
            ],
            [
                1,
                1,
                1,
                0
            ],
            [
                1,
                1,
                -1,
                0
            ],
            [
                1,
                -1,
                1,
                0
            ],
            [
                1,
                -1,
                -1,
                0
            ],
            [
                -1,
                1,
                1,
                0
            ],
            [
                -1,
                1,
                -1,
                0
            ],
            [
                -1,
                -1,
                1,
                0
            ],
            [
                -1,
                -1,
                -1,
                0
            ]
        ]);
        __publicField(this, "p", []);
        // To remove the need for index wrapping, double the permutation table length
        __publicField(this, "perm", []);
        // A lookup table to traverse the simplex around a given point in 4D.
        // Details can be found where this table is used, in the 4D noise method.
        __publicField(this, "simplex", [
            [
                0,
                1,
                2,
                3
            ],
            [
                0,
                1,
                3,
                2
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                2,
                3,
                1
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                1,
                2,
                3,
                0
            ],
            [
                0,
                2,
                1,
                3
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                3,
                1,
                2
            ],
            [
                0,
                3,
                2,
                1
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                1,
                3,
                2,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                1,
                2,
                0,
                3
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                1,
                3,
                0,
                2
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                2,
                3,
                0,
                1
            ],
            [
                2,
                3,
                1,
                0
            ],
            [
                1,
                0,
                2,
                3
            ],
            [
                1,
                0,
                3,
                2
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                2,
                0,
                3,
                1
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                2,
                1,
                3,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                2,
                0,
                1,
                3
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                3,
                0,
                1,
                2
            ],
            [
                3,
                0,
                2,
                1
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                3,
                1,
                2,
                0
            ],
            [
                2,
                1,
                0,
                3
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                3,
                1,
                0,
                2
            ],
            [
                0,
                0,
                0,
                0
            ],
            [
                3,
                2,
                0,
                1
            ],
            [
                3,
                2,
                1,
                0
            ]
        ]);
        __publicField(this, "dot", (g, x, y)=>{
            return g[0] * x + g[1] * y;
        });
        __publicField(this, "dot3", (g, x, y, z)=>{
            return g[0] * x + g[1] * y + g[2] * z;
        });
        __publicField(this, "dot4", (g, x, y, z, w)=>{
            return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
        });
        __publicField(this, "noise", (xin, yin)=>{
            let n0;
            let n1;
            let n2;
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const s = (xin + yin) * F2;
            const i = Math.floor(xin + s);
            const j = Math.floor(yin + s);
            const G2 = (3 - Math.sqrt(3)) / 6;
            const t = (i + j) * G2;
            const X0 = i - t;
            const Y0 = j - t;
            const x0 = xin - X0;
            const y0 = yin - Y0;
            let i1 = 0;
            let j1 = 1;
            if (x0 > y0) {
                i1 = 1;
                j1 = 0;
            }
            const x1 = x0 - i1 + G2;
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1 + 2 * G2;
            const y2 = y0 - 1 + 2 * G2;
            const ii = i & 255;
            const jj = j & 255;
            const gi0 = this.perm[ii + this.perm[jj]] % 12;
            const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
            const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
            let t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 < 0) {
                n0 = 0;
            } else {
                t0 *= t0;
                n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
            }
            let t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 < 0) {
                n1 = 0;
            } else {
                t1 *= t1;
                n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
            }
            let t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 < 0) {
                n2 = 0;
            } else {
                t2 *= t2;
                n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
            }
            return 70 * (n0 + n1 + n2);
        });
        // 3D simplex noise
        __publicField(this, "noise3d", (xin, yin, zin)=>{
            let n0;
            let n1;
            let n2;
            let n3;
            const F3 = 1 / 3;
            const s = (xin + yin + zin) * F3;
            const i = Math.floor(xin + s);
            const j = Math.floor(yin + s);
            const k = Math.floor(zin + s);
            const G3 = 1 / 6;
            const t = (i + j + k) * G3;
            const X0 = i - t;
            const Y0 = j - t;
            const Z0 = k - t;
            const x0 = xin - X0;
            const y0 = yin - Y0;
            const z0 = zin - Z0;
            let i1;
            let j1;
            let k1;
            let i2;
            let j2;
            let k2;
            if (x0 >= y0) {
                if (y0 >= z0) {
                    i1 = 1;
                    j1 = 0;
                    k1 = 0;
                    i2 = 1;
                    j2 = 1;
                    k2 = 0;
                } else if (x0 >= z0) {
                    i1 = 1;
                    j1 = 0;
                    k1 = 0;
                    i2 = 1;
                    j2 = 0;
                    k2 = 1;
                } else {
                    i1 = 0;
                    j1 = 0;
                    k1 = 1;
                    i2 = 1;
                    j2 = 0;
                    k2 = 1;
                }
            } else {
                if (y0 < z0) {
                    i1 = 0;
                    j1 = 0;
                    k1 = 1;
                    i2 = 0;
                    j2 = 1;
                    k2 = 1;
                } else if (x0 < z0) {
                    i1 = 0;
                    j1 = 1;
                    k1 = 0;
                    i2 = 0;
                    j2 = 1;
                    k2 = 1;
                } else {
                    i1 = 0;
                    j1 = 1;
                    k1 = 0;
                    i2 = 1;
                    j2 = 1;
                    k2 = 0;
                }
            }
            const x1 = x0 - i1 + G3;
            const y1 = y0 - j1 + G3;
            const z1 = z0 - k1 + G3;
            const x2 = x0 - i2 + 2 * G3;
            const y2 = y0 - j2 + 2 * G3;
            const z2 = z0 - k2 + 2 * G3;
            const x3 = x0 - 1 + 3 * G3;
            const y3 = y0 - 1 + 3 * G3;
            const z3 = z0 - 1 + 3 * G3;
            const ii = i & 255;
            const jj = j & 255;
            const kk = k & 255;
            const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
            const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
            const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
            const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
            let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
            if (t0 < 0) {
                n0 = 0;
            } else {
                t0 *= t0;
                n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
            }
            let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
            if (t1 < 0) {
                n1 = 0;
            } else {
                t1 *= t1;
                n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
            }
            let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
            if (t2 < 0) {
                n2 = 0;
            } else {
                t2 *= t2;
                n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);
            }
            let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
            if (t3 < 0) {
                n3 = 0;
            } else {
                t3 *= t3;
                n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
            }
            return 32 * (n0 + n1 + n2 + n3);
        });
        // 4D simplex noise
        __publicField(this, "noise4d", (x, y, z, w)=>{
            const grad4 = this.grad4;
            const simplex = this.simplex;
            const perm = this.perm;
            const F4 = (Math.sqrt(5) - 1) / 4;
            const G4 = (5 - Math.sqrt(5)) / 20;
            let n0;
            let n1;
            let n2;
            let n3;
            let n4;
            const s = (x + y + z + w) * F4;
            const i = Math.floor(x + s);
            const j = Math.floor(y + s);
            const k = Math.floor(z + s);
            const l = Math.floor(w + s);
            const t = (i + j + k + l) * G4;
            const X0 = i - t;
            const Y0 = j - t;
            const Z0 = k - t;
            const W0 = l - t;
            const x0 = x - X0;
            const y0 = y - Y0;
            const z0 = z - Z0;
            const w0 = w - W0;
            const c1 = x0 > y0 ? 32 : 0;
            const c2 = x0 > z0 ? 16 : 0;
            const c3 = y0 > z0 ? 8 : 0;
            const c4 = x0 > w0 ? 4 : 0;
            const c5 = y0 > w0 ? 2 : 0;
            const c6 = z0 > w0 ? 1 : 0;
            const c = c1 + c2 + c3 + c4 + c5 + c6;
            let i1;
            let j1;
            let k1;
            let l1;
            let i2;
            let j2;
            let k2;
            let l2;
            let i3;
            let j3;
            let k3;
            let l3;
            i1 = simplex[c][0] >= 3 ? 1 : 0;
            j1 = simplex[c][1] >= 3 ? 1 : 0;
            k1 = simplex[c][2] >= 3 ? 1 : 0;
            l1 = simplex[c][3] >= 3 ? 1 : 0;
            i2 = simplex[c][0] >= 2 ? 1 : 0;
            j2 = simplex[c][1] >= 2 ? 1 : 0;
            k2 = simplex[c][2] >= 2 ? 1 : 0;
            l2 = simplex[c][3] >= 2 ? 1 : 0;
            i3 = simplex[c][0] >= 1 ? 1 : 0;
            j3 = simplex[c][1] >= 1 ? 1 : 0;
            k3 = simplex[c][2] >= 1 ? 1 : 0;
            l3 = simplex[c][3] >= 1 ? 1 : 0;
            const x1 = x0 - i1 + G4;
            const y1 = y0 - j1 + G4;
            const z1 = z0 - k1 + G4;
            const w1 = w0 - l1 + G4;
            const x2 = x0 - i2 + 2 * G4;
            const y2 = y0 - j2 + 2 * G4;
            const z2 = z0 - k2 + 2 * G4;
            const w2 = w0 - l2 + 2 * G4;
            const x3 = x0 - i3 + 3 * G4;
            const y3 = y0 - j3 + 3 * G4;
            const z3 = z0 - k3 + 3 * G4;
            const w3 = w0 - l3 + 3 * G4;
            const x4 = x0 - 1 + 4 * G4;
            const y4 = y0 - 1 + 4 * G4;
            const z4 = z0 - 1 + 4 * G4;
            const w4 = w0 - 1 + 4 * G4;
            const ii = i & 255;
            const jj = j & 255;
            const kk = k & 255;
            const ll = l & 255;
            const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
            const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
            const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
            const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
            const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
            let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
            if (t0 < 0) {
                n0 = 0;
            } else {
                t0 *= t0;
                n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
            }
            let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
            if (t1 < 0) {
                n1 = 0;
            } else {
                t1 *= t1;
                n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
            }
            let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
            if (t2 < 0) {
                n2 = 0;
            } else {
                t2 *= t2;
                n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);
            }
            let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
            if (t3 < 0) {
                n3 = 0;
            } else {
                t3 *= t3;
                n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
            }
            let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
            if (t4 < 0) {
                n4 = 0;
            } else {
                t4 *= t4;
                n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
            }
            return 27 * (n0 + n1 + n2 + n3 + n4);
        });
        for(let i = 0; i < 256; i++){
            this.p[i] = Math.floor(r.random() * 256);
        }
        for(let i = 0; i < 512; i++){
            this.perm[i] = this.p[i & 255];
        }
    }
}
;
 //# sourceMappingURL=SimplexNoise.js.map
}}),
"[project]/node_modules/three-stdlib/math/MeshSurfaceSampler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MeshSurfaceSampler": (()=>MeshSurfaceSampler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _face = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Triangle"]();
const _color = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class MeshSurfaceSampler {
    constructor(mesh){
        let geometry = mesh.geometry;
        if (geometry.index) {
            console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.");
            geometry = geometry.toNonIndexed();
        }
        this.geometry = geometry;
        this.randomFunction = Math.random;
        this.positionAttribute = this.geometry.getAttribute("position");
        this.colorAttribute = this.geometry.getAttribute("color");
        this.weightAttribute = null;
        this.distribution = null;
    }
    setWeightAttribute(name) {
        this.weightAttribute = name ? this.geometry.getAttribute(name) : null;
        return this;
    }
    build() {
        const positionAttribute = this.positionAttribute;
        const weightAttribute = this.weightAttribute;
        const faceWeights = new Float32Array(positionAttribute.count / 3);
        for(let i = 0; i < positionAttribute.count; i += 3){
            let faceWeight = 1;
            if (weightAttribute) {
                faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);
            }
            _face.a.fromBufferAttribute(positionAttribute, i);
            _face.b.fromBufferAttribute(positionAttribute, i + 1);
            _face.c.fromBufferAttribute(positionAttribute, i + 2);
            faceWeight *= _face.getArea();
            faceWeights[i / 3] = faceWeight;
        }
        this.distribution = new Float32Array(positionAttribute.count / 3);
        let cumulativeTotal = 0;
        for(let i = 0; i < faceWeights.length; i++){
            cumulativeTotal += faceWeights[i];
            this.distribution[i] = cumulativeTotal;
        }
        return this;
    }
    setRandomGenerator(randomFunction) {
        this.randomFunction = randomFunction;
        return this;
    }
    sample(targetPosition, targetNormal, targetColor) {
        const faceIndex = this.sampleFaceIndex();
        return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);
    }
    sampleFaceIndex() {
        const cumulativeTotal = this.distribution[this.distribution.length - 1];
        return this.binarySearch(this.randomFunction() * cumulativeTotal);
    }
    binarySearch(x) {
        const dist = this.distribution;
        let start = 0;
        let end = dist.length - 1;
        let index = -1;
        while(start <= end){
            const mid = Math.ceil((start + end) / 2);
            if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {
                index = mid;
                break;
            } else if (x < dist[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return index;
    }
    sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {
        let u = this.randomFunction();
        let v = this.randomFunction();
        if (u + v > 1) {
            u = 1 - u;
            v = 1 - v;
        }
        _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);
        _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);
        _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);
        targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
        if (targetNormal !== void 0) {
            _face.getNormal(targetNormal);
        }
        if (targetColor !== void 0 && this.colorAttribute !== void 0) {
            _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);
            _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);
            _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);
            _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
            targetColor.r = _color.x;
            targetColor.g = _color.y;
            targetColor.b = _color.z;
        }
        return this;
    }
}
;
 //# sourceMappingURL=MeshSurfaceSampler.js.map
}}),
"[project]/node_modules/three-stdlib/math/OBB.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "OBB": (()=>OBB)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const a = {
    c: null,
    // center
    u: [
        /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
    ],
    // basis vectors
    e: []
};
const b = {
    c: null,
    // center
    u: [
        /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
    ],
    // basis vectors
    e: []
};
const R = [
    [],
    [],
    []
];
const AbsR = [
    [],
    [],
    []
];
const t = [];
const xAxis = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const yAxis = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const zAxis = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const v1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const size = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const closestPoint = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const rotationMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const aabb = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
const matrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const inverse = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const localRay = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ray"]();
class OBB {
    constructor(center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), halfSize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), rotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]()){
        this.center = center;
        this.halfSize = halfSize;
        this.rotation = rotation;
    }
    set(center, halfSize, rotation) {
        this.center = center;
        this.halfSize = halfSize;
        this.rotation = rotation;
        return this;
    }
    copy(obb2) {
        this.center.copy(obb2.center);
        this.halfSize.copy(obb2.halfSize);
        this.rotation.copy(obb2.rotation);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    getSize(result) {
        return result.copy(this.halfSize).multiplyScalar(2);
    }
    /**
   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection
   * by Christer Ericson (chapter 5.1.4)
   */ clampPoint(point, result) {
        const halfSize = this.halfSize;
        v1.subVectors(point, this.center);
        this.rotation.extractBasis(xAxis, yAxis, zAxis);
        result.copy(this.center);
        const x = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);
        result.add(xAxis.multiplyScalar(x));
        const y = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);
        result.add(yAxis.multiplyScalar(y));
        const z = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);
        result.add(zAxis.multiplyScalar(z));
        return result;
    }
    containsPoint(point) {
        v1.subVectors(point, this.center);
        this.rotation.extractBasis(xAxis, yAxis, zAxis);
        return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;
    }
    intersectsBox3(box3) {
        return this.intersectsOBB(obb.fromBox3(box3));
    }
    intersectsSphere(sphere) {
        this.clampPoint(sphere.center, closestPoint);
        return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    /**
   * Reference: OBB-OBB Intersection in Real-Time Collision Detection
   * by Christer Ericson (chapter 4.4.1)
   *
   */ intersectsOBB(obb2, epsilon = Number.EPSILON) {
        a.c = this.center;
        a.e[0] = this.halfSize.x;
        a.e[1] = this.halfSize.y;
        a.e[2] = this.halfSize.z;
        this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);
        b.c = obb2.center;
        b.e[0] = obb2.halfSize.x;
        b.e[1] = obb2.halfSize.y;
        b.e[2] = obb2.halfSize.z;
        obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);
        for(let i = 0; i < 3; i++){
            for(let j = 0; j < 3; j++){
                R[i][j] = a.u[i].dot(b.u[j]);
            }
        }
        v1.subVectors(b.c, a.c);
        t[0] = v1.dot(a.u[0]);
        t[1] = v1.dot(a.u[1]);
        t[2] = v1.dot(a.u[2]);
        for(let i = 0; i < 3; i++){
            for(let j = 0; j < 3; j++){
                AbsR[i][j] = Math.abs(R[i][j]) + epsilon;
            }
        }
        let ra, rb;
        for(let i = 0; i < 3; i++){
            ra = a.e[i];
            rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];
            if (Math.abs(t[i]) > ra + rb) return false;
        }
        for(let i = 0; i < 3; i++){
            ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];
            rb = b.e[i];
            if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false;
        }
        ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];
        rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];
        if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false;
        ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];
        rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];
        if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false;
        ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];
        rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];
        if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false;
        ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];
        rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];
        if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false;
        ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];
        rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];
        if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false;
        ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];
        rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];
        if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false;
        ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];
        rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];
        if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false;
        ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];
        rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];
        if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false;
        ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];
        rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];
        if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false;
        return true;
    }
    /**
   * Reference: Testing Box Against Plane in Real-Time Collision Detection
   * by Christer Ericson (chapter 5.2.3)
   */ intersectsPlane(plane) {
        this.rotation.extractBasis(xAxis, yAxis, zAxis);
        const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));
        const d = plane.normal.dot(this.center) - plane.constant;
        return Math.abs(d) <= r;
    }
    /**
   * Performs a ray/OBB intersection test and stores the intersection point
   * to the given 3D vector. If no intersection is detected, *null* is returned.
   */ intersectRay(ray, result) {
        this.getSize(size);
        aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);
        matrix.setFromMatrix3(this.rotation);
        matrix.setPosition(this.center);
        inverse.copy(matrix).invert();
        localRay.copy(ray).applyMatrix4(inverse);
        if (localRay.intersectBox(aabb, result)) {
            return result.applyMatrix4(matrix);
        } else {
            return null;
        }
    }
    /**
   * Performs a ray/OBB intersection test. Returns either true or false if
   * there is a intersection or not.
   */ intersectsRay(ray) {
        return this.intersectRay(ray, v1) !== null;
    }
    fromBox3(box3) {
        box3.getCenter(this.center);
        box3.getSize(this.halfSize).multiplyScalar(0.5);
        this.rotation.identity();
        return this;
    }
    equals(obb2) {
        return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);
    }
    applyMatrix4(matrix2) {
        const e = matrix2.elements;
        let sx = v1.set(e[0], e[1], e[2]).length();
        const sy = v1.set(e[4], e[5], e[6]).length();
        const sz = v1.set(e[8], e[9], e[10]).length();
        const det = matrix2.determinant();
        if (det < 0) sx = -sx;
        rotationMatrix.setFromMatrix4(matrix2);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        rotationMatrix.elements[0] *= invSX;
        rotationMatrix.elements[1] *= invSX;
        rotationMatrix.elements[2] *= invSX;
        rotationMatrix.elements[3] *= invSY;
        rotationMatrix.elements[4] *= invSY;
        rotationMatrix.elements[5] *= invSY;
        rotationMatrix.elements[6] *= invSZ;
        rotationMatrix.elements[7] *= invSZ;
        rotationMatrix.elements[8] *= invSZ;
        this.rotation.multiply(rotationMatrix);
        this.halfSize.x *= sx;
        this.halfSize.y *= sy;
        this.halfSize.z *= sz;
        v1.setFromMatrixPosition(matrix2);
        this.center.add(v1);
        return this;
    }
}
const obb = /* @__PURE__ */ new OBB();
;
 //# sourceMappingURL=OBB.js.map
}}),
"[project]/node_modules/three-stdlib/math/Capsule.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Capsule": (()=>Capsule)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _v1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _v2 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _v3 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const EPS = 1e-10;
class Capsule {
    constructor(start = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0), end = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0), radius = 1){
        this.start = start;
        this.end = end;
        this.radius = radius;
    }
    clone() {
        return new Capsule(this.start.clone(), this.end.clone(), this.radius);
    }
    set(start, end, radius) {
        this.start.copy(start);
        this.end.copy(end);
        this.radius = radius;
    }
    copy(capsule) {
        this.start.copy(capsule.start);
        this.end.copy(capsule.end);
        this.radius = capsule.radius;
    }
    getCenter(target) {
        return target.copy(this.end).add(this.start).multiplyScalar(0.5);
    }
    translate(v) {
        this.start.add(v);
        this.end.add(v);
    }
    checkAABBAxis(p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {
        return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);
    }
    intersectsBox(box) {
        return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, box.min.x, box.max.x, box.min.y, box.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, box.min.x, box.max.x, box.min.z, box.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, box.min.y, box.max.y, box.min.z, box.max.z, this.radius);
    }
    lineLineMinimumPoints(line1, line2) {
        const r = _v1.copy(line1.end).sub(line1.start);
        const s = _v2.copy(line2.end).sub(line2.start);
        const w = _v3.copy(line2.start).sub(line1.start);
        const a = r.dot(s), b = r.dot(r), c = s.dot(s), d = s.dot(w), e = r.dot(w);
        let t1, t2;
        const divisor = b * c - a * a;
        if (Math.abs(divisor) < EPS) {
            const d1 = -d / c;
            const d2 = (a - d) / c;
            if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {
                t1 = 0;
                t2 = d1;
            } else {
                t1 = 1;
                t2 = d2;
            }
        } else {
            t1 = (d * a + e * c) / divisor;
            t2 = (t1 * a - d) / c;
        }
        t2 = Math.max(0, Math.min(1, t2));
        t1 = Math.max(0, Math.min(1, t1));
        const point1 = r.multiplyScalar(t1).add(line1.start);
        const point2 = s.multiplyScalar(t2).add(line2.start);
        return [
            point1,
            point2
        ];
    }
}
;
 //# sourceMappingURL=Capsule.js.map
}}),
"[project]/node_modules/three-stdlib/math/ColorConverter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ColorConverter": (()=>ColorConverter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _hsl = {};
const ColorConverter = {
    setHSV (color, h, s, v) {
        h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].euclideanModulo(h, 1);
        s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(s, 0, 1);
        v = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(v, 0, 1);
        return color.setHSL(h, s * v / ((h = (2 - s) * v) < 1 ? h : 2 - h), h * 0.5);
    },
    getHSV (color, target) {
        color.getHSL(_hsl);
        _hsl.s *= _hsl.l < 0.5 ? _hsl.l : 1 - _hsl.l;
        target.h = _hsl.h;
        target.s = 2 * _hsl.s / (_hsl.l + _hsl.s);
        target.v = _hsl.l + _hsl.s;
        return target;
    },
    // where c, m, y, k is between 0 and 1
    setCMYK (color, c, m, y, k) {
        const r = (1 - c) * (1 - k);
        const g = (1 - m) * (1 - k);
        const b = (1 - y) * (1 - k);
        return color.setRGB(r, g, b);
    },
    getCMYK (color, target) {
        const r = color.r;
        const g = color.g;
        const b = color.b;
        const k = 1 - Math.max(r, g, b);
        const c = (1 - r - k) / (1 - k);
        const m = (1 - g - k) / (1 - k);
        const y = (1 - b - k) / (1 - k);
        target.c = c;
        target.m = m;
        target.y = y;
        target.k = k;
        return target;
    }
};
;
 //# sourceMappingURL=ColorConverter.js.map
}}),
"[project]/node_modules/three-stdlib/math/ImprovedNoise.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ImprovedNoise": (()=>ImprovedNoise)
});
function init() {
    const _p2 = [
        151,
        160,
        137,
        91,
        90,
        15,
        131,
        13,
        201,
        95,
        96,
        53,
        194,
        233,
        7,
        225,
        140,
        36,
        103,
        30,
        69,
        142,
        8,
        99,
        37,
        240,
        21,
        10,
        23,
        190,
        6,
        148,
        247,
        120,
        234,
        75,
        0,
        26,
        197,
        62,
        94,
        252,
        219,
        203,
        117,
        35,
        11,
        32,
        57,
        177,
        33,
        88,
        237,
        149,
        56,
        87,
        174,
        20,
        125,
        136,
        171,
        168,
        68,
        175,
        74,
        165,
        71,
        134,
        139,
        48,
        27,
        166,
        77,
        146,
        158,
        231,
        83,
        111,
        229,
        122,
        60,
        211,
        133,
        230,
        220,
        105,
        92,
        41,
        55,
        46,
        245,
        40,
        244,
        102,
        143,
        54,
        65,
        25,
        63,
        161,
        1,
        216,
        80,
        73,
        209,
        76,
        132,
        187,
        208,
        89,
        18,
        169,
        200,
        196,
        135,
        130,
        116,
        188,
        159,
        86,
        164,
        100,
        109,
        198,
        173,
        186,
        3,
        64,
        52,
        217,
        226,
        250,
        124,
        123,
        5,
        202,
        38,
        147,
        118,
        126,
        255,
        82,
        85,
        212,
        207,
        206,
        59,
        227,
        47,
        16,
        58,
        17,
        182,
        189,
        28,
        42,
        223,
        183,
        170,
        213,
        119,
        248,
        152,
        2,
        44,
        154,
        163,
        70,
        221,
        153,
        101,
        155,
        167,
        43,
        172,
        9,
        129,
        22,
        39,
        253,
        19,
        98,
        108,
        110,
        79,
        113,
        224,
        232,
        178,
        185,
        112,
        104,
        218,
        246,
        97,
        228,
        251,
        34,
        242,
        193,
        238,
        210,
        144,
        12,
        191,
        179,
        162,
        241,
        81,
        51,
        145,
        235,
        249,
        14,
        239,
        107,
        49,
        192,
        214,
        31,
        181,
        199,
        106,
        157,
        184,
        84,
        204,
        176,
        115,
        121,
        50,
        45,
        127,
        4,
        150,
        254,
        138,
        236,
        205,
        93,
        222,
        114,
        67,
        29,
        24,
        72,
        243,
        141,
        128,
        195,
        78,
        66,
        215,
        61,
        156,
        180
    ];
    for(let i = 0; i < 256; i++){
        _p2[256 + i] = _p2[i];
    }
    return _p2;
}
const _p = /* @__PURE__ */ init();
function fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}
function lerp(t, a, b) {
    return a + t * (b - a);
}
function grad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}
class ImprovedNoise {
    noise(x, y, z) {
        const floorX = Math.floor(x), floorY = Math.floor(y), floorZ = Math.floor(z);
        const X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;
        x -= floorX;
        y -= floorY;
        z -= floorZ;
        const xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;
        const u = fade(x), v = fade(y), w = fade(z);
        const A = _p[X] + Y, AA = _p[A] + Z, AB = _p[A + 1] + Z, B = _p[X + 1] + Y, BA = _p[B] + Z, BB = _p[B + 1] + Z;
        return lerp(w, lerp(v, lerp(u, grad(_p[AA], x, y, z), grad(_p[BA], xMinus1, y, z)), lerp(u, grad(_p[AB], x, yMinus1, z), grad(_p[BB], xMinus1, yMinus1, z))), lerp(v, lerp(u, grad(_p[AA + 1], x, y, zMinus1), grad(_p[BA + 1], xMinus1, y, zMinus1)), lerp(u, grad(_p[AB + 1], x, yMinus1, zMinus1), grad(_p[BB + 1], xMinus1, yMinus1, zMinus1))));
    }
}
;
 //# sourceMappingURL=ImprovedNoise.js.map
}}),
"[project]/node_modules/three-stdlib/math/Octree.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Octree": (()=>Octree)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$Capsule$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/Capsule.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
const _v1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _v2 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _plane = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
const _line1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line3"]();
const _line2 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line3"]();
const _sphere = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"]();
const _capsule = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$Capsule$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Capsule"]();
class Octree {
    constructor(box){
        this.triangles = [];
        this.box = box;
        this.subTrees = [];
    }
    addTriangle(triangle) {
        if (!this.bounds) this.bounds = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
        this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);
        this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);
        this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);
        this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);
        this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);
        this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);
        this.triangles.push(triangle);
        return this;
    }
    calcBox() {
        this.box = this.bounds.clone();
        this.box.min.x -= 0.01;
        this.box.min.y -= 0.01;
        this.box.min.z -= 0.01;
        return this;
    }
    split(level) {
        if (!this.box) return;
        const subTrees = [];
        const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5);
        for(let x = 0; x < 2; x++){
            for(let y = 0; y < 2; y++){
                for(let z = 0; z < 2; z++){
                    const box = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
                    const v = _v1.set(x, y, z);
                    box.min.copy(this.box.min).add(v.multiply(halfsize));
                    box.max.copy(box.min).add(halfsize);
                    subTrees.push(new Octree(box));
                }
            }
        }
        let triangle;
        while(triangle = this.triangles.pop()){
            for(let i = 0; i < subTrees.length; i++){
                if (subTrees[i].box.intersectsTriangle(triangle)) {
                    subTrees[i].triangles.push(triangle);
                }
            }
        }
        for(let i = 0; i < subTrees.length; i++){
            const len = subTrees[i].triangles.length;
            if (len > 8 && level < 16) {
                subTrees[i].split(level + 1);
            }
            if (len !== 0) {
                this.subTrees.push(subTrees[i]);
            }
        }
        return this;
    }
    build() {
        this.calcBox();
        this.split(0);
        return this;
    }
    getRayTriangles(ray, triangles) {
        for(let i = 0; i < this.subTrees.length; i++){
            const subTree = this.subTrees[i];
            if (!ray.intersectsBox(subTree.box)) continue;
            if (subTree.triangles.length > 0) {
                for(let j = 0; j < subTree.triangles.length; j++){
                    if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);
                }
            } else {
                subTree.getRayTriangles(ray, triangles);
            }
        }
        return triangles;
    }
    triangleCapsuleIntersect(capsule, triangle) {
        triangle.getPlane(_plane);
        const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;
        const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;
        if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {
            return false;
        }
        const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));
        const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);
        if (triangle.containsPoint(intersectPoint)) {
            return {
                normal: _plane.normal.clone(),
                point: intersectPoint.clone(),
                depth: Math.abs(Math.min(d1, d2))
            };
        }
        const r2 = capsule.radius * capsule.radius;
        const line1 = _line1.set(capsule.start, capsule.end);
        const lines = [
            [
                triangle.a,
                triangle.b
            ],
            [
                triangle.b,
                triangle.c
            ],
            [
                triangle.c,
                triangle.a
            ]
        ];
        for(let i = 0; i < lines.length; i++){
            const line2 = _line2.set(lines[i][0], lines[i][1]);
            const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);
            if (point1.distanceToSquared(point2) < r2) {
                return {
                    normal: point1.clone().sub(point2).normalize(),
                    point: point2.clone(),
                    depth: capsule.radius - point1.distanceTo(point2)
                };
            }
        }
        return false;
    }
    triangleSphereIntersect(sphere, triangle) {
        triangle.getPlane(_plane);
        if (!sphere.intersectsPlane(_plane)) return false;
        const depth = Math.abs(_plane.distanceToSphere(sphere));
        const r2 = sphere.radius * sphere.radius - depth * depth;
        const plainPoint = _plane.projectPoint(sphere.center, _v1);
        if (triangle.containsPoint(sphere.center)) {
            return {
                normal: _plane.normal.clone(),
                point: plainPoint.clone(),
                depth: Math.abs(_plane.distanceToSphere(sphere))
            };
        }
        const lines = [
            [
                triangle.a,
                triangle.b
            ],
            [
                triangle.b,
                triangle.c
            ],
            [
                triangle.c,
                triangle.a
            ]
        ];
        for(let i = 0; i < lines.length; i++){
            _line1.set(lines[i][0], lines[i][1]);
            _line1.closestPointToPoint(plainPoint, true, _v2);
            const d = _v2.distanceToSquared(sphere.center);
            if (d < r2) {
                return {
                    normal: sphere.center.clone().sub(_v2).normalize(),
                    point: _v2.clone(),
                    depth: sphere.radius - Math.sqrt(d)
                };
            }
        }
        return false;
    }
    getSphereTriangles(sphere, triangles) {
        for(let i = 0; i < this.subTrees.length; i++){
            const subTree = this.subTrees[i];
            if (!sphere.intersectsBox(subTree.box)) continue;
            if (subTree.triangles.length > 0) {
                for(let j = 0; j < subTree.triangles.length; j++){
                    if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);
                }
            } else {
                subTree.getSphereTriangles(sphere, triangles);
            }
        }
    }
    getCapsuleTriangles(capsule, triangles) {
        for(let i = 0; i < this.subTrees.length; i++){
            const subTree = this.subTrees[i];
            if (!capsule.intersectsBox(subTree.box)) continue;
            if (subTree.triangles.length > 0) {
                for(let j = 0; j < subTree.triangles.length; j++){
                    if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);
                }
            } else {
                subTree.getCapsuleTriangles(capsule, triangles);
            }
        }
    }
    sphereIntersect(sphere) {
        _sphere.copy(sphere);
        const triangles = [];
        let result, hit = false;
        this.getSphereTriangles(sphere, triangles);
        for(let i = 0; i < triangles.length; i++){
            if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {
                hit = true;
                _sphere.center.add(result.normal.multiplyScalar(result.depth));
            }
        }
        if (hit) {
            const collisionVector = _sphere.center.clone().sub(sphere.center);
            const depth = collisionVector.length();
            return {
                normal: collisionVector.normalize(),
                depth
            };
        }
        return false;
    }
    capsuleIntersect(capsule) {
        _capsule.copy(capsule);
        const triangles = [];
        let result, hit = false;
        this.getCapsuleTriangles(_capsule, triangles);
        for(let i = 0; i < triangles.length; i++){
            if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {
                hit = true;
                _capsule.translate(result.normal.multiplyScalar(result.depth));
            }
        }
        if (hit) {
            const collisionVector = _capsule.getCenter(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()).sub(capsule.getCenter(_v1));
            const depth = collisionVector.length();
            return {
                normal: collisionVector.normalize(),
                depth
            };
        }
        return false;
    }
    rayIntersect(ray) {
        if (ray.direction.length() === 0) return;
        const triangles = [];
        let triangle, position, distance = 1e100;
        this.getRayTriangles(ray, triangles);
        for(let i = 0; i < triangles.length; i++){
            const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);
            if (result) {
                const newdistance = result.sub(ray.origin).length();
                if (distance > newdistance) {
                    position = result.clone().add(ray.origin);
                    distance = newdistance;
                    triangle = triangles[i];
                }
            }
        }
        return distance < 1e100 ? {
            distance,
            triangle,
            position
        } : false;
    }
    fromGraphNode(group) {
        group.updateWorldMatrix(true, true);
        group.traverse((obj)=>{
            if (obj.isMesh === true) {
                let geometry, isTemp = false;
                if (obj.geometry.index !== null) {
                    isTemp = true;
                    geometry = obj.geometry.toNonIndexed();
                } else {
                    geometry = obj.geometry;
                }
                const positionAttribute = geometry.getAttribute("position");
                for(let i = 0; i < positionAttribute.count; i += 3){
                    const v1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(positionAttribute, i);
                    const v2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(positionAttribute, i + 1);
                    const v3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(positionAttribute, i + 2);
                    v1.applyMatrix4(obj.matrixWorld);
                    v2.applyMatrix4(obj.matrixWorld);
                    v3.applyMatrix4(obj.matrixWorld);
                    this.addTriangle(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Triangle"](v1, v2, v3));
                }
                if (isTemp) {
                    geometry.dispose();
                }
            }
        });
        this.build();
        return this;
    }
}
;
 //# sourceMappingURL=Octree.js.map
}}),
"[project]/node_modules/three-stdlib/math/Lut.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ColorMapKeywords": (()=>ColorMapKeywords),
    "Lut": (()=>Lut)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class Lut {
    constructor(colormap, count = 32){
        this.isLut = true;
        this.lut = [];
        this.map = [];
        this.n = 0;
        this.minV = 0;
        this.maxV = 1;
        this.setColorMap(colormap, count);
    }
    set(value) {
        if (value.isLut === true) {
            this.copy(value);
        }
        return this;
    }
    setMin(min) {
        this.minV = min;
        return this;
    }
    setMax(max) {
        this.maxV = max;
        return this;
    }
    setColorMap(colormap, count = 32) {
        this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;
        this.n = count;
        const step = 1 / this.n;
        const minColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        const maxColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        this.lut.length = 0;
        this.lut.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](this.map[0][1]));
        for(let i = 1; i < count; i++){
            const alpha = i * step;
            for(let j = 0; j < this.map.length - 1; j++){
                if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {
                    const min = this.map[j][0];
                    const max = this.map[j + 1][0];
                    minColor.setHex(this.map[j][1], "srgb-linear");
                    maxColor.setHex(this.map[j + 1][1], "srgb-linear");
                    const color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().lerpColors(minColor, maxColor, (alpha - min) / (max - min));
                    this.lut.push(color);
                }
            }
        }
        this.lut.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](this.map[this.map.length - 1][1]));
        return this;
    }
    copy(lut) {
        this.lut = lut.lut;
        this.map = lut.map;
        this.n = lut.n;
        this.minV = lut.minV;
        this.maxV = lut.maxV;
        return this;
    }
    getColor(alpha) {
        alpha = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].clamp(alpha, this.minV, this.maxV);
        alpha = (alpha - this.minV) / (this.maxV - this.minV);
        const colorPosition = Math.round(alpha * this.n);
        return this.lut[colorPosition];
    }
    addColorMap(name, arrayOfColors) {
        ColorMapKeywords[name] = arrayOfColors;
        return this;
    }
    createCanvas() {
        const canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = this.n;
        this.updateCanvas(canvas);
        return canvas;
    }
    updateCanvas(canvas) {
        const ctx = canvas.getContext("2d", {
            alpha: false
        });
        const imageData = ctx.getImageData(0, 0, 1, this.n);
        const data = imageData.data;
        let k = 0;
        const step = 1 / this.n;
        const minColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        const maxColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        const finalColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        for(let i = 1; i >= 0; i -= step){
            for(let j = this.map.length - 1; j >= 0; j--){
                if (i < this.map[j][0] && i >= this.map[j - 1][0]) {
                    const min = this.map[j - 1][0];
                    const max = this.map[j][0];
                    minColor.setHex(this.map[j - 1][1], "srgb-linear");
                    maxColor.setHex(this.map[j][1], "srgb-linear");
                    finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));
                    data[k * 4] = Math.round(finalColor.r * 255);
                    data[k * 4 + 1] = Math.round(finalColor.g * 255);
                    data[k * 4 + 2] = Math.round(finalColor.b * 255);
                    data[k * 4 + 3] = 255;
                    k += 1;
                }
            }
        }
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }
}
const ColorMapKeywords = {
    rainbow: [
        [
            0,
            255
        ],
        [
            0.2,
            65535
        ],
        [
            0.5,
            65280
        ],
        [
            0.8,
            16776960
        ],
        [
            1,
            16711680
        ]
    ],
    cooltowarm: [
        [
            0,
            3952322
        ],
        [
            0.2,
            10206463
        ],
        [
            0.5,
            14474460
        ],
        [
            0.8,
            16163717
        ],
        [
            1,
            11797542
        ]
    ],
    blackbody: [
        [
            0,
            0
        ],
        [
            0.2,
            7864320
        ],
        [
            0.5,
            15086080
        ],
        [
            0.8,
            16776960
        ],
        [
            1,
            16777215
        ]
    ],
    grayscale: [
        [
            0,
            0
        ],
        [
            0.2,
            4210752
        ],
        [
            0.5,
            8355712
        ],
        [
            0.8,
            12566463
        ],
        [
            1,
            16777215
        ]
    ]
};
;
 //# sourceMappingURL=Lut.js.map
}}),
"[project]/node_modules/three-stdlib/geometries/ConvexGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ConvexGeometry": (()=>ConvexGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$ConvexHull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/ConvexHull.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class ConvexGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(points = []){
        super();
        const vertices = [];
        const normals = [];
        const convexHull = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$ConvexHull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConvexHull"]().setFromPoints(points);
        const faces = convexHull.faces;
        for(let i = 0; i < faces.length; i++){
            const face = faces[i];
            let edge = face.edge;
            do {
                const point = edge.head().point;
                vertices.push(point.x, point.y, point.z);
                normals.push(face.normal.x, face.normal.y, face.normal.z);
                edge = edge.next;
            }while (edge !== face.edge)
        }
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](vertices, 3));
        this.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normals, 3));
    }
}
;
 //# sourceMappingURL=ConvexGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/geometries/LightningStrike.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LightningStrike": (()=>LightningStrike)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$SimplexNoise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/SimplexNoise.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
const LightningStrike = /* @__PURE__ */ (()=>{
    const _LightningStrike = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
        constructor(rayParameters = {}){
            super();
            this.isLightningStrike = true;
            this.type = "LightningStrike";
            this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));
            this.createMesh();
        }
        static createRandomGenerator() {
            const numSeeds = 2053;
            const seeds = [];
            for(let i = 0; i < numSeeds; i++){
                seeds.push(Math.random());
            }
            const generator = {
                currentSeed: 0,
                random: function() {
                    const value = seeds[generator.currentSeed];
                    generator.currentSeed = (generator.currentSeed + 1) % numSeeds;
                    return value;
                },
                getSeed: function() {
                    return generator.currentSeed / numSeeds;
                },
                setSeed: function(seed) {
                    generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;
                }
            };
            return generator;
        }
        static copyParameters(dest = {}, source = {}) {
            const vecCopy = function(v) {
                if (source === dest) {
                    return v;
                } else {
                    return v.clone();
                }
            };
            dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1);
            dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;
            dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;
            dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;
            dest.ramification = source.ramification !== void 0 ? source.ramification : 5;
            dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;
            dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;
            dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;
            dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;
            return dest;
        }
        update(time) {
            if (this.isStatic) return;
            if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {
                this.updateMesh(time);
                if (time < this.subrays[0].endPropagationTime) {
                    this.state = _LightningStrike.RAY_PROPAGATING;
                } else if (time > this.subrays[0].beginVanishingTime) {
                    this.state = _LightningStrike.RAY_VANISHING;
                } else {
                    this.state = _LightningStrike.RAY_STEADY;
                }
                this.visible = true;
            } else {
                this.visible = false;
                if (time < this.rayParameters.birthTime) {
                    this.state = _LightningStrike.RAY_UNBORN;
                } else {
                    this.state = _LightningStrike.RAY_EXTINGUISHED;
                }
            }
        }
        init(rayParameters) {
            this.rayParameters = rayParameters;
            this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;
            rayParameters.maxIterations = this.maxIterations;
            this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;
            rayParameters.isStatic = this.isStatic;
            this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;
            rayParameters.ramification = this.ramification;
            this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;
            rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;
            this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;
            rayParameters.recursionProbability = this.recursionProbability;
            this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;
            rayParameters.generateUVs = this.generateUVs;
            if (rayParameters.randomGenerator !== void 0) {
                this.randomGenerator = rayParameters.randomGenerator;
                this.seedGenerator = rayParameters.randomGenerator;
                if (rayParameters.noiseSeed !== void 0) {
                    this.seedGenerator.setSeed(rayParameters.noiseSeed);
                }
            } else {
                this.randomGenerator = _LightningStrike.createRandomGenerator();
                this.seedGenerator = Math;
            }
            if (rayParameters.onDecideSubrayCreation !== void 0) {
                this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;
            } else {
                this.createDefaultSubrayCreationCallbacks();
                if (rayParameters.onSubrayCreation !== void 0) {
                    this.onSubrayCreation = rayParameters.onSubrayCreation;
                }
            }
            this.state = _LightningStrike.RAY_INITIALIZED;
            this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));
            rayParameters.maxSubrays = this.maxSubrays;
            this.maxRaySegments = 2 * (1 << this.maxIterations);
            this.subrays = [];
            for(let i = 0; i < this.maxSubrays; i++){
                this.subrays.push(this.createSubray());
            }
            this.raySegments = [];
            for(let i = 0; i < this.maxRaySegments; i++){
                this.raySegments.push(this.createSegment());
            }
            this.time = 0;
            this.timeFraction = 0;
            this.currentSegmentCallback = null;
            this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;
            this.numSubrays = 0;
            this.currentSubray = null;
            this.currentSegmentIndex = 0;
            this.isInitialSegment = false;
            this.subrayProbability = 0;
            this.currentVertex = 0;
            this.currentIndex = 0;
            this.currentCoordinate = 0;
            this.currentUVCoordinate = 0;
            this.vertices = null;
            this.uvs = null;
            this.indices = null;
            this.positionAttribute = null;
            this.uvsAttribute = null;
            this.simplexX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$SimplexNoise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplexNoise"](this.seedGenerator);
            this.simplexY = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$SimplexNoise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplexNoise"](this.seedGenerator);
            this.simplexZ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$SimplexNoise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplexNoise"](this.seedGenerator);
            this.forwards = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.forwardsFill = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.side = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.down = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.middlePos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.middleLinPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.newPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.vPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.cross1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        }
        createMesh() {
            const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;
            const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;
            const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;
            this.vertices = new Float32Array(maxVerts * 3);
            this.indices = new Uint32Array(maxIndices);
            if (this.generateUVs) {
                this.uvs = new Float32Array(maxVerts * 2);
            }
            this.fillMesh(0);
            this.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Uint32BufferAttribute"](this.indices, 1));
            this.positionAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](this.vertices, 3);
            this.setAttribute("position", this.positionAttribute);
            if (this.generateUVs) {
                this.uvsAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](new Float32Array(this.uvs), 2);
                this.setAttribute("uv", this.uvsAttribute);
            }
            if (!this.isStatic) {
                this.index.usage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"];
                this.positionAttribute.usage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"];
                if (this.generateUVs) {
                    this.uvsAttribute.usage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"];
                }
            }
            this.vertices = this.positionAttribute.array;
            this.indices = this.index.array;
            if (this.generateUVs) {
                this.uvs = this.uvsAttribute.array;
            }
        }
        updateMesh(time) {
            this.fillMesh(time);
            this.drawRange.count = this.currentIndex;
            this.index.needsUpdate = true;
            this.positionAttribute.needsUpdate = true;
            if (this.generateUVs) {
                this.uvsAttribute.needsUpdate = true;
            }
        }
        fillMesh(time) {
            const scope = this;
            this.currentVertex = 0;
            this.currentIndex = 0;
            this.currentCoordinate = 0;
            this.currentUVCoordinate = 0;
            this.fractalRay(time, function fillVertices(segment) {
                const subray = scope.currentSubray;
                if (time < subray.birthTime) {
                    return;
                } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {
                    scope.createPrism(segment);
                    scope.onDecideSubrayCreation(segment, scope);
                } else if (time < subray.endPropagationTime) {
                    if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {
                        scope.createPrism(segment);
                        scope.onDecideSubrayCreation(segment, scope);
                    }
                } else if (time < subray.beginVanishingTime) {
                    scope.createPrism(segment);
                    scope.onDecideSubrayCreation(segment, scope);
                } else {
                    if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {
                        scope.createPrism(segment);
                    }
                    scope.onDecideSubrayCreation(segment, scope);
                }
            });
        }
        addNewSubray() {
            return this.subrays[this.numSubrays++];
        }
        initSubray(subray, rayParameters) {
            subray.pos0.copy(rayParameters.sourceOffset);
            subray.pos1.copy(rayParameters.destOffset);
            subray.up0.copy(rayParameters.up0);
            subray.up1.copy(rayParameters.up1);
            subray.radius0 = rayParameters.radius0;
            subray.radius1 = rayParameters.radius1;
            subray.birthTime = rayParameters.birthTime;
            subray.deathTime = rayParameters.deathTime;
            subray.timeScale = rayParameters.timeScale;
            subray.roughness = rayParameters.roughness;
            subray.straightness = rayParameters.straightness;
            subray.propagationTimeFactor = rayParameters.propagationTimeFactor;
            subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;
            subray.maxIterations = this.maxIterations;
            subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;
            subray.recursion = 0;
        }
        fractalRay(time, segmentCallback) {
            this.time = time;
            this.currentSegmentCallback = segmentCallback;
            this.numSubrays = 0;
            this.initSubray(this.addNewSubray(), this.rayParameters);
            for(let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++){
                const subray = this.subrays[subrayIndex];
                this.currentSubray = subray;
                this.randomGenerator.setSeed(subray.seed);
                subray.endPropagationTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);
                subray.beginVanishingTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);
                const random1 = this.randomGenerator.random;
                subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
                subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
                this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);
                this.currentSegmentIndex = 0;
                this.isInitialSegment = true;
                const segment = this.getNewSegment();
                segment.iteration = 0;
                segment.pos0.copy(subray.pos0);
                segment.pos1.copy(subray.pos1);
                segment.linPos0.copy(subray.linPos0);
                segment.linPos1.copy(subray.linPos1);
                segment.up0.copy(subray.up0);
                segment.up1.copy(subray.up1);
                segment.radius0 = subray.radius0;
                segment.radius1 = subray.radius1;
                segment.fraction0 = 0;
                segment.fraction1 = 1;
                segment.positionVariationFactor = 1 - subray.straightness;
                this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);
                this.fractalRayRecursive(segment);
            }
            this.currentSegmentCallback = null;
            this.currentSubray = null;
        }
        fractalRayRecursive(segment) {
            if (segment.iteration >= this.currentSubray.maxIterations) {
                this.currentSegmentCallback(segment);
                return;
            }
            this.forwards.subVectors(segment.pos1, segment.pos0);
            let lForwards = this.forwards.length();
            if (lForwards < 1e-6) {
                this.forwards.set(0, 0, 0.01);
                lForwards = this.forwards.length();
            }
            const middleRadius = (segment.radius0 + segment.radius1) * 0.5;
            const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;
            const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);
            this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);
            this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);
            const p = this.middleLinPos;
            this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));
            this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);
            this.newPos.add(this.middlePos);
            const newSegment1 = this.getNewSegment();
            newSegment1.pos0.copy(segment.pos0);
            newSegment1.pos1.copy(this.newPos);
            newSegment1.linPos0.copy(segment.linPos0);
            newSegment1.linPos1.copy(this.middleLinPos);
            newSegment1.up0.copy(segment.up0);
            newSegment1.up1.copy(segment.up1);
            newSegment1.radius0 = segment.radius0;
            newSegment1.radius1 = middleRadius;
            newSegment1.fraction0 = segment.fraction0;
            newSegment1.fraction1 = middleFraction;
            newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
            newSegment1.iteration = segment.iteration + 1;
            const newSegment2 = this.getNewSegment();
            newSegment2.pos0.copy(this.newPos);
            newSegment2.pos1.copy(segment.pos1);
            newSegment2.linPos0.copy(this.middleLinPos);
            newSegment2.linPos1.copy(segment.linPos1);
            this.cross1.crossVectors(segment.up0, this.forwards.normalize());
            newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();
            newSegment2.up1.copy(segment.up1);
            newSegment2.radius0 = middleRadius;
            newSegment2.radius1 = segment.radius1;
            newSegment2.fraction0 = middleFraction;
            newSegment2.fraction1 = segment.fraction1;
            newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
            newSegment2.iteration = segment.iteration + 1;
            this.fractalRayRecursive(newSegment1);
            this.fractalRayRecursive(newSegment2);
        }
        createPrism(segment) {
            this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();
            if (this.isInitialSegment) {
                this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);
                this.isInitialSegment = false;
            }
            this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);
            this.createPrismFaces();
        }
        createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {
            this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);
            this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);
            const p = this.vPos;
            const v = this.vertices;
            p.copy(pos).sub(this.side).add(this.down);
            v[this.currentCoordinate++] = p.x;
            v[this.currentCoordinate++] = p.y;
            v[this.currentCoordinate++] = p.z;
            p.copy(pos).add(this.side).add(this.down);
            v[this.currentCoordinate++] = p.x;
            v[this.currentCoordinate++] = p.y;
            v[this.currentCoordinate++] = p.z;
            p.copy(up).multiplyScalar(radius).add(pos);
            v[this.currentCoordinate++] = p.x;
            v[this.currentCoordinate++] = p.y;
            v[this.currentCoordinate++] = p.z;
            this.currentVertex += 3;
        }
        createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {
            this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);
            this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);
            const p = this.vPos;
            const v = this.vertices;
            const uv = this.uvs;
            p.copy(pos).sub(this.side).add(this.down);
            v[this.currentCoordinate++] = p.x;
            v[this.currentCoordinate++] = p.y;
            v[this.currentCoordinate++] = p.z;
            uv[this.currentUVCoordinate++] = u;
            uv[this.currentUVCoordinate++] = 0;
            p.copy(pos).add(this.side).add(this.down);
            v[this.currentCoordinate++] = p.x;
            v[this.currentCoordinate++] = p.y;
            v[this.currentCoordinate++] = p.z;
            uv[this.currentUVCoordinate++] = u;
            uv[this.currentUVCoordinate++] = 0.5;
            p.copy(up).multiplyScalar(radius).add(pos);
            v[this.currentCoordinate++] = p.x;
            v[this.currentCoordinate++] = p.y;
            v[this.currentCoordinate++] = p.z;
            uv[this.currentUVCoordinate++] = u;
            uv[this.currentUVCoordinate++] = 1;
            this.currentVertex += 3;
        }
        createPrismFaces(vertex) {
            const indices = this.indices;
            vertex = this.currentVertex - 6;
            indices[this.currentIndex++] = vertex + 1;
            indices[this.currentIndex++] = vertex + 2;
            indices[this.currentIndex++] = vertex + 5;
            indices[this.currentIndex++] = vertex + 1;
            indices[this.currentIndex++] = vertex + 5;
            indices[this.currentIndex++] = vertex + 4;
            indices[this.currentIndex++] = vertex + 0;
            indices[this.currentIndex++] = vertex + 1;
            indices[this.currentIndex++] = vertex + 4;
            indices[this.currentIndex++] = vertex + 0;
            indices[this.currentIndex++] = vertex + 4;
            indices[this.currentIndex++] = vertex + 3;
            indices[this.currentIndex++] = vertex + 2;
            indices[this.currentIndex++] = vertex + 0;
            indices[this.currentIndex++] = vertex + 3;
            indices[this.currentIndex++] = vertex + 2;
            indices[this.currentIndex++] = vertex + 3;
            indices[this.currentIndex++] = vertex + 5;
        }
        createDefaultSubrayCreationCallbacks() {
            const random1 = this.randomGenerator.random;
            this.onDecideSubrayCreation = function(segment, lightningStrike) {
                const subray = lightningStrike.currentSubray;
                const period = lightningStrike.rayParameters.subrayPeriod;
                const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;
                const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;
                const phase = lightningStrike.time - phase0;
                const currentCycle = Math.floor(phase / period);
                const childSubraySeed = random1() * (currentCycle + 1);
                const isActive = phase % period <= dutyCycle * period;
                let probability = 0;
                if (isActive) {
                    probability = lightningStrike.subrayProbability;
                }
                if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {
                    const childSubray = lightningStrike.addNewSubray();
                    const parentSeed = lightningStrike.randomGenerator.getSeed();
                    childSubray.seed = childSubraySeed;
                    lightningStrike.randomGenerator.setSeed(childSubraySeed);
                    childSubray.recursion = subray.recursion + 1;
                    childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);
                    childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
                    childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
                    childSubray.up0.copy(subray.up0);
                    childSubray.up1.copy(subray.up1);
                    childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;
                    childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);
                    childSubray.birthTime = phase0 + currentCycle * period;
                    childSubray.deathTime = childSubray.birthTime + period * dutyCycle;
                    if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {
                        childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);
                        childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);
                    }
                    childSubray.timeScale = subray.timeScale * 2;
                    childSubray.roughness = subray.roughness;
                    childSubray.straightness = subray.straightness;
                    childSubray.propagationTimeFactor = subray.propagationTimeFactor;
                    childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;
                    lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);
                    lightningStrike.randomGenerator.setSeed(parentSeed);
                }
            };
            const vec1Pos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const vec2Forward = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const vec3Side = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const vec4Up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            this.onSubrayCreation = function(segment, parentSubray, childSubray, lightningStrike) {
                lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);
            };
            this.subrayConePosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {
                childSubray.pos0.copy(segment.pos0);
                vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
                vec2Forward.copy(vec1Pos).normalize();
                vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));
                const length = vec1Pos.length();
                vec3Side.crossVectors(parentSubray.up0, vec2Forward);
                const angle = 2 * Math.PI * random1();
                vec3Side.multiplyScalar(Math.cos(angle));
                vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
                childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
            };
            this.subrayCylinderPosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {
                childSubray.pos0.copy(segment.pos0);
                vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
                vec2Forward.copy(vec1Pos).normalize();
                vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));
                const length = vec1Pos.length();
                vec3Side.crossVectors(parentSubray.up0, vec2Forward);
                const angle = 2 * Math.PI * random1();
                vec3Side.multiplyScalar(Math.cos(angle));
                vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
                childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
            };
        }
        createSubray() {
            return {
                seed: 0,
                maxIterations: 0,
                recursion: 0,
                pos0: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                pos1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                linPos0: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                linPos1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                up0: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                up1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                radius0: 0,
                radius1: 0,
                birthTime: 0,
                deathTime: 0,
                timeScale: 0,
                roughness: 0,
                straightness: 0,
                propagationTimeFactor: 0,
                vanishingTimeFactor: 0,
                endPropagationTime: 0,
                beginVanishingTime: 0
            };
        }
        createSegment() {
            return {
                iteration: 0,
                pos0: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                pos1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                linPos0: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                linPos1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                up0: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                up1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                radius0: 0,
                radius1: 0,
                fraction0: 0,
                fraction1: 0,
                positionVariationFactor: 0
            };
        }
        getNewSegment() {
            return this.raySegments[this.currentSegmentIndex++];
        }
        copy(source) {
            super.copy(source);
            this.init(_LightningStrike.copyParameters({}, source.rayParameters));
            return this;
        }
        clone() {
            return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));
        }
    };
    let LightningStrike2 = _LightningStrike;
    // Ray states
    __publicField(LightningStrike2, "RAY_INITIALIZED", 0);
    __publicField(LightningStrike2, "RAY_UNBORN", 1);
    __publicField(LightningStrike2, "RAY_PROPAGATING", 2);
    __publicField(LightningStrike2, "RAY_STEADY", 3);
    __publicField(LightningStrike2, "RAY_VANISHING", 4);
    __publicField(LightningStrike2, "RAY_EXTINGUISHED", 5);
    __publicField(LightningStrike2, "COS30DEG", Math.cos(30 * Math.PI / 180));
    __publicField(LightningStrike2, "SIN30DEG", Math.sin(30 * Math.PI / 180));
    return LightningStrike2;
})();
;
 //# sourceMappingURL=LightningStrike.js.map
}}),
"[project]/node_modules/three-stdlib/geometries/ParametricGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ParametricGeometry": (()=>ParametricGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class ParametricGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(func = (u, v, target)=>target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8){
        super();
        this.type = "ParametricGeometry";
        this.parameters = {
            func,
            slices,
            stacks
        };
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const EPS = 1e-5;
        const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const p0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), p1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const pu = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), pv = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const sliceCount = slices + 1;
        for(let i = 0; i <= stacks; i++){
            const v = i / stacks;
            for(let j = 0; j <= slices; j++){
                const u = j / slices;
                func(u, v, p0);
                vertices.push(p0.x, p0.y, p0.z);
                if (u - EPS >= 0) {
                    func(u - EPS, v, p1);
                    pu.subVectors(p0, p1);
                } else {
                    func(u + EPS, v, p1);
                    pu.subVectors(p1, p0);
                }
                if (v - EPS >= 0) {
                    func(u, v - EPS, p1);
                    pv.subVectors(p0, p1);
                } else {
                    func(u, v + EPS, p1);
                    pv.subVectors(p1, p0);
                }
                normal.crossVectors(pu, pv).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, v);
            }
        }
        for(let i = 0; i < stacks; i++){
            for(let j = 0; j < slices; j++){
                const a = i * sliceCount + j;
                const b = i * sliceCount + j + 1;
                const c = (i + 1) * sliceCount + j + 1;
                const d = (i + 1) * sliceCount + j;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](vertices, 3));
        this.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normals, 3));
        this.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uvs, 2));
    }
}
;
 //# sourceMappingURL=ParametricGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/geometries/ParametricGeometries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ParametricGeometries": (()=>ParametricGeometries)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ParametricGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/ParametricGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class TubeGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ParametricGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ParametricGeometry"] {
    constructor(path, segments = 64, radius = 1, segmentsRadius = 8, closed = false){
        const numpoints = segments + 1;
        const frames = path.computeFrenetFrames(segments, closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        function ParametricTube(u, v, target) {
            v *= 2 * Math.PI;
            const i = Math.floor(u * (numpoints - 1));
            path.getPointAt(u, position);
            const normal = normals[i];
            const binormal = binormals[i];
            const cx = -radius * Math.cos(v);
            const cy = radius * Math.sin(v);
            position.x += cx * normal.x + cy * binormal.x;
            position.y += cx * normal.y + cy * binormal.y;
            position.z += cx * normal.z + cy * binormal.z;
            target.copy(position);
        }
        super(ParametricTube, segments, segmentsRadius);
        this.tangents = tangents;
        this.normals = normals;
        this.binormals = binormals;
        this.path = path;
        this.segments = segments;
        this.radius = radius;
        this.segmentsRadius = segmentsRadius;
        this.closed = closed;
    }
}
const ParametricGeometries = {
    klein: function(v, u, target) {
        u *= Math.PI;
        v *= 2 * Math.PI;
        u = u * 2;
        let x, z;
        if (u < Math.PI) {
            x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);
            z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
        } else {
            x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
            z = -8 * Math.sin(u);
        }
        const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
        target.set(x, y, z);
    },
    plane: function(width, height) {
        return function(u, v, target) {
            const x = u * width;
            const y = 0;
            const z = v * height;
            target.set(x, y, z);
        };
    },
    mobius: function(u, t, target) {
        u = u - 0.5;
        const v = 2 * Math.PI * t;
        const a = 2;
        const x = Math.cos(v) * (a + u * Math.cos(v / 2));
        const y = Math.sin(v) * (a + u * Math.cos(v / 2));
        const z = u * Math.sin(v / 2);
        target.set(x, y, z);
    },
    mobius3d: function(u, t, target) {
        u *= Math.PI;
        t *= 2 * Math.PI;
        u = u * 2;
        const phi = u / 2;
        const major = 2.25, a = 0.125, b = 0.65;
        let x = a * Math.cos(t) * Math.cos(phi) - b * Math.sin(t) * Math.sin(phi);
        const z = a * Math.cos(t) * Math.sin(phi) + b * Math.sin(t) * Math.cos(phi);
        const y = (major + x) * Math.sin(u);
        x = (major + x) * Math.cos(u);
        target.set(x, y, z);
    },
    TubeGeometry,
    TorusKnotGeometry: class TorusKnotGeometry extends TubeGeometry {
        constructor(radius = 200, tube = 40, segmentsT = 64, segmentsR = 8, p = 2, q = 3){
            class TorusKnotCurve extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
                getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
                    const point = optionalTarget;
                    t *= Math.PI * 2;
                    const r = 0.5;
                    const x = (1 + r * Math.cos(q * t)) * Math.cos(p * t);
                    const y = (1 + r * Math.cos(q * t)) * Math.sin(p * t);
                    const z = r * Math.sin(q * t);
                    return point.set(x, y, z).multiplyScalar(radius);
                }
            }
            const segments = segmentsT;
            const radiusSegments = segmentsR;
            const extrudePath = new TorusKnotCurve();
            super(extrudePath, segments, tube, radiusSegments, true, false);
            this.radius = radius;
            this.tube = tube;
            this.segmentsT = segmentsT;
            this.segmentsR = segmentsR;
            this.p = p;
            this.q = q;
        }
    },
    SphereGeometry: class SphereGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ParametricGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ParametricGeometry"] {
        constructor(size, u, v){
            function sphere(u2, v2, target) {
                u2 *= Math.PI;
                v2 *= 2 * Math.PI;
                const x = size * Math.sin(u2) * Math.cos(v2);
                const y = size * Math.sin(u2) * Math.sin(v2);
                const z = size * Math.cos(u2);
                target.set(x, y, z);
            }
            super(sphere, u, v);
        }
    },
    PlaneGeometry: class PlaneGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ParametricGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ParametricGeometry"] {
        constructor(width, depth, segmentsWidth, segmentsDepth){
            function plane(u, v, target) {
                const x = u * width;
                const y = 0;
                const z = v * depth;
                target.set(x, y, z);
            }
            super(plane, segmentsWidth, segmentsDepth);
        }
    }
};
;
 //# sourceMappingURL=ParametricGeometries.js.map
}}),
"[project]/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RoundedBoxGeometry": (()=>RoundedBoxGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const tempNormal = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
function getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {
    const totArcLength = 2 * Math.PI * radius / 4;
    const centerLength = Math.max(sideLength - 2 * radius, 0);
    const halfArc = Math.PI / 4;
    tempNormal.copy(normal);
    tempNormal[projectionAxis] = 0;
    tempNormal.normalize();
    const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);
    const arcAngleRatio = 1 - tempNormal.angleTo(faceDirVector) / halfArc;
    if (Math.sign(tempNormal[uvAxis]) === 1) {
        return arcAngleRatio * arcUvRatio;
    } else {
        const lenUv = centerLength / (totArcLength + centerLength);
        return lenUv + arcUvRatio + arcUvRatio * (1 - arcAngleRatio);
    }
}
class RoundedBoxGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxGeometry"] {
    constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1){
        segments = segments * 2 + 1;
        radius = Math.min(width / 2, height / 2, depth / 2, radius);
        super(1, 1, 1, segments, segments, segments);
        if (segments === 1) return;
        const geometry2 = this.toNonIndexed();
        this.index = null;
        this.attributes.position = geometry2.attributes.position;
        this.attributes.normal = geometry2.attributes.normal;
        this.attributes.uv = geometry2.attributes.uv;
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const box = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](width, height, depth).divideScalar(2).subScalar(radius);
        const positions = this.attributes.position.array;
        const normals = this.attributes.normal.array;
        const uvs = this.attributes.uv.array;
        const faceTris = positions.length / 6;
        const faceDirVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const halfSegmentSize = 0.5 / segments;
        for(let i = 0, j = 0; i < positions.length; i += 3, j += 2){
            position.fromArray(positions, i);
            normal.copy(position);
            normal.x -= Math.sign(normal.x) * halfSegmentSize;
            normal.y -= Math.sign(normal.y) * halfSegmentSize;
            normal.z -= Math.sign(normal.z) * halfSegmentSize;
            normal.normalize();
            positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;
            positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;
            positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;
            normals[i + 0] = normal.x;
            normals[i + 1] = normal.y;
            normals[i + 2] = normal.z;
            const side = Math.floor(i / faceTris);
            switch(side){
                case 0:
                    faceDirVector.set(1, 0, 0);
                    uvs[j + 0] = getUv(faceDirVector, normal, "z", "y", radius, depth);
                    uvs[j + 1] = 1 - getUv(faceDirVector, normal, "y", "z", radius, height);
                    break;
                case 1:
                    faceDirVector.set(-1, 0, 0);
                    uvs[j + 0] = 1 - getUv(faceDirVector, normal, "z", "y", radius, depth);
                    uvs[j + 1] = 1 - getUv(faceDirVector, normal, "y", "z", radius, height);
                    break;
                case 2:
                    faceDirVector.set(0, 1, 0);
                    uvs[j + 0] = 1 - getUv(faceDirVector, normal, "x", "z", radius, width);
                    uvs[j + 1] = getUv(faceDirVector, normal, "z", "x", radius, depth);
                    break;
                case 3:
                    faceDirVector.set(0, -1, 0);
                    uvs[j + 0] = 1 - getUv(faceDirVector, normal, "x", "z", radius, width);
                    uvs[j + 1] = 1 - getUv(faceDirVector, normal, "z", "x", radius, depth);
                    break;
                case 4:
                    faceDirVector.set(0, 0, 1);
                    uvs[j + 0] = 1 - getUv(faceDirVector, normal, "x", "y", radius, width);
                    uvs[j + 1] = 1 - getUv(faceDirVector, normal, "y", "x", radius, height);
                    break;
                case 5:
                    faceDirVector.set(0, 0, -1);
                    uvs[j + 0] = getUv(faceDirVector, normal, "x", "y", radius, width);
                    uvs[j + 1] = 1 - getUv(faceDirVector, normal, "y", "x", radius, height);
                    break;
            }
        }
    }
}
;
 //# sourceMappingURL=RoundedBoxGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/geometries/BoxLineGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BoxLineGeometry": (()=>BoxLineGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class BoxLineGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(width, height, depth, widthSegments, heightSegments, depthSegments){
        super();
        width = width || 1;
        height = height || 1;
        depth = depth || 1;
        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;
        const widthHalf = width / 2;
        const heightHalf = height / 2;
        const depthHalf = depth / 2;
        const segmentWidth = width / widthSegments;
        const segmentHeight = height / heightSegments;
        const segmentDepth = depth / depthSegments;
        const vertices = [];
        let x = -widthHalf, y = -heightHalf, z = -depthHalf;
        for(let i = 0; i <= widthSegments; i++){
            vertices.push(x, -heightHalf, -depthHalf, x, heightHalf, -depthHalf);
            vertices.push(x, heightHalf, -depthHalf, x, heightHalf, depthHalf);
            vertices.push(x, heightHalf, depthHalf, x, -heightHalf, depthHalf);
            vertices.push(x, -heightHalf, depthHalf, x, -heightHalf, -depthHalf);
            x += segmentWidth;
        }
        for(let i = 0; i <= heightSegments; i++){
            vertices.push(-widthHalf, y, -depthHalf, widthHalf, y, -depthHalf);
            vertices.push(widthHalf, y, -depthHalf, widthHalf, y, depthHalf);
            vertices.push(widthHalf, y, depthHalf, -widthHalf, y, depthHalf);
            vertices.push(-widthHalf, y, depthHalf, -widthHalf, y, -depthHalf);
            y += segmentHeight;
        }
        for(let i = 0; i <= depthSegments; i++){
            vertices.push(-widthHalf, -heightHalf, z, -widthHalf, heightHalf, z);
            vertices.push(-widthHalf, heightHalf, z, widthHalf, heightHalf, z);
            vertices.push(widthHalf, heightHalf, z, widthHalf, -heightHalf, z);
            vertices.push(widthHalf, -heightHalf, z, -widthHalf, -heightHalf, z);
            z += segmentDepth;
        }
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](vertices, 3));
    }
}
;
 //# sourceMappingURL=BoxLineGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/geometries/DecalGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DecalGeometry": (()=>DecalGeometry),
    "DecalVertex": (()=>DecalVertex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class DecalGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"] {
    constructor(mesh, position, orientation, size){
        super();
        const vertices = [];
        const normals = [];
        const uvs = [];
        const plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const projectorMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        projectorMatrix.makeRotationFromEuler(orientation);
        projectorMatrix.setPosition(position);
        const projectorMatrixInverse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        projectorMatrixInverse.copy(projectorMatrix).invert();
        generate();
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](vertices, 3));
        this.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normals, 3));
        this.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uvs, 2));
        function generate() {
            let i;
            let decalVertices = [];
            const vertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            if (mesh.geometry.isGeometry === true) {
                console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");
                return;
            }
            const geometry = mesh.geometry;
            const positionAttribute = geometry.attributes.position;
            const normalAttribute = geometry.attributes.normal;
            if (geometry.index !== null) {
                const index = geometry.index;
                for(i = 0; i < index.count; i++){
                    vertex.fromBufferAttribute(positionAttribute, index.getX(i));
                    normal.fromBufferAttribute(normalAttribute, index.getX(i));
                    pushDecalVertex(decalVertices, vertex, normal);
                }
            } else {
                for(i = 0; i < positionAttribute.count; i++){
                    vertex.fromBufferAttribute(positionAttribute, i);
                    normal.fromBufferAttribute(normalAttribute, i);
                    pushDecalVertex(decalVertices, vertex, normal);
                }
            }
            decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));
            decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));
            decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));
            decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));
            decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));
            decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));
            for(i = 0; i < decalVertices.length; i++){
                const decalVertex = decalVertices[i];
                uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y);
                decalVertex.position.applyMatrix4(projectorMatrix);
                vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);
                normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);
            }
        }
        function pushDecalVertex(decalVertices, vertex, normal) {
            vertex.applyMatrix4(mesh.matrixWorld);
            vertex.applyMatrix4(projectorMatrixInverse);
            normal.transformDirection(mesh.matrixWorld);
            decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));
        }
        function clipGeometry(inVertices, plane2) {
            const outVertices = [];
            const s = 0.5 * Math.abs(size.dot(plane2));
            for(let i = 0; i < inVertices.length; i += 3){
                let v1Out, v2Out, v3Out, total = 0;
                let nV1, nV2, nV3, nV4;
                const d1 = inVertices[i + 0].position.dot(plane2) - s;
                const d2 = inVertices[i + 1].position.dot(plane2) - s;
                const d3 = inVertices[i + 2].position.dot(plane2) - s;
                v1Out = d1 > 0;
                v2Out = d2 > 0;
                v3Out = d3 > 0;
                total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
                switch(total){
                    case 0:
                        {
                            outVertices.push(inVertices[i]);
                            outVertices.push(inVertices[i + 1]);
                            outVertices.push(inVertices[i + 2]);
                            break;
                        }
                    case 1:
                        {
                            if (v1Out) {
                                nV1 = inVertices[i + 1];
                                nV2 = inVertices[i + 2];
                                nV3 = clip(inVertices[i], nV1, plane2, s);
                                nV4 = clip(inVertices[i], nV2, plane2, s);
                            }
                            if (v2Out) {
                                nV1 = inVertices[i];
                                nV2 = inVertices[i + 2];
                                nV3 = clip(inVertices[i + 1], nV1, plane2, s);
                                nV4 = clip(inVertices[i + 1], nV2, plane2, s);
                                outVertices.push(nV3);
                                outVertices.push(nV2.clone());
                                outVertices.push(nV1.clone());
                                outVertices.push(nV2.clone());
                                outVertices.push(nV3.clone());
                                outVertices.push(nV4);
                                break;
                            }
                            if (v3Out) {
                                nV1 = inVertices[i];
                                nV2 = inVertices[i + 1];
                                nV3 = clip(inVertices[i + 2], nV1, plane2, s);
                                nV4 = clip(inVertices[i + 2], nV2, plane2, s);
                            }
                            outVertices.push(nV1.clone());
                            outVertices.push(nV2.clone());
                            outVertices.push(nV3);
                            outVertices.push(nV4);
                            outVertices.push(nV3.clone());
                            outVertices.push(nV2.clone());
                            break;
                        }
                    case 2:
                        {
                            if (!v1Out) {
                                nV1 = inVertices[i].clone();
                                nV2 = clip(nV1, inVertices[i + 1], plane2, s);
                                nV3 = clip(nV1, inVertices[i + 2], plane2, s);
                                outVertices.push(nV1);
                                outVertices.push(nV2);
                                outVertices.push(nV3);
                            }
                            if (!v2Out) {
                                nV1 = inVertices[i + 1].clone();
                                nV2 = clip(nV1, inVertices[i + 2], plane2, s);
                                nV3 = clip(nV1, inVertices[i], plane2, s);
                                outVertices.push(nV1);
                                outVertices.push(nV2);
                                outVertices.push(nV3);
                            }
                            if (!v3Out) {
                                nV1 = inVertices[i + 2].clone();
                                nV2 = clip(nV1, inVertices[i], plane2, s);
                                nV3 = clip(nV1, inVertices[i + 1], plane2, s);
                                outVertices.push(nV1);
                                outVertices.push(nV2);
                                outVertices.push(nV3);
                            }
                            break;
                        }
                }
            }
            return outVertices;
        }
        function clip(v0, v1, p, s) {
            const d0 = v0.position.dot(p) - s;
            const d1 = v1.position.dot(p) - s;
            const s0 = d0 / (d0 - d1);
            const v = new DecalVertex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z)));
            return v;
        }
    }
}
class DecalVertex {
    constructor(position, normal){
        this.position = position;
        this.normal = normal;
    }
    clone() {
        return new this.constructor(this.position.clone(), this.normal.clone());
    }
}
;
 //# sourceMappingURL=DecalGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/renderers/CSS2DRenderer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CSS2DObject": (()=>CSS2DObject),
    "CSS2DRenderer": (()=>CSS2DRenderer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class CSS2DObject extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(element = document.createElement("div")){
        super();
        this.isCSS2DObject = true;
        this.element = element;
        this.element.style.position = "absolute";
        this.element.style.userSelect = "none";
        this.element.setAttribute("draggable", false);
        this.center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](0.5, 0.5);
        this.addEventListener("removed", function() {
            this.traverse(function(object) {
                if (object.element instanceof Element && object.element.parentNode !== null) {
                    object.element.parentNode.removeChild(object.element);
                }
            });
        });
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.element = source.element.cloneNode(true);
        this.center = source.center;
        return this;
    }
}
const _vector = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _viewMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _viewProjectionMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _a = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _b = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class CSS2DRenderer {
    constructor(parameters = {}){
        const _this = this;
        let _width, _height;
        let _widthHalf, _heightHalf;
        const cache = {
            objects: /* @__PURE__ */ new WeakMap()
        };
        const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
        domElement.style.overflow = "hidden";
        this.domElement = domElement;
        this.getSize = function() {
            return {
                width: _width,
                height: _height
            };
        };
        this.render = function(scene, camera) {
            if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
            _viewMatrix.copy(camera.matrixWorldInverse);
            _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
            renderObject(scene, scene, camera);
            zOrder(scene);
        };
        this.setSize = function(width, height) {
            _width = width;
            _height = height;
            _widthHalf = _width / 2;
            _heightHalf = _height / 2;
            domElement.style.width = width + "px";
            domElement.style.height = height + "px";
        };
        function renderObject(object, scene, camera) {
            if (object.isCSS2DObject) {
                _vector.setFromMatrixPosition(object.matrixWorld);
                _vector.applyMatrix4(_viewProjectionMatrix);
                const visible = object.visible === true && _vector.z >= -1 && _vector.z <= 1 && object.layers.test(camera.layers) === true;
                object.element.style.display = visible === true ? "" : "none";
                if (visible === true) {
                    object.onBeforeRender(_this, scene, camera);
                    const element = object.element;
                    element.style.transform = "translate(" + -100 * object.center.x + "%," + -100 * object.center.y + "%)translate(" + (_vector.x * _widthHalf + _widthHalf) + "px," + (-_vector.y * _heightHalf + _heightHalf) + "px)";
                    if (element.parentNode !== domElement) {
                        domElement.appendChild(element);
                    }
                    object.onAfterRender(_this, scene, camera);
                }
                const objectData = {
                    distanceToCameraSquared: getDistanceToSquared(camera, object)
                };
                cache.objects.set(object, objectData);
            }
            for(let i = 0, l = object.children.length; i < l; i++){
                renderObject(object.children[i], scene, camera);
            }
        }
        function getDistanceToSquared(object1, object2) {
            _a.setFromMatrixPosition(object1.matrixWorld);
            _b.setFromMatrixPosition(object2.matrixWorld);
            return _a.distanceToSquared(_b);
        }
        function filterAndFlatten(scene) {
            const result = [];
            scene.traverse(function(object) {
                if (object.isCSS2DObject) result.push(object);
            });
            return result;
        }
        function zOrder(scene) {
            const sorted = filterAndFlatten(scene).sort(function(a, b) {
                if (a.renderOrder !== b.renderOrder) {
                    return b.renderOrder - a.renderOrder;
                }
                const distanceA = cache.objects.get(a).distanceToCameraSquared;
                const distanceB = cache.objects.get(b).distanceToCameraSquared;
                return distanceA - distanceB;
            });
            const zMax = sorted.length;
            for(let i = 0, l = sorted.length; i < l; i++){
                sorted[i].element.style.zIndex = zMax - i;
            }
        }
    }
}
;
 //# sourceMappingURL=CSS2DRenderer.js.map
}}),
"[project]/node_modules/three-stdlib/renderers/CSS3DRenderer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CSS3DObject": (()=>CSS3DObject),
    "CSS3DRenderer": (()=>CSS3DRenderer),
    "CSS3DSprite": (()=>CSS3DSprite)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _position = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _quaternion = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
const _scale = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class CSS3DObject extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(element = document.createElement("div")){
        super();
        this.isCSS3DObject = true;
        this.element = element;
        this.element.style.position = "absolute";
        this.element.style.pointerEvents = "auto";
        this.element.style.userSelect = "none";
        this.element.setAttribute("draggable", false);
        this.addEventListener("removed", function() {
            this.traverse(function(object) {
                if (object.element instanceof Element && object.element.parentNode !== null) {
                    object.element.parentNode.removeChild(object.element);
                }
            });
        });
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.element = source.element.cloneNode(true);
        return this;
    }
}
class CSS3DSprite extends CSS3DObject {
    constructor(element){
        super(element);
        this.isCSS3DSprite = true;
        this.rotation2D = 0;
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.rotation2D = source.rotation2D;
        return this;
    }
}
const _matrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _matrix2 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
class CSS3DRenderer {
    constructor(parameters = {}){
        const _this = this;
        let _width, _height;
        let _widthHalf, _heightHalf;
        const cache = {
            camera: {
                style: ""
            },
            objects: /* @__PURE__ */ new WeakMap()
        };
        const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
        domElement.style.overflow = "hidden";
        this.domElement = domElement;
        const viewElement = document.createElement("div");
        viewElement.style.transformOrigin = "0 0";
        viewElement.style.pointerEvents = "none";
        domElement.appendChild(viewElement);
        const cameraElement = document.createElement("div");
        cameraElement.style.transformStyle = "preserve-3d";
        viewElement.appendChild(cameraElement);
        this.getSize = function() {
            return {
                width: _width,
                height: _height
            };
        };
        this.render = function(scene, camera) {
            const fov = camera.projectionMatrix.elements[5] * _heightHalf;
            if (camera.view && camera.view.enabled) {
                viewElement.style.transform = `translate( ${-camera.view.offsetX * (_width / camera.view.width)}px, ${-camera.view.offsetY * (_height / camera.view.height)}px )`;
                viewElement.style.transform += `scale( ${camera.view.fullWidth / camera.view.width}, ${camera.view.fullHeight / camera.view.height} )`;
            } else {
                viewElement.style.transform = "";
            }
            if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
            let tx, ty;
            if (camera.isOrthographicCamera) {
                tx = -(camera.right + camera.left) / 2;
                ty = (camera.top + camera.bottom) / 2;
            }
            const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;
            const cameraCSSMatrix = camera.isOrthographicCamera ? `scale( ${scaleByViewOffset} )scale(` + fov + ")translate(" + epsilon(tx) + "px," + epsilon(ty) + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse) : `scale( ${scaleByViewOffset} )translateZ(` + fov + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse);
            const perspective = camera.isPerspectiveCamera ? "perspective(" + fov + "px) " : "";
            const style = perspective + cameraCSSMatrix + "translate(" + _widthHalf + "px," + _heightHalf + "px)";
            if (cache.camera.style !== style) {
                cameraElement.style.transform = style;
                cache.camera.style = style;
            }
            renderObject(scene, scene, camera);
        };
        this.setSize = function(width, height) {
            _width = width;
            _height = height;
            _widthHalf = _width / 2;
            _heightHalf = _height / 2;
            domElement.style.width = width + "px";
            domElement.style.height = height + "px";
            viewElement.style.width = width + "px";
            viewElement.style.height = height + "px";
            cameraElement.style.width = width + "px";
            cameraElement.style.height = height + "px";
        };
        function epsilon(value) {
            return Math.abs(value) < 1e-10 ? 0 : value;
        }
        function getCameraCSSMatrix(matrix) {
            const elements = matrix.elements;
            return "matrix3d(" + epsilon(elements[0]) + "," + epsilon(-elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(elements[6]) + "," + epsilon(elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(-elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(-elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
        }
        function getObjectCSSMatrix(matrix) {
            const elements = matrix.elements;
            const matrix3d = "matrix3d(" + epsilon(elements[0]) + "," + epsilon(elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(-elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(-elements[6]) + "," + epsilon(-elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
            return "translate(-50%,-50%)" + matrix3d;
        }
        function renderObject(object, scene, camera, cameraCSSMatrix) {
            if (object.isCSS3DObject) {
                const visible = object.visible === true && object.layers.test(camera.layers) === true;
                object.element.style.display = visible === true ? "" : "none";
                if (visible === true) {
                    object.onBeforeRender(_this, scene, camera);
                    let style;
                    if (object.isCSS3DSprite) {
                        _matrix.copy(camera.matrixWorldInverse);
                        _matrix.transpose();
                        if (object.rotation2D !== 0) _matrix.multiply(_matrix2.makeRotationZ(object.rotation2D));
                        object.matrixWorld.decompose(_position, _quaternion, _scale);
                        _matrix.setPosition(_position);
                        _matrix.scale(_scale);
                        _matrix.elements[3] = 0;
                        _matrix.elements[7] = 0;
                        _matrix.elements[11] = 0;
                        _matrix.elements[15] = 1;
                        style = getObjectCSSMatrix(_matrix);
                    } else {
                        style = getObjectCSSMatrix(object.matrixWorld);
                    }
                    const element = object.element;
                    const cachedObject = cache.objects.get(object);
                    if (cachedObject === void 0 || cachedObject.style !== style) {
                        element.style.transform = style;
                        const objectData = {
                            style
                        };
                        cache.objects.set(object, objectData);
                    }
                    if (element.parentNode !== cameraElement) {
                        cameraElement.appendChild(element);
                    }
                    object.onAfterRender(_this, scene, camera);
                }
            }
            for(let i = 0, l = object.children.length; i < l; i++){
                renderObject(object.children[i], scene, camera);
            }
        }
    }
}
;
 //# sourceMappingURL=CSS3DRenderer.js.map
}}),
"[project]/node_modules/three-stdlib/renderers/Projector.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Projector": (()=>Projector),
    "RenderableFace": (()=>RenderableFace),
    "RenderableLine": (()=>RenderableLine),
    "RenderableObject": (()=>RenderableObject),
    "RenderableSprite": (()=>RenderableSprite),
    "RenderableVertex": (()=>RenderableVertex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class RenderableObject {
    constructor(){
        this.id = 0;
        this.object = null;
        this.z = 0;
        this.renderOrder = 0;
    }
}
class RenderableFace {
    constructor(){
        this.id = 0;
        this.v1 = new RenderableVertex();
        this.v2 = new RenderableVertex();
        this.v3 = new RenderableVertex();
        this.normalModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.vertexNormalsModel = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
        ];
        this.vertexNormalsLength = 0;
        this.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        this.material = null;
        this.uvs = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]()
        ];
        this.z = 0;
        this.renderOrder = 0;
    }
}
class RenderableVertex {
    constructor(){
        this.position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.positionWorld = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.positionScreen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
        this.visible = true;
    }
    copy(vertex) {
        this.positionWorld.copy(vertex.positionWorld);
        this.positionScreen.copy(vertex.positionScreen);
    }
}
class RenderableLine {
    constructor(){
        this.id = 0;
        this.v1 = new RenderableVertex();
        this.v2 = new RenderableVertex();
        this.vertexColors = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]()
        ];
        this.material = null;
        this.z = 0;
        this.renderOrder = 0;
    }
}
class RenderableSprite {
    constructor(){
        this.id = 0;
        this.object = null;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.rotation = 0;
        this.scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this.material = null;
        this.renderOrder = 0;
    }
}
class Projector {
    constructor(){
        let _object, _objectCount, _objectPoolLength = 0, _vertex, _vertexCount, _vertexPoolLength = 0, _face, _faceCount, _facePoolLength = 0, _line, _lineCount, _linePoolLength = 0, _sprite, _spriteCount, _spritePoolLength = 0, _modelMatrix;
        const _renderData = {
            objects: [],
            lights: [],
            elements: []
        }, _vector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), _vector4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](), _clipBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-1, -1, -1), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1)), _boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"](), _points3 = new Array(3), _viewMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](), _viewProjectionMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](), _modelViewProjectionMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](), _frustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Frustum"](), _objectPool = [], _vertexPool = [], _facePool = [], _linePool = [], _spritePool = [];
        function RenderList() {
            const normals = [];
            const colors = [];
            const uvs = [];
            let object = null;
            const normalMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]();
            function setObject(value) {
                object = value;
                normalMatrix.getNormalMatrix(object.matrixWorld);
                normals.length = 0;
                colors.length = 0;
                uvs.length = 0;
            }
            function projectVertex(vertex) {
                const position = vertex.position;
                const positionWorld = vertex.positionWorld;
                const positionScreen = vertex.positionScreen;
                positionWorld.copy(position).applyMatrix4(_modelMatrix);
                positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);
                const invW = 1 / positionScreen.w;
                positionScreen.x *= invW;
                positionScreen.y *= invW;
                positionScreen.z *= invW;
                vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;
            }
            function pushVertex(x, y, z) {
                _vertex = getNextVertexInPool();
                _vertex.position.set(x, y, z);
                projectVertex(_vertex);
            }
            function pushNormal(x, y, z) {
                normals.push(x, y, z);
            }
            function pushColor(r, g, b) {
                colors.push(r, g, b);
            }
            function pushUv(x, y) {
                uvs.push(x, y);
            }
            function checkTriangleVisibility(v1, v2, v3) {
                if (v1.visible === true || v2.visible === true || v3.visible === true) return true;
                _points3[0] = v1.positionScreen;
                _points3[1] = v2.positionScreen;
                _points3[2] = v3.positionScreen;
                return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));
            }
            function checkBackfaceCulling(v1, v2, v3) {
                return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;
            }
            function pushLine(a, b) {
                const v1 = _vertexPool[a];
                const v2 = _vertexPool[b];
                v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);
                v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);
                if (clipLine(v1.positionScreen, v2.positionScreen) === true) {
                    v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);
                    v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);
                    _line = getNextLineInPool();
                    _line.id = object.id;
                    _line.v1.copy(v1);
                    _line.v2.copy(v2);
                    _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);
                    _line.renderOrder = object.renderOrder;
                    _line.material = object.material;
                    if (object.material.vertexColors) {
                        _line.vertexColors[0].fromArray(colors, a * 3);
                        _line.vertexColors[1].fromArray(colors, b * 3);
                    }
                    _renderData.elements.push(_line);
                }
            }
            function pushTriangle(a, b, c, material) {
                const v1 = _vertexPool[a];
                const v2 = _vertexPool[b];
                const v3 = _vertexPool[c];
                if (checkTriangleVisibility(v1, v2, v3) === false) return;
                if (material.side === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"] || checkBackfaceCulling(v1, v2, v3) === true) {
                    _face = getNextFaceInPool();
                    _face.id = object.id;
                    _face.v1.copy(v1);
                    _face.v2.copy(v2);
                    _face.v3.copy(v3);
                    _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
                    _face.renderOrder = object.renderOrder;
                    _vector3.subVectors(v3.position, v2.position);
                    _vector4.subVectors(v1.position, v2.position);
                    _vector3.cross(_vector4);
                    _face.normalModel.copy(_vector3);
                    _face.normalModel.applyMatrix3(normalMatrix).normalize();
                    for(let i = 0; i < 3; i++){
                        const normal = _face.vertexNormalsModel[i];
                        normal.fromArray(normals, arguments[i] * 3);
                        normal.applyMatrix3(normalMatrix).normalize();
                        const uv = _face.uvs[i];
                        uv.fromArray(uvs, arguments[i] * 2);
                    }
                    _face.vertexNormalsLength = 3;
                    _face.material = material;
                    if (material.vertexColors) {
                        _face.color.fromArray(colors, a * 3);
                    }
                    _renderData.elements.push(_face);
                }
            }
            return {
                setObject,
                projectVertex,
                checkTriangleVisibility,
                checkBackfaceCulling,
                pushVertex,
                pushNormal,
                pushColor,
                pushUv,
                pushLine,
                pushTriangle
            };
        }
        const renderList = new RenderList();
        function projectObject(object) {
            if (object.visible === false) return;
            if (object.isLight) {
                _renderData.lights.push(object);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.material.visible === false) return;
                if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;
                addObject(object);
            } else if (object.isSprite) {
                if (object.material.visible === false) return;
                if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;
                addObject(object);
            }
            const children = object.children;
            for(let i = 0, l = children.length; i < l; i++){
                projectObject(children[i]);
            }
        }
        function addObject(object) {
            _object = getNextObjectInPool();
            _object.id = object.id;
            _object.object = object;
            _vector3.setFromMatrixPosition(object.matrixWorld);
            _vector3.applyMatrix4(_viewProjectionMatrix);
            _object.z = _vector3.z;
            _object.renderOrder = object.renderOrder;
            _renderData.objects.push(_object);
        }
        this.projectScene = function(scene, camera, sortObjects, sortElements) {
            _faceCount = 0;
            _lineCount = 0;
            _spriteCount = 0;
            _renderData.elements.length = 0;
            if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
            _viewMatrix.copy(camera.matrixWorldInverse);
            _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
            _frustum.setFromProjectionMatrix(_viewProjectionMatrix);
            _objectCount = 0;
            _renderData.objects.length = 0;
            _renderData.lights.length = 0;
            projectObject(scene);
            if (sortObjects === true) {
                _renderData.objects.sort(painterSort);
            }
            const objects = _renderData.objects;
            for(let o = 0, ol = objects.length; o < ol; o++){
                const object = objects[o].object;
                const geometry = object.geometry;
                renderList.setObject(object);
                _modelMatrix = object.matrixWorld;
                _vertexCount = 0;
                if (object.isMesh) {
                    let material = object.material;
                    const isMultiMaterial = Array.isArray(material);
                    const attributes = geometry.attributes;
                    const groups = geometry.groups;
                    if (attributes.position === void 0) continue;
                    const positions = attributes.position.array;
                    for(let i = 0, l = positions.length; i < l; i += 3){
                        let x = positions[i];
                        let y = positions[i + 1];
                        let z = positions[i + 2];
                        const morphTargets = geometry.morphAttributes.position;
                        if (morphTargets !== void 0) {
                            const morphTargetsRelative = geometry.morphTargetsRelative;
                            const morphInfluences = object.morphTargetInfluences;
                            for(let t = 0, tl = morphTargets.length; t < tl; t++){
                                const influence = morphInfluences[t];
                                if (influence === 0) continue;
                                const target = morphTargets[t];
                                if (morphTargetsRelative) {
                                    x += target.getX(i / 3) * influence;
                                    y += target.getY(i / 3) * influence;
                                    z += target.getZ(i / 3) * influence;
                                } else {
                                    x += (target.getX(i / 3) - positions[i]) * influence;
                                    y += (target.getY(i / 3) - positions[i + 1]) * influence;
                                    z += (target.getZ(i / 3) - positions[i + 2]) * influence;
                                }
                            }
                        }
                        renderList.pushVertex(x, y, z);
                    }
                    if (attributes.normal !== void 0) {
                        const normals = attributes.normal.array;
                        for(let i = 0, l = normals.length; i < l; i += 3){
                            renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);
                        }
                    }
                    if (attributes.color !== void 0) {
                        const colors = attributes.color.array;
                        for(let i = 0, l = colors.length; i < l; i += 3){
                            renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);
                        }
                    }
                    if (attributes.uv !== void 0) {
                        const uvs = attributes.uv.array;
                        for(let i = 0, l = uvs.length; i < l; i += 2){
                            renderList.pushUv(uvs[i], uvs[i + 1]);
                        }
                    }
                    if (geometry.index !== null) {
                        const indices = geometry.index.array;
                        if (groups.length > 0) {
                            for(let g = 0; g < groups.length; g++){
                                const group = groups[g];
                                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;
                                if (material === void 0) continue;
                                for(let i = group.start, l = group.start + group.count; i < l; i += 3){
                                    renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);
                                }
                            }
                        } else {
                            for(let i = 0, l = indices.length; i < l; i += 3){
                                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);
                            }
                        }
                    } else {
                        if (groups.length > 0) {
                            for(let g = 0; g < groups.length; g++){
                                const group = groups[g];
                                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;
                                if (material === void 0) continue;
                                for(let i = group.start, l = group.start + group.count; i < l; i += 3){
                                    renderList.pushTriangle(i, i + 1, i + 2, material);
                                }
                            }
                        } else {
                            for(let i = 0, l = positions.length / 3; i < l; i += 3){
                                renderList.pushTriangle(i, i + 1, i + 2, material);
                            }
                        }
                    }
                } else if (object.isLine) {
                    _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
                    const attributes = geometry.attributes;
                    if (attributes.position !== void 0) {
                        const positions = attributes.position.array;
                        for(let i = 0, l = positions.length; i < l; i += 3){
                            renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);
                        }
                        if (attributes.color !== void 0) {
                            const colors = attributes.color.array;
                            for(let i = 0, l = colors.length; i < l; i += 3){
                                renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);
                            }
                        }
                        if (geometry.index !== null) {
                            const indices = geometry.index.array;
                            for(let i = 0, l = indices.length; i < l; i += 2){
                                renderList.pushLine(indices[i], indices[i + 1]);
                            }
                        } else {
                            const step = object.isLineSegments ? 2 : 1;
                            for(let i = 0, l = positions.length / 3 - 1; i < l; i += step){
                                renderList.pushLine(i, i + 1);
                            }
                        }
                    }
                } else if (object.isPoints) {
                    _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
                    const attributes = geometry.attributes;
                    if (attributes.position !== void 0) {
                        const positions = attributes.position.array;
                        for(let i = 0, l = positions.length; i < l; i += 3){
                            _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1);
                            _vector4.applyMatrix4(_modelViewProjectionMatrix);
                            pushPoint(_vector4, object, camera);
                        }
                    }
                } else if (object.isSprite) {
                    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                    _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
                    _vector4.applyMatrix4(_viewProjectionMatrix);
                    pushPoint(_vector4, object, camera);
                }
            }
            if (sortElements === true) {
                _renderData.elements.sort(painterSort);
            }
            return _renderData;
        };
        function pushPoint(_vector42, object, camera) {
            const invW = 1 / _vector42.w;
            _vector42.z *= invW;
            if (_vector42.z >= -1 && _vector42.z <= 1) {
                _sprite = getNextSpriteInPool();
                _sprite.id = object.id;
                _sprite.x = _vector42.x * invW;
                _sprite.y = _vector42.y * invW;
                _sprite.z = _vector42.z;
                _sprite.renderOrder = object.renderOrder;
                _sprite.object = object;
                _sprite.rotation = object.rotation;
                _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector42.x + camera.projectionMatrix.elements[0]) / (_vector42.w + camera.projectionMatrix.elements[12]));
                _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector42.y + camera.projectionMatrix.elements[5]) / (_vector42.w + camera.projectionMatrix.elements[13]));
                _sprite.material = object.material;
                _renderData.elements.push(_sprite);
            }
        }
        function getNextObjectInPool() {
            if (_objectCount === _objectPoolLength) {
                const object = new RenderableObject();
                _objectPool.push(object);
                _objectPoolLength++;
                _objectCount++;
                return object;
            }
            return _objectPool[_objectCount++];
        }
        function getNextVertexInPool() {
            if (_vertexCount === _vertexPoolLength) {
                const vertex = new RenderableVertex();
                _vertexPool.push(vertex);
                _vertexPoolLength++;
                _vertexCount++;
                return vertex;
            }
            return _vertexPool[_vertexCount++];
        }
        function getNextFaceInPool() {
            if (_faceCount === _facePoolLength) {
                const face = new RenderableFace();
                _facePool.push(face);
                _facePoolLength++;
                _faceCount++;
                return face;
            }
            return _facePool[_faceCount++];
        }
        function getNextLineInPool() {
            if (_lineCount === _linePoolLength) {
                const line = new RenderableLine();
                _linePool.push(line);
                _linePoolLength++;
                _lineCount++;
                return line;
            }
            return _linePool[_lineCount++];
        }
        function getNextSpriteInPool() {
            if (_spriteCount === _spritePoolLength) {
                const sprite = new RenderableSprite();
                _spritePool.push(sprite);
                _spritePoolLength++;
                _spriteCount++;
                return sprite;
            }
            return _spritePool[_spriteCount++];
        }
        function painterSort(a, b) {
            if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            } else if (a.z !== b.z) {
                return b.z - a.z;
            } else if (a.id !== b.id) {
                return a.id - b.id;
            } else {
                return 0;
            }
        }
        function clipLine(s1, s2) {
            let alpha1 = 0, alpha2 = 1;
            const bc1near = s1.z + s1.w, bc2near = s2.z + s2.w, bc1far = -s1.z + s1.w, bc2far = -s2.z + s2.w;
            if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
                return true;
            } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {
                return false;
            } else {
                if (bc1near < 0) {
                    alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
                } else if (bc2near < 0) {
                    alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
                }
                if (bc1far < 0) {
                    alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
                } else if (bc2far < 0) {
                    alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
                }
                if (alpha2 < alpha1) {
                    return false;
                } else {
                    s1.lerp(s2, alpha1);
                    s2.lerp(s1, 1 - alpha2);
                    return true;
                }
            }
        }
    }
}
;
 //# sourceMappingURL=Projector.js.map
}}),
"[project]/node_modules/three-stdlib/textures/FlakesTexture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "FlakesTexture": (()=>FlakesTexture)
});
class FlakesTexture {
    constructor(width = 512, height = 512){
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.fillStyle = "rgb(127,127,255)";
        context.fillRect(0, 0, width, height);
        for(let i = 0; i < 4e3; i++){
            const x = Math.random() * width;
            const y = Math.random() * height;
            const r = Math.random() * 3 + 3;
            let nx = Math.random() * 2 - 1;
            let ny = Math.random() * 2 - 1;
            let nz = 1.5;
            const l = Math.sqrt(nx * nx + ny * ny + nz * nz);
            nx /= l;
            ny /= l;
            nz /= l;
            context.fillStyle = "rgb(" + (nx * 127 + 127) + "," + (ny * 127 + 127) + "," + nz * 255 + ")";
            context.beginPath();
            context.arc(x, y, r, 0, Math.PI * 2);
            context.fill();
        }
        return canvas;
    }
}
;
 //# sourceMappingURL=FlakesTexture.js.map
}}),
"[project]/node_modules/three-stdlib/modifiers/CurveModifier.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Flow": (()=>Flow),
    "InstancedFlow": (()=>InstancedFlow),
    "getUniforms": (()=>getUniforms),
    "initSplineTexture": (()=>initSplineTexture),
    "modifyShader": (()=>modifyShader),
    "updateSplineTexture": (()=>updateSplineTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
const CHANNELS = 4;
const TEXTURE_WIDTH = 1024;
const TEXTURE_HEIGHT = 4;
const initSplineTexture = (numberOfCurves = 1)=>{
    const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);
    const dataTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"](dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]);
    dataTexture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
    dataTexture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
    dataTexture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
    dataTexture.needsUpdate = true;
    return dataTexture;
};
const updateSplineTexture = (texture, splineCurve, offset = 0)=>{
    const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));
    splineCurve.arcLengthDivisions = numberOfPoints / 2;
    splineCurve.updateArcLengths();
    const points = splineCurve.getSpacedPoints(numberOfPoints);
    const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);
    for(let i = 0; i < numberOfPoints; i++){
        const rowOffset = Math.floor(i / TEXTURE_WIDTH);
        const rowIndex = i % TEXTURE_WIDTH;
        let pt = points[i];
        setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);
        pt = frenetFrames.tangents[i];
        setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);
        pt = frenetFrames.normals[i];
        setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);
        pt = frenetFrames.binormals[i];
        setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);
    }
    texture.needsUpdate = true;
};
const setTextureValue = (texture, index, x, y, z, o)=>{
    const image = texture.image;
    const { data } = image;
    const i = CHANNELS * TEXTURE_WIDTH * o;
    data[index * CHANNELS + i + 0] = x;
    data[index * CHANNELS + i + 1] = y;
    data[index * CHANNELS + i + 2] = z;
    data[index * CHANNELS + i + 3] = 1;
};
const getUniforms = (splineTexture)=>({
        spineTexture: {
            value: splineTexture
        },
        pathOffset: {
            type: "f",
            value: 0
        },
        // time of path curve
        pathSegment: {
            type: "f",
            value: 1
        },
        // fractional length of path
        spineOffset: {
            type: "f",
            value: 161
        },
        spineLength: {
            type: "f",
            value: 400
        },
        flow: {
            type: "i",
            value: 1
        }
    });
function modifyShader(material, uniforms, numberOfCurves = 1) {
    if (material.__ok) return;
    material.__ok = true;
    material.onBeforeCompile = (shader)=>{
        if (shader.__modified) return;
        shader.__modified = true;
        Object.assign(shader.uniforms, uniforms);
        const vertexShader = /* glsl */ `
		uniform sampler2D spineTexture;
		uniform float pathOffset;
		uniform float pathSegment;
		uniform float spineOffset;
		uniform float spineLength;
		uniform int flow;

		float textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;
		float textureStacks = ${TEXTURE_HEIGHT / 4}.;

		${shader.vertexShader}
		`.replace("#include <beginnormal_vertex>", "").replace("#include <defaultnormal_vertex>", "").replace("#include <begin_vertex>", "").replace(/void\s*main\s*\(\)\s*\{/, /* glsl */ `
        void main() {
        #include <beginnormal_vertex>

        vec4 worldPos = modelMatrix * vec4(position, 1.);

        bool bend = flow > 0;
        float xWeight = bend ? 0. : 1.;

        #ifdef USE_INSTANCING
        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];
        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];
        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;
        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;
        #else
        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;
        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;
        #endif

        mt = mod(mt, textureStacks);
        float rowOffset = floor(mt);

        #ifdef USE_INSTANCING
        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;
        #endif

        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;
        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;
        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;
        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;
        mat3 basis = mat3(a, b, c);

        vec3 transformed = basis
          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)
          + spinePos;

        vec3 transformedNormal = normalMatrix * (basis * objectNormal);
			`).replace("#include <project_vertex>", /* glsl */ `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
				gl_Position = projectionMatrix * mvPosition;`);
        shader.vertexShader = vertexShader;
    };
}
class Flow {
    /**
   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve
   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves
   */ constructor(mesh, numberOfCurves = 1){
        __publicField(this, "curveArray");
        __publicField(this, "curveLengthArray");
        __publicField(this, "object3D");
        __publicField(this, "splineTexure");
        __publicField(this, "uniforms");
        const obj3D = mesh.clone();
        const splineTexure = initSplineTexture(numberOfCurves);
        const uniforms = getUniforms(splineTexure);
        obj3D.traverse((child)=>{
            if (child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] || child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedMesh"]) {
                child.material = child.material.clone();
                modifyShader(child.material, uniforms, numberOfCurves);
            }
        });
        this.curveArray = new Array(numberOfCurves);
        this.curveLengthArray = new Array(numberOfCurves);
        this.object3D = obj3D;
        this.splineTexure = splineTexure;
        this.uniforms = uniforms;
    }
    updateCurve(index, curve) {
        if (index >= this.curveArray.length) throw Error("Index out of range for Flow");
        const curveLength = curve.getLength();
        this.uniforms.spineLength.value = curveLength;
        this.curveLengthArray[index] = curveLength;
        this.curveArray[index] = curve;
        updateSplineTexture(this.splineTexure, curve, index);
    }
    moveAlongCurve(amount) {
        this.uniforms.pathOffset.value += amount;
    }
}
const matrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
class InstancedFlow extends Flow {
    /**
   *
   * @param {number} count The number of instanced elements
   * @param {number} curveCount The number of curves to preallocate for
   * @param {Geometry} geometry The geometry to use for the instanced mesh
   * @param {Material} material The material to use for the instanced mesh
   */ constructor(count, curveCount, geometry, material){
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedMesh"](geometry, material, count);
        mesh.instanceMatrix.setUsage(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"]);
        mesh.frustumCulled = false;
        super(mesh, curveCount);
        __publicField(this, "offsets");
        __publicField(this, "whichCurve");
        this.offsets = new Array(count).fill(0);
        this.whichCurve = new Array(count).fill(0);
    }
    /**
   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects
   * This writes that information to the matrix and marks it as needing update.
   *
   * @param {number} index of the instanced element to update
   */ writeChanges(index) {
        matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);
        this.object3D.setMatrixAt(index, matrix);
        this.object3D.instanceMatrix.needsUpdate = true;
    }
    /**
   * Move an individual element along the curve by a specific amount
   *
   * @param {number} index Which element to update
   * @param {number} offset Move by how much
   */ moveIndividualAlongCurve(index, offset) {
        this.offsets[index] += offset;
        this.writeChanges(index);
    }
    /**
   * Select which curve to use for an element
   *
   * @param {number} index the index of the instanced element to update
   * @param {number} curveNo the index of the curve it should use
   */ setCurve(index, curveNo) {
        if (isNaN(curveNo)) throw Error("curve index being set is Not a Number (NaN)");
        this.whichCurve[index] = curveNo;
        this.writeChanges(index);
    }
}
;
 //# sourceMappingURL=CurveModifier.js.map
}}),
"[project]/node_modules/three-stdlib/modifiers/SimplifyModifier.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SimplifyModifier": (()=>SimplifyModifier)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
const cb = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const ab = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
function pushIfUnique(array, object) {
    if (array.indexOf(object) === -1) array.push(object);
}
function removeFromArray(array, object) {
    const k = array.indexOf(object);
    if (k > -1) array.splice(k, 1);
}
class Vertex {
    constructor(v, id){
        __publicField(this, "position");
        __publicField(this, "id");
        __publicField(this, "faces");
        __publicField(this, "neighbors");
        __publicField(this, "collapseCost");
        __publicField(this, "collapseNeighbor");
        __publicField(this, "minCost", 0);
        __publicField(this, "totalCost", 0);
        __publicField(this, "costCount", 0);
        this.position = v;
        this.id = id;
        this.faces = [];
        this.neighbors = [];
        this.collapseCost = 0;
        this.collapseNeighbor = null;
    }
    addUniqueNeighbor(vertex) {
        pushIfUnique(this.neighbors, vertex);
    }
    removeIfNonNeighbor(n) {
        const neighbors = this.neighbors;
        const faces = this.faces;
        const offset = neighbors.indexOf(n);
        if (offset === -1) return;
        for(let i = 0; i < faces.length; i++){
            if (faces[i].hasVertex(n)) return;
        }
        neighbors.splice(offset, 1);
    }
}
class Triangle {
    constructor(v1, v2, v3, a, b, c){
        __publicField(this, "a");
        __publicField(this, "b");
        __publicField(this, "c");
        __publicField(this, "v1");
        __publicField(this, "v2");
        __publicField(this, "v3");
        __publicField(this, "normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]());
        this.a = a;
        this.b = b;
        this.c = c;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        this.computeNormal();
        v1.faces.push(this);
        v1.addUniqueNeighbor(v2);
        v1.addUniqueNeighbor(v3);
        v2.faces.push(this);
        v2.addUniqueNeighbor(v1);
        v2.addUniqueNeighbor(v3);
        v3.faces.push(this);
        v3.addUniqueNeighbor(v1);
        v3.addUniqueNeighbor(v2);
    }
    computeNormal() {
        const vA = this.v1.position;
        const vB = this.v2.position;
        const vC = this.v3.position;
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab).normalize();
        this.normal.copy(cb);
    }
    hasVertex(v) {
        return v === this.v1 || v === this.v2 || v === this.v3;
    }
    replaceVertex(oldv, newv) {
        if (oldv === this.v1) this.v1 = newv;
        else if (oldv === this.v2) this.v2 = newv;
        else if (oldv === this.v3) this.v3 = newv;
        removeFromArray(oldv.faces, this);
        newv.faces.push(this);
        oldv.removeIfNonNeighbor(this.v1);
        this.v1.removeIfNonNeighbor(oldv);
        oldv.removeIfNonNeighbor(this.v2);
        this.v2.removeIfNonNeighbor(oldv);
        oldv.removeIfNonNeighbor(this.v3);
        this.v3.removeIfNonNeighbor(oldv);
        this.v1.addUniqueNeighbor(this.v2);
        this.v1.addUniqueNeighbor(this.v3);
        this.v2.addUniqueNeighbor(this.v1);
        this.v2.addUniqueNeighbor(this.v3);
        this.v3.addUniqueNeighbor(this.v1);
        this.v3.addUniqueNeighbor(this.v2);
        this.computeNormal();
    }
}
class SimplifyModifier {
    constructor(){
        __publicField(this, "computeEdgeCollapseCost", (u, v)=>{
            const edgelength = v.position.distanceTo(u.position);
            let curvature = 0;
            const sideFaces = [];
            let i, il = u.faces.length, face, sideFace;
            for(i = 0; i < il; i++){
                face = u.faces[i];
                if (face.hasVertex(v)) {
                    sideFaces.push(face);
                }
            }
            for(i = 0; i < il; i++){
                let minCurvature = 1;
                face = u.faces[i];
                for(let j = 0; j < sideFaces.length; j++){
                    sideFace = sideFaces[j];
                    const dotProd = face.normal.dot(sideFace.normal);
                    minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);
                }
                curvature = Math.max(curvature, minCurvature);
            }
            const borders = 0;
            if (sideFaces.length < 2) {
                curvature = 1;
            }
            const amt = edgelength * curvature + borders;
            return amt;
        });
        __publicField(this, "computeEdgeCostAtVertex", (v)=>{
            if (v.neighbors.length === 0) {
                v.collapseNeighbor = null;
                v.collapseCost = -0.01;
                return;
            }
            v.collapseCost = 1e5;
            v.collapseNeighbor = null;
            for(let i = 0; i < v.neighbors.length; i++){
                const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);
                if (!v.collapseNeighbor) {
                    v.collapseNeighbor = v.neighbors[i];
                    v.collapseCost = collapseCost;
                    v.minCost = collapseCost;
                    v.totalCost = 0;
                    v.costCount = 0;
                }
                v.costCount++;
                v.totalCost += collapseCost;
                if (collapseCost < v.minCost) {
                    v.collapseNeighbor = v.neighbors[i];
                    v.minCost = collapseCost;
                }
            }
            v.collapseCost = v.totalCost / v.costCount;
        });
        __publicField(this, "removeFace", (f, faces)=>{
            removeFromArray(faces, f);
            if (f.v1) removeFromArray(f.v1.faces, f);
            if (f.v2) removeFromArray(f.v2.faces, f);
            if (f.v3) removeFromArray(f.v3.faces, f);
            const vs = [
                f.v1,
                f.v2,
                f.v3
            ];
            let v1, v2;
            for(let i = 0; i < 3; i++){
                v1 = vs[i];
                v2 = vs[(i + 1) % 3];
                if (!v1 || !v2) continue;
                v1.removeIfNonNeighbor(v2);
                v2.removeIfNonNeighbor(v1);
            }
        });
        __publicField(this, "collapse", (vertices, faces, u, v)=>{
            if (!v) {
                this.removeVertex(u, vertices);
                return;
            }
            let i;
            const tmpVertices = [];
            for(i = 0; i < u.neighbors.length; i++){
                tmpVertices.push(u.neighbors[i]);
            }
            for(i = u.faces.length - 1; i >= 0; i--){
                if (u.faces[i].hasVertex(v)) {
                    this.removeFace(u.faces[i], faces);
                }
            }
            for(i = u.faces.length - 1; i >= 0; i--){
                u.faces[i].replaceVertex(u, v);
            }
            this.removeVertex(u, vertices);
            for(i = 0; i < tmpVertices.length; i++){
                this.computeEdgeCostAtVertex(tmpVertices[i]);
            }
        });
        __publicField(this, "minimumCostEdge", (vertices)=>{
            let least = vertices[0];
            for(let i = 0; i < vertices.length; i++){
                if (vertices[i].collapseCost < least.collapseCost) {
                    least = vertices[i];
                }
            }
            return least;
        });
        __publicField(this, "modify", (geometry, count)=>{
            geometry = geometry.clone();
            const attributes = geometry.attributes;
            for(let name in attributes){
                if (name !== "position") geometry.deleteAttribute(name);
            }
            geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeVertices"])(geometry);
            const vertices = [];
            const faces = [];
            const positionAttribute = geometry.getAttribute("position");
            for(let i = 0; i < positionAttribute.count; i++){
                const v = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(positionAttribute, i);
                const vertex = new Vertex(v, i);
                vertices.push(vertex);
            }
            const geomIndex = geometry.getIndex();
            if (geomIndex !== null) {
                for(let i = 0; i < geomIndex.count; i += 3){
                    const a = geomIndex.getX(i);
                    const b = geomIndex.getX(i + 1);
                    const c = geomIndex.getX(i + 2);
                    const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);
                    faces.push(triangle);
                }
            } else {
                for(let i = 0; i < positionAttribute.count; i += 3){
                    const a = i;
                    const b = i + 1;
                    const c = i + 2;
                    const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);
                    faces.push(triangle);
                }
            }
            for(let i = 0, il = vertices.length; i < il; i++){
                this.computeEdgeCostAtVertex(vertices[i]);
            }
            let nextVertex;
            let z = count;
            while(z--){
                nextVertex = this.minimumCostEdge(vertices);
                if (!nextVertex) {
                    console.log("THREE.SimplifyModifier: No next vertex");
                    break;
                } else {
                    this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);
                }
            }
            const simplifiedGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            const position = [];
            let index = [];
            for(let i = 0; i < vertices.length; i++){
                const vertex = vertices[i].position;
                position.push(vertex.x, vertex.y, vertex.z);
            }
            for(let i = 0; i < faces.length; i++){
                const face = faces[i];
                const a = vertices.indexOf(face.v1);
                const b = vertices.indexOf(face.v2);
                const c = vertices.indexOf(face.v3);
                index.push(a, b, c);
            }
            simplifiedGeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](position, 3));
            simplifiedGeometry.setIndex(index);
            return simplifiedGeometry;
        });
    }
    removeVertex(v, vertices) {
        console.assert(v.faces.length === 0);
        while(v.neighbors.length){
            const n = v.neighbors.pop();
            removeFromArray(n.neighbors, v);
        }
        removeFromArray(vertices, v);
    }
}
;
 //# sourceMappingURL=SimplifyModifier.js.map
}}),
"[project]/node_modules/three-stdlib/modifiers/EdgeSplitModifier.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "EdgeSplitModifier": (()=>EdgeSplitModifier)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
;
class EdgeSplitModifier {
    constructor(){
        __publicField(this, "A", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]());
        __publicField(this, "B", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]());
        __publicField(this, "C", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]());
        __publicField(this, "positions", []);
        __publicField(this, "normals", new Float32Array());
        __publicField(this, "indexes", []);
        __publicField(this, "pointToIndexMap", []);
        __publicField(this, "splitIndexes", []);
        __publicField(this, "oldNormals", []);
        __publicField(this, "computeNormals", ()=>{
            this.normals = new Float32Array(this.indexes.length * 3);
            for(let i = 0; i < this.indexes.length; i += 3){
                let index = this.indexes[i];
                this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);
                index = this.indexes[i + 1];
                this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);
                index = this.indexes[i + 2];
                this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);
                this.C.sub(this.B);
                this.A.sub(this.B);
                const normal = this.C.cross(this.A).normalize();
                for(let j = 0; j < 3; j++){
                    this.normals[3 * (i + j)] = normal.x;
                    this.normals[3 * (i + j) + 1] = normal.y;
                    this.normals[3 * (i + j) + 2] = normal.z;
                }
            }
        });
        __publicField(this, "mapPositionsToIndexes", ()=>{
            this.pointToIndexMap = Array(this.positions.length / 3);
            for(let i = 0; i < this.indexes.length; i++){
                const index = this.indexes[i];
                if (this.pointToIndexMap[index] == null) {
                    this.pointToIndexMap[index] = [];
                }
                this.pointToIndexMap[index].push(i);
            }
        });
        __publicField(this, "edgeSplitToGroups", (indexes, cutOff, firstIndex)=>{
            this.A.set(this.normals[3 * firstIndex], this.normals[3 * firstIndex + 1], this.normals[3 * firstIndex + 2]).normalize();
            const result = {
                splitGroup: [],
                currentGroup: [
                    firstIndex
                ]
            };
            for (let j of indexes){
                if (j !== firstIndex) {
                    this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();
                    if (this.B.dot(this.A) < cutOff) {
                        result.splitGroup.push(j);
                    } else {
                        result.currentGroup.push(j);
                    }
                }
            }
            return result;
        });
        __publicField(this, "edgeSplit", (indexes, cutOff, original = null)=>{
            if (indexes.length === 0) return;
            const groupResults = [];
            for (let index of indexes){
                groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index));
            }
            let result = groupResults[0];
            for (let groupResult of groupResults){
                if (groupResult.currentGroup.length > result.currentGroup.length) {
                    result = groupResult;
                }
            }
            if (original != null) {
                this.splitIndexes.push({
                    original,
                    indexes: result.currentGroup
                });
            }
            if (result.splitGroup.length) {
                this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);
            }
        });
        __publicField(this, "modify", (geometry, cutOffAngle, tryKeepNormals = true)=>{
            let hadNormals = false;
            if (geometry.attributes.normal) {
                hadNormals = true;
                geometry = geometry.clone();
                if (tryKeepNormals === true && geometry.index !== null) {
                    this.oldNormals = geometry.attributes.normal.array;
                }
                geometry.deleteAttribute("normal");
            }
            if (geometry.index == null) {
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ === void 0) {
                    throw "THREE.EdgeSplitModifier relies on BufferGeometryUtils";
                }
                geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeVertices"])(geometry);
            }
            this.indexes = geometry.index.array;
            this.positions = geometry.getAttribute("position").array;
            this.computeNormals();
            this.mapPositionsToIndexes();
            this.splitIndexes = [];
            for (let vertexIndexes of this.pointToIndexMap){
                this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);
            }
            const newAttributes = {};
            for (let name of Object.keys(geometry.attributes)){
                const oldAttribute = geometry.attributes[name];
                const newArray = new oldAttribute.array.constructor((this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize);
                newArray.set(oldAttribute.array);
                newAttributes[name] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](newArray, oldAttribute.itemSize, oldAttribute.normalized);
            }
            const newIndexes = new Uint32Array(this.indexes.length);
            newIndexes.set(this.indexes);
            for(let i = 0; i < this.splitIndexes.length; i++){
                const split = this.splitIndexes[i];
                const index = this.indexes[split.original];
                for (let attribute of Object.values(newAttributes)){
                    for(let j = 0; j < attribute.itemSize; j++){
                        attribute.array[(this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];
                    }
                }
                for (let j of split.indexes){
                    newIndexes[j] = this.indexes.length + i;
                }
            }
            geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            geometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](newIndexes, 1));
            for (let name of Object.keys(newAttributes)){
                geometry.setAttribute(name, newAttributes[name]);
            }
            if (hadNormals) {
                geometry.computeVertexNormals();
                if (this.oldNormals !== null) {
                    const changedNormals = new Array(this.oldNormals.length / 3).fill(false);
                    for (let splitData of this.splitIndexes)changedNormals[splitData.original] = true;
                    for(let i = 0; i < changedNormals.length; i++){
                        if (changedNormals[i] === false) {
                            for(let j = 0; j < 3; j++){
                                geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j];
                            }
                        }
                    }
                }
            }
            return geometry;
        });
    }
}
;
 //# sourceMappingURL=EdgeSplitModifier.js.map
}}),
"[project]/node_modules/three-stdlib/types/helpers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getWithKey": (()=>getWithKey)
});
const getWithKey = (obj, key)=>obj[key];
;
 //# sourceMappingURL=helpers.js.map
}}),
"[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "computeMorphedAttributes": (()=>computeMorphedAttributes),
    "estimateBytesUsed": (()=>estimateBytesUsed),
    "interleaveAttributes": (()=>interleaveAttributes),
    "mergeBufferAttributes": (()=>mergeBufferAttributes),
    "mergeBufferGeometries": (()=>mergeBufferGeometries),
    "mergeVertices": (()=>mergeVertices),
    "toCreasedNormals": (()=>toCreasedNormals),
    "toTrianglesDrawMode": (()=>toTrianglesDrawMode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$types$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/types/helpers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
const mergeBufferGeometries = (geometries, useGroups)=>{
    const isIndexed = geometries[0].index !== null;
    const attributesUsed = new Set(Object.keys(geometries[0].attributes));
    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
    const attributes = {};
    const morphAttributes = {};
    const morphTargetsRelative = geometries[0].morphTargetsRelative;
    const mergedGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
    let offset = 0;
    geometries.forEach((geom, i)=>{
        let attributesCount = 0;
        if (isIndexed !== (geom.index !== null)) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
            return null;
        }
        for(let name in geom.attributes){
            if (!attributesUsed.has(name)) {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
                return null;
            }
            if (attributes[name] === void 0) {
                attributes[name] = [];
            }
            attributes[name].push(geom.attributes[name]);
            attributesCount++;
        }
        if (attributesCount !== attributesUsed.size) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
            return null;
        }
        if (morphTargetsRelative !== geom.morphTargetsRelative) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
            return null;
        }
        for(let name in geom.morphAttributes){
            if (!morphAttributesUsed.has(name)) {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
                return null;
            }
            if (morphAttributes[name] === void 0) morphAttributes[name] = [];
            morphAttributes[name].push(geom.morphAttributes[name]);
        }
        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
        mergedGeometry.userData.mergedUserData.push(geom.userData);
        if (useGroups) {
            let count;
            if (geom.index) {
                count = geom.index.count;
            } else if (geom.attributes.position !== void 0) {
                count = geom.attributes.position.count;
            } else {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
                return null;
            }
            mergedGeometry.addGroup(offset, count, i);
            offset += count;
        }
    });
    if (isIndexed) {
        let indexOffset = 0;
        const mergedIndex = [];
        geometries.forEach((geom)=>{
            const index = geom.index;
            for(let j = 0; j < index.count; ++j){
                mergedIndex.push(index.getX(j) + indexOffset);
            }
            indexOffset += geom.attributes.position.count;
        });
        mergedGeometry.setIndex(mergedIndex);
    }
    for(let name in attributes){
        const mergedAttribute = mergeBufferAttributes(attributes[name]);
        if (!mergedAttribute) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " attribute.");
            return null;
        }
        mergedGeometry.setAttribute(name, mergedAttribute);
    }
    for(let name in morphAttributes){
        const numMorphTargets = morphAttributes[name][0].length;
        if (numMorphTargets === 0) break;
        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
        mergedGeometry.morphAttributes[name] = [];
        for(let i = 0; i < numMorphTargets; ++i){
            const morphAttributesToMerge = [];
            for(let j = 0; j < morphAttributes[name].length; ++j){
                morphAttributesToMerge.push(morphAttributes[name][j][i]);
            }
            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);
            if (!mergedMorphAttribute) {
                console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " morphAttribute.");
                return null;
            }
            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
        }
    }
    return mergedGeometry;
};
const mergeBufferAttributes = (attributes)=>{
    let TypedArray = void 0;
    let itemSize = void 0;
    let normalized = void 0;
    let arrayLength = 0;
    attributes.forEach((attr)=>{
        if (TypedArray === void 0) {
            TypedArray = attr.array.constructor;
        }
        if (TypedArray !== attr.array.constructor) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
            return null;
        }
        if (itemSize === void 0) itemSize = attr.itemSize;
        if (itemSize !== attr.itemSize) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
            return null;
        }
        if (normalized === void 0) normalized = attr.normalized;
        if (normalized !== attr.normalized) {
            console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
            return null;
        }
        arrayLength += attr.array.length;
    });
    if (TypedArray && itemSize) {
        const array = new TypedArray(arrayLength);
        let offset = 0;
        attributes.forEach((attr)=>{
            array.set(attr.array, offset);
            offset += attr.array.length;
        });
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize, normalized);
    }
};
const interleaveAttributes = (attributes)=>{
    let TypedArray = void 0;
    let arrayLength = 0;
    let stride = 0;
    for(let i = 0, l = attributes.length; i < l; ++i){
        const attribute = attributes[i];
        if (TypedArray === void 0) TypedArray = attribute.array.constructor;
        if (TypedArray !== attribute.array.constructor) {
            console.error("AttributeBuffers of different types cannot be interleaved");
            return null;
        }
        arrayLength += attribute.array.length;
        stride += attribute.itemSize;
    }
    const interleavedBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBuffer"](new TypedArray(arrayLength), stride);
    let offset = 0;
    const res = [];
    const getters = [
        "getX",
        "getY",
        "getZ",
        "getW"
    ];
    const setters = [
        "setX",
        "setY",
        "setZ",
        "setW"
    ];
    for(let j = 0, l = attributes.length; j < l; j++){
        const attribute = attributes[j];
        const itemSize = attribute.itemSize;
        const count = attribute.count;
        const iba = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](interleavedBuffer, itemSize, offset, attribute.normalized);
        res.push(iba);
        offset += itemSize;
        for(let c = 0; c < count; c++){
            for(let k = 0; k < itemSize; k++){
                const set = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$types$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWithKey"])(iba, setters[k]);
                const get = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$types$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWithKey"])(attribute, getters[k]);
                set(c, get(c));
            }
        }
    }
    return res;
};
function estimateBytesUsed(geometry) {
    let mem = 0;
    for(let name in geometry.attributes){
        const attr = geometry.getAttribute(name);
        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
    }
    const indices = geometry.getIndex();
    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    return mem;
}
function mergeVertices(geometry, tolerance = 1e-4) {
    tolerance = Math.max(tolerance, Number.EPSILON);
    const hashToIndex = {};
    const indices = geometry.getIndex();
    const positions = geometry.getAttribute("position");
    const vertexCount = indices ? indices.count : positions.count;
    let nextIndex = 0;
    const attributeNames = Object.keys(geometry.attributes);
    const attrArrays = {};
    const morphAttrsArrays = {};
    const newIndices = [];
    const getters = [
        "getX",
        "getY",
        "getZ",
        "getW"
    ];
    for(let i = 0, l = attributeNames.length; i < l; i++){
        const name = attributeNames[i];
        attrArrays[name] = [];
        const morphAttr = geometry.morphAttributes[name];
        if (morphAttr) {
            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);
        }
    }
    const decimalShift = Math.log10(1 / tolerance);
    const shiftMultiplier = Math.pow(10, decimalShift);
    for(let i = 0; i < vertexCount; i++){
        const index = indices ? indices.getX(i) : i;
        let hash = "";
        for(let j = 0, l = attributeNames.length; j < l; j++){
            const name = attributeNames[j];
            const attribute = geometry.getAttribute(name);
            const itemSize = attribute.itemSize;
            for(let k = 0; k < itemSize; k++){
                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;
            }
        }
        if (hash in hashToIndex) {
            newIndices.push(hashToIndex[hash]);
        } else {
            for(let j = 0, l = attributeNames.length; j < l; j++){
                const name = attributeNames[j];
                const attribute = geometry.getAttribute(name);
                const morphAttr = geometry.morphAttributes[name];
                const itemSize = attribute.itemSize;
                const newarray = attrArrays[name];
                const newMorphArrays = morphAttrsArrays[name];
                for(let k = 0; k < itemSize; k++){
                    const getterFunc = getters[k];
                    newarray.push(attribute[getterFunc](index));
                    if (morphAttr) {
                        for(let m = 0, ml = morphAttr.length; m < ml; m++){
                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));
                        }
                    }
                }
            }
            hashToIndex[hash] = nextIndex;
            newIndices.push(nextIndex);
            nextIndex++;
        }
    }
    const result = geometry.clone();
    for(let i = 0, l = attributeNames.length; i < l; i++){
        const name = attributeNames[i];
        const oldAttribute = geometry.getAttribute(name);
        const buffer = new oldAttribute.array.constructor(attrArrays[name]);
        const attribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](buffer, oldAttribute.itemSize, oldAttribute.normalized);
        result.setAttribute(name, attribute);
        if (name in morphAttrsArrays) {
            for(let j = 0; j < morphAttrsArrays[name].length; j++){
                const oldMorphAttribute = geometry.morphAttributes[name][j];
                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);
                const morphAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
                result.morphAttributes[name][j] = morphAttribute;
            }
        }
    }
    result.setIndex(newIndices);
    return result;
}
function toTrianglesDrawMode(geometry, drawMode) {
    if (drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TrianglesDrawMode"]) {
        console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
        return geometry;
    }
    if (drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleFanDrawMode"] || drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleStripDrawMode"]) {
        let index = geometry.getIndex();
        if (index === null) {
            const indices = [];
            const position = geometry.getAttribute("position");
            if (position !== void 0) {
                for(let i = 0; i < position.count; i++){
                    indices.push(i);
                }
                geometry.setIndex(indices);
                index = geometry.getIndex();
            } else {
                console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
                return geometry;
            }
        }
        const numberOfTriangles = index.count - 2;
        const newIndices = [];
        if (index) {
            if (drawMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleFanDrawMode"]) {
                for(let i = 1; i <= numberOfTriangles; i++){
                    newIndices.push(index.getX(0));
                    newIndices.push(index.getX(i));
                    newIndices.push(index.getX(i + 1));
                }
            } else {
                for(let i = 0; i < numberOfTriangles; i++){
                    if (i % 2 === 0) {
                        newIndices.push(index.getX(i));
                        newIndices.push(index.getX(i + 1));
                        newIndices.push(index.getX(i + 2));
                    } else {
                        newIndices.push(index.getX(i + 2));
                        newIndices.push(index.getX(i + 1));
                        newIndices.push(index.getX(i));
                    }
                }
            }
        }
        if (newIndices.length / 3 !== numberOfTriangles) {
            console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        }
        const newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);
        newGeometry.clearGroups();
        return newGeometry;
    } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
        return geometry;
    }
}
function computeMorphedAttributes(object) {
    if (object.geometry.isBufferGeometry !== true) {
        console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.");
        return null;
    }
    const _vA = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _vB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _vC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _tempA = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _tempB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _tempC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _morphA = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _morphB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _morphC = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {
        _vA.fromBufferAttribute(attribute, a2);
        _vB.fromBufferAttribute(attribute, b2);
        _vC.fromBufferAttribute(attribute, c2);
        const morphInfluences = object2.morphTargetInfluences;
        if (// @ts-ignore
        material2.morphTargets && morphAttribute && morphInfluences) {
            _morphA.set(0, 0, 0);
            _morphB.set(0, 0, 0);
            _morphC.set(0, 0, 0);
            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){
                const influence = morphInfluences[i2];
                const morph = morphAttribute[i2];
                if (influence === 0) continue;
                _tempA.fromBufferAttribute(morph, a2);
                _tempB.fromBufferAttribute(morph, b2);
                _tempC.fromBufferAttribute(morph, c2);
                if (morphTargetsRelative2) {
                    _morphA.addScaledVector(_tempA, influence);
                    _morphB.addScaledVector(_tempB, influence);
                    _morphC.addScaledVector(_tempC, influence);
                } else {
                    _morphA.addScaledVector(_tempA.sub(_vA), influence);
                    _morphB.addScaledVector(_tempB.sub(_vB), influence);
                    _morphC.addScaledVector(_tempC.sub(_vC), influence);
                }
            }
            _vA.add(_morphA);
            _vB.add(_morphB);
            _vC.add(_morphC);
        }
        if (object2.isSkinnedMesh) {
            object2.boneTransform(a2, _vA);
            object2.boneTransform(b2, _vB);
            object2.boneTransform(c2, _vC);
        }
        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;
        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;
        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;
        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;
        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;
        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;
        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;
        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;
        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;
    }
    const geometry = object.geometry;
    const material = object.material;
    let a, b, c;
    const index = geometry.index;
    const positionAttribute = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    const normalAttribute = geometry.attributes.normal;
    const morphNormal = geometry.morphAttributes.position;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    let i, j, il, jl;
    let group, groupMaterial;
    let start, end;
    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
    if (index !== null) {
        if (Array.isArray(material)) {
            for(i = 0, il = groups.length; i < il; i++){
                group = groups[i];
                groupMaterial = material[group.materialIndex];
                start = Math.max(group.start, drawRange.start);
                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for(j = start, jl = end; j < jl; j += 3){
                    a = index.getX(j);
                    b = index.getX(j + 1);
                    c = index.getX(j + 2);
                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
                }
            }
        } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(index.count, drawRange.start + drawRange.count);
            for(i = start, il = end; i < il; i += 3){
                a = index.getX(i);
                b = index.getX(i + 1);
                c = index.getX(i + 2);
                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
            }
        }
    } else if (positionAttribute !== void 0) {
        if (Array.isArray(material)) {
            for(i = 0, il = groups.length; i < il; i++){
                group = groups[i];
                groupMaterial = material[group.materialIndex];
                start = Math.max(group.start, drawRange.start);
                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for(j = start, jl = end; j < jl; j += 3){
                    a = j;
                    b = j + 1;
                    c = j + 2;
                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
                }
            }
        } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for(i = start, il = end; i < il; i += 3){
                a = i;
                b = i + 1;
                c = i + 2;
                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
            }
        }
    }
    const morphedPositionAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](modifiedPosition, 3);
    const morphedNormalAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](modifiedNormal, 3);
    return {
        positionAttribute,
        normalAttribute,
        morphedPositionAttribute,
        morphedNormalAttribute
    };
}
function toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {
    const creaseDot = Math.cos(creaseAngle);
    const hashMultiplier = (1 + 1e-10) * 100;
    const verts = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
    ];
    const tempVec1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const tempVec2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const tempNorm = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const tempNorm2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    function hashVertex(v) {
        const x = ~~(v.x * hashMultiplier);
        const y = ~~(v.y * hashMultiplier);
        const z = ~~(v.z * hashMultiplier);
        return `${x},${y},${z}`;
    }
    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
    const posAttr = resultGeometry.attributes.position;
    const vertexMap = {};
    for(let i = 0, l = posAttr.count / 3; i < l; i++){
        const i3 = 3 * i;
        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
        tempVec1.subVectors(c, b);
        tempVec2.subVectors(a, b);
        const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().crossVectors(tempVec1, tempVec2).normalize();
        for(let n = 0; n < 3; n++){
            const vert = verts[n];
            const hash = hashVertex(vert);
            if (!(hash in vertexMap)) {
                vertexMap[hash] = [];
            }
            vertexMap[hash].push(normal);
        }
    }
    const normalArray = new Float32Array(posAttr.count * 3);
    const normAttr = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](normalArray, 3, false);
    for(let i = 0, l = posAttr.count / 3; i < l; i++){
        const i3 = 3 * i;
        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
        tempVec1.subVectors(c, b);
        tempVec2.subVectors(a, b);
        tempNorm.crossVectors(tempVec1, tempVec2).normalize();
        for(let n = 0; n < 3; n++){
            const vert = verts[n];
            const hash = hashVertex(vert);
            const otherNormals = vertexMap[hash];
            tempNorm2.set(0, 0, 0);
            for(let k = 0, lk = otherNormals.length; k < lk; k++){
                const otherNorm = otherNormals[k];
                if (tempNorm.dot(otherNorm) > creaseDot) {
                    tempNorm2.add(otherNorm);
                }
            }
            tempNorm2.normalize();
            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);
        }
    }
    resultGeometry.setAttribute("normal", normAttr);
    return resultGeometry;
}
;
 //# sourceMappingURL=BufferGeometryUtils.js.map
}}),
"[project]/node_modules/three-stdlib/utils/SceneUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SceneUtils": (()=>SceneUtils)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const SceneUtils = {
    createMeshesFromInstancedMesh: function(instancedMesh) {
        const group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        const count = instancedMesh.count;
        const geometry = instancedMesh.geometry;
        const material = instancedMesh.material;
        for(let i = 0; i < count; i++){
            const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
            instancedMesh.getMatrixAt(i, mesh.matrix);
            mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
            group.add(mesh);
        }
        group.copy(instancedMesh);
        group.updateMatrixWorld();
        return group;
    },
    createMultiMaterialObject: function(geometry, materials) {
        const group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        for(let i = 0, l = materials.length; i < l; i++){
            group.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, materials[i]));
        }
        return group;
    },
    detach: function(child, parent, scene) {
        console.warn("THREE.SceneUtils: detach() has been deprecated. Use scene.attach( child ) instead.");
        scene.attach(child);
    },
    attach: function(child, scene, parent) {
        console.warn("THREE.SceneUtils: attach() has been deprecated. Use parent.attach( child ) instead.");
        parent.attach(child);
    }
};
;
 //# sourceMappingURL=SceneUtils.js.map
}}),
"[project]/node_modules/three-stdlib/utils/GeometryUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GeometryUtils": (()=>GeometryUtils)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const hilbert2D = (center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3)=>{
    const half = size / 2;
    const vec_s = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x - half, center.y, center.z - half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x - half, center.y, center.z + half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x + half, center.y, center.z + half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x + half, center.y, center.z - half)
    ];
    const vec = [
        vec_s[v0],
        vec_s[v1],
        vec_s[v2],
        vec_s[v3]
    ];
    if (0 <= --iterations) {
        const tmp = [];
        Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));
        Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));
        Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));
        Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3));
        return tmp;
    }
    return vec;
};
const hilbert3D = (center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7)=>{
    const half = size / 2;
    const vec_s = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x - half, center.y + half, center.z - half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x - half, center.y + half, center.z + half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x - half, center.y - half, center.z + half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x - half, center.y - half, center.z - half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x + half, center.y - half, center.z - half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x + half, center.y - half, center.z + half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x + half, center.y + half, center.z + half),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](center.x + half, center.y + half, center.z - half)
    ];
    const vec = [
        vec_s[v0],
        vec_s[v1],
        vec_s[v2],
        vec_s[v3],
        vec_s[v4],
        vec_s[v5],
        vec_s[v6],
        vec_s[v7]
    ];
    if (--iterations >= 0) {
        const tmp = [];
        Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));
        Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));
        Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));
        Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));
        Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));
        Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));
        Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));
        Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7));
        return tmp;
    }
    return vec;
};
const gosper = (size = 1)=>{
    function fractalize(config) {
        let output = "";
        let input = config.axiom;
        for(let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--){
            output = "";
            for(let j = 0, jl = input.length; j < jl; j++){
                const char = input[j];
                if (char in config.rules) {
                    output += config.rules[char];
                } else {
                    output += char;
                }
            }
            input = output;
        }
        return output;
    }
    function toPoints(config) {
        let currX = 0;
        let currY = 0;
        let angle = 0;
        const path = [
            0,
            0,
            0
        ];
        const fractal = config.fractal;
        for(let i = 0, l = fractal.length; i < l; i++){
            const char = fractal[i];
            if (char === "+") {
                angle += config.angle;
            } else if (char === "-") {
                angle -= config.angle;
            } else if (char === "F") {
                currX += config.size * Math.cos(angle);
                currY += -config.size * Math.sin(angle);
                path.push(currX, currY, 0);
            }
        }
        return path;
    }
    const gosper2 = fractalize({
        axiom: "A",
        steps: 4,
        rules: {
            A: "A+BF++BF-FA--FAFA-BF+",
            B: "-FA+BFBF++BF+FA--FA-B"
        }
    });
    const points = toPoints({
        fractal: gosper2,
        size,
        angle: Math.PI / 3
    });
    return points;
};
const GeometryUtils = {
    hilbert3D,
    gosper,
    hilbert2D
};
;
 //# sourceMappingURL=GeometryUtils.js.map
}}),
"[project]/node_modules/three-stdlib/utils/RoughnessMipmapper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RoughnessMipmapper": (()=>RoughnessMipmapper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
var _mipmapMaterial = /* @__PURE__ */ _getMipmapMaterial();
var _mesh = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](/* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](2, 2), _mipmapMaterial);
var _flatCamera = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](0, 1, 0, 1, 0, 1);
var _tempTarget = null;
class RoughnessMipmapper {
    constructor(renderer){
        __publicField(this, "generateMipmaps", function(material) {
            if ("roughnessMap" in material === false) return;
            var { roughnessMap, normalMap } = material;
            if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) {
                return;
            }
            material.userData.roughnessUpdated = true;
            var width = Math.max(roughnessMap.image.width, normalMap.image.width);
            var height = Math.max(roughnessMap.image.height, normalMap.image.height);
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].isPowerOfTwo(width) || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].isPowerOfTwo(height)) return;
            var oldTarget = this._renderer.getRenderTarget();
            var autoClear = this._renderer.autoClear;
            this._renderer.autoClear = false;
            if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {
                if (_tempTarget !== null) _tempTarget.dispose();
                _tempTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](width, height, {
                    depthBuffer: false
                });
                _tempTarget.scissorTest = true;
            }
            if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {
                var params = {
                    wrapS: roughnessMap.wrapS,
                    wrapT: roughnessMap.wrapT,
                    magFilter: roughnessMap.magFilter,
                    minFilter: roughnessMap.minFilter,
                    depthBuffer: false
                };
                var newRoughnessTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](width, height, params);
                newRoughnessTarget.texture.generateMipmaps = true;
                this._renderer.setRenderTarget(newRoughnessTarget);
                material.roughnessMap = newRoughnessTarget.texture;
                if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;
                if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap;
            }
            _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;
            _mipmapMaterial.uniforms.normalMap.value = normalMap;
            var position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](0, 0);
            var texelSize = _mipmapMaterial.uniforms.texelSize.value;
            for(let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2){
                texelSize.set(1 / width, 1 / height);
                if (mip == 0) texelSize.set(0, 0);
                _tempTarget.viewport.set(position.x, position.y, width, height);
                _tempTarget.scissor.set(position.x, position.y, width, height);
                this._renderer.setRenderTarget(_tempTarget);
                this._renderer.render(_mesh, _flatCamera);
                this._renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);
                _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;
            }
            if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();
            this._renderer.setRenderTarget(oldTarget);
            this._renderer.autoClear = autoClear;
        });
        __publicField(this, "dispose", function() {
            _mipmapMaterial.dispose();
            _mesh.geometry.dispose();
            if (_tempTarget != null) _tempTarget.dispose();
        });
        this._renderer = renderer;
        this._renderer.compile(_mesh, _flatCamera);
    }
}
function _getMipmapMaterial() {
    var shaderMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawShaderMaterial"]({
        uniforms: {
            roughnessMap: {
                value: null
            },
            normalMap: {
                value: null
            },
            texelSize: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](1, 1)
            }
        },
        vertexShader: /* glsl */ `
			precision mediump float;
			precision mediump int;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = vec4( position, 1.0 );

			}
		`,
        fragmentShader: /* glsl */ `
			precision mediump float;
			precision mediump int;

			varying vec2 vUv;

			uniform sampler2D roughnessMap;
			uniform sampler2D normalMap;
			uniform vec2 texelSize;

			#define ENVMAP_TYPE_CUBE_UV

			vec4 envMapTexelToLinear( vec4 a ) { return a; }

			#include <cube_uv_reflection_fragment>

			float roughnessToVariance( float roughness ) {

				float variance = 0.0;

				if ( roughness >= r1 ) {

					variance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;

				} else if ( roughness >= r4 ) {

					variance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;

				} else if ( roughness >= r5 ) {

					variance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;

				} else {

					float roughness2 = roughness * roughness;

					variance = 1.79 * roughness2 * roughness2;

				}

				return variance;

			}

			float varianceToRoughness( float variance ) {

				float roughness = 0.0;

				if ( variance >= v1 ) {

					roughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;

				} else if ( variance >= v4 ) {

					roughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;

				} else if ( variance >= v5 ) {

					roughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;

				} else {

					roughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79

				}

				return roughness;

			}

			void main() {

				gl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );

				if ( texelSize.x == 0.0 ) return;

				float roughness = gl_FragColor.g;

				float variance = roughnessToVariance( roughness );

				vec3 avgNormal;

				for ( float x = - 1.0; x < 2.0; x += 2.0 ) {

					for ( float y = - 1.0; y < 2.0; y += 2.0 ) {

						vec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;

						avgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );

					}

				}

				variance += 1.0 - 0.25 * length( avgNormal );

				gl_FragColor.g = varianceToRoughness( variance );

			}
		`,
        blending: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoBlending"],
        depthTest: false,
        depthWrite: false
    });
    shaderMaterial.type = "RoughnessMipmapper";
    return shaderMaterial;
}
;
 //# sourceMappingURL=RoughnessMipmapper.js.map
}}),
"[project]/node_modules/three-stdlib/utils/SkeletonUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SkeletonUtils": (()=>SkeletonUtils)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
function retarget(target, source, options = {}) {
    const pos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), quat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"](), scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), bindBoneMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](), relativeMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](), globalMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;
    options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;
    options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;
    options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;
    options.hip = options.hip !== void 0 ? options.hip : "hip";
    options.names = options.names || {};
    const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);
    let bindBones, bone, name, boneTo, bonesPosition;
    if (target.isObject3D) {
        target.skeleton.pose();
    } else {
        options.useTargetMatrix = true;
        options.preserveMatrix = false;
    }
    if (options.preservePosition) {
        bonesPosition = [];
        for(let i = 0; i < bones.length; i++){
            bonesPosition.push(bones[i].position.clone());
        }
    }
    if (options.preserveMatrix) {
        target.updateMatrixWorld();
        target.matrixWorld.identity();
        for(let i = 0; i < target.children.length; ++i){
            target.children[i].updateMatrixWorld(true);
        }
    }
    if (options.offsets) {
        bindBones = [];
        for(let i = 0; i < bones.length; ++i){
            bone = bones[i];
            name = options.names[bone.name] || bone.name;
            if (options.offsets[name]) {
                bone.matrix.multiply(options.offsets[name]);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                bone.updateMatrixWorld();
            }
            bindBones.push(bone.matrixWorld.clone());
        }
    }
    for(let i = 0; i < bones.length; ++i){
        bone = bones[i];
        name = options.names[bone.name] || bone.name;
        boneTo = getBoneByName(name, sourceBones);
        globalMatrix.copy(bone.matrixWorld);
        if (boneTo) {
            boneTo.updateMatrixWorld();
            if (options.useTargetMatrix) {
                relativeMatrix.copy(boneTo.matrixWorld);
            } else {
                relativeMatrix.copy(target.matrixWorld).invert();
                relativeMatrix.multiply(boneTo.matrixWorld);
            }
            scale.setFromMatrixScale(relativeMatrix);
            relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));
            globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));
            if (target.isObject3D) {
                const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();
                globalMatrix.multiply(wBindMatrix);
            }
            globalMatrix.copyPosition(relativeMatrix);
        }
        if (bone.parent && bone.parent.isBone) {
            bone.matrix.copy(bone.parent.matrixWorld).invert();
            bone.matrix.multiply(globalMatrix);
        } else {
            bone.matrix.copy(globalMatrix);
        }
        if (options.preserveHipPosition && name === options.hip) {
            bone.matrix.setPosition(pos.set(0, bone.position.y, 0));
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        bone.updateMatrixWorld();
    }
    if (options.preservePosition) {
        for(let i = 0; i < bones.length; ++i){
            bone = bones[i];
            name = options.names[bone.name] || bone.name;
            if (name !== options.hip) {
                bone.position.copy(bonesPosition[i]);
            }
        }
    }
    if (options.preserveMatrix) {
        target.updateMatrixWorld(true);
    }
}
function retargetClip(target, source, clip, options = {}) {
    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;
    options.fps = options.fps !== void 0 ? options.fps : 30;
    options.names = options.names || [];
    if (!source.isObject3D) {
        source = getHelperFromSkeleton(source);
    }
    const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](source), bones = getBones(target.skeleton), boneDatas = [];
    let positionOffset, bone, boneTo, boneData, name;
    mixer.clipAction(clip).play();
    mixer.update(0);
    source.updateMatrixWorld();
    for(let i = 0; i < numFrames; ++i){
        const time = i * delta;
        retarget(target, source, options);
        for(let j = 0; j < bones.length; ++j){
            name = options.names[bones[j].name] || bones[j].name;
            boneTo = getBoneByName(name, source.skeleton);
            if (boneTo) {
                bone = bones[j];
                boneData = boneDatas[j] = boneDatas[j] || {
                    bone
                };
                if (options.hip === name) {
                    if (!boneData.pos) {
                        boneData.pos = {
                            times: new Float32Array(numFrames),
                            values: new Float32Array(numFrames * 3)
                        };
                    }
                    if (options.useFirstFramePosition) {
                        if (i === 0) {
                            positionOffset = bone.position.clone();
                        }
                        bone.position.sub(positionOffset);
                    }
                    boneData.pos.times[i] = time;
                    bone.position.toArray(boneData.pos.values, i * 3);
                }
                if (!boneData.quat) {
                    boneData.quat = {
                        times: new Float32Array(numFrames),
                        values: new Float32Array(numFrames * 4)
                    };
                }
                boneData.quat.times[i] = time;
                bone.quaternion.toArray(boneData.quat.values, i * 4);
            }
        }
        mixer.update(delta);
        source.updateMatrixWorld();
    }
    for(let i = 0; i < boneDatas.length; ++i){
        boneData = boneDatas[i];
        if (boneData) {
            if (boneData.pos) {
                convertedTracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](".bones[" + boneData.bone.name + "].position", boneData.pos.times, boneData.pos.values));
            }
            convertedTracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"](".bones[" + boneData.bone.name + "].quaternion", boneData.quat.times, boneData.quat.values));
        }
    }
    mixer.uncacheAction(clip);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](clip.name, -1, convertedTracks);
}
function clone(source) {
    const sourceLookup = /* @__PURE__ */ new Map();
    const cloneLookup = /* @__PURE__ */ new Map();
    const clone2 = source.clone();
    parallelTraverse(source, clone2, function(sourceNode, clonedNode) {
        sourceLookup.set(clonedNode, sourceNode);
        cloneLookup.set(sourceNode, clonedNode);
    });
    clone2.traverse(function(node) {
        if (!node.isSkinnedMesh) return;
        const clonedMesh = node;
        const sourceMesh = sourceLookup.get(node);
        const sourceBones = sourceMesh.skeleton.bones;
        clonedMesh.skeleton = sourceMesh.skeleton.clone();
        clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
        clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
            return cloneLookup.get(bone);
        });
        clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone2;
}
function getBoneByName(name, skeleton) {
    for(let i = 0, bones = getBones(skeleton); i < bones.length; i++){
        if (name === bones[i].name) return bones[i];
    }
}
function getBones(skeleton) {
    return Array.isArray(skeleton) ? skeleton : skeleton.bones;
}
function getHelperFromSkeleton(skeleton) {
    const source = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkeletonHelper"](skeleton.bones[0]);
    source.skeleton = skeleton;
    return source;
}
function parallelTraverse(a, b, callback) {
    callback(a, b);
    for(let i = 0; i < a.children.length; i++){
        parallelTraverse(a.children[i], b.children[i], callback);
    }
}
const SkeletonUtils = {
    retarget,
    retargetClip,
    clone
};
;
 //# sourceMappingURL=SkeletonUtils.js.map
}}),
"[project]/node_modules/three-stdlib/utils/ShadowMapViewer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ShadowMapViewer": (()=>ShadowMapViewer)
});
(()=>{
    const e = new Error("Cannot find module '../shaders/UnpackDepthRGBAShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class ShadowMapViewer {
    constructor(light){
        const scope = this;
        const doRenderLabel = light.name !== void 0 && light.name !== "";
        let userAutoClearSetting;
        const frame = {
            x: 10,
            y: 10,
            width: 256,
            height: 256
        };
        const camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);
        camera.position.set(0, 0, 2);
        const scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        const shader = UnpackDepthRGBAShader;
        const uniforms = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(shader.uniforms);
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            uniforms,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
        });
        const plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](frame.width, frame.height);
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](plane, material);
        scene.add(mesh);
        let labelCanvas, labelMesh;
        if (doRenderLabel) {
            labelCanvas = document.createElement("canvas");
            const context = labelCanvas.getContext("2d");
            context.font = "Bold 20px Arial";
            const labelWidth = context.measureText(light.name).width;
            labelCanvas.width = labelWidth;
            labelCanvas.height = 25;
            context.font = "Bold 20px Arial";
            context.fillStyle = "rgba( 255, 0, 0, 1 )";
            context.fillText(light.name, 0, 20);
            const labelTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](labelCanvas);
            labelTexture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
            labelTexture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
            labelTexture.needsUpdate = true;
            const labelMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
                map: labelTexture,
                side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"]
            });
            labelMaterial.transparent = true;
            const labelPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](labelCanvas.width, labelCanvas.height);
            labelMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](labelPlane, labelMaterial);
            scene.add(labelMesh);
        }
        function resetPosition() {
            scope.position.set(scope.position.x, scope.position.y);
        }
        this.enabled = true;
        this.size = {
            width: frame.width,
            height: frame.height,
            set: function(width, height) {
                this.width = width;
                this.height = height;
                mesh.scale.set(this.width / frame.width, this.height / frame.height, 1);
                resetPosition();
            }
        };
        this.position = {
            x: frame.x,
            y: frame.y,
            set: function(x, y) {
                this.x = x;
                this.y = y;
                const width = scope.size.width;
                const height = scope.size.height;
                mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);
                if (doRenderLabel) labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);
            }
        };
        this.render = function(renderer) {
            if (this.enabled) {
                uniforms.tDiffuse.value = light.shadow.map.texture;
                userAutoClearSetting = renderer.autoClear;
                renderer.autoClear = false;
                renderer.clearDepth();
                renderer.render(scene, camera);
                renderer.autoClear = userAutoClearSetting;
            }
        };
        this.updateForWindowResize = function() {
            if (this.enabled) {
                camera.left = window.innerWidth / -2;
                camera.right = window.innerWidth / 2;
                camera.top = window.innerHeight / 2;
                camera.bottom = window.innerHeight / -2;
                camera.updateProjectionMatrix();
                this.update();
            }
        };
        this.update = function() {
            this.position.set(this.position.x, this.position.y);
            this.size.set(this.size.width, this.size.height);
        };
        this.update();
    }
}
;
 //# sourceMappingURL=ShadowMapViewer.js.map
}}),
"[project]/node_modules/three-stdlib/utils/GeometryCompressionUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GeometryCompressionUtils": (()=>GeometryCompressionUtils),
    "PackedPhongMaterial": (()=>PackedPhongMaterial)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
;
var GeometryCompressionUtils = {
    /**
   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.
   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.
   *
   * @param {THREE.Mesh} mesh
   * @param {String} encodeMethod		"DEFAULT" || "OCT1Byte" || "OCT2Byte" || "ANGLES"
   *
   */ compressNormals: function(mesh, encodeMethod) {
        if (!mesh.geometry) {
            console.error("Mesh must contain geometry. ");
        }
        const normal = mesh.geometry.attributes.normal;
        if (!normal) {
            console.error("Geometry must contain normal attribute. ");
        }
        if (normal.isPacked) return;
        if (normal.itemSize != 3) {
            console.error("normal.itemSize is not 3, which cannot be encoded. ");
        }
        const array = normal.array;
        const count = normal.count;
        let result;
        if (encodeMethod == "DEFAULT") {
            result = new Uint8Array(count * 3);
            for(let idx = 0; idx < array.length; idx += 3){
                const encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);
                result[idx + 0] = encoded[0];
                result[idx + 1] = encoded[1];
                result[idx + 2] = encoded[2];
            }
            mesh.geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](result, 3, true));
            mesh.geometry.attributes.normal.bytes = result.length * 1;
        } else if (encodeMethod == "OCT1Byte") {
            result = new Int8Array(count * 2);
            for(let idx = 0; idx < array.length; idx += 3){
                const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);
                result[idx / 3 * 2 + 0] = encoded[0];
                result[idx / 3 * 2 + 1] = encoded[1];
            }
            mesh.geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](result, 2, true));
            mesh.geometry.attributes.normal.bytes = result.length * 1;
        } else if (encodeMethod == "OCT2Byte") {
            result = new Int16Array(count * 2);
            for(let idx = 0; idx < array.length; idx += 3){
                const encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);
                result[idx / 3 * 2 + 0] = encoded[0];
                result[idx / 3 * 2 + 1] = encoded[1];
            }
            mesh.geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](result, 2, true));
            mesh.geometry.attributes.normal.bytes = result.length * 2;
        } else if (encodeMethod == "ANGLES") {
            result = new Uint16Array(count * 2);
            for(let idx = 0; idx < array.length; idx += 3){
                const encoded = this.EncodingFuncs.anglesEncode(array[idx], array[idx + 1], array[idx + 2]);
                result[idx / 3 * 2 + 0] = encoded[0];
                result[idx / 3 * 2 + 1] = encoded[1];
            }
            mesh.geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](result, 2, true));
            mesh.geometry.attributes.normal.bytes = result.length * 2;
        } else {
            console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");
        }
        mesh.geometry.attributes.normal.needsUpdate = true;
        mesh.geometry.attributes.normal.isPacked = true;
        mesh.geometry.attributes.normal.packingMethod = encodeMethod;
        if (!(mesh.material instanceof PackedPhongMaterial)) {
            mesh.material = new PackedPhongMaterial().copy(mesh.material);
        }
        if (encodeMethod == "ANGLES") {
            mesh.material.defines.USE_PACKED_NORMAL = 0;
        }
        if (encodeMethod == "OCT1Byte") {
            mesh.material.defines.USE_PACKED_NORMAL = 1;
        }
        if (encodeMethod == "OCT2Byte") {
            mesh.material.defines.USE_PACKED_NORMAL = 1;
        }
        if (encodeMethod == "DEFAULT") {
            mesh.material.defines.USE_PACKED_NORMAL = 2;
        }
    },
    /**
   * Make the input mesh.geometry's position attribute encoded and compressed.
   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.
   *
   * @param {THREE.Mesh} mesh
   *
   */ compressPositions: function(mesh) {
        if (!mesh.geometry) {
            console.error("Mesh must contain geometry. ");
        }
        const position = mesh.geometry.attributes.position;
        if (!position) {
            console.error("Geometry must contain position attribute. ");
        }
        if (position.isPacked) return;
        if (position.itemSize != 3) {
            console.error("position.itemSize is not 3, which cannot be packed. ");
        }
        const array = position.array;
        const encodingBytes = 2;
        const result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);
        const quantized = result.quantized;
        const decodeMat = result.decodeMat;
        if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();
        if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();
        mesh.geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](quantized, 3));
        mesh.geometry.attributes.position.isPacked = true;
        mesh.geometry.attributes.position.needsUpdate = true;
        mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;
        if (!(mesh.material instanceof PackedPhongMaterial)) {
            mesh.material = new PackedPhongMaterial().copy(mesh.material);
        }
        mesh.material.defines.USE_PACKED_POSITION = 0;
        mesh.material.uniforms.quantizeMatPos.value = decodeMat;
        mesh.material.uniforms.quantizeMatPos.needsUpdate = true;
    },
    /**
   * Make the input mesh.geometry's uv attribute encoded and compressed.
   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.
   *
   * @param {THREE.Mesh} mesh
   *
   */ compressUvs: function(mesh) {
        if (!mesh.geometry) {
            console.error("Mesh must contain geometry property. ");
        }
        const uvs = mesh.geometry.attributes.uv;
        if (!uvs) {
            console.error("Geometry must contain uv attribute. ");
        }
        if (uvs.isPacked) return;
        const range = {
            min: Infinity,
            max: -Infinity
        };
        const array = uvs.array;
        for(let i = 0; i < array.length; i++){
            range.min = Math.min(range.min, array[i]);
            range.max = Math.max(range.max, array[i]);
        }
        let result;
        if (range.min >= -1 && range.max <= 1) {
            result = new Uint16Array(array.length);
            for(let i = 0; i < array.length; i += 2){
                const encoded = this.EncodingFuncs.defaultEncode(array[i], array[i + 1], 0, 2);
                result[i] = encoded[0];
                result[i + 1] = encoded[1];
            }
            mesh.geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](result, 2, true));
            mesh.geometry.attributes.uv.isPacked = true;
            mesh.geometry.attributes.uv.needsUpdate = true;
            mesh.geometry.attributes.uv.bytes = result.length * 2;
            if (!(mesh.material instanceof PackedPhongMaterial)) {
                mesh.material = new PackedPhongMaterial().copy(mesh.material);
            }
            mesh.material.defines.USE_PACKED_UV = 0;
        } else {
            result = this.EncodingFuncs.quantizedEncodeUV(array, 2);
            mesh.geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](result.quantized, 2));
            mesh.geometry.attributes.uv.isPacked = true;
            mesh.geometry.attributes.uv.needsUpdate = true;
            mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;
            if (!(mesh.material instanceof PackedPhongMaterial)) {
                mesh.material = new PackedPhongMaterial().copy(mesh.material);
            }
            mesh.material.defines.USE_PACKED_UV = 1;
            mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;
            mesh.material.uniforms.quantizeMatUV.needsUpdate = true;
        }
    },
    EncodingFuncs: {
        defaultEncode: function(x, y, z, bytes) {
            if (bytes == 1) {
                const tmpx = Math.round((x + 1) * 0.5 * 255);
                const tmpy = Math.round((y + 1) * 0.5 * 255);
                const tmpz = Math.round((z + 1) * 0.5 * 255);
                return new Uint8Array([
                    tmpx,
                    tmpy,
                    tmpz
                ]);
            } else if (bytes == 2) {
                const tmpx = Math.round((x + 1) * 0.5 * 65535);
                const tmpy = Math.round((y + 1) * 0.5 * 65535);
                const tmpz = Math.round((z + 1) * 0.5 * 65535);
                return new Uint16Array([
                    tmpx,
                    tmpy,
                    tmpz
                ]);
            } else {
                console.error("number of bytes must be 1 or 2");
            }
        },
        defaultDecode: function(array, bytes) {
            if (bytes == 1) {
                return [
                    array[0] / 255 * 2 - 1,
                    array[1] / 255 * 2 - 1,
                    array[2] / 255 * 2 - 1
                ];
            } else if (bytes == 2) {
                return [
                    array[0] / 65535 * 2 - 1,
                    array[1] / 65535 * 2 - 1,
                    array[2] / 65535 * 2 - 1
                ];
            } else {
                console.error("number of bytes must be 1 or 2");
            }
        },
        // for `Angles` encoding
        anglesEncode: function(x, y, z) {
            const normal0 = parseInt(0.5 * (1 + Math.atan2(y, x) / Math.PI) * 65535);
            const normal1 = parseInt(0.5 * (1 + z) * 65535);
            return new Uint16Array([
                normal0,
                normal1
            ]);
        },
        // for `Octahedron` encoding
        octEncodeBest: function(x, y, z, bytes) {
            var oct, dec, best, currentCos, bestCos;
            best = oct = octEncodeVec3(x, y, z, "floor", "floor");
            dec = octDecodeVec2(oct);
            bestCos = dot(x, y, z, dec);
            oct = octEncodeVec3(x, y, z, "ceil", "floor");
            dec = octDecodeVec2(oct);
            currentCos = dot(x, y, z, dec);
            if (currentCos > bestCos) {
                best = oct;
                bestCos = currentCos;
            }
            oct = octEncodeVec3(x, y, z, "floor", "ceil");
            dec = octDecodeVec2(oct);
            currentCos = dot(x, y, z, dec);
            if (currentCos > bestCos) {
                best = oct;
                bestCos = currentCos;
            }
            oct = octEncodeVec3(x, y, z, "ceil", "ceil");
            dec = octDecodeVec2(oct);
            currentCos = dot(x, y, z, dec);
            if (currentCos > bestCos) {
                best = oct;
            }
            return best;
            "TURBOPACK unreachable";
            function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {
                var x2 = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));
                var y2 = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));
                if (z < 0) {
                    var tempx = (1 - Math.abs(y2)) * (x2 >= 0 ? 1 : -1);
                    var tempy = (1 - Math.abs(x2)) * (y2 >= 0 ? 1 : -1);
                    x2 = tempx;
                    y2 = tempy;
                    var diff = 1 - Math.abs(x2) - Math.abs(y2);
                    if (diff > 0) {
                        diff += 1e-3;
                        x2 += x2 > 0 ? diff / 2 : -diff / 2;
                        y2 += y2 > 0 ? diff / 2 : -diff / 2;
                    }
                }
                if (bytes == 1) {
                    return new Int8Array([
                        Math[xfunc](x2 * 127.5 + (x2 < 0 ? 1 : 0)),
                        Math[yfunc](y2 * 127.5 + (y2 < 0 ? 1 : 0))
                    ]);
                }
                if (bytes == 2) {
                    return new Int16Array([
                        Math[xfunc](x2 * 32767.5 + (x2 < 0 ? 1 : 0)),
                        Math[yfunc](y2 * 32767.5 + (y2 < 0 ? 1 : 0))
                    ]);
                }
            }
            function octDecodeVec2(oct2) {
                var x2 = oct2[0];
                var y2 = oct2[1];
                if (bytes == 1) {
                    x2 /= x2 < 0 ? 127 : 128;
                    y2 /= y2 < 0 ? 127 : 128;
                } else if (bytes == 2) {
                    x2 /= x2 < 0 ? 32767 : 32768;
                    y2 /= y2 < 0 ? 32767 : 32768;
                }
                var z2 = 1 - Math.abs(x2) - Math.abs(y2);
                if (z2 < 0) {
                    var tmpx = x2;
                    x2 = (1 - Math.abs(y2)) * (x2 >= 0 ? 1 : -1);
                    y2 = (1 - Math.abs(tmpx)) * (y2 >= 0 ? 1 : -1);
                }
                var length = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
                return [
                    x2 / length,
                    y2 / length,
                    z2 / length
                ];
            }
            function dot(x2, y2, z2, vec3) {
                return x2 * vec3[0] + y2 * vec3[1] + z2 * vec3[2];
            }
        },
        quantizedEncode: function(array, bytes) {
            let quantized, segments;
            if (bytes == 1) {
                quantized = new Uint8Array(array.length);
                segments = 255;
            } else if (bytes == 2) {
                quantized = new Uint16Array(array.length);
                segments = 65535;
            } else {
                console.error("number of bytes error! ");
            }
            const decodeMat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            const min = new Float32Array(3);
            const max = new Float32Array(3);
            min[0] = min[1] = min[2] = Number.MAX_VALUE;
            max[0] = max[1] = max[2] = -Number.MAX_VALUE;
            for(let i = 0; i < array.length; i += 3){
                min[0] = Math.min(min[0], array[i + 0]);
                min[1] = Math.min(min[1], array[i + 1]);
                min[2] = Math.min(min[2], array[i + 2]);
                max[0] = Math.max(max[0], array[i + 0]);
                max[1] = Math.max(max[1], array[i + 1]);
                max[2] = Math.max(max[2], array[i + 2]);
            }
            decodeMat.scale(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));
            decodeMat.elements[12] = min[0];
            decodeMat.elements[13] = min[1];
            decodeMat.elements[14] = min[2];
            decodeMat.transpose();
            const multiplier = new Float32Array([
                max[0] !== min[0] ? segments / (max[0] - min[0]) : 0,
                max[1] !== min[1] ? segments / (max[1] - min[1]) : 0,
                max[2] !== min[2] ? segments / (max[2] - min[2]) : 0
            ]);
            for(let i = 0; i < array.length; i += 3){
                quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
                quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
                quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);
            }
            return {
                quantized,
                decodeMat
            };
        },
        quantizedEncodeUV: function(array, bytes) {
            let quantized, segments;
            if (bytes == 1) {
                quantized = new Uint8Array(array.length);
                segments = 255;
            } else if (bytes == 2) {
                quantized = new Uint16Array(array.length);
                segments = 65535;
            } else {
                console.error("number of bytes error! ");
            }
            const decodeMat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]();
            const min = new Float32Array(2);
            const max = new Float32Array(2);
            min[0] = min[1] = Number.MAX_VALUE;
            max[0] = max[1] = -Number.MAX_VALUE;
            for(let i = 0; i < array.length; i += 2){
                min[0] = Math.min(min[0], array[i + 0]);
                min[1] = Math.min(min[1], array[i + 1]);
                max[0] = Math.max(max[0], array[i + 0]);
                max[1] = Math.max(max[1], array[i + 1]);
            }
            decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);
            decodeMat.elements[6] = min[0];
            decodeMat.elements[7] = min[1];
            decodeMat.transpose();
            const multiplier = new Float32Array([
                max[0] !== min[0] ? segments / (max[0] - min[0]) : 0,
                max[1] !== min[1] ? segments / (max[1] - min[1]) : 0
            ]);
            for(let i = 0; i < array.length; i += 2){
                quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
                quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
            }
            return {
                quantized,
                decodeMat
            };
        }
    }
};
class PackedPhongMaterial extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"] {
    constructor(parameters){
        super();
        this.defines = {};
        this.type = "PackedPhongMaterial";
        this.uniforms = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].merge([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderLib"].phong.uniforms,
            {
                quantizeMatPos: {
                    value: null
                },
                quantizeMatUV: {
                    value: null
                }
            }
        ]);
        this.vertexShader = [
            "#define PHONG",
            "varying vec3 vViewPosition;",
            "#ifndef FLAT_SHADED",
            "varying vec3 vNormal;",
            "#endif",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].common,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].uv_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].uv2_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].displacementmap_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].envmap_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].color_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].fog_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].morphtarget_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].skinning_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].shadowmap_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].logdepthbuf_pars_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].clipping_planes_pars_vertex,
            `#ifdef USE_PACKED_NORMAL
					#if USE_PACKED_NORMAL == 0
						vec3 decodeNormal(vec3 packedNormal)
						{
							float x = packedNormal.x * 2.0 - 1.0;
							float y = packedNormal.y * 2.0 - 1.0;
							vec2 scth = vec2(sin(x * PI), cos(x * PI));
							vec2 scphi = vec2(sqrt(1.0 - y * y), y);
							return normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );
						}
					#endif

					#if USE_PACKED_NORMAL == 1
						vec3 decodeNormal(vec3 packedNormal)
						{
							vec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));
							if (v.z < 0.0)
							{
								v.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);
							}
							return normalize(v);
						}
					#endif

					#if USE_PACKED_NORMAL == 2
						vec3 decodeNormal(vec3 packedNormal)
						{
							vec3 v = (packedNormal * 2.0) - 1.0;
							return normalize(v);
						}
					#endif
				#endif`,
            `#ifdef USE_PACKED_POSITION
					#if USE_PACKED_POSITION == 0
						uniform mat4 quantizeMatPos;
					#endif
				#endif`,
            `#ifdef USE_PACKED_UV
					#if USE_PACKED_UV == 1
						uniform mat3 quantizeMatUV;
					#endif
				#endif`,
            `#ifdef USE_PACKED_UV
					#if USE_PACKED_UV == 0
						vec2 decodeUV(vec2 packedUV)
						{
							vec2 uv = (packedUV * 2.0) - 1.0;
							return uv;
						}
					#endif

					#if USE_PACKED_UV == 1
						vec2 decodeUV(vec2 packedUV)
						{
							vec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;
							return uv;
						}
					#endif
				#endif`,
            "void main() {",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].uv_vertex,
            `#ifdef USE_UV
					#ifdef USE_PACKED_UV
						vUv = decodeUV(vUv);
					#endif
				#endif`,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].uv2_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].color_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].beginnormal_vertex,
            `#ifdef USE_PACKED_NORMAL
					objectNormal = decodeNormal(objectNormal);
				#endif

				#ifdef USE_TANGENT
					vec3 objectTangent = vec3( tangent.xyz );
				#endif
				`,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].morphnormal_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].skinbase_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].skinnormal_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].defaultnormal_vertex,
            "#ifndef FLAT_SHADED",
            "	vNormal = normalize( transformedNormal );",
            "#endif",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].begin_vertex,
            `#ifdef USE_PACKED_POSITION
					#if USE_PACKED_POSITION == 0
						transformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;
					#endif
				#endif`,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].morphtarget_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].skinning_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].displacementmap_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].project_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].logdepthbuf_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].clipping_planes_vertex,
            "vViewPosition = - mvPosition.xyz;",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].worldpos_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].envmap_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].shadowmap_vertex,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].fog_vertex,
            "}"
        ].join("\n");
        this.fragmentShader = [
            "#define PHONG",
            "uniform vec3 diffuse;",
            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",
            "uniform float opacity;",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].common,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].packing,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].dithering_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].color_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].uv_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].uv2_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].map_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].alphamap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].aomap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lightmap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].emissivemap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].envmap_common_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].envmap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].cube_uv_reflection_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].fog_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].bsdfs,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_pars_begin,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_phong_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].shadowmap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].bumpmap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].normalmap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].specularmap_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].logdepthbuf_pars_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].clipping_planes_pars_fragment,
            "void main() {",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].clipping_planes_fragment,
            "vec4 diffuseColor = vec4( diffuse, opacity );",
            "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
            "vec3 totalEmissiveRadiance = emissive;",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].logdepthbuf_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].map_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].color_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].alphamap_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].alphatest_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].specularmap_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].normal_fragment_begin,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].normal_fragment_maps,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].emissivemap_fragment,
            // accumulation
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_phong_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_fragment_begin,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_fragment_maps,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_fragment_end,
            // modulation
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].aomap_fragment,
            "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].envmap_fragment,
            "gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].tonemapping_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].colorspace_fragment : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].encodings_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].fog_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].premultiplied_alpha_fragment,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].dithering_fragment,
            "}"
        ].join("\n");
        this.setValues(parameters);
    }
}
;
 //# sourceMappingURL=GeometryCompressionUtils.js.map
}}),
"[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "version": (()=>version)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const version = /* @__PURE__ */ (()=>parseInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REVISION"].replace(/\D+/g, "")))();
;
 //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/three-stdlib/_polyfill/CapsuleGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CapsuleGeometry": (()=>CapsuleGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const CapsuleGeometry = /* @__PURE__ */ (()=>{
    class CapsuleGeometry2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LatheGeometry"] {
        constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8){
            const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"]();
            path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
            path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
            super(path.getPoints(capSegments), radialSegments);
            this.type = "CapsuleGeometry";
            this.parameters = {
                radius,
                height: length,
                capSegments,
                radialSegments
            };
        }
        static fromJSON(data) {
            return new CapsuleGeometry2(data.radius, data.length, data.capSegments, data.radialSegments);
        }
    }
    return CapsuleGeometry2;
})();
;
 //# sourceMappingURL=CapsuleGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "decodeText": (()=>decodeText)
});
function decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
    }
    let s = "";
    for(let i = 0, il = array.length; i < il; i++){
        s += String.fromCharCode(array[i]);
    }
    try {
        return decodeURIComponent(escape(s));
    } catch (e) {
        return s;
    }
}
;
 //# sourceMappingURL=LoaderUtils.js.map
}}),
"[project]/node_modules/three-stdlib/_polyfill/Data3DTexture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Data3DTexture": (()=>Data3DTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class Data3DTexture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"] {
    constructor(data = null, width = 1, height = 1, depth = 1){
        super(null);
        this.isData3DTexture = true;
        this.image = {
            data,
            width,
            height,
            depth
        };
        this.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
        this.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
        this.wrapR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
}
;
 //# sourceMappingURL=Data3DTexture.js.map
}}),
"[project]/node_modules/three-stdlib/_polyfill/CompressedCubeTexture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CompressedCubeTexture": (()=>CompressedCubeTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class CompressedCubeTexture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTexture"] {
    constructor(images, format, type){
        super(void 0, images[0].width, images[0].height, format, type, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeReflectionMapping"]);
        this.isCompressedCubeTexture = true;
        this.isCubeTexture = true;
        this.image = images;
    }
}
;
 //# sourceMappingURL=CompressedCubeTexture.js.map
}}),
"[project]/node_modules/three-stdlib/_polyfill/CompressedArrayTexture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CompressedArrayTexture": (()=>CompressedArrayTexture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class CompressedArrayTexture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTexture"] {
    constructor(mipmaps, width, height, depth, format, type){
        super(mipmaps, width, height, format, type);
        this.isCompressedArrayTexture = true;
        this.image.depth = depth;
        this.wrapR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
    }
}
;
 //# sourceMappingURL=CompressedArrayTexture.js.map
}}),
"[project]/node_modules/three-stdlib/environments/RoomEnvironment.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RoomEnvironment": (()=>RoomEnvironment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
;
function RoomEnvironment() {
    const scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Scene();
    const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.BoxGeometry();
    geometry.deleteAttribute("uv");
    const roomMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.MeshStandardMaterial({
        side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.BackSide
    });
    const boxMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.MeshStandardMaterial();
    const mainLight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.PointLight(16777215, 5, 28, 2);
    mainLight.position.set(0.418, 16.199, 0.3);
    scene.add(mainLight);
    const room = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, roomMaterial);
    room.position.set(-0.757, 13.219, 0.717);
    room.scale.set(31.713, 28.305, 28.591);
    scene.add(room);
    const box1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, boxMaterial);
    box1.position.set(-10.906, 2.009, 1.846);
    box1.rotation.set(0, -0.195, 0);
    box1.scale.set(2.328, 7.905, 4.651);
    scene.add(box1);
    const box2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, boxMaterial);
    box2.position.set(-5.607, -0.754, -0.758);
    box2.rotation.set(0, 0.994, 0);
    box2.scale.set(1.97, 1.534, 3.955);
    scene.add(box2);
    const box3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, boxMaterial);
    box3.position.set(6.167, 0.857, 7.803);
    box3.rotation.set(0, 0.561, 0);
    box3.scale.set(3.927, 6.285, 3.687);
    scene.add(box3);
    const box4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, boxMaterial);
    box4.position.set(-2.017, 0.018, 6.124);
    box4.rotation.set(0, 0.333, 0);
    box4.scale.set(2.002, 4.566, 2.064);
    scene.add(box4);
    const box5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, boxMaterial);
    box5.position.set(2.291, -0.756, -2.621);
    box5.rotation.set(0, -0.286, 0);
    box5.scale.set(1.546, 1.552, 1.496);
    scene.add(box5);
    const box6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, boxMaterial);
    box6.position.set(-2.193, -0.369, -5.547);
    box6.rotation.set(0, 0.516, 0);
    box6.scale.set(3.875, 3.487, 2.986);
    scene.add(box6);
    const light1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, createAreaLightMaterial(50));
    light1.position.set(-16.116, 14.37, 8.208);
    light1.scale.set(0.1, 2.428, 2.739);
    scene.add(light1);
    const light2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, createAreaLightMaterial(50));
    light2.position.set(-16.109, 18.021, -8.207);
    light2.scale.set(0.1, 2.425, 2.751);
    scene.add(light2);
    const light3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, createAreaLightMaterial(17));
    light3.position.set(14.904, 12.198, -1.832);
    light3.scale.set(0.15, 4.265, 6.331);
    scene.add(light3);
    const light4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, createAreaLightMaterial(43));
    light4.position.set(-0.462, 8.89, 14.52);
    light4.scale.set(4.38, 5.441, 0.088);
    scene.add(light4);
    const light5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, createAreaLightMaterial(20));
    light5.position.set(3.235, 11.486, -12.541);
    light5.scale.set(2.5, 2, 0.1);
    scene.add(light5);
    const light6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(geometry, createAreaLightMaterial(100));
    light6.position.set(0, 20, 0);
    light6.scale.set(1, 0.1, 1);
    scene.add(light6);
    function createAreaLightMaterial(intensity) {
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.MeshBasicMaterial();
        material.color.setScalar(intensity);
        return material;
    }
    return scene;
}
;
 //# sourceMappingURL=RoomEnvironment.js.map
}}),
"[project]/node_modules/three-stdlib/animation/AnimationClipCreator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AnimationClipCreator": (()=>AnimationClipCreator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const AnimationClipCreator = {
    CreateRotationAnimation (period, axis = "x") {
        const times = [
            0,
            period
        ], values = [
            0,
            360
        ];
        const trackName = ".rotation[" + axis + "]";
        const track = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"](trackName, times, values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](null, period, [
            track
        ]);
    },
    CreateScaleAxisAnimation (period, axis = "x") {
        const times = [
            0,
            period
        ], values = [
            0,
            1
        ];
        const trackName = ".scale[" + axis + "]";
        const track = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"](trackName, times, values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](null, period, [
            track
        ]);
    },
    CreateShakeAnimation (duration, shakeScale) {
        const times = [], values = [], tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0; i < duration * 10; i++){
            times.push(i / 10);
            tmp.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).multiply(shakeScale).toArray(values, values.length);
        }
        const trackName = ".position";
        const track = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](trackName, times, values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](null, duration, [
            track
        ]);
    },
    CreatePulsationAnimation (duration, pulseScale) {
        const times = [], values = [], tmp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0; i < duration * 10; i++){
            times.push(i / 10);
            const scaleFactor = Math.random() * pulseScale;
            tmp.set(scaleFactor, scaleFactor, scaleFactor).toArray(values, values.length);
        }
        const trackName = ".scale";
        const track = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](trackName, times, values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](null, duration, [
            track
        ]);
    },
    CreateVisibilityAnimation (duration) {
        const times = [
            0,
            duration / 2,
            duration
        ], values = [
            true,
            false,
            true
        ];
        const trackName = ".visible";
        const track = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BooleanKeyframeTrack"](trackName, times, values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](null, duration, [
            track
        ]);
    },
    CreateMaterialColorAnimation (duration, colors) {
        const times = [], values = [], timeStep = duration / colors.length;
        for(let i = 0; i < colors.length; i++){
            times.push(i * timeStep);
            const color = colors[i];
            values.push(color.r, color.g, color.b);
        }
        const trackName = ".material.color";
        const track = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ColorKeyframeTrack"](trackName, times, values);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](null, duration, [
            track
        ]);
    }
};
;
 //# sourceMappingURL=AnimationClipCreator.js.map
}}),
"[project]/node_modules/three-stdlib/animation/CCDIKSolver.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CCDIKHelper": (()=>CCDIKHelper),
    "CCDIKSolver": (()=>CCDIKSolver)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _q = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
const _targetPos = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _targetVec = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _effectorPos = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _effectorVec = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _linkPos = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _invLinkQ = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
const _linkScale = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _axis = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _vector = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _matrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
class CCDIKSolver {
    /**
   * @param {THREE.SkinnedMesh} mesh
   * @param {Array<Object>} iks
   */ constructor(mesh, iks = []){
        this.mesh = mesh;
        this.iks = iks;
        this._valid();
    }
    /**
   * Update all IK bones.
   *
   * @return {CCDIKSolver}
   */ update() {
        const iks = this.iks;
        for(let i = 0, il = iks.length; i < il; i++){
            this.updateOne(iks[i]);
        }
        return this;
    }
    /**
   * Update one IK bone
   *
   * @param {Object} ik parameter
   * @return {CCDIKSolver}
   */ updateOne(ik) {
        const bones = this.mesh.skeleton.bones;
        const math = Math;
        const effector = bones[ik.effector];
        const target = bones[ik.target];
        _targetPos.setFromMatrixPosition(target.matrixWorld);
        const links = ik.links;
        const iteration = ik.iteration !== void 0 ? ik.iteration : 1;
        for(let i = 0; i < iteration; i++){
            let rotated = false;
            for(let j = 0, jl = links.length; j < jl; j++){
                const link = bones[links[j].index];
                if (links[j].enabled === false) break;
                const limitation = links[j].limitation;
                const rotationMin = links[j].rotationMin;
                const rotationMax = links[j].rotationMax;
                link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);
                _invLinkQ.invert();
                _effectorPos.setFromMatrixPosition(effector.matrixWorld);
                _effectorVec.subVectors(_effectorPos, _linkPos);
                _effectorVec.applyQuaternion(_invLinkQ);
                _effectorVec.normalize();
                _targetVec.subVectors(_targetPos, _linkPos);
                _targetVec.applyQuaternion(_invLinkQ);
                _targetVec.normalize();
                let angle = _targetVec.dot(_effectorVec);
                if (angle > 1) {
                    angle = 1;
                } else if (angle < -1) {
                    angle = -1;
                }
                angle = math.acos(angle);
                if (angle < 1e-5) continue;
                if (ik.minAngle !== void 0 && angle < ik.minAngle) {
                    angle = ik.minAngle;
                }
                if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {
                    angle = ik.maxAngle;
                }
                _axis.crossVectors(_effectorVec, _targetVec);
                _axis.normalize();
                _q.setFromAxisAngle(_axis, angle);
                link.quaternion.multiply(_q);
                if (limitation !== void 0) {
                    let c = link.quaternion.w;
                    if (c > 1) c = 1;
                    const c2 = math.sqrt(1 - c * c);
                    link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);
                }
                if (rotationMin !== void 0) {
                    link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));
                }
                if (rotationMax !== void 0) {
                    link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));
                }
                link.updateMatrixWorld(true);
                rotated = true;
            }
            if (!rotated) break;
        }
        return this;
    }
    /**
   * Creates Helper
   *
   * @return {CCDIKHelper}
   */ createHelper() {
        return new CCDIKHelper(this.mesh, this.iks);
    }
    // private methods
    _valid() {
        const iks = this.iks;
        const bones = this.mesh.skeleton.bones;
        for(let i = 0, il = iks.length; i < il; i++){
            const ik = iks[i];
            const effector = bones[ik.effector];
            const links = ik.links;
            let link0, link1;
            link0 = effector;
            for(let j = 0, jl = links.length; j < jl; j++){
                link1 = bones[links[j].index];
                if (link0.parent !== link1) {
                    console.warn("THREE.CCDIKSolver: bone " + link0.name + " is not the child of bone " + link1.name);
                }
                link0 = link1;
            }
        }
    }
}
function getPosition(bone, matrixWorldInv) {
    return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);
}
function setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {
    const v = getPosition(bone, matrixWorldInv);
    array[index * 3 + 0] = v.x;
    array[index * 3 + 1] = v.y;
    array[index * 3 + 2] = v.z;
}
class CCDIKHelper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(mesh, iks = [], sphereSize = 0.25){
        super();
        this.root = mesh;
        this.iks = iks;
        this.matrix.copy(mesh.matrixWorld);
        this.matrixAutoUpdate = false;
        this.sphereGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SphereGeometry"](sphereSize, 16, 8);
        this.targetSphereMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](16746632),
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        this.effectorSphereMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8978312),
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        this.linkSphereMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8947967),
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        this.lineMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](16711680),
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        this._init();
    }
    /**
   * Updates IK bones visualization.
   */ updateMatrixWorld(force) {
        const mesh = this.root;
        if (this.visible) {
            let offset = 0;
            const iks = this.iks;
            const bones = mesh.skeleton.bones;
            _matrix.copy(mesh.matrixWorld).invert();
            for(let i = 0, il = iks.length; i < il; i++){
                const ik = iks[i];
                const targetBone = bones[ik.target];
                const effectorBone = bones[ik.effector];
                const targetMesh = this.children[offset++];
                const effectorMesh = this.children[offset++];
                targetMesh.position.copy(getPosition(targetBone, _matrix));
                effectorMesh.position.copy(getPosition(effectorBone, _matrix));
                for(let j = 0, jl = ik.links.length; j < jl; j++){
                    const link = ik.links[j];
                    const linkBone = bones[link.index];
                    const linkMesh = this.children[offset++];
                    linkMesh.position.copy(getPosition(linkBone, _matrix));
                }
                const line = this.children[offset++];
                const array = line.geometry.attributes.position.array;
                setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);
                setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);
                for(let j = 0, jl = ik.links.length; j < jl; j++){
                    const link = ik.links[j];
                    const linkBone = bones[link.index];
                    setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix);
                }
                line.geometry.attributes.position.needsUpdate = true;
            }
        }
        this.matrix.copy(mesh.matrixWorld);
        super.updateMatrixWorld(force);
    }
    /**
   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.
   */ dispose() {
        this.sphereGeometry.dispose();
        this.targetSphereMaterial.dispose();
        this.effectorSphereMaterial.dispose();
        this.linkSphereMaterial.dispose();
        this.lineMaterial.dispose();
        const children = this.children;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (child.isLine) child.geometry.dispose();
        }
    }
    // private method
    _init() {
        const scope = this;
        const iks = this.iks;
        function createLineGeometry(ik) {
            const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            const vertices = new Float32Array((2 + ik.links.length) * 3);
            geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](vertices, 3));
            return geometry;
        }
        function createTargetMesh() {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](scope.sphereGeometry, scope.targetSphereMaterial);
        }
        function createEffectorMesh() {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](scope.sphereGeometry, scope.effectorSphereMaterial);
        }
        function createLinkMesh() {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](scope.sphereGeometry, scope.linkSphereMaterial);
        }
        function createLine(ik) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](createLineGeometry(ik), scope.lineMaterial);
        }
        for(let i = 0, il = iks.length; i < il; i++){
            const ik = iks[i];
            this.add(createTargetMesh());
            this.add(createEffectorMesh());
            for(let j = 0, jl = ik.links.length; j < jl; j++){
                this.add(createLinkMesh());
            }
            this.add(createLine(ik));
        }
    }
}
;
 //# sourceMappingURL=CCDIKSolver.js.map
}}),
"[project]/node_modules/three-stdlib/animation/MMDPhysics.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MMDPhysics": (()=>MMDPhysics)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$CapsuleGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/CapsuleGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class MMDPhysics {
    /**
   * @param {THREE.SkinnedMesh} mesh
   * @param {Array<Object>} rigidBodyParams
   * @param {Array<Object>} (optional) constraintParams
   * @param {Object} params - (optional)
   * @param {Number} params.unitStep - Default is 1 / 65.
   * @param {Integer} params.maxStepNum - Default is 3.
   * @param {Vector3} params.gravity - Default is ( 0, - 9.8 * 10, 0 )
   */ constructor(mesh, rigidBodyParams, constraintParams = [], params = {}){
        if (typeof Ammo === "undefined") {
            throw new Error("THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js");
        }
        this.manager = new ResourceManager();
        this.mesh = mesh;
        this.unitStep = params.unitStep !== void 0 ? params.unitStep : 1 / 65;
        this.maxStepNum = params.maxStepNum !== void 0 ? params.maxStepNum : 3;
        this.gravity = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, -9.8 * 10, 0);
        if (params.gravity !== void 0) this.gravity.copy(params.gravity);
        this.world = params.world !== void 0 ? params.world : null;
        this.bodies = [];
        this.constraints = [];
        this._init(mesh, rigidBodyParams, constraintParams);
    }
    /**
   * Advances Physics calculation and updates bones.
   *
   * @param {Number} delta - time in second
   * @return {MMDPhysics}
   */ update(delta) {
        const manager = this.manager;
        const mesh = this.mesh;
        let isNonDefaultScale = false;
        const position = manager.allocThreeVector3();
        const quaternion = manager.allocThreeQuaternion();
        const scale = manager.allocThreeVector3();
        mesh.matrixWorld.decompose(position, quaternion, scale);
        if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
            isNonDefaultScale = true;
        }
        let parent;
        if (isNonDefaultScale) {
            parent = mesh.parent;
            if (parent !== null) mesh.parent = null;
            scale.copy(this.mesh.scale);
            mesh.scale.set(1, 1, 1);
            mesh.updateMatrixWorld(true);
        }
        this._updateRigidBodies();
        this._stepSimulation(delta);
        this._updateBones();
        if (isNonDefaultScale) {
            if (parent !== null) mesh.parent = parent;
            mesh.scale.copy(scale);
        }
        manager.freeThreeVector3(scale);
        manager.freeThreeQuaternion(quaternion);
        manager.freeThreeVector3(position);
        return this;
    }
    /**
   * Resets rigid bodies transorm to current bone's.
   *
   * @return {MMDPhysics}
   */ reset() {
        for(let i = 0, il = this.bodies.length; i < il; i++){
            this.bodies[i].reset();
        }
        return this;
    }
    /**
   * Warm ups Rigid bodies. Calculates cycles steps.
   *
   * @param {Integer} cycles
   * @return {MMDPhysics}
   */ warmup(cycles) {
        for(let i = 0; i < cycles; i++){
            this.update(1 / 60);
        }
        return this;
    }
    /**
   * Sets gravity.
   *
   * @param {Vector3} gravity
   * @return {MMDPhysicsHelper}
   */ setGravity(gravity) {
        this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));
        this.gravity.copy(gravity);
        return this;
    }
    /**
   * Creates MMDPhysicsHelper
   *
   * @return {MMDPhysicsHelper}
   */ createHelper() {
        return new MMDPhysicsHelper(this.mesh, this);
    }
    // private methods
    _init(mesh, rigidBodyParams, constraintParams) {
        const manager = this.manager;
        const parent = mesh.parent;
        if (parent !== null) mesh.parent = null;
        const currentPosition = manager.allocThreeVector3();
        const currentQuaternion = manager.allocThreeQuaternion();
        const currentScale = manager.allocThreeVector3();
        currentPosition.copy(mesh.position);
        currentQuaternion.copy(mesh.quaternion);
        currentScale.copy(mesh.scale);
        mesh.position.set(0, 0, 0);
        mesh.quaternion.set(0, 0, 0, 1);
        mesh.scale.set(1, 1, 1);
        mesh.updateMatrixWorld(true);
        if (this.world === null) {
            this.world = this._createWorld();
            this.setGravity(this.gravity);
        }
        this._initRigidBodies(rigidBodyParams);
        this._initConstraints(constraintParams);
        if (parent !== null) mesh.parent = parent;
        mesh.position.copy(currentPosition);
        mesh.quaternion.copy(currentQuaternion);
        mesh.scale.copy(currentScale);
        mesh.updateMatrixWorld(true);
        this.reset();
        manager.freeThreeVector3(currentPosition);
        manager.freeThreeQuaternion(currentQuaternion);
        manager.freeThreeVector3(currentScale);
    }
    _createWorld() {
        const config = new Ammo.btDefaultCollisionConfiguration();
        const dispatcher = new Ammo.btCollisionDispatcher(config);
        const cache = new Ammo.btDbvtBroadphase();
        const solver = new Ammo.btSequentialImpulseConstraintSolver();
        const world = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);
        return world;
    }
    _initRigidBodies(rigidBodies) {
        for(let i = 0, il = rigidBodies.length; i < il; i++){
            this.bodies.push(new RigidBody(this.mesh, this.world, rigidBodies[i], this.manager));
        }
    }
    _initConstraints(constraints) {
        for(let i = 0, il = constraints.length; i < il; i++){
            const params = constraints[i];
            const bodyA = this.bodies[params.rigidBodyIndex1];
            const bodyB = this.bodies[params.rigidBodyIndex2];
            this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager));
        }
    }
    _stepSimulation(delta) {
        const unitStep = this.unitStep;
        let stepTime = delta;
        let maxStepNum = (delta / unitStep | 0) + 1;
        if (stepTime < unitStep) {
            stepTime = unitStep;
            maxStepNum = 1;
        }
        if (maxStepNum > this.maxStepNum) {
            maxStepNum = this.maxStepNum;
        }
        this.world.stepSimulation(stepTime, maxStepNum, unitStep);
    }
    _updateRigidBodies() {
        for(let i = 0, il = this.bodies.length; i < il; i++){
            this.bodies[i].updateFromBone();
        }
    }
    _updateBones() {
        for(let i = 0, il = this.bodies.length; i < il; i++){
            this.bodies[i].updateBone();
        }
    }
}
class ResourceManager {
    constructor(){
        this.threeVector3s = [];
        this.threeMatrix4s = [];
        this.threeQuaternions = [];
        this.threeEulers = [];
        this.transforms = [];
        this.quaternions = [];
        this.vector3s = [];
    }
    allocThreeVector3() {
        return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    }
    freeThreeVector3(v) {
        this.threeVector3s.push(v);
    }
    allocThreeMatrix4() {
        return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    }
    freeThreeMatrix4(m) {
        this.threeMatrix4s.push(m);
    }
    allocThreeQuaternion() {
        return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
    }
    freeThreeQuaternion(q) {
        this.threeQuaternions.push(q);
    }
    allocThreeEuler() {
        return this.threeEulers.length > 0 ? this.threeEulers.pop() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"]();
    }
    freeThreeEuler(e) {
        this.threeEulers.push(e);
    }
    allocTransform() {
        return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform();
    }
    freeTransform(t) {
        this.transforms.push(t);
    }
    allocQuaternion() {
        return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion();
    }
    freeQuaternion(q) {
        this.quaternions.push(q);
    }
    allocVector3() {
        return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3();
    }
    freeVector3(v) {
        this.vector3s.push(v);
    }
    setIdentity(t) {
        t.setIdentity();
    }
    getBasis(t) {
        var q = this.allocQuaternion();
        t.getBasis().getRotation(q);
        return q;
    }
    getBasisAsMatrix3(t) {
        var q = this.getBasis(t);
        var m = this.quaternionToMatrix3(q);
        this.freeQuaternion(q);
        return m;
    }
    getOrigin(t) {
        return t.getOrigin();
    }
    setOrigin(t, v) {
        t.getOrigin().setValue(v.x(), v.y(), v.z());
    }
    copyOrigin(t1, t2) {
        var o = t2.getOrigin();
        this.setOrigin(t1, o);
    }
    setBasis(t, q) {
        t.setRotation(q);
    }
    setBasisFromMatrix3(t, m) {
        var q = this.matrix3ToQuaternion(m);
        this.setBasis(t, q);
        this.freeQuaternion(q);
    }
    setOriginFromArray3(t, a) {
        t.getOrigin().setValue(a[0], a[1], a[2]);
    }
    setOriginFromThreeVector3(t, v) {
        t.getOrigin().setValue(v.x, v.y, v.z);
    }
    setBasisFromArray3(t, a) {
        var thQ = this.allocThreeQuaternion();
        var thE = this.allocThreeEuler();
        thE.set(a[0], a[1], a[2]);
        this.setBasisFromThreeQuaternion(t, thQ.setFromEuler(thE));
        this.freeThreeEuler(thE);
        this.freeThreeQuaternion(thQ);
    }
    setBasisFromThreeQuaternion(t, a) {
        var q = this.allocQuaternion();
        q.setX(a.x);
        q.setY(a.y);
        q.setZ(a.z);
        q.setW(a.w);
        this.setBasis(t, q);
        this.freeQuaternion(q);
    }
    multiplyTransforms(t1, t2) {
        var t = this.allocTransform();
        this.setIdentity(t);
        var m1 = this.getBasisAsMatrix3(t1);
        var m2 = this.getBasisAsMatrix3(t2);
        var o1 = this.getOrigin(t1);
        var o2 = this.getOrigin(t2);
        var v1 = this.multiplyMatrix3ByVector3(m1, o2);
        var v2 = this.addVector3(v1, o1);
        this.setOrigin(t, v2);
        var m3 = this.multiplyMatrices3(m1, m2);
        this.setBasisFromMatrix3(t, m3);
        this.freeVector3(v1);
        this.freeVector3(v2);
        return t;
    }
    inverseTransform(t) {
        var t2 = this.allocTransform();
        var m1 = this.getBasisAsMatrix3(t);
        var o = this.getOrigin(t);
        var m2 = this.transposeMatrix3(m1);
        var v1 = this.negativeVector3(o);
        var v2 = this.multiplyMatrix3ByVector3(m2, v1);
        this.setOrigin(t2, v2);
        this.setBasisFromMatrix3(t2, m2);
        this.freeVector3(v1);
        this.freeVector3(v2);
        return t2;
    }
    multiplyMatrices3(m1, m2) {
        var m3 = [];
        var v10 = this.rowOfMatrix3(m1, 0);
        var v11 = this.rowOfMatrix3(m1, 1);
        var v12 = this.rowOfMatrix3(m1, 2);
        var v20 = this.columnOfMatrix3(m2, 0);
        var v21 = this.columnOfMatrix3(m2, 1);
        var v22 = this.columnOfMatrix3(m2, 2);
        m3[0] = this.dotVectors3(v10, v20);
        m3[1] = this.dotVectors3(v10, v21);
        m3[2] = this.dotVectors3(v10, v22);
        m3[3] = this.dotVectors3(v11, v20);
        m3[4] = this.dotVectors3(v11, v21);
        m3[5] = this.dotVectors3(v11, v22);
        m3[6] = this.dotVectors3(v12, v20);
        m3[7] = this.dotVectors3(v12, v21);
        m3[8] = this.dotVectors3(v12, v22);
        this.freeVector3(v10);
        this.freeVector3(v11);
        this.freeVector3(v12);
        this.freeVector3(v20);
        this.freeVector3(v21);
        this.freeVector3(v22);
        return m3;
    }
    addVector3(v1, v2) {
        var v = this.allocVector3();
        v.setValue(v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z());
        return v;
    }
    dotVectors3(v1, v2) {
        return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();
    }
    rowOfMatrix3(m, i) {
        var v = this.allocVector3();
        v.setValue(m[i * 3 + 0], m[i * 3 + 1], m[i * 3 + 2]);
        return v;
    }
    columnOfMatrix3(m, i) {
        var v = this.allocVector3();
        v.setValue(m[i + 0], m[i + 3], m[i + 6]);
        return v;
    }
    negativeVector3(v) {
        var v2 = this.allocVector3();
        v2.setValue(-v.x(), -v.y(), -v.z());
        return v2;
    }
    multiplyMatrix3ByVector3(m, v) {
        var v4 = this.allocVector3();
        var v0 = this.rowOfMatrix3(m, 0);
        var v1 = this.rowOfMatrix3(m, 1);
        var v2 = this.rowOfMatrix3(m, 2);
        var x = this.dotVectors3(v0, v);
        var y = this.dotVectors3(v1, v);
        var z = this.dotVectors3(v2, v);
        v4.setValue(x, y, z);
        this.freeVector3(v0);
        this.freeVector3(v1);
        this.freeVector3(v2);
        return v4;
    }
    transposeMatrix3(m) {
        var m2 = [];
        m2[0] = m[0];
        m2[1] = m[3];
        m2[2] = m[6];
        m2[3] = m[1];
        m2[4] = m[4];
        m2[5] = m[7];
        m2[6] = m[2];
        m2[7] = m[5];
        m2[8] = m[8];
        return m2;
    }
    quaternionToMatrix3(q) {
        var m = [];
        var x = q.x();
        var y = q.y();
        var z = q.z();
        var w = q.w();
        var xx = x * x;
        var yy = y * y;
        var zz = z * z;
        var xy = x * y;
        var yz = y * z;
        var zx = z * x;
        var xw = x * w;
        var yw = y * w;
        var zw = z * w;
        m[0] = 1 - 2 * (yy + zz);
        m[1] = 2 * (xy - zw);
        m[2] = 2 * (zx + yw);
        m[3] = 2 * (xy + zw);
        m[4] = 1 - 2 * (zz + xx);
        m[5] = 2 * (yz - xw);
        m[6] = 2 * (zx - yw);
        m[7] = 2 * (yz + xw);
        m[8] = 1 - 2 * (xx + yy);
        return m;
    }
    matrix3ToQuaternion(m) {
        var t = m[0] + m[4] + m[8];
        var s, x, y, z, w;
        if (t > 0) {
            s = Math.sqrt(t + 1) * 2;
            w = 0.25 * s;
            x = (m[7] - m[5]) / s;
            y = (m[2] - m[6]) / s;
            z = (m[3] - m[1]) / s;
        } else if (m[0] > m[4] && m[0] > m[8]) {
            s = Math.sqrt(1 + m[0] - m[4] - m[8]) * 2;
            w = (m[7] - m[5]) / s;
            x = 0.25 * s;
            y = (m[1] + m[3]) / s;
            z = (m[2] + m[6]) / s;
        } else if (m[4] > m[8]) {
            s = Math.sqrt(1 + m[4] - m[0] - m[8]) * 2;
            w = (m[2] - m[6]) / s;
            x = (m[1] + m[3]) / s;
            y = 0.25 * s;
            z = (m[5] + m[7]) / s;
        } else {
            s = Math.sqrt(1 + m[8] - m[0] - m[4]) * 2;
            w = (m[3] - m[1]) / s;
            x = (m[2] + m[6]) / s;
            y = (m[5] + m[7]) / s;
            z = 0.25 * s;
        }
        var q = this.allocQuaternion();
        q.setX(x);
        q.setY(y);
        q.setZ(z);
        q.setW(w);
        return q;
    }
}
class RigidBody {
    constructor(mesh, world, params, manager){
        this.mesh = mesh;
        this.world = world;
        this.params = params;
        this.manager = manager;
        this.body = null;
        this.bone = null;
        this.boneOffsetForm = null;
        this.boneOffsetFormInverse = null;
        this._init();
    }
    /**
   * Resets rigid body transform to the current bone's.
   *
   * @return {RigidBody}
   */ reset() {
        this._setTransformFromBone();
        return this;
    }
    /**
   * Updates rigid body's transform from the current bone.
   *
   * @return {RidigBody}
   */ updateFromBone() {
        if (this.params.boneIndex !== -1 && this.params.type === 0) {
            this._setTransformFromBone();
        }
        return this;
    }
    /**
   * Updates bone from the current ridid body's transform.
   *
   * @return {RidigBody}
   */ updateBone() {
        if (this.params.type === 0 || this.params.boneIndex === -1) {
            return this;
        }
        this._updateBoneRotation();
        if (this.params.type === 1) {
            this._updateBonePosition();
        }
        this.bone.updateMatrixWorld(true);
        if (this.params.type === 2) {
            this._setPositionFromBone();
        }
        return this;
    }
    // private methods
    _init() {
        function generateShape(p) {
            switch(p.shapeType){
                case 0:
                    return new Ammo.btSphereShape(p.width);
                case 1:
                    return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth));
                case 2:
                    return new Ammo.btCapsuleShape(p.width, p.height);
                default:
                    throw new Error("unknown shape type " + p.shapeType);
            }
        }
        const manager = this.manager;
        const params = this.params;
        const bones = this.mesh.skeleton.bones;
        const bone = params.boneIndex === -1 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]() : bones[params.boneIndex];
        const shape = generateShape(params);
        const weight = params.type === 0 ? 0 : params.weight;
        const localInertia = manager.allocVector3();
        localInertia.setValue(0, 0, 0);
        if (weight !== 0) {
            shape.calculateLocalInertia(weight, localInertia);
        }
        const boneOffsetForm = manager.allocTransform();
        manager.setIdentity(boneOffsetForm);
        manager.setOriginFromArray3(boneOffsetForm, params.position);
        manager.setBasisFromArray3(boneOffsetForm, params.rotation);
        const vector = manager.allocThreeVector3();
        const boneForm = manager.allocTransform();
        manager.setIdentity(boneForm);
        manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector));
        const form = manager.multiplyTransforms(boneForm, boneOffsetForm);
        const state = new Ammo.btDefaultMotionState(form);
        const info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);
        info.set_m_friction(params.friction);
        info.set_m_restitution(params.restitution);
        const body = new Ammo.btRigidBody(info);
        if (params.type === 0) {
            body.setCollisionFlags(body.getCollisionFlags() | 2);
            body.setActivationState(4);
        }
        body.setDamping(params.positionDamping, params.rotationDamping);
        body.setSleepingThresholds(0, 0);
        this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget);
        this.body = body;
        this.bone = bone;
        this.boneOffsetForm = boneOffsetForm;
        this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm);
        manager.freeVector3(localInertia);
        manager.freeTransform(form);
        manager.freeTransform(boneForm);
        manager.freeThreeVector3(vector);
    }
    _getBoneTransform() {
        const manager = this.manager;
        const p = manager.allocThreeVector3();
        const q = manager.allocThreeQuaternion();
        const s = manager.allocThreeVector3();
        this.bone.matrixWorld.decompose(p, q, s);
        const tr = manager.allocTransform();
        manager.setOriginFromThreeVector3(tr, p);
        manager.setBasisFromThreeQuaternion(tr, q);
        const form = manager.multiplyTransforms(tr, this.boneOffsetForm);
        manager.freeTransform(tr);
        manager.freeThreeVector3(s);
        manager.freeThreeQuaternion(q);
        manager.freeThreeVector3(p);
        return form;
    }
    _getWorldTransformForBone() {
        const manager = this.manager;
        const tr = this.body.getCenterOfMassTransform();
        return manager.multiplyTransforms(tr, this.boneOffsetFormInverse);
    }
    _setTransformFromBone() {
        const manager = this.manager;
        const form = this._getBoneTransform();
        this.body.setCenterOfMassTransform(form);
        this.body.getMotionState().setWorldTransform(form);
        manager.freeTransform(form);
    }
    _setPositionFromBone() {
        const manager = this.manager;
        const form = this._getBoneTransform();
        const tr = manager.allocTransform();
        this.body.getMotionState().getWorldTransform(tr);
        manager.copyOrigin(tr, form);
        this.body.setCenterOfMassTransform(tr);
        this.body.getMotionState().setWorldTransform(tr);
        manager.freeTransform(tr);
        manager.freeTransform(form);
    }
    _updateBoneRotation() {
        const manager = this.manager;
        const tr = this._getWorldTransformForBone();
        const q = manager.getBasis(tr);
        const thQ = manager.allocThreeQuaternion();
        const thQ2 = manager.allocThreeQuaternion();
        const thQ3 = manager.allocThreeQuaternion();
        thQ.set(q.x(), q.y(), q.z(), q.w());
        thQ2.setFromRotationMatrix(this.bone.matrixWorld);
        thQ2.conjugate();
        thQ2.multiply(thQ);
        thQ3.setFromRotationMatrix(this.bone.matrix);
        this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize());
        manager.freeThreeQuaternion(thQ);
        manager.freeThreeQuaternion(thQ2);
        manager.freeThreeQuaternion(thQ3);
        manager.freeQuaternion(q);
        manager.freeTransform(tr);
    }
    _updateBonePosition() {
        const manager = this.manager;
        const tr = this._getWorldTransformForBone();
        const thV = manager.allocThreeVector3();
        const o = manager.getOrigin(tr);
        thV.set(o.x(), o.y(), o.z());
        if (this.bone.parent) {
            this.bone.parent.worldToLocal(thV);
        }
        this.bone.position.copy(thV);
        manager.freeThreeVector3(thV);
        manager.freeTransform(tr);
    }
}
class Constraint {
    /**
   * @param {THREE.SkinnedMesh} mesh
   * @param {Ammo.btDiscreteDynamicsWorld} world
   * @param {RigidBody} bodyA
   * @param {RigidBody} bodyB
   * @param {Object} params
   * @param {ResourceManager} manager
   */ constructor(mesh, world, bodyA, bodyB, params, manager){
        this.mesh = mesh;
        this.world = world;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
        this.params = params;
        this.manager = manager;
        this.constraint = null;
        this._init();
    }
    // private method
    _init() {
        const manager = this.manager;
        const params = this.params;
        const bodyA = this.bodyA;
        const bodyB = this.bodyB;
        const form = manager.allocTransform();
        manager.setIdentity(form);
        manager.setOriginFromArray3(form, params.position);
        manager.setBasisFromArray3(form, params.rotation);
        const formA = manager.allocTransform();
        const formB = manager.allocTransform();
        bodyA.body.getMotionState().getWorldTransform(formA);
        bodyB.body.getMotionState().getWorldTransform(formB);
        const formInverseA = manager.inverseTransform(formA);
        const formInverseB = manager.inverseTransform(formB);
        const formA2 = manager.multiplyTransforms(formInverseA, form);
        const formB2 = manager.multiplyTransforms(formInverseB, form);
        const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true);
        const lll = manager.allocVector3();
        const lul = manager.allocVector3();
        const all = manager.allocVector3();
        const aul = manager.allocVector3();
        lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2]);
        lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2]);
        all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2]);
        aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2]);
        constraint.setLinearLowerLimit(lll);
        constraint.setLinearUpperLimit(lul);
        constraint.setAngularLowerLimit(all);
        constraint.setAngularUpperLimit(aul);
        for(let i = 0; i < 3; i++){
            if (params.springPosition[i] !== 0) {
                constraint.enableSpring(i, true);
                constraint.setStiffness(i, params.springPosition[i]);
            }
        }
        for(let i = 0; i < 3; i++){
            if (params.springRotation[i] !== 0) {
                constraint.enableSpring(i + 3, true);
                constraint.setStiffness(i + 3, params.springRotation[i]);
            }
        }
        if (constraint.setParam !== void 0) {
            for(let i = 0; i < 6; i++){
                constraint.setParam(2, 0.475, i);
            }
        }
        this.world.addConstraint(constraint, true);
        this.constraint = constraint;
        manager.freeTransform(form);
        manager.freeTransform(formA);
        manager.freeTransform(formB);
        manager.freeTransform(formInverseA);
        manager.freeTransform(formInverseB);
        manager.freeTransform(formA2);
        manager.freeTransform(formB2);
        manager.freeVector3(lll);
        manager.freeVector3(lul);
        manager.freeVector3(all);
        manager.freeVector3(aul);
    }
}
const _position = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _quaternion = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
const _scale = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _matrixWorldInv = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
class MMDPhysicsHelper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    /**
   * Visualize Rigid bodies
   *
   * @param {THREE.SkinnedMesh} mesh
   * @param {Physics} physics
   */ constructor(mesh, physics){
        super();
        this.root = mesh;
        this.physics = physics;
        this.matrix.copy(mesh.matrixWorld);
        this.matrixAutoUpdate = false;
        this.materials = [];
        this.materials.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](16746632),
            wireframe: true,
            depthTest: false,
            depthWrite: false,
            opacity: 0.25,
            transparent: true
        }));
        this.materials.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8978312),
            wireframe: true,
            depthTest: false,
            depthWrite: false,
            opacity: 0.25,
            transparent: true
        }));
        this.materials.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8947967),
            wireframe: true,
            depthTest: false,
            depthWrite: false,
            opacity: 0.25,
            transparent: true
        }));
        this._init();
    }
    /**
   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.
   */ dispose() {
        const materials = this.materials;
        const children = this.children;
        for(let i = 0; i < materials.length; i++){
            materials[i].dispose();
        }
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (child.isMesh) child.geometry.dispose();
        }
    }
    /**
   * Updates Rigid Bodies visualization.
   */ updateMatrixWorld(force) {
        var mesh = this.root;
        if (this.visible) {
            var bodies = this.physics.bodies;
            _matrixWorldInv.copy(mesh.matrixWorld).decompose(_position, _quaternion, _scale).compose(_position, _quaternion, _scale.set(1, 1, 1)).invert();
            for(var i = 0, il = bodies.length; i < il; i++){
                var body = bodies[i].body;
                var child = this.children[i];
                var tr = body.getCenterOfMassTransform();
                var origin = tr.getOrigin();
                var rotation = tr.getRotation();
                child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(_matrixWorldInv);
                child.quaternion.setFromRotationMatrix(_matrixWorldInv).multiply(_quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()));
            }
        }
        this.matrix.copy(mesh.matrixWorld).decompose(_position, _quaternion, _scale).compose(_position, _quaternion, _scale.set(1, 1, 1));
        super.updateMatrixWorld(force);
    }
    // private method
    _init() {
        var bodies = this.physics.bodies;
        function createGeometry(param2) {
            switch(param2.shapeType){
                case 0:
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SphereGeometry"](param2.width, 16, 8);
                case 1:
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxGeometry"](param2.width * 2, param2.height * 2, param2.depth * 2, 8, 8, 8);
                case 2:
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$CapsuleGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CapsuleGeometry"](param2.width, param2.height, 8, 16);
                default:
                    return null;
            }
        }
        for(var i = 0, il = bodies.length; i < il; i++){
            var param = bodies[i].params;
            this.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](createGeometry(param), this.materials[param.type]));
        }
    }
}
;
 //# sourceMappingURL=MMDPhysics.js.map
}}),
"[project]/node_modules/three-stdlib/animation/MMDAnimationHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MMDAnimationHelper": (()=>MMDAnimationHelper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$CCDIKSolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/animation/CCDIKSolver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$MMDPhysics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/animation/MMDPhysics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
class MMDAnimationHelper {
    /**
   * @param {Object} params - (optional)
   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.
   * @param {Number} params.afterglow - Default is 0.0.
   * @param {boolean} params.resetPhysicsOnLoop - Default is true.
   */ constructor(params = {}){
        this.meshes = [];
        this.camera = null;
        this.cameraTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
        this.cameraTarget.name = "target";
        this.audio = null;
        this.audioManager = null;
        this.objects = /* @__PURE__ */ new WeakMap();
        this.configuration = {
            sync: params.sync !== void 0 ? params.sync : true,
            afterglow: params.afterglow !== void 0 ? params.afterglow : 0,
            resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,
            pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false
        };
        this.enabled = {
            animation: true,
            ik: true,
            grant: true,
            physics: true,
            cameraAnimation: true
        };
        this.onBeforePhysics = function() {};
        this.sharedPhysics = false;
        this.masterPhysics = null;
    }
    /**
   * Adds an Three.js Object to helper and setups animation.
   * The anmation durations of added objects are synched
   * if this.configuration.sync is true.
   *
   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object
   * @param {Object} params - (optional)
   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.
   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.
   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.
   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.
   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.
   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).
   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.
   * @return {MMDAnimationHelper}
   */ add(object, params = {}) {
        if (object.isSkinnedMesh) {
            this._addMesh(object, params);
        } else if (object.isCamera) {
            this._setupCamera(object, params);
        } else if (object.type === "Audio") {
            this._setupAudio(object, params);
        } else {
            throw new Error("THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
        }
        if (this.configuration.sync) this._syncDuration();
        return this;
    }
    /**
   * Removes an Three.js Object from helper.
   *
   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object
   * @return {MMDAnimationHelper}
   */ remove(object) {
        if (object.isSkinnedMesh) {
            this._removeMesh(object);
        } else if (object.isCamera) {
            this._clearCamera(object);
        } else if (object.type === "Audio") {
            this._clearAudio(object);
        } else {
            throw new Error("THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
        }
        if (this.configuration.sync) this._syncDuration();
        return this;
    }
    /**
   * Updates the animation.
   *
   * @param {Number} delta
   * @return {MMDAnimationHelper}
   */ update(delta) {
        if (this.audioManager !== null) this.audioManager.control(delta);
        for(let i = 0; i < this.meshes.length; i++){
            this._animateMesh(this.meshes[i], delta);
        }
        if (this.sharedPhysics) this._updateSharedPhysics(delta);
        if (this.camera !== null) this._animateCamera(this.camera, delta);
        return this;
    }
    /**
   * Changes the pose of SkinnedMesh as VPD specifies.
   *
   * @param {THREE.SkinnedMesh} mesh
   * @param {Object} vpd - VPD content parsed MMDParser
   * @param {Object} params - (optional)
   * @param {boolean} params.resetPose - Default is true.
   * @param {boolean} params.ik - Default is true.
   * @param {boolean} params.grant - Default is true.
   * @return {MMDAnimationHelper}
   */ pose(mesh, vpd, params = {}) {
        if (params.resetPose !== false) mesh.pose();
        const bones = mesh.skeleton.bones;
        const boneParams = vpd.bones;
        const boneNameDictionary = {};
        for(let i = 0, il = bones.length; i < il; i++){
            boneNameDictionary[bones[i].name] = i;
        }
        const vector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        for(let i = 0, il = boneParams.length; i < il; i++){
            const boneParam = boneParams[i];
            const boneIndex = boneNameDictionary[boneParam.name];
            if (boneIndex === void 0) continue;
            const bone = bones[boneIndex];
            bone.position.add(vector.fromArray(boneParam.translation));
            bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));
        }
        mesh.updateMatrixWorld(true);
        if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === "pmx") {
            const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());
            const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;
            const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;
            this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);
        } else {
            if (params.ik !== false) {
                this._createCCDIKSolver(mesh).update();
            }
            if (params.grant !== false) {
                this.createGrantSolver(mesh).update();
            }
        }
        return this;
    }
    /**
   * Enabes/Disables an animation feature.
   *
   * @param {string} key
   * @param {boolean} enabled
   * @return {MMDAnimationHelper}
   */ enable(key, enabled) {
        if (this.enabled[key] === void 0) {
            throw new Error("THREE.MMDAnimationHelper.enable: unknown key " + key);
        }
        this.enabled[key] = enabled;
        if (key === "physics") {
            for(let i = 0, il = this.meshes.length; i < il; i++){
                this._optimizeIK(this.meshes[i], enabled);
            }
        }
        return this;
    }
    /**
   * Creates an GrantSolver instance.
   *
   * @param {THREE.SkinnedMesh} mesh
   * @return {GrantSolver}
   */ createGrantSolver(mesh) {
        return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);
    }
    // private methods
    _addMesh(mesh, params) {
        if (this.meshes.indexOf(mesh) >= 0) {
            throw new Error("THREE.MMDAnimationHelper._addMesh: SkinnedMesh '" + mesh.name + "' has already been added.");
        }
        this.meshes.push(mesh);
        this.objects.set(mesh, {
            looped: false
        });
        this._setupMeshAnimation(mesh, params.animation);
        if (params.physics !== false) {
            this._setupMeshPhysics(mesh, params);
        }
        return this;
    }
    _setupCamera(camera, params) {
        if (this.camera === camera) {
            throw new Error("THREE.MMDAnimationHelper._setupCamera: Camera '" + camera.name + "' has already been set.");
        }
        if (this.camera) this.clearCamera(this.camera);
        this.camera = camera;
        camera.add(this.cameraTarget);
        this.objects.set(camera, {});
        if (params.animation !== void 0) {
            this._setupCameraAnimation(camera, params.animation);
        }
        return this;
    }
    _setupAudio(audio, params) {
        if (this.audio === audio) {
            throw new Error("THREE.MMDAnimationHelper._setupAudio: Audio '" + audio.name + "' has already been set.");
        }
        if (this.audio) this.clearAudio(this.audio);
        this.audio = audio;
        this.audioManager = new AudioManager(audio, params);
        this.objects.set(this.audioManager, {
            duration: this.audioManager.duration
        });
        return this;
    }
    _removeMesh(mesh) {
        let found = false;
        let writeIndex = 0;
        for(let i = 0, il = this.meshes.length; i < il; i++){
            if (this.meshes[i] === mesh) {
                this.objects.delete(mesh);
                found = true;
                continue;
            }
            this.meshes[writeIndex++] = this.meshes[i];
        }
        if (!found) {
            throw new Error("THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '" + mesh.name + "' has not been added yet.");
        }
        this.meshes.length = writeIndex;
        return this;
    }
    _clearCamera(camera) {
        if (camera !== this.camera) {
            throw new Error("THREE.MMDAnimationHelper._clearCamera: Camera '" + camera.name + "' has not been set yet.");
        }
        this.camera.remove(this.cameraTarget);
        this.objects.delete(this.camera);
        this.camera = null;
        return this;
    }
    _clearAudio(audio) {
        if (audio !== this.audio) {
            throw new Error("THREE.MMDAnimationHelper._clearAudio: Audio '" + audio.name + "' has not been set yet.");
        }
        this.objects.delete(this.audioManager);
        this.audio = null;
        this.audioManager = null;
        return this;
    }
    _setupMeshAnimation(mesh, animation) {
        const objects = this.objects.get(mesh);
        if (animation !== void 0) {
            const animations = Array.isArray(animation) ? animation : [
                animation
            ];
            objects.mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](mesh);
            for(let i = 0, il = animations.length; i < il; i++){
                objects.mixer.clipAction(animations[i]).play();
            }
            objects.mixer.addEventListener("loop", function(event) {
                const tracks = event.action._clip.tracks;
                if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== ".bones") return;
                objects.looped = true;
            });
        }
        objects.ikSolver = this._createCCDIKSolver(mesh);
        objects.grantSolver = this.createGrantSolver(mesh);
        return this;
    }
    _setupCameraAnimation(camera, animation) {
        const animations = Array.isArray(animation) ? animation : [
            animation
        ];
        const objects = this.objects.get(camera);
        objects.mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](camera);
        for(let i = 0, il = animations.length; i < il; i++){
            objects.mixer.clipAction(animations[i]).play();
        }
    }
    _setupMeshPhysics(mesh, params) {
        const objects = this.objects.get(mesh);
        if (params.world === void 0 && this.sharedPhysics) {
            const masterPhysics = this._getMasterPhysics();
            if (masterPhysics !== null) world = masterPhysics.world;
        }
        objects.physics = this._createMMDPhysics(mesh, params);
        if (objects.mixer && params.animationWarmup !== false) {
            this._animateMesh(mesh, 0);
            objects.physics.reset();
        }
        objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);
        this._optimizeIK(mesh, true);
    }
    _animateMesh(mesh, delta) {
        const objects = this.objects.get(mesh);
        const mixer = objects.mixer;
        const ikSolver = objects.ikSolver;
        const grantSolver = objects.grantSolver;
        const physics = objects.physics;
        const looped = objects.looped;
        if (mixer && this.enabled.animation) {
            this._restoreBones(mesh);
            mixer.update(delta);
            this._saveBones(mesh);
            if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === "pmx") {
                if (!objects.sortedBonesData) objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());
                this._animatePMXMesh(mesh, objects.sortedBonesData, ikSolver && this.enabled.ik ? ikSolver : null, grantSolver && this.enabled.grant ? grantSolver : null);
            } else {
                if (ikSolver && this.enabled.ik) {
                    mesh.updateMatrixWorld(true);
                    ikSolver.update();
                }
                if (grantSolver && this.enabled.grant) {
                    grantSolver.update();
                }
            }
        }
        if (looped === true && this.enabled.physics) {
            if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();
            objects.looped = false;
        }
        if (physics && this.enabled.physics && !this.sharedPhysics) {
            this.onBeforePhysics(mesh);
            physics.update(delta);
        }
    }
    // Sort bones in order by 1. transformationClass and 2. bone index.
    // In PMX animation system, bone transformations should be processed
    // in this order.
    _sortBoneDataArray(boneDataArray) {
        return boneDataArray.sort(function(a, b) {
            if (a.transformationClass !== b.transformationClass) {
                return a.transformationClass - b.transformationClass;
            } else {
                return a.index - b.index;
            }
        });
    }
    // PMX Animation system is a bit too complex and doesn't great match to
    // Three.js Animation system. This method attempts to simulate it as much as
    // possible but doesn't perfectly simulate.
    // This method is more costly than the regular one so
    // you are recommended to set constructor parameter "pmxAnimation: true"
    // only if your PMX model animation doesn't work well.
    // If you need better method you would be required to write your own.
    _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {
        _quaternionIndex = 0;
        _grantResultMap.clear();
        for(let i = 0, il = sortedBonesData.length; i < il; i++){
            updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);
        }
        mesh.updateMatrixWorld(true);
        return this;
    }
    _animateCamera(camera, delta) {
        const mixer = this.objects.get(camera).mixer;
        if (mixer && this.enabled.cameraAnimation) {
            mixer.update(delta);
            camera.updateProjectionMatrix();
            camera.up.set(0, 1, 0);
            camera.up.applyQuaternion(camera.quaternion);
            camera.lookAt(this.cameraTarget.position);
        }
    }
    _optimizeIK(mesh, physicsEnabled) {
        const iks = mesh.geometry.userData.MMD.iks;
        const bones = mesh.geometry.userData.MMD.bones;
        for(let i = 0, il = iks.length; i < il; i++){
            const ik = iks[i];
            const links = ik.links;
            for(let j = 0, jl = links.length; j < jl; j++){
                const link = links[j];
                if (physicsEnabled === true) {
                    link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;
                } else {
                    link.enabled = true;
                }
            }
        }
    }
    _createCCDIKSolver(mesh) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$CCDIKSolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CCDIKSolver"] === void 0) {
            throw new Error("THREE.MMDAnimationHelper: Import CCDIKSolver.");
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$CCDIKSolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CCDIKSolver"](mesh, mesh.geometry.userData.MMD.iks);
    }
    _createMMDPhysics(mesh, params) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$MMDPhysics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MMDPhysics"] === void 0) {
            throw new Error("THREE.MMDPhysics: Import MMDPhysics.");
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$MMDPhysics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MMDPhysics"](mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);
    }
    /*
   * Detects the longest duration and then sets it to them to sync.
   * TODO: Not to access private properties ( ._actions and ._clip )
   */ _syncDuration() {
        let max = 0;
        const objects = this.objects;
        const meshes = this.meshes;
        const camera = this.camera;
        const audioManager = this.audioManager;
        for(let i = 0, il = meshes.length; i < il; i++){
            const mixer = this.objects.get(meshes[i]).mixer;
            if (mixer === void 0) continue;
            for(let j = 0; j < mixer._actions.length; j++){
                const clip = mixer._actions[j]._clip;
                if (!objects.has(clip)) {
                    objects.set(clip, {
                        duration: clip.duration
                    });
                }
                max = Math.max(max, objects.get(clip).duration);
            }
        }
        if (camera !== null) {
            const mixer = this.objects.get(camera).mixer;
            if (mixer !== void 0) {
                for(let i = 0, il = mixer._actions.length; i < il; i++){
                    const clip = mixer._actions[i]._clip;
                    if (!objects.has(clip)) {
                        objects.set(clip, {
                            duration: clip.duration
                        });
                    }
                    max = Math.max(max, objects.get(clip).duration);
                }
            }
        }
        if (audioManager !== null) {
            max = Math.max(max, objects.get(audioManager).duration);
        }
        max += this.configuration.afterglow;
        for(let i = 0, il = this.meshes.length; i < il; i++){
            const mixer = this.objects.get(this.meshes[i]).mixer;
            if (mixer === void 0) continue;
            for(let j = 0, jl = mixer._actions.length; j < jl; j++){
                mixer._actions[j]._clip.duration = max;
            }
        }
        if (camera !== null) {
            const mixer = this.objects.get(camera).mixer;
            if (mixer !== void 0) {
                for(let i = 0, il = mixer._actions.length; i < il; i++){
                    mixer._actions[i]._clip.duration = max;
                }
            }
        }
        if (audioManager !== null) {
            audioManager.duration = max;
        }
    }
    // workaround
    _updatePropertyMixersBuffer(mesh) {
        const mixer = this.objects.get(mesh).mixer;
        const propertyMixers = mixer._bindings;
        const accuIndex = mixer._accuIndex;
        for(let i = 0, il = propertyMixers.length; i < il; i++){
            const propertyMixer = propertyMixers[i];
            const buffer = propertyMixer.buffer;
            const stride = propertyMixer.valueSize;
            const offset = (accuIndex + 1) * stride;
            propertyMixer.binding.getValue(buffer, offset);
        }
    }
    /*
   * Avoiding these two issues by restore/save bones before/after mixer animation.
   *
   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.
   *    Calculating IK, Grant, and Physics after mixer animation can break
   *    the cache coherency.
   *
   * 2. Applying Grant two or more times without reset the posing breaks model.
   */ _saveBones(mesh) {
        const objects = this.objects.get(mesh);
        const bones = mesh.skeleton.bones;
        let backupBones = objects.backupBones;
        if (backupBones === void 0) {
            backupBones = new Float32Array(bones.length * 7);
            objects.backupBones = backupBones;
        }
        for(let i = 0, il = bones.length; i < il; i++){
            const bone = bones[i];
            bone.position.toArray(backupBones, i * 7);
            bone.quaternion.toArray(backupBones, i * 7 + 3);
        }
    }
    _restoreBones(mesh) {
        const objects = this.objects.get(mesh);
        const backupBones = objects.backupBones;
        if (backupBones === void 0) return;
        const bones = mesh.skeleton.bones;
        for(let i = 0, il = bones.length; i < il; i++){
            const bone = bones[i];
            bone.position.fromArray(backupBones, i * 7);
            bone.quaternion.fromArray(backupBones, i * 7 + 3);
        }
    }
    // experimental
    _getMasterPhysics() {
        if (this.masterPhysics !== null) return this.masterPhysics;
        for(let i = 0, il = this.meshes.length; i < il; i++){
            const physics = this.meshes[i].physics;
            if (physics !== void 0 && physics !== null) {
                this.masterPhysics = physics;
                return this.masterPhysics;
            }
        }
        return null;
    }
    _updateSharedPhysics(delta) {
        if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;
        const physics = this._getMasterPhysics();
        if (physics === null) return;
        for(let i = 0, il = this.meshes.length; i < il; i++){
            const p = this.meshes[i].physics;
            if (p !== null && p !== void 0) {
                p.updateRigidBodies();
            }
        }
        physics.stepSimulation(delta);
        for(let i = 0, il = this.meshes.length; i < il; i++){
            const p = this.meshes[i].physics;
            if (p !== null && p !== void 0) {
                p.updateBones();
            }
        }
    }
}
const _quaternions = [];
let _quaternionIndex = 0;
function getQuaternion() {
    if (_quaternionIndex >= _quaternions.length) {
        _quaternions.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]());
    }
    return _quaternions[_quaternionIndex++];
}
const _grantResultMap = /* @__PURE__ */ new Map();
function updateOne(mesh, boneIndex, ikSolver, grantSolver) {
    const bones = mesh.skeleton.bones;
    const bonesData = mesh.geometry.userData.MMD.bones;
    const boneData = bonesData[boneIndex];
    const bone = bones[boneIndex];
    if (_grantResultMap.has(boneIndex)) return;
    const quaternion = getQuaternion();
    _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));
    if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {
        const parentIndex = boneData.grant.parentIndex;
        const ratio = boneData.grant.ratio;
        if (!_grantResultMap.has(parentIndex)) {
            updateOne(mesh, parentIndex, ikSolver, grantSolver);
        }
        grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);
    }
    if (ikSolver && boneData.ik) {
        mesh.updateMatrixWorld(true);
        ikSolver.updateOne(boneData.ik);
        const links = boneData.ik.links;
        for(let i = 0, il = links.length; i < il; i++){
            const link = links[i];
            if (link.enabled === false) continue;
            const linkIndex = link.index;
            if (_grantResultMap.has(linkIndex)) {
                _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));
            }
        }
    }
    quaternion.copy(bone.quaternion);
}
class AudioManager {
    /**
   * @param {THREE.Audio} audio
   * @param {Object} params - (optional)
   * @param {Nuumber} params.delayTime
   */ constructor(audio, params = {}){
        this.audio = audio;
        this.elapsedTime = 0;
        this.currentTime = 0;
        this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;
        this.audioDuration = this.audio.buffer.duration;
        this.duration = this.audioDuration + this.delayTime;
    }
    /**
   * @param {Number} delta
   * @return {AudioManager}
   */ control(delta) {
        this.elapsed += delta;
        this.currentTime += delta;
        if (this._shouldStopAudio()) this.audio.stop();
        if (this._shouldStartAudio()) this.audio.play();
        return this;
    }
    // private methods
    _shouldStartAudio() {
        if (this.audio.isPlaying) return false;
        while(this.currentTime >= this.duration){
            this.currentTime -= this.duration;
        }
        if (this.currentTime < this.delayTime) return false;
        if (this.currentTime - this.delayTime > this.audioDuration) return false;
        return true;
    }
    _shouldStopAudio() {
        return this.audio.isPlaying && this.currentTime >= this.duration;
    }
}
const _q = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
class GrantSolver {
    constructor(mesh, grants = []){
        this.mesh = mesh;
        this.grants = grants;
    }
    /**
   * Solve all the grant bones
   * @return {GrantSolver}
   */ update() {
        const grants = this.grants;
        for(let i = 0, il = grants.length; i < il; i++){
            this.updateOne(grants[i]);
        }
        return this;
    }
    /**
   * Solve a grant bone
   * @param {Object} grant - grant parameter
   * @return {GrantSolver}
   */ updateOne(grant) {
        const bones = this.mesh.skeleton.bones;
        const bone = bones[grant.index];
        const parentBone = bones[grant.parentIndex];
        if (grant.isLocal) {
            if (grant.affectPosition) ;
            if (grant.affectRotation) ;
        } else {
            if (grant.affectPosition) ;
            if (grant.affectRotation) {
                this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);
            }
        }
        return this;
    }
    addGrantRotation(bone, q, ratio) {
        _q.set(0, 0, 0, 1);
        _q.slerp(q, ratio);
        bone.quaternion.multiply(_q);
        return this;
    }
}
;
 //# sourceMappingURL=MMDAnimationHelper.js.map
}}),
"[project]/node_modules/three-stdlib/cameras/CinematicCamera.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CinematicCamera": (()=>CinematicCamera)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BokehShader2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/BokehShader2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class CinematicCamera extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"] {
    constructor(fov, aspect, near, far){
        super(fov, aspect, near, far);
        this.type = "CinematicCamera";
        this.postprocessing = {
            enabled: true
        };
        this.shaderSettings = {
            rings: 3,
            samples: 4
        };
        const depthShader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BokehShader2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BokehDepthShader"];
        this.materialDepth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            uniforms: depthShader.uniforms,
            vertexShader: depthShader.vertexShader,
            fragmentShader: depthShader.fragmentShader
        });
        this.materialDepth.uniforms["mNear"].value = near;
        this.materialDepth.uniforms["mFar"].value = far;
        this.setLens();
        this.initPostProcessing();
    }
    // providing fnumber and coc(Circle of Confusion) as extra arguments
    setLens(focalLength, filmGauge, fNumber, coc) {
        if (focalLength === void 0) focalLength = 35;
        if (filmGauge !== void 0) this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
        if (fNumber === void 0) fNumber = 8;
        if (coc === void 0) coc = 0.019;
        this.fNumber = fNumber;
        this.coc = coc;
        this.aperture = focalLength / this.fNumber;
        this.hyperFocal = focalLength * focalLength / (this.aperture * this.coc);
    }
    linearize(depth) {
        const zfar = this.far;
        const znear = this.near;
        return -zfar * znear / (depth * (zfar - znear) - zfar);
    }
    smoothstep(near, far, depth) {
        const x = this.saturate((depth - near) / (far - near));
        return x * x * (3 - 2 * x);
    }
    saturate(x) {
        return Math.max(0, Math.min(1, x));
    }
    // function for focusing at a distance from the camera
    focusAt(focusDistance) {
        if (focusDistance === void 0) focusDistance = 20;
        const focalLength = this.getFocalLength();
        this.focus = focusDistance;
        this.nearPoint = this.hyperFocal * this.focus / (this.hyperFocal + (this.focus - focalLength));
        this.farPoint = this.hyperFocal * this.focus / (this.hyperFocal - (this.focus - focalLength));
        this.depthOfField = this.farPoint - this.nearPoint;
        if (this.depthOfField < 0) this.depthOfField = 0;
        this.sdistance = this.smoothstep(this.near, this.far, this.focus);
        this.ldistance = this.linearize(1 - this.sdistance);
        this.postprocessing.bokeh_uniforms["focalDepth"].value = this.ldistance;
    }
    initPostProcessing() {
        if (this.postprocessing.enabled) {
            this.postprocessing.scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
            this.postprocessing.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -1e4, 1e4);
            this.postprocessing.scene.add(this.postprocessing.camera);
            this.postprocessing.rtTextureDepth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](window.innerWidth, window.innerHeight);
            this.postprocessing.rtTextureColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](window.innerWidth, window.innerHeight);
            const bokeh_shader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BokehShader2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BokehShader2"];
            this.postprocessing.bokeh_uniforms = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(bokeh_shader.uniforms);
            this.postprocessing.bokeh_uniforms["tColor"].value = this.postprocessing.rtTextureColor.texture;
            this.postprocessing.bokeh_uniforms["tDepth"].value = this.postprocessing.rtTextureDepth.texture;
            this.postprocessing.bokeh_uniforms["manualdof"].value = 0;
            this.postprocessing.bokeh_uniforms["shaderFocus"].value = 0;
            this.postprocessing.bokeh_uniforms["fstop"].value = 2.8;
            this.postprocessing.bokeh_uniforms["showFocus"].value = 1;
            this.postprocessing.bokeh_uniforms["focalDepth"].value = 0.1;
            this.postprocessing.bokeh_uniforms["znear"].value = this.near;
            this.postprocessing.bokeh_uniforms["zfar"].value = this.near;
            this.postprocessing.bokeh_uniforms["textureWidth"].value = window.innerWidth;
            this.postprocessing.bokeh_uniforms["textureHeight"].value = window.innerHeight;
            this.postprocessing.materialBokeh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
                uniforms: this.postprocessing.bokeh_uniforms,
                vertexShader: bokeh_shader.vertexShader,
                fragmentShader: bokeh_shader.fragmentShader,
                defines: {
                    RINGS: this.shaderSettings.rings,
                    SAMPLES: this.shaderSettings.samples,
                    DEPTH_PACKING: 1
                }
            });
            this.postprocessing.quad = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](window.innerWidth, window.innerHeight), this.postprocessing.materialBokeh);
            this.postprocessing.quad.position.z = -500;
            this.postprocessing.scene.add(this.postprocessing.quad);
        }
    }
    renderCinematic(scene, renderer) {
        if (this.postprocessing.enabled) {
            const currentRenderTarget = renderer.getRenderTarget();
            renderer.clear();
            scene.overrideMaterial = null;
            renderer.setRenderTarget(this.postprocessing.rtTextureColor);
            renderer.clear();
            renderer.render(scene, this);
            scene.overrideMaterial = this.materialDepth;
            renderer.setRenderTarget(this.postprocessing.rtTextureDepth);
            renderer.clear();
            renderer.render(scene, this);
            renderer.setRenderTarget(null);
            renderer.render(this.postprocessing.scene, this.postprocessing.camera);
            renderer.setRenderTarget(currentRenderTarget);
        }
    }
}
;
 //# sourceMappingURL=CinematicCamera.js.map
}}),
"[project]/node_modules/three-stdlib/webxr/ARButton.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ARButton": (()=>ARButton)
});
const ARButton = {
    createButton (renderer, sessionInit = {}) {
        const button = document.createElement("button");
        function showStartAR() {
            if (sessionInit.domOverlay === void 0) {
                const overlay = document.createElement("div");
                overlay.style.display = "none";
                document.body.appendChild(overlay);
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute("width", "38px");
                svg.setAttribute("height", "38px");
                svg.style.position = "absolute";
                svg.style.right = "20px";
                svg.style.top = "20px";
                svg.addEventListener("click", function() {
                    currentSession == null ? void 0 : currentSession.end();
                });
                overlay.appendChild(svg);
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28");
                path.setAttribute("stroke", "#fff");
                path.setAttribute("stroke-width", "2px");
                svg.appendChild(path);
                if (sessionInit.optionalFeatures === void 0) {
                    sessionInit.optionalFeatures = [];
                }
                sessionInit.optionalFeatures.push("dom-overlay");
                sessionInit.domOverlay = {
                    root: overlay
                };
            }
            let currentSession = null;
            async function onSessionStarted(session) {
                session.addEventListener("end", onSessionEnded);
                renderer.xr.setReferenceSpaceType("local");
                await renderer.xr.setSession(session);
                button.textContent = "STOP AR";
                sessionInit.domOverlay.root.style.display = "";
                currentSession = session;
            }
            function onSessionEnded() {
                currentSession.removeEventListener("end", onSessionEnded);
                button.textContent = "START AR";
                sessionInit.domOverlay.root.style.display = "none";
                currentSession = null;
            }
            button.style.display = "";
            button.style.cursor = "pointer";
            button.style.left = "calc(50% - 50px)";
            button.style.width = "100px";
            button.textContent = "START AR";
            button.onmouseenter = ()=>{
                button.style.opacity = "1.0";
            };
            button.onmouseleave = ()=>{
                button.style.opacity = "0.5";
            };
            button.onclick = ()=>{
                if (currentSession === null) {
                    navigator.xr.requestSession("immersive-ar", sessionInit).then(onSessionStarted);
                } else {
                    currentSession.end();
                }
            };
        }
        function disableButton() {
            button.style.display = "";
            button.style.cursor = "auto";
            button.style.left = "calc(50% - 75px)";
            button.style.width = "150px";
            button.onmouseenter = null;
            button.onmouseleave = null;
            button.onclick = null;
        }
        function showARNotSupported() {
            disableButton();
            button.textContent = "AR NOT SUPPORTED";
        }
        function stylizeElement(element) {
            element.style.position = "absolute";
            element.style.bottom = "20px";
            element.style.padding = "12px 6px";
            element.style.border = "1px solid #fff";
            element.style.borderRadius = "4px";
            element.style.background = "rgba(0,0,0,0.1)";
            element.style.color = "#fff";
            element.style.font = "normal 13px sans-serif";
            element.style.textAlign = "center";
            element.style.opacity = "0.5";
            element.style.outline = "none";
            element.style.zIndex = "999";
        }
        if ("xr" in navigator) {
            button.id = "ARButton";
            button.style.display = "none";
            stylizeElement(button);
            navigator.xr.isSessionSupported("immersive-ar").then(function(supported) {
                supported ? showStartAR() : showARNotSupported();
            }).catch(showARNotSupported);
            return button;
        } else {
            const message = document.createElement("a");
            if (window.isSecureContext === false) {
                message.href = document.location.href.replace(/^http:/, "https:");
                message.innerHTML = "WEBXR NEEDS HTTPS";
            } else {
                message.href = "https://immersiveweb.dev/";
                message.innerHTML = "WEBXR NOT AVAILABLE";
            }
            message.style.left = "calc(50% - 90px)";
            message.style.width = "180px";
            message.style.textDecoration = "none";
            stylizeElement(message);
            return message;
        }
    }
};
;
 //# sourceMappingURL=ARButton.js.map
}}),
"[project]/node_modules/three-stdlib/webxr/OculusHandModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "OculusHandModel": (()=>OculusHandModel)
});
(()=>{
    const e = new Error("Cannot find module './XRHandMeshModel.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
const TOUCH_RADIUS = 0.01;
const POINTING_JOINT = "index-finger-tip";
class OculusHandModel extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(controller, leftModelPath, rightModelPath){
        super();
        __publicField(this, "controller");
        __publicField(this, "motionController");
        __publicField(this, "envMap");
        __publicField(this, "mesh");
        __publicField(this, "xrInputSource");
        this.controller = controller;
        this.motionController = null;
        this.envMap = null;
        this.mesh = null;
        this.xrInputSource = null;
        controller.addEventListener("connected", (event)=>{
            const xrInputSource = event.data;
            if (xrInputSource.hand && !this.motionController) {
                this.xrInputSource = xrInputSource;
                this.motionController = new XRHandMeshModel(this, controller, void 0, xrInputSource.handedness, xrInputSource.handedness === "left" ? leftModelPath : rightModelPath);
            }
        });
        controller.addEventListener("disconnected", ()=>{
            this.dispose();
        });
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.motionController) {
            this.motionController.updateMesh();
        }
    }
    getPointerPosition() {
        const indexFingerTip = this.controller.joints[POINTING_JOINT];
        if (indexFingerTip) {
            return indexFingerTip.position;
        } else {
            return null;
        }
    }
    intersectBoxObject(boxObject) {
        const pointerPosition = this.getPointerPosition();
        if (pointerPosition) {
            const indexSphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"](pointerPosition, TOUCH_RADIUS);
            const box = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]().setFromObject(boxObject);
            return indexSphere.intersectsBox(box);
        } else {
            return false;
        }
    }
    checkButton(button) {
        if (this.intersectBoxObject(button)) {
            button.onPress();
        } else {
            button.onClear();
        }
        if (button.isPressed()) {
            button.whilePressed();
        }
    }
    dispose() {
        this.clear();
        this.motionController = null;
    }
}
;
 //# sourceMappingURL=OculusHandModel.js.map
}}),
"[project]/node_modules/three-stdlib/webxr/OculusHandPointerModel.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "OculusHandPointerModel": (()=>OculusHandPointerModel)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
;
const PINCH_MAX = 0.05;
const PINCH_THRESHOLD = 0.02;
const PINCH_MIN = 0.01;
const POINTER_ADVANCE_MAX = 0.02;
const POINTER_OPACITY_MAX = 1;
const POINTER_OPACITY_MIN = 0.4;
const POINTER_FRONT_RADIUS = 2e-3;
const POINTER_REAR_RADIUS = 0.01;
const POINTER_REAR_RADIUS_MIN = 3e-3;
const POINTER_LENGTH = 0.035;
const POINTER_SEGMENTS = 16;
const POINTER_RINGS = 12;
const POINTER_HEMISPHERE_ANGLE = 110;
const YAXIS = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(0, 1, 0);
const ZAXIS = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(0, 0, 1);
const CURSOR_RADIUS = 0.02;
const CURSOR_MAX_DISTANCE = 1.5;
class OculusHandPointerModel extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Object3D {
    constructor(hand, controller){
        super();
        this.hand = hand;
        this.controller = controller;
        this.motionController = null;
        this.envMap = null;
        this.mesh = null;
        this.pointerGeometry = null;
        this.pointerMesh = null;
        this.pointerObject = null;
        this.pinched = false;
        this.attached = false;
        this.cursorObject = null;
        this.raycaster = null;
        this._onConnected = this._onConnected.bind(this);
        this._onDisconnected = this._onDisconnected.bind(this);
        this.hand.addEventListener("connected", this._onConnected);
        this.hand.addEventListener("disconnected", this._onDisconnected);
    }
    _onConnected(event) {
        const xrInputSource = event.data;
        if (xrInputSource.hand) {
            this.visible = true;
            this.xrInputSource = xrInputSource;
            this.createPointer();
        }
    }
    _onDisconnected() {
        var _a, _b;
        this.visible = false;
        this.xrInputSource = null;
        (_a = this.pointerGeometry) == null ? void 0 : _a.dispose();
        (_b = this.pointerMesh) == null ? void 0 : _b.material.dispose();
        this.clear();
    }
    _drawVerticesRing(vertices, baseVector, ringIndex) {
        const segmentVector = baseVector.clone();
        for(var i = 0; i < POINTER_SEGMENTS; i++){
            segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);
            const vid = ringIndex * POINTER_SEGMENTS + i;
            vertices[3 * vid] = segmentVector.x;
            vertices[3 * vid + 1] = segmentVector.y;
            vertices[3 * vid + 2] = segmentVector.z;
        }
    }
    _updatePointerVertices(rearRadius) {
        const vertices = this.pointerGeometry.attributes.position.array;
        const frontFaceBase = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));
        this._drawVerticesRing(vertices, frontFaceBase, 0);
        const rearBase = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);
        for(var i = 0; i < POINTER_RINGS; i++){
            this._drawVerticesRing(vertices, rearBase, i + 1);
            rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));
        }
        const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);
        const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;
        const frontCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));
        vertices[frontCenterIndex * 3] = frontCenter.x;
        vertices[frontCenterIndex * 3 + 1] = frontCenter.y;
        vertices[frontCenterIndex * 3 + 2] = frontCenter.z;
        const rearCenter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(0, 0, rearRadius);
        vertices[rearCenterIndex * 3] = rearCenter.x;
        vertices[rearCenterIndex * 3 + 1] = rearCenter.y;
        vertices[rearCenterIndex * 3 + 2] = rearCenter.z;
        this.pointerGeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Float32BufferAttribute(vertices, 3));
    }
    createPointer() {
        var i, j;
        const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);
        const indices = [];
        this.pointerGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.BufferGeometry();
        this.pointerGeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Float32BufferAttribute(vertices, 3));
        this._updatePointerVertices(POINTER_REAR_RADIUS);
        for(i = 0; i < POINTER_RINGS; i++){
            for(j = 0; j < POINTER_SEGMENTS - 1; j++){
                indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);
                indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);
            }
            indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);
            indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);
        }
        const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);
        const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;
        for(i = 0; i < POINTER_SEGMENTS - 1; i++){
            indices.push(frontCenterIndex, i + 1, i);
            indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);
        }
        indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);
        indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.MeshBasicMaterial();
        material.transparent = true;
        material.opacity = POINTER_OPACITY_MIN;
        this.pointerGeometry.setIndex(indices);
        this.pointerMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(this.pointerGeometry, material);
        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);
        this.pointerObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Object3D();
        this.pointerObject.add(this.pointerMesh);
        this.raycaster = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Raycaster();
        const cursorGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.SphereGeometry(CURSOR_RADIUS, 10, 10);
        const cursorMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.MeshBasicMaterial();
        cursorMaterial.transparent = true;
        cursorMaterial.opacity = POINTER_OPACITY_MIN;
        this.cursorObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Mesh(cursorGeometry, cursorMaterial);
        this.pointerObject.add(this.cursorObject);
        this.add(this.pointerObject);
    }
    _updateRaycaster() {
        if (this.raycaster) {
            const pointerMatrix = this.pointerObject.matrixWorld;
            const tempMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Matrix4();
            tempMatrix.identity().extractRotation(pointerMatrix);
            this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);
            this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        }
    }
    _updatePointer() {
        this.pointerObject.visible = this.controller.visible;
        const indexTip = this.hand.joints["index-finger-tip"];
        const thumbTip = this.hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);
        this.pointerObject.position.copy(position);
        this.pointerObject.quaternion.copy(this.controller.quaternion);
        this.pinched = distance <= PINCH_THRESHOLD;
        const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);
        const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);
        if (pinchScale > 1) {
            this._updatePointerVertices(POINTER_REAR_RADIUS);
            this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);
            this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;
        } else if (pinchScale > 0) {
            const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;
            this._updatePointerVertices(rearRadius);
            if (focusScale < 1) {
                this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);
                this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);
            } else {
                this.pointerMesh.position.set(0, 0, -1 * rearRadius);
                this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;
            }
        } else {
            this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);
            this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);
            this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;
        }
        this.cursorObject.material.opacity = this.pointerMesh.material.opacity;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.pointerGeometry) {
            this._updatePointer();
            this._updateRaycaster();
        }
    }
    isPinched() {
        return this.pinched;
    }
    setAttached(attached) {
        this.attached = attached;
    }
    isAttached() {
        return this.attached;
    }
    intersectObject(object, recursive = true) {
        if (this.raycaster) {
            return this.raycaster.intersectObject(object, recursive);
        }
    }
    intersectObjects(objects, recursive = true) {
        if (this.raycaster) {
            return this.raycaster.intersectObjects(objects, recursive);
        }
    }
    checkIntersections(objects, recursive = false) {
        if (this.raycaster && !this.attached) {
            const intersections = this.raycaster.intersectObjects(objects, recursive);
            const direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(0, 0, -1);
            if (intersections.length > 0) {
                const intersection = intersections[0];
                const distance = intersection.distance;
                this.cursorObject.position.copy(direction.multiplyScalar(distance));
            } else {
                this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));
            }
        }
    }
    setCursor(distance) {
        const direction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Vector3(0, 0, -1);
        if (this.raycaster && !this.attached) {
            this.cursorObject.position.copy(direction.multiplyScalar(distance));
        }
    }
    dispose() {
        this._onDisconnected();
        this.hand.removeEventListener("connected", this._onConnected);
        this.hand.removeEventListener("disconnected", this._onDisconnected);
    }
}
;
 //# sourceMappingURL=OculusHandPointerModel.js.map
}}),
"[project]/node_modules/three-stdlib/csm/CSMFrustum.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CSMFrustum": (()=>CSMFrustum)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const inverseProjectionMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
class CSMFrustum {
    constructor(data){
        data = data || {};
        this.vertices = {
            near: [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
            ],
            far: [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
            ]
        };
        if (data.projectionMatrix !== void 0) {
            this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
        }
    }
    setFromProjectionMatrix(projectionMatrix, maxFar) {
        const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
        inverseProjectionMatrix.copy(projectionMatrix).invert();
        this.vertices.near[0].set(1, 1, -1);
        this.vertices.near[1].set(1, -1, -1);
        this.vertices.near[2].set(-1, -1, -1);
        this.vertices.near[3].set(-1, 1, -1);
        this.vertices.near.forEach(function(v) {
            v.applyMatrix4(inverseProjectionMatrix);
        });
        this.vertices.far[0].set(1, 1, 1);
        this.vertices.far[1].set(1, -1, 1);
        this.vertices.far[2].set(-1, -1, 1);
        this.vertices.far[3].set(-1, 1, 1);
        this.vertices.far.forEach(function(v) {
            v.applyMatrix4(inverseProjectionMatrix);
            const absZ = Math.abs(v.z);
            if (isOrthographic) {
                v.z *= Math.min(maxFar / absZ, 1);
            } else {
                v.multiplyScalar(Math.min(maxFar / absZ, 1));
            }
        });
        return this.vertices;
    }
    split(breaks, target) {
        while(breaks.length > target.length){
            target.push(new CSMFrustum());
        }
        target.length = breaks.length;
        for(let i = 0; i < breaks.length; i++){
            const cascade = target[i];
            if (i === 0) {
                for(let j = 0; j < 4; j++){
                    cascade.vertices.near[j].copy(this.vertices.near[j]);
                }
            } else {
                for(let j = 0; j < 4; j++){
                    cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);
                }
            }
            if (i === breaks.length - 1) {
                for(let j = 0; j < 4; j++){
                    cascade.vertices.far[j].copy(this.vertices.far[j]);
                }
            } else {
                for(let j = 0; j < 4; j++){
                    cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);
                }
            }
        }
    }
    toSpace(cameraMatrix, target) {
        for(let i = 0; i < 4; i++){
            target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);
            target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);
        }
    }
}
;
 //# sourceMappingURL=CSMFrustum.js.map
}}),
"[project]/node_modules/three-stdlib/csm/CSMShader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CSMShader": (()=>CSMShader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
const CSMShader = {
    lights_fragment_begin: /* glsl */ `
GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further
			cascade = CSM_cascades[ i ];
			cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
			closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
			margin = 0.25 * pow( closestEdge, 2.0 );
			csmx = cascade.x - margin / 2.0;
			csmy = cascade.y + margin / 2.0;
			if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

				float dist = min( linearDepth - csmx, csmy - linearDepth );
				float ratio = clamp( dist / margin, 0.0, 1.0 );

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

				ReflectedLight prevLight = reflectedLight;
				RE_Direct( directLight, geometry, material, reflectedLight );

				bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
				float blendRatio = shouldBlend ? ratio : 1.0;

				reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
				reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
				reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
				reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

			}
	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, geometry, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

			directionalLightShadow = directionalLightShadows[ i ];
			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, geometry, directLight );

			RE_Direct( directLight, geometry, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,
    getlights_pars_begin () {
        return /* glsl */ `
			#if defined( USE_CSM ) && defined( CSM_CASCADES )
			uniform vec2 CSM_cascades[CSM_CASCADES];
			uniform float cameraNear;
			uniform float shadowFar;
			#endif

			${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_pars_begin}
		`;
    }
};
;
 //# sourceMappingURL=CSMShader.js.map
}}),
"[project]/node_modules/three-stdlib/csm/CSM.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CSM": (()=>CSM)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/csm/CSMFrustum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/csm/CSMShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
;
;
const _cameraToLightMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _lightSpaceFrustum = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSMFrustum"]();
const _center = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _bbox = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
const _uniformArray = [];
const _logArray = [];
class CSM {
    constructor(data){
        data = data || {};
        this.camera = data.camera;
        this.parent = data.parent;
        this.cascades = data.cascades || 3;
        this.maxFar = data.maxFar || 1e5;
        this.mode = data.mode || "practical";
        this.shadowMapSize = data.shadowMapSize || 2048;
        this.shadowBias = data.shadowBias || 1e-6;
        this.lightDirection = data.lightDirection || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, -1, 1).normalize();
        this.lightIntensity = data.lightIntensity || 1;
        this.lightNear = data.lightNear || 1;
        this.lightFar = data.lightFar || 2e3;
        this.lightMargin = data.lightMargin || 200;
        this.customSplitsCallback = data.customSplitsCallback;
        this.fade = false;
        this.mainFrustum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSMFrustum"]();
        this.frustums = [];
        this.breaks = [];
        this.lights = [];
        this.shaders = /* @__PURE__ */ new Map();
        this.createLights();
        this.updateFrustums();
        this.injectInclude();
    }
    createLights() {
        for(let i = 0; i < this.cascades; i++){
            const light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DirectionalLight"](16777215, this.lightIntensity);
            light.castShadow = true;
            light.shadow.mapSize.width = this.shadowMapSize;
            light.shadow.mapSize.height = this.shadowMapSize;
            light.shadow.camera.near = this.lightNear;
            light.shadow.camera.far = this.lightFar;
            light.shadow.bias = this.shadowBias;
            this.parent.add(light);
            this.parent.add(light.target);
            this.lights.push(light);
        }
    }
    initCascades() {
        const camera = this.camera;
        camera.updateProjectionMatrix();
        this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);
        this.mainFrustum.split(this.breaks, this.frustums);
    }
    updateShadowBounds() {
        const frustums = this.frustums;
        for(let i = 0; i < frustums.length; i++){
            const light = this.lights[i];
            const shadowCam = light.shadow.camera;
            const frustum = this.frustums[i];
            const nearVerts = frustum.vertices.near;
            const farVerts = frustum.vertices.far;
            const point1 = farVerts[0];
            let point2;
            if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {
                point2 = farVerts[2];
            } else {
                point2 = nearVerts[2];
            }
            let squaredBBWidth = point1.distanceTo(point2);
            if (this.fade) {
                const camera = this.camera;
                const far = Math.max(camera.far, this.maxFar);
                const linearDepth = frustum.vertices.far[0].z / (far - camera.near);
                const margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);
                squaredBBWidth += margin;
            }
            shadowCam.left = -squaredBBWidth / 2;
            shadowCam.right = squaredBBWidth / 2;
            shadowCam.top = squaredBBWidth / 2;
            shadowCam.bottom = -squaredBBWidth / 2;
            shadowCam.updateProjectionMatrix();
        }
    }
    getBreaks() {
        const camera = this.camera;
        const far = Math.min(camera.far, this.maxFar);
        this.breaks.length = 0;
        switch(this.mode){
            case "uniform":
                uniformSplit(this.cascades, camera.near, far, this.breaks);
                break;
            case "logarithmic":
                logarithmicSplit(this.cascades, camera.near, far, this.breaks);
                break;
            case "practical":
                practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);
                break;
            case "custom":
                if (this.customSplitsCallback === void 0) console.error("CSM: Custom split scheme callback not defined.");
                this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);
                break;
        }
        function uniformSplit(amount, near, far2, target) {
            for(let i = 1; i < amount; i++){
                target.push((near + (far2 - near) * i / amount) / far2);
            }
            target.push(1);
        }
        function logarithmicSplit(amount, near, far2, target) {
            for(let i = 1; i < amount; i++){
                target.push(near * (far2 / near) ** (i / amount) / far2);
            }
            target.push(1);
        }
        function practicalSplit(amount, near, far2, lambda, target) {
            _uniformArray.length = 0;
            _logArray.length = 0;
            logarithmicSplit(amount, near, far2, _logArray);
            uniformSplit(amount, near, far2, _uniformArray);
            for(let i = 1; i < amount; i++){
                target.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));
            }
            target.push(1);
        }
    }
    update() {
        const camera = this.camera;
        const frustums = this.frustums;
        for(let i = 0; i < frustums.length; i++){
            const light = this.lights[i];
            const shadowCam = light.shadow.camera;
            const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;
            const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;
            light.shadow.camera.updateMatrixWorld(true);
            _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);
            frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);
            const nearVerts = _lightSpaceFrustum.vertices.near;
            const farVerts = _lightSpaceFrustum.vertices.far;
            _bbox.makeEmpty();
            for(let j = 0; j < 4; j++){
                _bbox.expandByPoint(nearVerts[j]);
                _bbox.expandByPoint(farVerts[j]);
            }
            _bbox.getCenter(_center);
            _center.z = _bbox.max.z + this.lightMargin;
            _center.x = Math.floor(_center.x / texelWidth) * texelWidth;
            _center.y = Math.floor(_center.y / texelHeight) * texelHeight;
            _center.applyMatrix4(light.shadow.camera.matrixWorld);
            light.position.copy(_center);
            light.target.position.copy(_center);
            light.target.position.x += this.lightDirection.x;
            light.target.position.y += this.lightDirection.y;
            light.target.position.z += this.lightDirection.z;
        }
    }
    injectInclude() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_fragment_begin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSMShader"].lights_fragment_begin;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ShaderChunk"].lights_pars_begin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSMShader"].lights_pars_begin;
    }
    setupMaterial(material) {
        material.defines = material.defines || {};
        material.defines.USE_CSM = 1;
        material.defines.CSM_CASCADES = this.cascades;
        if (this.fade) {
            material.defines.CSM_FADE = "";
        }
        const breaksVec2 = [];
        const scope = this;
        const shaders = this.shaders;
        material.onBeforeCompile = function(shader) {
            const far = Math.min(scope.camera.far, scope.maxFar);
            scope.getExtendedBreaks(breaksVec2);
            shader.uniforms.CSM_cascades = {
                value: breaksVec2
            };
            shader.uniforms.cameraNear = {
                value: scope.camera.near
            };
            shader.uniforms.shadowFar = {
                value: far
            };
            shaders.set(material, shader);
        };
        shaders.set(material, null);
    }
    updateUniforms() {
        const far = Math.min(this.camera.far, this.maxFar);
        const shaders = this.shaders;
        shaders.forEach(function(shader, material) {
            if (shader !== null) {
                const uniforms = shader.uniforms;
                this.getExtendedBreaks(uniforms.CSM_cascades.value);
                uniforms.cameraNear.value = this.camera.near;
                uniforms.shadowFar.value = far;
            }
            if (!this.fade && "CSM_FADE" in material.defines) {
                delete material.defines.CSM_FADE;
                material.needsUpdate = true;
            } else if (this.fade && !("CSM_FADE" in material.defines)) {
                material.defines.CSM_FADE = "";
                material.needsUpdate = true;
            }
        }, this);
    }
    getExtendedBreaks(target) {
        while(target.length < this.breaks.length){
            target.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]());
        }
        target.length = this.breaks.length;
        for(let i = 0; i < this.cascades; i++){
            const amount = this.breaks[i];
            const prev = this.breaks[i - 1] || 0;
            target[i].x = prev;
            target[i].y = amount;
        }
    }
    updateFrustums() {
        this.getBreaks();
        this.initCascades();
        this.updateShadowBounds();
        this.updateUniforms();
    }
    remove() {
        for(let i = 0; i < this.lights.length; i++){
            this.parent.remove(this.lights[i]);
        }
    }
    dispose() {
        const shaders = this.shaders;
        shaders.forEach(function(shader, material) {
            delete material.onBeforeCompile;
            delete material.defines.USE_CSM;
            delete material.defines.CSM_CASCADES;
            delete material.defines.CSM_FADE;
            if (shader !== null) {
                delete shader.uniforms.CSM_cascades;
                delete shader.uniforms.cameraNear;
                delete shader.uniforms.shadowFar;
            }
            material.needsUpdate = true;
        });
        shaders.clear();
    }
}
;
 //# sourceMappingURL=CSM.js.map
}}),
"[project]/node_modules/three-stdlib/csm/CSMHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CSMHelper": (()=>CSMHelper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class CSMHelper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"] {
    constructor(csm){
        super();
        this.csm = csm;
        this.displayFrustum = true;
        this.displayPlanes = true;
        this.displayShadowBounds = true;
        const indices = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions = new Float32Array(24);
        const frustumGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        frustumGeometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](indices, 1));
        frustumGeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](positions, 3, false));
        const frustumLines = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](frustumGeometry, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]());
        this.add(frustumLines);
        this.frustumLines = frustumLines;
        this.cascadeLines = [];
        this.cascadePlanes = [];
        this.shadowLines = [];
    }
    updateVisibility() {
        const displayFrustum = this.displayFrustum;
        const displayPlanes = this.displayPlanes;
        const displayShadowBounds = this.displayShadowBounds;
        const frustumLines = this.frustumLines;
        const cascadeLines = this.cascadeLines;
        const cascadePlanes = this.cascadePlanes;
        const shadowLines = this.shadowLines;
        for(let i = 0, l = cascadeLines.length; i < l; i++){
            const cascadeLine = cascadeLines[i];
            const cascadePlane = cascadePlanes[i];
            const shadowLineGroup = shadowLines[i];
            cascadeLine.visible = displayFrustum;
            cascadePlane.visible = displayFrustum && displayPlanes;
            shadowLineGroup.visible = displayShadowBounds;
        }
        frustumLines.visible = displayFrustum;
    }
    update() {
        const csm = this.csm;
        const camera = csm.camera;
        const cascades = csm.cascades;
        const mainFrustum = csm.mainFrustum;
        const frustums = csm.frustums;
        const lights = csm.lights;
        const frustumLines = this.frustumLines;
        const frustumLinePositions = frustumLines.geometry.getAttribute("position");
        const cascadeLines = this.cascadeLines;
        const cascadePlanes = this.cascadePlanes;
        const shadowLines = this.shadowLines;
        this.position.copy(camera.position);
        this.quaternion.copy(camera.quaternion);
        this.scale.copy(camera.scale);
        this.updateMatrixWorld(true);
        while(cascadeLines.length > cascades){
            this.remove(cascadeLines.pop());
            this.remove(cascadePlanes.pop());
            this.remove(shadowLines.pop());
        }
        while(cascadeLines.length < cascades){
            const cascadeLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3Helper"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"](), 16777215);
            const planeMat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
                transparent: true,
                opacity: 0.1,
                depthWrite: false,
                side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"]
            });
            const cascadePlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](), planeMat);
            const shadowLineGroup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            const shadowLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3Helper"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"](), 16776960);
            shadowLineGroup.add(shadowLine);
            this.add(cascadeLine);
            this.add(cascadePlane);
            this.add(shadowLineGroup);
            cascadeLines.push(cascadeLine);
            cascadePlanes.push(cascadePlane);
            shadowLines.push(shadowLineGroup);
        }
        for(let i = 0; i < cascades; i++){
            const frustum = frustums[i];
            const light = lights[i];
            const shadowCam = light.shadow.camera;
            const farVerts2 = frustum.vertices.far;
            const cascadeLine = cascadeLines[i];
            const cascadePlane = cascadePlanes[i];
            const shadowLineGroup = shadowLines[i];
            const shadowLine = shadowLineGroup.children[0];
            cascadeLine.box.min.copy(farVerts2[2]);
            cascadeLine.box.max.copy(farVerts2[0]);
            cascadeLine.box.max.z += 1e-4;
            cascadePlane.position.addVectors(farVerts2[0], farVerts2[2]);
            cascadePlane.position.multiplyScalar(0.5);
            cascadePlane.scale.subVectors(farVerts2[0], farVerts2[2]);
            cascadePlane.scale.z = 1e-4;
            this.remove(shadowLineGroup);
            shadowLineGroup.position.copy(shadowCam.position);
            shadowLineGroup.quaternion.copy(shadowCam.quaternion);
            shadowLineGroup.scale.copy(shadowCam.scale);
            shadowLineGroup.updateMatrixWorld(true);
            this.attach(shadowLineGroup);
            shadowLine.box.min.set(shadowCam.bottom, shadowCam.left, -shadowCam.far);
            shadowLine.box.max.set(shadowCam.top, shadowCam.right, -shadowCam.near);
        }
        const nearVerts = mainFrustum.vertices.near;
        const farVerts = mainFrustum.vertices.far;
        frustumLinePositions.setXYZ(0, farVerts[0].x, farVerts[0].y, farVerts[0].z);
        frustumLinePositions.setXYZ(1, farVerts[3].x, farVerts[3].y, farVerts[3].z);
        frustumLinePositions.setXYZ(2, farVerts[2].x, farVerts[2].y, farVerts[2].z);
        frustumLinePositions.setXYZ(3, farVerts[1].x, farVerts[1].y, farVerts[1].z);
        frustumLinePositions.setXYZ(4, nearVerts[0].x, nearVerts[0].y, nearVerts[0].z);
        frustumLinePositions.setXYZ(5, nearVerts[3].x, nearVerts[3].y, nearVerts[3].z);
        frustumLinePositions.setXYZ(6, nearVerts[2].x, nearVerts[2].y, nearVerts[2].z);
        frustumLinePositions.setXYZ(7, nearVerts[1].x, nearVerts[1].y, nearVerts[1].z);
        frustumLinePositions.needsUpdate = true;
    }
}
;
 //# sourceMappingURL=CSMHelper.js.map
}}),
"[project]/node_modules/three-stdlib/interactive/HTMLMesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "HTMLMesh": (()=>HTMLMesh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class HTMLMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(dom){
        const texture = new HTMLTexture(dom);
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](texture.image.width * 1e-3, texture.image.height * 1e-3);
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            map: texture,
            toneMapped: false,
            transparent: true
        });
        super(geometry, material);
        function onEvent(event) {
            material.map.dispatchDOMEvent(event);
        }
        this.addEventListener("mousedown", onEvent);
        this.addEventListener("mousemove", onEvent);
        this.addEventListener("mouseup", onEvent);
        this.addEventListener("click", onEvent);
        this.dispose = function() {
            geometry.dispose();
            material.dispose();
            material.map.dispose();
            canvases.delete(dom);
            this.removeEventListener("mousedown", onEvent);
            this.removeEventListener("mousemove", onEvent);
            this.removeEventListener("mouseup", onEvent);
            this.removeEventListener("click", onEvent);
        };
    }
}
class HTMLTexture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CanvasTexture"] {
    constructor(dom){
        super(html2canvas(dom));
        this.dom = dom;
        this.anisotropy = 16;
        if ("colorSpace" in this) this.colorSpace = "srgb";
        else this.encoding = 3001;
        this.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        this.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        const observer = new MutationObserver(()=>{
            if (!this.scheduleUpdate) {
                this.scheduleUpdate = setTimeout(()=>this.update(), 16);
            }
        });
        const config = {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
        };
        observer.observe(dom, config);
        this.observer = observer;
    }
    dispatchDOMEvent(event) {
        if (event.data) {
            htmlevent(this.dom, event.type, event.data.x, event.data.y);
        }
    }
    update() {
        this.image = html2canvas(this.dom);
        this.needsUpdate = true;
        this.scheduleUpdate = null;
    }
    dispose() {
        if (this.observer) {
            this.observer.disconnect();
        }
        this.scheduleUpdate = clearTimeout(this.scheduleUpdate);
        super.dispose();
    }
}
const canvases = /* @__PURE__ */ new WeakMap();
function html2canvas(element) {
    const range = document.createRange();
    const color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
    function Clipper(context2) {
        const clips = [];
        let isClipping = false;
        function doClip() {
            if (isClipping) {
                isClipping = false;
                context2.restore();
            }
            if (clips.length === 0) return;
            let minX = -Infinity, minY = -Infinity;
            let maxX = Infinity, maxY = Infinity;
            for(let i = 0; i < clips.length; i++){
                const clip = clips[i];
                minX = Math.max(minX, clip.x);
                minY = Math.max(minY, clip.y);
                maxX = Math.min(maxX, clip.x + clip.width);
                maxY = Math.min(maxY, clip.y + clip.height);
            }
            context2.save();
            context2.beginPath();
            context2.rect(minX, minY, maxX - minX, maxY - minY);
            context2.clip();
            isClipping = true;
        }
        return {
            add: function(clip) {
                clips.push(clip);
                doClip();
            },
            remove: function() {
                clips.pop();
                doClip();
            }
        };
    }
    function drawText(style, x, y, string) {
        if (string !== "") {
            if (style.textTransform === "uppercase") {
                string = string.toUpperCase();
            }
            context.font = style.fontWeight + " " + style.fontSize + " " + style.fontFamily;
            context.textBaseline = "top";
            context.fillStyle = style.color;
            context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);
        }
    }
    function buildRectPath(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        context.beginPath();
        context.moveTo(x + r, y);
        context.arcTo(x + w, y, x + w, y + h, r);
        context.arcTo(x + w, y + h, x, y + h, r);
        context.arcTo(x, y + h, x, y, r);
        context.arcTo(x, y, x + w, y, r);
        context.closePath();
    }
    function drawBorder(style, which, x, y, width, height) {
        const borderWidth = style[which + "Width"];
        const borderStyle = style[which + "Style"];
        const borderColor = style[which + "Color"];
        if (borderWidth !== "0px" && borderStyle !== "none" && borderColor !== "transparent" && borderColor !== "rgba(0, 0, 0, 0)") {
            context.strokeStyle = borderColor;
            context.lineWidth = parseFloat(borderWidth);
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x + width, y + height);
            context.stroke();
        }
    }
    function drawElement(element2, style) {
        let x = 0, y = 0, width = 0, height = 0;
        if (element2.nodeType === Node.TEXT_NODE) {
            range.selectNode(element2);
            const rect = range.getBoundingClientRect();
            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;
            drawText(style, x, y, element2.nodeValue.trim());
        } else if (element2.nodeType === Node.COMMENT_NODE) {
            return;
        } else if (element2 instanceof HTMLCanvasElement) {
            if (element2.style.display === "none") return;
            context.save();
            const dpr = window.devicePixelRatio;
            context.scale(1 / dpr, 1 / dpr);
            context.drawImage(element2, 0, 0);
            context.restore();
        } else {
            if (element2.style.display === "none") return;
            const rect = element2.getBoundingClientRect();
            x = rect.left - offset.left - 0.5;
            y = rect.top - offset.top - 0.5;
            width = rect.width;
            height = rect.height;
            style = window.getComputedStyle(element2);
            buildRectPath(x, y, width, height, parseFloat(style.borderRadius));
            const backgroundColor = style.backgroundColor;
            if (backgroundColor !== "transparent" && backgroundColor !== "rgba(0, 0, 0, 0)") {
                context.fillStyle = backgroundColor;
                context.fill();
            }
            const borders = [
                "borderTop",
                "borderLeft",
                "borderBottom",
                "borderRight"
            ];
            let match = true;
            let prevBorder = null;
            for (const border of borders){
                if (prevBorder !== null) {
                    match = style[border + "Width"] === style[prevBorder + "Width"] && style[border + "Color"] === style[prevBorder + "Color"] && style[border + "Style"] === style[prevBorder + "Style"];
                }
                if (match === false) break;
                prevBorder = border;
            }
            if (match === true) {
                const width2 = parseFloat(style.borderTopWidth);
                if (style.borderTopWidth !== "0px" && style.borderTopStyle !== "none" && style.borderTopColor !== "transparent" && style.borderTopColor !== "rgba(0, 0, 0, 0)") {
                    context.strokeStyle = style.borderTopColor;
                    context.lineWidth = width2;
                    context.stroke();
                }
            } else {
                drawBorder(style, "borderTop", x, y, width, 0);
                drawBorder(style, "borderLeft", x, y, 0, height);
                drawBorder(style, "borderBottom", x, y + height, width, 0);
                drawBorder(style, "borderRight", x + width, y, 0, height);
            }
            if (element2 instanceof HTMLInputElement) {
                let accentColor = style.accentColor;
                if (accentColor === void 0 || accentColor === "auto") accentColor = style.color;
                color.set(accentColor);
                const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);
                const accentTextColor = luminance < 0.5 ? "white" : "#111111";
                if (element2.type === "radio") {
                    buildRectPath(x, y, width, height, height);
                    context.fillStyle = "white";
                    context.strokeStyle = accentColor;
                    context.lineWidth = 1;
                    context.fill();
                    context.stroke();
                    if (element2.checked) {
                        buildRectPath(x + 2, y + 2, width - 4, height - 4, height);
                        context.fillStyle = accentColor;
                        context.strokeStyle = accentTextColor;
                        context.lineWidth = 2;
                        context.fill();
                        context.stroke();
                    }
                }
                if (element2.type === "checkbox") {
                    buildRectPath(x, y, width, height, 2);
                    context.fillStyle = element2.checked ? accentColor : "white";
                    context.strokeStyle = element2.checked ? accentTextColor : accentColor;
                    context.lineWidth = 1;
                    context.stroke();
                    context.fill();
                    if (element2.checked) {
                        const currentTextAlign = context.textAlign;
                        context.textAlign = "center";
                        const properties = {
                            color: accentTextColor,
                            fontFamily: style.fontFamily,
                            fontSize: height + "px",
                            fontWeight: "bold"
                        };
                        drawText(properties, x + width / 2, y, "✔");
                        context.textAlign = currentTextAlign;
                    }
                }
                if (element2.type === "range") {
                    const [min, max, value] = [
                        "min",
                        "max",
                        "value"
                    ].map((property)=>parseFloat(element2[property]));
                    const position = (value - min) / (max - min) * (width - height);
                    buildRectPath(x, y + height / 4, width, height / 2, height / 4);
                    context.fillStyle = accentTextColor;
                    context.strokeStyle = accentColor;
                    context.lineWidth = 1;
                    context.fill();
                    context.stroke();
                    buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);
                    context.fillStyle = accentColor;
                    context.fill();
                    buildRectPath(x + position, y, height, height, height / 2);
                    context.fillStyle = accentColor;
                    context.fill();
                }
                if (element2.type === "color" || element2.type === "text" || element2.type === "number") {
                    clipper.add({
                        x,
                        y,
                        width,
                        height
                    });
                    drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);
                    clipper.remove();
                }
            }
        }
        const isClipping = style.overflow === "auto" || style.overflow === "hidden";
        if (isClipping) clipper.add({
            x,
            y,
            width,
            height
        });
        for(let i = 0; i < element2.childNodes.length; i++){
            drawElement(element2.childNodes[i], style);
        }
        if (isClipping) clipper.remove();
    }
    const offset = element.getBoundingClientRect();
    let canvas = canvases.get(element);
    if (canvas === void 0) {
        canvas = document.createElement("canvas");
        canvas.width = offset.width;
        canvas.height = offset.height;
        canvases.set(element, canvas);
    }
    const context = canvas.getContext("2d");
    const clipper = new Clipper(context);
    drawElement(element);
    return canvas;
}
function htmlevent(element, event, x, y) {
    const mouseEventInit = {
        clientX: x * element.offsetWidth + element.offsetLeft,
        clientY: y * element.offsetHeight + element.offsetTop,
        view: element.ownerDocument.defaultView
    };
    window.dispatchEvent(new MouseEvent(event, mouseEventInit));
    const rect = element.getBoundingClientRect();
    x = x * rect.width + rect.left;
    y = y * rect.height + rect.top;
    function traverse(element2) {
        if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {
            const rect2 = element2.getBoundingClientRect();
            if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {
                element2.dispatchEvent(new MouseEvent(event, mouseEventInit));
                if (element2 instanceof HTMLInputElement && element2.type === "range" && (event === "mousedown" || event === "click")) {
                    const [min, max] = [
                        "min",
                        "max"
                    ].map((property)=>parseFloat(element2[property]));
                    const width = rect2.width;
                    const offsetX = x - rect2.x;
                    const proportion = offsetX / width;
                    element2.value = min + (max - min) * proportion;
                    element2.dispatchEvent(new InputEvent("input", {
                        bubbles: true
                    }));
                }
            }
            for(let i = 0; i < element2.childNodes.length; i++){
                traverse(element2.childNodes[i]);
            }
        }
    }
    traverse(element);
}
;
 //# sourceMappingURL=HTMLMesh.js.map
}}),
"[project]/node_modules/three-stdlib/interactive/InteractiveGroup.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "InteractiveGroup": (()=>InteractiveGroup)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _pointer = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
const _event = {
    type: "",
    data: _pointer
};
class InteractiveGroup extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"] {
    constructor(renderer, camera){
        super();
        const scope = this;
        const raycaster = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Raycaster"]();
        const tempMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        const element = renderer.domElement;
        function onPointerEvent(event) {
            event.stopPropagation();
            _pointer.x = event.clientX / element.clientWidth * 2 - 1;
            _pointer.y = -(event.clientY / element.clientHeight) * 2 + 1;
            raycaster.setFromCamera(_pointer, camera);
            const intersects = raycaster.intersectObjects(scope.children, false);
            if (intersects.length > 0) {
                const intersection = intersects[0];
                const object = intersection.object;
                const uv = intersection.uv;
                _event.type = event.type;
                _event.data.set(uv.x, 1 - uv.y);
                object.dispatchEvent(_event);
            }
        }
        element.addEventListener("pointerdown", onPointerEvent);
        element.addEventListener("pointerup", onPointerEvent);
        element.addEventListener("pointermove", onPointerEvent);
        element.addEventListener("mousedown", onPointerEvent);
        element.addEventListener("mouseup", onPointerEvent);
        element.addEventListener("mousemove", onPointerEvent);
        element.addEventListener("click", onPointerEvent);
        const events = {
            move: "mousemove",
            select: "click",
            selectstart: "mousedown",
            selectend: "mouseup"
        };
        function onXRControllerEvent(event) {
            const controller = event.target;
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            const intersections = raycaster.intersectObjects(scope.children, false);
            if (intersections.length > 0) {
                const intersection = intersections[0];
                const object = intersection.object;
                const uv = intersection.uv;
                _event.type = events[event.type];
                _event.data.set(uv.x, 1 - uv.y);
                object.dispatchEvent(_event);
            }
        }
        const controller1 = renderer.xr.getController(0);
        controller1.addEventListener("move", onXRControllerEvent);
        controller1.addEventListener("select", onXRControllerEvent);
        controller1.addEventListener("selectstart", onXRControllerEvent);
        controller1.addEventListener("selectend", onXRControllerEvent);
        const controller2 = renderer.xr.getController(1);
        controller2.addEventListener("move", onXRControllerEvent);
        controller2.addEventListener("select", onXRControllerEvent);
        controller2.addEventListener("selectstart", onXRControllerEvent);
        controller2.addEventListener("selectend", onXRControllerEvent);
    }
}
;
 //# sourceMappingURL=InteractiveGroup.js.map
}}),
"[project]/node_modules/three-stdlib/interactive/SelectionHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SelectionHelper": (()=>SelectionHelper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class SelectionHelper {
    constructor(selectionBox, renderer, cssClassName){
        this.element = document.createElement("div");
        this.element.classList.add(cssClassName);
        this.element.style.pointerEvents = "none";
        this.renderer = renderer;
        this.startPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this.pointTopLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this.pointBottomRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this.isDown = false;
        this.renderer.domElement.addEventListener("pointerdown", (event)=>{
            this.isDown = true;
            this.onSelectStart(event);
        });
        this.renderer.domElement.addEventListener("pointermove", (event)=>{
            if (this.isDown) {
                this.onSelectMove(event);
            }
        });
        this.renderer.domElement.addEventListener("pointerup", (event)=>{
            this.isDown = false;
            this.onSelectOver(event);
        });
    }
    onSelectStart(event) {
        this.renderer.domElement.parentElement.appendChild(this.element);
        this.element.style.left = `${event.clientX}px`;
        this.element.style.top = `${event.clientY}px`;
        this.element.style.width = "0px";
        this.element.style.height = "0px";
        this.startPoint.x = event.clientX;
        this.startPoint.y = event.clientY;
    }
    onSelectMove(event) {
        this.pointBottomRight.x = Math.max(this.startPoint.x, event.clientX);
        this.pointBottomRight.y = Math.max(this.startPoint.y, event.clientY);
        this.pointTopLeft.x = Math.min(this.startPoint.x, event.clientX);
        this.pointTopLeft.y = Math.min(this.startPoint.y, event.clientY);
        this.element.style.left = `${this.pointTopLeft.x}px`;
        this.element.style.top = `${this.pointTopLeft.y}px`;
        this.element.style.width = `${this.pointBottomRight.x - this.pointTopLeft.x}px`;
        this.element.style.height = `${this.pointBottomRight.y - this.pointTopLeft.y}px`;
    }
    onSelectOver() {
        this.element.parentElement.removeChild(this.element);
    }
}
;
 //# sourceMappingURL=SelectionHelper.js.map
}}),
"[project]/node_modules/three-stdlib/interactive/SelectionBox.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "SelectionBox": (()=>SelectionBox)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const frustum = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Frustum"]();
const center = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const tmpPoint = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecNear = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecTopLeft = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecTopRight = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecDownRight = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecDownLeft = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecFarTopLeft = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecFarTopRight = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecFarDownRight = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vecFarDownLeft = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vectemp1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vectemp2 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const vectemp3 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class SelectionBox {
    constructor(camera, scene, deep){
        this.camera = camera;
        this.scene = scene;
        this.startPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.endPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.collection = [];
        this.deep = deep || Number.MAX_VALUE;
    }
    select(startPoint, endPoint) {
        this.startPoint = startPoint || this.startPoint;
        this.endPoint = endPoint || this.endPoint;
        this.collection = [];
        this.updateFrustum(this.startPoint, this.endPoint);
        this.searchChildInFrustum(frustum, this.scene);
        return this.collection;
    }
    updateFrustum(startPoint, endPoint) {
        startPoint = startPoint || this.startPoint;
        endPoint = endPoint || this.endPoint;
        if (startPoint.x === endPoint.x) {
            endPoint.x += Number.EPSILON;
        }
        if (startPoint.y === endPoint.y) {
            endPoint.y += Number.EPSILON;
        }
        this.camera.updateProjectionMatrix();
        this.camera.updateMatrixWorld();
        if (this.camera.isPerspectiveCamera) {
            tmpPoint.copy(startPoint);
            tmpPoint.x = Math.min(startPoint.x, endPoint.x);
            tmpPoint.y = Math.max(startPoint.y, endPoint.y);
            endPoint.x = Math.max(startPoint.x, endPoint.x);
            endPoint.y = Math.min(startPoint.y, endPoint.y);
            vecNear.setFromMatrixPosition(this.camera.matrixWorld);
            vecTopLeft.copy(tmpPoint);
            vecTopRight.set(endPoint.x, tmpPoint.y, 0);
            vecDownRight.copy(endPoint);
            vecDownLeft.set(tmpPoint.x, endPoint.y, 0);
            vecTopLeft.unproject(this.camera);
            vecTopRight.unproject(this.camera);
            vecDownRight.unproject(this.camera);
            vecDownLeft.unproject(this.camera);
            vectemp1.copy(vecTopLeft).sub(vecNear);
            vectemp2.copy(vecTopRight).sub(vecNear);
            vectemp3.copy(vecDownRight).sub(vecNear);
            vectemp1.normalize();
            vectemp2.normalize();
            vectemp3.normalize();
            vectemp1.multiplyScalar(this.deep);
            vectemp2.multiplyScalar(this.deep);
            vectemp3.multiplyScalar(this.deep);
            vectemp1.add(vecNear);
            vectemp2.add(vecNear);
            vectemp3.add(vecNear);
            var planes = frustum.planes;
            planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);
            planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);
            planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);
            planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);
            planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
            planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);
            planes[5].normal.multiplyScalar(-1);
        } else if (this.camera.isOrthographicCamera) {
            const left = Math.min(startPoint.x, endPoint.x);
            const top = Math.max(startPoint.y, endPoint.y);
            const right = Math.max(startPoint.x, endPoint.x);
            const down = Math.min(startPoint.y, endPoint.y);
            vecTopLeft.set(left, top, -1);
            vecTopRight.set(right, top, -1);
            vecDownRight.set(right, down, -1);
            vecDownLeft.set(left, down, -1);
            vecFarTopLeft.set(left, top, 1);
            vecFarTopRight.set(right, top, 1);
            vecFarDownRight.set(right, down, 1);
            vecFarDownLeft.set(left, down, 1);
            vecTopLeft.unproject(this.camera);
            vecTopRight.unproject(this.camera);
            vecDownRight.unproject(this.camera);
            vecDownLeft.unproject(this.camera);
            vecFarTopLeft.unproject(this.camera);
            vecFarTopRight.unproject(this.camera);
            vecFarDownRight.unproject(this.camera);
            vecFarDownLeft.unproject(this.camera);
            var planes = frustum.planes;
            planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);
            planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);
            planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);
            planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);
            planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
            planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);
            planes[5].normal.multiplyScalar(-1);
        } else {
            console.error("THREE.SelectionBox: Unsupported camera type.");
        }
    }
    searchChildInFrustum(frustum2, object) {
        if (object.isMesh || object.isLine || object.isPoints) {
            if (object.material !== void 0) {
                if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();
                center.copy(object.geometry.boundingSphere.center);
                center.applyMatrix4(object.matrixWorld);
                if (frustum2.containsPoint(center)) {
                    this.collection.push(object);
                }
            }
        }
        if (object.children.length > 0) {
            for(let x = 0; x < object.children.length; x++){
                this.searchChildInFrustum(frustum2, object.children[x]);
            }
        }
    }
}
;
 //# sourceMappingURL=SelectionBox.js.map
}}),
"[project]/node_modules/three-stdlib/physics/AmmoPhysics.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AmmoPhysics": (()=>AmmoPhysics)
});
async function AmmoPhysics() {
    if ("Ammo" in window === false) {
        console.error("AmmoPhysics: Couldn't find Ammo.js");
        return;
    }
    const AmmoLib = await Ammo();
    const frameRate = 60;
    const collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();
    const dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);
    const broadphase = new AmmoLib.btDbvtBroadphase();
    const solver = new AmmoLib.btSequentialImpulseConstraintSolver();
    const world = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
    world.setGravity(new AmmoLib.btVector3(0, -9.8, 0));
    const worldTransform = new AmmoLib.btTransform();
    function getShape(geometry) {
        const parameters = geometry.parameters;
        if (geometry.type === "BoxGeometry") {
            const sx = parameters.width !== void 0 ? parameters.width / 2 : 0.5;
            const sy = parameters.height !== void 0 ? parameters.height / 2 : 0.5;
            const sz = parameters.depth !== void 0 ? parameters.depth / 2 : 0.5;
            const shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz));
            shape.setMargin(0.05);
            return shape;
        } else if (geometry.type === "SphereGeometry" || geometry.type === "IcosahedronGeometry") {
            const radius = parameters.radius !== void 0 ? parameters.radius : 1;
            const shape = new AmmoLib.btSphereShape(radius);
            shape.setMargin(0.05);
            return shape;
        }
        return null;
    }
    const meshes = [];
    const meshMap = /* @__PURE__ */ new WeakMap();
    function addMesh(mesh, mass = 0) {
        const shape = getShape(mesh.geometry);
        if (shape !== null) {
            if (mesh.isInstancedMesh) {
                handleInstancedMesh(mesh, mass, shape);
            } else if (mesh.isMesh) {
                handleMesh(mesh, mass, shape);
            }
        }
    }
    function handleMesh(mesh, mass, shape) {
        const position = mesh.position;
        const quaternion = mesh.quaternion;
        const transform = new AmmoLib.btTransform();
        transform.setIdentity();
        transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));
        transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
        const motionState = new AmmoLib.btDefaultMotionState(transform);
        const localInertia = new AmmoLib.btVector3(0, 0, 0);
        shape.calculateLocalInertia(mass, localInertia);
        const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
        const body = new AmmoLib.btRigidBody(rbInfo);
        world.addRigidBody(body);
        if (mass > 0) {
            meshes.push(mesh);
            meshMap.set(mesh, body);
        }
    }
    function handleInstancedMesh(mesh, mass, shape) {
        const array = mesh.instanceMatrix.array;
        const bodies = [];
        for(let i = 0; i < mesh.count; i++){
            const index = i * 16;
            const transform = new AmmoLib.btTransform();
            transform.setFromOpenGLMatrix(array.slice(index, index + 16));
            const motionState = new AmmoLib.btDefaultMotionState(transform);
            const localInertia = new AmmoLib.btVector3(0, 0, 0);
            shape.calculateLocalInertia(mass, localInertia);
            const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
            const body = new AmmoLib.btRigidBody(rbInfo);
            world.addRigidBody(body);
            bodies.push(body);
        }
        if (mass > 0) {
            mesh.instanceMatrix.setUsage(35048);
            meshes.push(mesh);
            meshMap.set(mesh, bodies);
        }
    }
    function setMeshPosition(mesh, position, index = 0) {
        if (mesh.isInstancedMesh) {
            const bodies = meshMap.get(mesh);
            const body = bodies[index];
            body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));
            body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));
            worldTransform.setIdentity();
            worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));
            body.setWorldTransform(worldTransform);
        } else if (mesh.isMesh) {
            const body = meshMap.get(mesh);
            body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));
            body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));
            worldTransform.setIdentity();
            worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));
            body.setWorldTransform(worldTransform);
        }
    }
    let lastTime = 0;
    function step() {
        const time = performance.now();
        if (lastTime > 0) {
            const delta = (time - lastTime) / 1e3;
            world.stepSimulation(delta, 10);
        }
        lastTime = time;
        for(let i = 0, l = meshes.length; i < l; i++){
            const mesh = meshes[i];
            if (mesh.isInstancedMesh) {
                const array = mesh.instanceMatrix.array;
                const bodies = meshMap.get(mesh);
                for(let j = 0; j < bodies.length; j++){
                    const body = bodies[j];
                    const motionState = body.getMotionState();
                    motionState.getWorldTransform(worldTransform);
                    const position = worldTransform.getOrigin();
                    const quaternion = worldTransform.getRotation();
                    compose(position, quaternion, array, j * 16);
                }
                mesh.instanceMatrix.needsUpdate = true;
            } else if (mesh.isMesh) {
                const body = meshMap.get(mesh);
                const motionState = body.getMotionState();
                motionState.getWorldTransform(worldTransform);
                const position = worldTransform.getOrigin();
                const quaternion = worldTransform.getRotation();
                mesh.position.set(position.x(), position.y(), position.z());
                mesh.quaternion.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w());
            }
        }
    }
    setInterval(step, 1e3 / frameRate);
    return {
        addMesh,
        setMeshPosition
    };
}
function compose(position, quaternion, array, index) {
    const x = quaternion.x(), y = quaternion.y(), z = quaternion.z(), w = quaternion.w();
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    array[index + 0] = 1 - (yy + zz);
    array[index + 1] = xy + wz;
    array[index + 2] = xz - wy;
    array[index + 3] = 0;
    array[index + 4] = xy - wz;
    array[index + 5] = 1 - (xx + zz);
    array[index + 6] = yz + wx;
    array[index + 7] = 0;
    array[index + 8] = xz + wy;
    array[index + 9] = yz - wx;
    array[index + 10] = 1 - (xx + yy);
    array[index + 11] = 0;
    array[index + 12] = position.x();
    array[index + 13] = position.y();
    array[index + 14] = position.z();
    array[index + 15] = 1;
}
;
 //# sourceMappingURL=AmmoPhysics.js.map
}}),
"[project]/node_modules/three-stdlib/effects/ParallaxBarrierEffect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ParallaxBarrierEffect": (()=>ParallaxBarrierEffect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class ParallaxBarrierEffect {
    constructor(renderer){
        const _camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-1, 1, 1, -1, 0, 1);
        const _scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        const _stereo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StereoCamera"]();
        const _params = {
            minFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"],
            magFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"],
            format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"]
        };
        const _renderTargetL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](512, 512, _params);
        const _renderTargetR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](512, 512, _params);
        const _material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            uniforms: {
                mapLeft: {
                    value: _renderTargetL.texture
                },
                mapRight: {
                    value: _renderTargetR.texture
                }
            },
            vertexShader: [
                "varying vec2 vUv;",
                "void main() {",
                "	vUv = vec2( uv.x, uv.y );",
                "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                "}"
            ].join("\n"),
            fragmentShader: [
                "uniform sampler2D mapLeft;",
                "uniform sampler2D mapRight;",
                "varying vec2 vUv;",
                "void main() {",
                "	vec2 uv = vUv;",
                "	if ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {",
                "		gl_FragColor = texture2D( mapLeft, uv );",
                "	} else {",
                "		gl_FragColor = texture2D( mapRight, uv );",
                "	}",
                "	#include <tonemapping_fragment>",
                `	#include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>`,
                "}"
            ].join("\n")
        });
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](2, 2), _material);
        _scene.add(mesh);
        this.setSize = function(width, height) {
            renderer.setSize(width, height);
            const pixelRatio = renderer.getPixelRatio();
            _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);
            _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);
        };
        this.render = function(scene, camera) {
            if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
            _stereo.update(camera);
            renderer.setRenderTarget(_renderTargetL);
            renderer.clear();
            renderer.render(scene, _stereo.cameraL);
            renderer.setRenderTarget(_renderTargetR);
            renderer.clear();
            renderer.render(scene, _stereo.cameraR);
            renderer.setRenderTarget(null);
            renderer.render(_scene, _camera);
        };
    }
}
;
 //# sourceMappingURL=ParallaxBarrierEffect.js.map
}}),
"[project]/node_modules/three-stdlib/effects/PeppersGhostEffect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PeppersGhostEffect": (()=>PeppersGhostEffect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class PeppersGhostEffect {
    constructor(renderer){
        const scope = this;
        scope.cameraDistance = 15;
        scope.reflectFromAbove = false;
        let _halfWidth, _width, _height;
        const _cameraF = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
        const _cameraB = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
        const _cameraL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
        const _cameraR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
        const _position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const _quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        const _scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        renderer.autoClear = false;
        this.setSize = function(width, height) {
            _halfWidth = width / 2;
            if (width < height) {
                _width = width / 3;
                _height = width / 3;
            } else {
                _width = height / 3;
                _height = height / 3;
            }
            renderer.setSize(width, height);
        };
        this.render = function(scene, camera) {
            if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
            camera.matrixWorld.decompose(_position, _quaternion, _scale);
            _cameraF.position.copy(_position);
            _cameraF.quaternion.copy(_quaternion);
            _cameraF.translateZ(scope.cameraDistance);
            _cameraF.lookAt(scene.position);
            _cameraB.position.copy(_position);
            _cameraB.quaternion.copy(_quaternion);
            _cameraB.translateZ(-scope.cameraDistance);
            _cameraB.lookAt(scene.position);
            _cameraB.rotation.z += 180 * (Math.PI / 180);
            _cameraL.position.copy(_position);
            _cameraL.quaternion.copy(_quaternion);
            _cameraL.translateX(-scope.cameraDistance);
            _cameraL.lookAt(scene.position);
            _cameraL.rotation.x += 90 * (Math.PI / 180);
            _cameraR.position.copy(_position);
            _cameraR.quaternion.copy(_quaternion);
            _cameraR.translateX(scope.cameraDistance);
            _cameraR.lookAt(scene.position);
            _cameraR.rotation.x += 90 * (Math.PI / 180);
            renderer.clear();
            renderer.setScissorTest(true);
            renderer.setScissor(_halfWidth - _width / 2, _height * 2, _width, _height);
            renderer.setViewport(_halfWidth - _width / 2, _height * 2, _width, _height);
            if (scope.reflectFromAbove) {
                renderer.render(scene, _cameraB);
            } else {
                renderer.render(scene, _cameraF);
            }
            renderer.setScissor(_halfWidth - _width / 2, 0, _width, _height);
            renderer.setViewport(_halfWidth - _width / 2, 0, _width, _height);
            if (scope.reflectFromAbove) {
                renderer.render(scene, _cameraF);
            } else {
                renderer.render(scene, _cameraB);
            }
            renderer.setScissor(_halfWidth - _width / 2 - _width, _height, _width, _height);
            renderer.setViewport(_halfWidth - _width / 2 - _width, _height, _width, _height);
            if (scope.reflectFromAbove) {
                renderer.render(scene, _cameraR);
            } else {
                renderer.render(scene, _cameraL);
            }
            renderer.setScissor(_halfWidth + _width / 2, _height, _width, _height);
            renderer.setViewport(_halfWidth + _width / 2, _height, _width, _height);
            if (scope.reflectFromAbove) {
                renderer.render(scene, _cameraL);
            } else {
                renderer.render(scene, _cameraR);
            }
            renderer.setScissorTest(false);
        };
    }
}
;
 //# sourceMappingURL=PeppersGhostEffect.js.map
}}),
"[project]/node_modules/three-stdlib/effects/OutlineEffect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "OutlineEffect": (()=>OutlineEffect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
;
class OutlineEffect {
    constructor(renderer, parameters = {}){
        this.enabled = true;
        const defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;
        const defaultColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(parameters.defaultColor !== void 0 ? parameters.defaultColor : [
            0,
            0,
            0
        ]);
        const defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;
        const defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;
        const cache = {};
        const removeThresholdCount = 60;
        const originalMaterials = {};
        const originalOnBeforeRenders = {};
        const uniformsOutline = {
            outlineThickness: {
                value: defaultThickness
            },
            outlineColor: {
                value: defaultColor
            },
            outlineAlpha: {
                value: defaultAlpha
            }
        };
        const vertexShader = [
            "#include <common>",
            "#include <uv_pars_vertex>",
            "#include <displacementmap_pars_vertex>",
            "#include <fog_pars_vertex>",
            "#include <morphtarget_pars_vertex>",
            "#include <skinning_pars_vertex>",
            "#include <logdepthbuf_pars_vertex>",
            "#include <clipping_planes_pars_vertex>",
            "uniform float outlineThickness;",
            "vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {",
            "	float thickness = outlineThickness;",
            "	const float ratio = 1.0;",
            // TODO: support outline thickness ratio for each vertex
            "	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );",
            // NOTE: subtract pos2 from pos because BackSide objectNormal is negative
            "	vec4 norm = normalize( pos - pos2 );",
            "	return pos + norm * thickness * pos.w * ratio;",
            "}",
            "void main() {",
            "	#include <uv_vertex>",
            "	#include <beginnormal_vertex>",
            "	#include <morphnormal_vertex>",
            "	#include <skinbase_vertex>",
            "	#include <skinnormal_vertex>",
            "	#include <begin_vertex>",
            "	#include <morphtarget_vertex>",
            "	#include <skinning_vertex>",
            "	#include <displacementmap_vertex>",
            "	#include <project_vertex>",
            "	vec3 outlineNormal = - objectNormal;",
            // the outline material is always rendered with BackSide
            "	gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );",
            "	#include <logdepthbuf_vertex>",
            "	#include <clipping_planes_vertex>",
            "	#include <fog_vertex>",
            "}"
        ].join("\n");
        const fragmentShader = [
            "#include <common>",
            "#include <fog_pars_fragment>",
            "#include <logdepthbuf_pars_fragment>",
            "#include <clipping_planes_pars_fragment>",
            "uniform vec3 outlineColor;",
            "uniform float outlineAlpha;",
            "void main() {",
            "	#include <clipping_planes_fragment>",
            "	#include <logdepthbuf_fragment>",
            "	gl_FragColor = vec4( outlineColor, outlineAlpha );",
            "	#include <tonemapping_fragment>",
            `	#include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>`,
            "	#include <fog_fragment>",
            "	#include <premultiplied_alpha_fragment>",
            "}"
        ].join("\n");
        function createMaterial() {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
                type: "OutlineEffect",
                uniforms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].merge([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UniformsLib"]["fog"],
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UniformsLib"]["displacementmap"],
                    uniformsOutline
                ]),
                vertexShader,
                fragmentShader,
                side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"]
            });
        }
        function getOutlineMaterialFromCache(originalMaterial) {
            let data = cache[originalMaterial.uuid];
            if (data === void 0) {
                data = {
                    material: createMaterial(),
                    used: true,
                    keepAlive: defaultKeepAlive,
                    count: 0
                };
                cache[originalMaterial.uuid] = data;
            }
            data.used = true;
            return data.material;
        }
        function getOutlineMaterial(originalMaterial) {
            const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);
            originalMaterials[outlineMaterial.uuid] = originalMaterial;
            updateOutlineMaterial(outlineMaterial, originalMaterial);
            return outlineMaterial;
        }
        function isCompatible(object) {
            const geometry = object.geometry;
            const hasNormals = geometry !== void 0 && geometry.attributes.normal !== void 0;
            return object.isMesh === true && object.material !== void 0 && hasNormals === true;
        }
        function setOutlineMaterial(object) {
            if (isCompatible(object) === false) return;
            if (Array.isArray(object.material)) {
                for(let i = 0, il = object.material.length; i < il; i++){
                    object.material[i] = getOutlineMaterial(object.material[i]);
                }
            } else {
                object.material = getOutlineMaterial(object.material);
            }
            originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
            object.onBeforeRender = onBeforeRender;
        }
        function restoreOriginalMaterial(object) {
            if (isCompatible(object) === false) return;
            if (Array.isArray(object.material)) {
                for(let i = 0, il = object.material.length; i < il; i++){
                    object.material[i] = originalMaterials[object.material[i].uuid];
                }
            } else {
                object.material = originalMaterials[object.material.uuid];
            }
            object.onBeforeRender = originalOnBeforeRenders[object.uuid];
        }
        function onBeforeRender(renderer2, scene, camera, geometry, material) {
            const originalMaterial = originalMaterials[material.uuid];
            if (originalMaterial === void 0) return;
            updateUniforms(material, originalMaterial);
        }
        function updateUniforms(material, originalMaterial) {
            const outlineParameters = originalMaterial.userData.outlineParameters;
            material.uniforms.outlineAlpha.value = originalMaterial.opacity;
            if (outlineParameters !== void 0) {
                if (outlineParameters.thickness !== void 0) material.uniforms.outlineThickness.value = outlineParameters.thickness;
                if (outlineParameters.color !== void 0) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);
                if (outlineParameters.alpha !== void 0) material.uniforms.outlineAlpha.value = outlineParameters.alpha;
            }
            if (originalMaterial.displacementMap) {
                material.uniforms.displacementMap.value = originalMaterial.displacementMap;
                material.uniforms.displacementScale.value = originalMaterial.displacementScale;
                material.uniforms.displacementBias.value = originalMaterial.displacementBias;
            }
        }
        function updateOutlineMaterial(material, originalMaterial) {
            if (material.name === "invisible") return;
            const outlineParameters = originalMaterial.userData.outlineParameters;
            material.fog = originalMaterial.fog;
            material.toneMapped = originalMaterial.toneMapped;
            material.premultipliedAlpha = originalMaterial.premultipliedAlpha;
            material.displacementMap = originalMaterial.displacementMap;
            if (outlineParameters !== void 0) {
                if (originalMaterial.visible === false) {
                    material.visible = false;
                } else {
                    material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;
                }
                material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;
                if (outlineParameters.keepAlive !== void 0) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
            } else {
                material.transparent = originalMaterial.transparent;
                material.visible = originalMaterial.visible;
            }
            if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;
            if (originalMaterial.clippingPlanes) {
                material.clipping = true;
                material.clippingPlanes = originalMaterial.clippingPlanes;
                material.clipIntersection = originalMaterial.clipIntersection;
                material.clipShadows = originalMaterial.clipShadows;
            }
            material.version = originalMaterial.version;
        }
        function cleanupCache() {
            let keys;
            keys = Object.keys(originalMaterials);
            for(let i = 0, il = keys.length; i < il; i++){
                originalMaterials[keys[i]] = void 0;
            }
            keys = Object.keys(originalOnBeforeRenders);
            for(let i = 0, il = keys.length; i < il; i++){
                originalOnBeforeRenders[keys[i]] = void 0;
            }
            keys = Object.keys(cache);
            for(let i = 0, il = keys.length; i < il; i++){
                const key = keys[i];
                if (cache[key].used === false) {
                    cache[key].count++;
                    if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {
                        delete cache[key];
                    }
                } else {
                    cache[key].used = false;
                    cache[key].count = 0;
                }
            }
        }
        this.render = function(scene, camera) {
            if (this.enabled === false) {
                renderer.render(scene, camera);
                return;
            }
            const currentAutoClear = renderer.autoClear;
            renderer.autoClear = this.autoClear;
            renderer.render(scene, camera);
            renderer.autoClear = currentAutoClear;
            this.renderOutline(scene, camera);
        };
        this.renderOutline = function(scene, camera) {
            const currentAutoClear = renderer.autoClear;
            const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;
            const currentSceneBackground = scene.background;
            const currentShadowMapEnabled = renderer.shadowMap.enabled;
            scene.matrixWorldAutoUpdate = false;
            scene.background = null;
            renderer.autoClear = false;
            renderer.shadowMap.enabled = false;
            scene.traverse(setOutlineMaterial);
            renderer.render(scene, camera);
            scene.traverse(restoreOriginalMaterial);
            cleanupCache();
            scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;
            scene.background = currentSceneBackground;
            renderer.autoClear = currentAutoClear;
            renderer.shadowMap.enabled = currentShadowMapEnabled;
        };
        this.autoClear = renderer.autoClear;
        this.domElement = renderer.domElement;
        this.shadowMap = renderer.shadowMap;
        this.clear = function(color, depth, stencil) {
            renderer.clear(color, depth, stencil);
        };
        this.getPixelRatio = function() {
            return renderer.getPixelRatio();
        };
        this.setPixelRatio = function(value) {
            renderer.setPixelRatio(value);
        };
        this.getSize = function(target) {
            return renderer.getSize(target);
        };
        this.setSize = function(width, height, updateStyle) {
            renderer.setSize(width, height, updateStyle);
        };
        this.setViewport = function(x, y, width, height) {
            renderer.setViewport(x, y, width, height);
        };
        this.setScissor = function(x, y, width, height) {
            renderer.setScissor(x, y, width, height);
        };
        this.setScissorTest = function(boolean) {
            renderer.setScissorTest(boolean);
        };
        this.setRenderTarget = function(renderTarget) {
            renderer.setRenderTarget(renderTarget);
        };
    }
}
;
 //# sourceMappingURL=OutlineEffect.js.map
}}),
"[project]/node_modules/three-stdlib/effects/AnaglyphEffect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AnaglyphEffect": (()=>AnaglyphEffect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class AnaglyphEffect {
    constructor(renderer, width = 512, height = 512){
        this.colorMatrixLeft = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]().fromArray([
            0.4561,
            -0.0400822,
            -0.0152161,
            0.500484,
            -0.0378246,
            -0.0205971,
            0.176381,
            -0.0157589,
            -546856e-8
        ]);
        this.colorMatrixRight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]().fromArray([
            -0.0434706,
            0.378476,
            -0.0721527,
            -0.0879388,
            0.73364,
            -0.112961,
            -155529e-8,
            -0.0184503,
            1.2264
        ]);
        const _camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-1, 1, 1, -1, 0, 1);
        const _scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        const _stereo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StereoCamera"]();
        const _params = {
            minFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"],
            magFilter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"],
            format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"]
        };
        const _renderTargetL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](width, height, _params);
        const _renderTargetR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](width, height, _params);
        const _material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            uniforms: {
                mapLeft: {
                    value: _renderTargetL.texture
                },
                mapRight: {
                    value: _renderTargetR.texture
                },
                colorMatrixLeft: {
                    value: this.colorMatrixLeft
                },
                colorMatrixRight: {
                    value: this.colorMatrixRight
                }
            },
            vertexShader: [
                "varying vec2 vUv;",
                "void main() {",
                "	vUv = vec2( uv.x, uv.y );",
                "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                "}"
            ].join("\n"),
            fragmentShader: [
                "uniform sampler2D mapLeft;",
                "uniform sampler2D mapRight;",
                "varying vec2 vUv;",
                "uniform mat3 colorMatrixLeft;",
                "uniform mat3 colorMatrixRight;",
                "void main() {",
                "	vec2 uv = vUv;",
                "	vec4 colorL = texture2D( mapLeft, uv );",
                "	vec4 colorR = texture2D( mapRight, uv );",
                "	vec3 color = clamp(",
                "			colorMatrixLeft * colorL.rgb +",
                "			colorMatrixRight * colorR.rgb, 0., 1. );",
                "	gl_FragColor = vec4(",
                "			color.r, color.g, color.b,",
                "			max( colorL.a, colorR.a ) );",
                "	#include <tonemapping_fragment>",
                `	#include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>`,
                "}"
            ].join("\n")
        });
        const _mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](2, 2), _material);
        _scene.add(_mesh);
        this.setSize = function(width2, height2) {
            renderer.setSize(width2, height2);
            const pixelRatio = renderer.getPixelRatio();
            _renderTargetL.setSize(width2 * pixelRatio, height2 * pixelRatio);
            _renderTargetR.setSize(width2 * pixelRatio, height2 * pixelRatio);
        };
        this.render = function(scene, camera) {
            const currentRenderTarget = renderer.getRenderTarget();
            if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
            _stereo.update(camera);
            renderer.setRenderTarget(_renderTargetL);
            renderer.clear();
            renderer.render(scene, _stereo.cameraL);
            renderer.setRenderTarget(_renderTargetR);
            renderer.clear();
            renderer.render(scene, _stereo.cameraR);
            renderer.setRenderTarget(null);
            renderer.render(_scene, _camera);
            renderer.setRenderTarget(currentRenderTarget);
        };
        this.dispose = function() {
            _renderTargetL.dispose();
            _renderTargetR.dispose();
            _mesh.geometry.dispose();
            _mesh.material.dispose();
        };
    }
}
;
 //# sourceMappingURL=AnaglyphEffect.js.map
}}),
"[project]/node_modules/three-stdlib/effects/AsciiEffect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AsciiEffect": (()=>AsciiEffect)
});
class AsciiEffect {
    constructor(renderer, charSet = " .:-=+*#%@", options = {}){
        const fResolution = options["resolution"] || 0.15;
        const iScale = options["scale"] || 1;
        const bColor = options["color"] || false;
        const bAlpha = options["alpha"] || false;
        const bBlock = options["block"] || false;
        const bInvert = options["invert"] || false;
        const strResolution = options["strResolution"] || "low";
        let width, height;
        const domElement = document.createElement("div");
        domElement.style.cursor = "default";
        const oAscii = document.createElement("table");
        domElement.appendChild(oAscii);
        let iWidth, iHeight;
        let oImg;
        this.setSize = function(w, h) {
            width = w;
            height = h;
            renderer.setSize(w, h);
            initAsciiSize();
        };
        this.render = function(scene, camera) {
            renderer.render(scene, camera);
            asciifyImage(oAscii);
        };
        this.domElement = domElement;
        function initAsciiSize() {
            iWidth = Math.floor(width * fResolution);
            iHeight = Math.floor(height * fResolution);
            oCanvas.width = iWidth;
            oCanvas.height = iHeight;
            oImg = renderer.domElement;
            if (oImg.style.backgroundColor) {
                oAscii.rows[0].cells[0].style.backgroundColor = oImg.style.backgroundColor;
                oAscii.rows[0].cells[0].style.color = oImg.style.color;
            }
            oAscii.cellSpacing = 0;
            oAscii.cellPadding = 0;
            const oStyle = oAscii.style;
            oStyle.whiteSpace = "pre";
            oStyle.margin = "0px";
            oStyle.padding = "0px";
            oStyle.letterSpacing = fLetterSpacing + "px";
            oStyle.fontFamily = strFont;
            oStyle.fontSize = fFontSize + "px";
            oStyle.lineHeight = fLineHeight + "px";
            oStyle.textAlign = "left";
            oStyle.textDecoration = "none";
        }
        const aDefaultCharList = " .,:;i1tfLCG08@".split("");
        const aDefaultColorCharList = " CGO08@".split("");
        const strFont = "courier new, monospace";
        const oCanvasImg = renderer.domElement;
        const oCanvas = document.createElement("canvas");
        if (!oCanvas.getContext) {
            return;
        }
        const oCtx = oCanvas.getContext("2d");
        if (!oCtx.getImageData) {
            return;
        }
        let aCharList = bColor ? aDefaultColorCharList : aDefaultCharList;
        if (charSet) aCharList = charSet;
        const fFontSize = 2 / fResolution * iScale;
        const fLineHeight = 2 / fResolution * iScale;
        let fLetterSpacing = 0;
        if (strResolution == "low") {
            switch(iScale){
                case 1:
                    fLetterSpacing = -1;
                    break;
                case 2:
                case 3:
                    fLetterSpacing = -2.1;
                    break;
                case 4:
                    fLetterSpacing = -3.1;
                    break;
                case 5:
                    fLetterSpacing = -4.15;
                    break;
            }
        }
        if (strResolution == "medium") {
            switch(iScale){
                case 1:
                    fLetterSpacing = 0;
                    break;
                case 2:
                    fLetterSpacing = -1;
                    break;
                case 3:
                    fLetterSpacing = -1.04;
                    break;
                case 4:
                case 5:
                    fLetterSpacing = -2.1;
                    break;
            }
        }
        if (strResolution == "high") {
            switch(iScale){
                case 1:
                case 2:
                    fLetterSpacing = 0;
                    break;
                case 3:
                case 4:
                case 5:
                    fLetterSpacing = -1;
                    break;
            }
        }
        function asciifyImage(oAscii2) {
            oCtx.clearRect(0, 0, iWidth, iHeight);
            oCtx.drawImage(oCanvasImg, 0, 0, iWidth, iHeight);
            const oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;
            let strChars = "";
            for(let y = 0; y < iHeight; y += 2){
                for(let x = 0; x < iWidth; x++){
                    const iOffset = (y * iWidth + x) * 4;
                    const iRed = oImgData[iOffset];
                    const iGreen = oImgData[iOffset + 1];
                    const iBlue = oImgData[iOffset + 2];
                    const iAlpha = oImgData[iOffset + 3];
                    let iCharIdx;
                    let fBrightness;
                    fBrightness = (0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue) / 255;
                    if (iAlpha == 0) {
                        fBrightness = 1;
                    }
                    iCharIdx = Math.floor((1 - fBrightness) * (aCharList.length - 1));
                    if (bInvert) {
                        iCharIdx = aCharList.length - iCharIdx - 1;
                    }
                    let strThisChar = aCharList[iCharIdx];
                    if (strThisChar === void 0 || strThisChar == " ") strThisChar = "&nbsp;";
                    if (bColor) {
                        strChars += "<span style='color:rgb(" + iRed + "," + iGreen + "," + iBlue + ");" + (bBlock ? "background-color:rgb(" + iRed + "," + iGreen + "," + iBlue + ");" : "") + (bAlpha ? "opacity:" + iAlpha / 255 + ";" : "") + "'>" + strThisChar + "</span>";
                    } else {
                        strChars += strThisChar;
                    }
                }
                strChars += "<br/>";
            }
            oAscii2.innerHTML = `<tr><td style="display:block;width:${width}px;height:${height}px;overflow:hidden">${strChars}</td></tr>`;
        }
    }
}
;
 //# sourceMappingURL=AsciiEffect.js.map
}}),
"[project]/node_modules/three-stdlib/curves/NURBSUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "calcBSplineDerivatives": (()=>calcBSplineDerivatives),
    "calcBSplinePoint": (()=>calcBSplinePoint),
    "calcBasisFunctionDerivatives": (()=>calcBasisFunctionDerivatives),
    "calcBasisFunctions": (()=>calcBasisFunctions),
    "calcKoverI": (()=>calcKoverI),
    "calcNURBSDerivatives": (()=>calcNURBSDerivatives),
    "calcRationalCurveDerivatives": (()=>calcRationalCurveDerivatives),
    "calcSurfacePoint": (()=>calcSurfacePoint),
    "findSpan": (()=>findSpan)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
function findSpan(p, u, U) {
    const n = U.length - p - 1;
    if (u >= U[n]) {
        return n - 1;
    }
    if (u <= U[p]) {
        return p;
    }
    let low = p;
    let high = n;
    let mid = Math.floor((low + high) / 2);
    while(u < U[mid] || u >= U[mid + 1]){
        if (u < U[mid]) {
            high = mid;
        } else {
            low = mid;
        }
        mid = Math.floor((low + high) / 2);
    }
    return mid;
}
function calcBasisFunctions(span, u, p, U) {
    const N = [];
    const left = [];
    const right = [];
    N[0] = 1;
    for(let j = 1; j <= p; ++j){
        left[j] = u - U[span + 1 - j];
        right[j] = U[span + j] - u;
        let saved = 0;
        for(let r = 0; r < j; ++r){
            const rv = right[r + 1];
            const lv = left[j - r];
            const temp = N[r] / (rv + lv);
            N[r] = saved + rv * temp;
            saved = lv * temp;
        }
        N[j] = saved;
    }
    return N;
}
function calcBSplinePoint(p, U, P, u) {
    const span = findSpan(p, u, U);
    const N = calcBasisFunctions(span, u, p, U);
    const C = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](0, 0, 0, 0);
    for(let j = 0; j <= p; ++j){
        const point = P[span - p + j];
        const Nj = N[j];
        const wNj = point.w * Nj;
        C.x += point.x * wNj;
        C.y += point.y * wNj;
        C.z += point.z * wNj;
        C.w += point.w * Nj;
    }
    return C;
}
function calcBasisFunctionDerivatives(span, u, p, n, U) {
    const zeroArr = [];
    for(let i = 0; i <= p; ++i)zeroArr[i] = 0;
    const ders = [];
    for(let i = 0; i <= n; ++i)ders[i] = zeroArr.slice(0);
    const ndu = [];
    for(let i = 0; i <= p; ++i)ndu[i] = zeroArr.slice(0);
    ndu[0][0] = 1;
    const left = zeroArr.slice(0);
    const right = zeroArr.slice(0);
    for(let j = 1; j <= p; ++j){
        left[j] = u - U[span + 1 - j];
        right[j] = U[span + j] - u;
        let saved = 0;
        for(let r2 = 0; r2 < j; ++r2){
            const rv = right[r2 + 1];
            const lv = left[j - r2];
            ndu[j][r2] = rv + lv;
            const temp = ndu[r2][j - 1] / ndu[j][r2];
            ndu[r2][j] = saved + rv * temp;
            saved = lv * temp;
        }
        ndu[j][j] = saved;
    }
    for(let j = 0; j <= p; ++j){
        ders[0][j] = ndu[j][p];
    }
    for(let r2 = 0; r2 <= p; ++r2){
        let s1 = 0;
        let s2 = 1;
        const a = [];
        for(let i = 0; i <= p; ++i){
            a[i] = zeroArr.slice(0);
        }
        a[0][0] = 1;
        for(let k = 1; k <= n; ++k){
            let d = 0;
            const rk = r2 - k;
            const pk = p - k;
            if (r2 >= k) {
                a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
                d = a[s2][0] * ndu[rk][pk];
            }
            const j1 = rk >= -1 ? 1 : -rk;
            const j2 = r2 - 1 <= pk ? k - 1 : p - r2;
            for(let j3 = j1; j3 <= j2; ++j3){
                a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
                d += a[s2][j3] * ndu[rk + j3][pk];
            }
            if (r2 <= pk) {
                a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];
                d += a[s2][k] * ndu[r2][pk];
            }
            ders[k][r2] = d;
            const j = s1;
            s1 = s2;
            s2 = j;
        }
    }
    let r = p;
    for(let k = 1; k <= n; ++k){
        for(let j = 0; j <= p; ++j){
            ders[k][j] *= r;
        }
        r *= p - k;
    }
    return ders;
}
function calcBSplineDerivatives(p, U, P, u, nd) {
    const du = nd < p ? nd : p;
    const CK = [];
    const span = findSpan(p, u, U);
    const nders = calcBasisFunctionDerivatives(span, u, p, du, U);
    const Pw = [];
    for(let i = 0; i < P.length; ++i){
        const point = P[i].clone();
        const w = point.w;
        point.x *= w;
        point.y *= w;
        point.z *= w;
        Pw[i] = point;
    }
    for(let k = 0; k <= du; ++k){
        const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
        for(let j = 1; j <= p; ++j){
            point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
        }
        CK[k] = point;
    }
    for(let k = du + 1; k <= nd + 1; ++k){
        CK[k] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](0, 0, 0);
    }
    return CK;
}
function calcKoverI(k, i) {
    let nom = 1;
    for(let j = 2; j <= k; ++j){
        nom *= j;
    }
    let denom = 1;
    for(let j = 2; j <= i; ++j){
        denom *= j;
    }
    for(let j = 2; j <= k - i; ++j){
        denom *= j;
    }
    return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
    const nd = Pders.length;
    const Aders = [];
    const wders = [];
    for(let i = 0; i < nd; ++i){
        const point = Pders[i];
        Aders[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](point.x, point.y, point.z);
        wders[i] = point.w;
    }
    const CK = [];
    for(let k = 0; k < nd; ++k){
        const v = Aders[k].clone();
        for(let i = 1; i <= k; ++i){
            v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));
        }
        CK[k] = v.divideScalar(wders[0]);
    }
    return CK;
}
function calcNURBSDerivatives(p, U, P, u, nd) {
    const Pders = calcBSplineDerivatives(p, U, P, u, nd);
    return calcRationalCurveDerivatives(Pders);
}
function calcSurfacePoint(p, q, U, V, P, u, v, target) {
    const uspan = findSpan(p, u, U);
    const vspan = findSpan(q, v, V);
    const Nu = calcBasisFunctions(uspan, u, p, U);
    const Nv = calcBasisFunctions(vspan, v, q, V);
    const temp = [];
    for(let l = 0; l <= q; ++l){
        temp[l] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](0, 0, 0, 0);
        for(let k = 0; k <= p; ++k){
            const point = P[uspan - p + k][vspan - q + l].clone();
            const w = point.w;
            point.x *= w;
            point.y *= w;
            point.z *= w;
            temp[l].add(point.multiplyScalar(Nu[k]));
        }
    }
    const Sw = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](0, 0, 0, 0);
    for(let l = 0; l <= q; ++l){
        Sw.add(temp[l].multiplyScalar(Nv[l]));
    }
    Sw.divideScalar(Sw.w);
    target.set(Sw.x, Sw.y, Sw.z);
}
;
 //# sourceMappingURL=NURBSUtils.js.map
}}),
"[project]/node_modules/three-stdlib/curves/NURBSCurve.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "NURBSCurve": (()=>NURBSCurve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/curves/NURBSUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class NURBSCurve extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(degree, knots, controlPoints, startKnot, endKnot){
        super();
        this.degree = degree;
        this.knots = knots;
        this.controlPoints = [];
        this.startKnot = startKnot || 0;
        this.endKnot = endKnot || this.knots.length - 1;
        for(let i = 0; i < controlPoints.length; ++i){
            const point = controlPoints[i];
            this.controlPoints[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](point.x, point.y, point.z, point.w);
        }
    }
    getPoint(t, optionalTarget) {
        const point = optionalTarget || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]);
        const hpoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcBSplinePoint"])(this.degree, this.knots, this.controlPoints, u);
        if (hpoint.w != 1) {
            hpoint.divideScalar(hpoint.w);
        }
        return point.set(hpoint.x, hpoint.y, hpoint.z);
    }
    getTangent(t, optionalTarget) {
        const tangent = optionalTarget || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
        const ders = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcNURBSDerivatives"])(this.degree, this.knots, this.controlPoints, u, 1);
        tangent.copy(ders[1]).normalize();
        return tangent;
    }
}
;
 //# sourceMappingURL=NURBSCurve.js.map
}}),
"[project]/node_modules/three-stdlib/curves/NURBSSurface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "NURBSSurface": (()=>NURBSSurface)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/curves/NURBSUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class NURBSSurface {
    constructor(degree1, degree2, knots1, knots2, controlPoints){
        this.degree1 = degree1;
        this.degree2 = degree2;
        this.knots1 = knots1;
        this.knots2 = knots2;
        this.controlPoints = [];
        const len1 = knots1.length - degree1 - 1;
        const len2 = knots2.length - degree2 - 1;
        for(let i = 0; i < len1; ++i){
            this.controlPoints[i] = [];
            for(let j = 0; j < len2; ++j){
                const point = controlPoints[i][j];
                this.controlPoints[i][j] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](point.x, point.y, point.z, point.w);
            }
        }
    }
    getPoint(t1, t2, target) {
        const u = this.knots1[0] + t1 * (this.knots1[this.knots1.length - 1] - this.knots1[0]);
        const v = this.knots2[0] + t2 * (this.knots2[this.knots2.length - 1] - this.knots2[0]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcSurfacePoint"])(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target);
    }
}
;
 //# sourceMappingURL=NURBSSurface.js.map
}}),
"[project]/node_modules/three-stdlib/curves/CurveExtras.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CinquefoilKnot": (()=>CinquefoilKnot),
    "DecoratedTorusKnot4a": (()=>DecoratedTorusKnot4a),
    "DecoratedTorusKnot4b": (()=>DecoratedTorusKnot4b),
    "DecoratedTorusKnot5a": (()=>DecoratedTorusKnot5a),
    "DecoratedTorusKnot5c": (()=>DecoratedTorusKnot5c),
    "FigureEightPolynomialKnot": (()=>FigureEightPolynomialKnot),
    "GrannyKnot": (()=>GrannyKnot),
    "HeartCurve": (()=>HeartCurve),
    "HelixCurve": (()=>HelixCurve),
    "KnotCurve": (()=>KnotCurve),
    "TorusKnot": (()=>TorusKnot),
    "TrefoilKnot": (()=>TrefoilKnot),
    "TrefoilPolynomialKnot": (()=>TrefoilPolynomialKnot),
    "VivianiCurve": (()=>VivianiCurve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class GrannyKnot extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t = 2 * Math.PI * t;
        const x = -0.22 * Math.cos(t) - 1.28 * Math.sin(t) - 0.44 * Math.cos(3 * t) - 0.78 * Math.sin(3 * t);
        const y = -0.1 * Math.cos(2 * t) - 0.27 * Math.sin(2 * t) + 0.38 * Math.cos(4 * t) + 0.46 * Math.sin(4 * t);
        const z = 0.7 * Math.cos(3 * t) - 0.4 * Math.sin(3 * t);
        return point.set(x, y, z).multiplyScalar(20);
    }
}
class HeartCurve extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 5){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t *= 2 * Math.PI;
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        const z = 0;
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class VivianiCurve extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 70){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t = t * 4 * Math.PI;
        const a = this.scale / 2;
        const x = a * (1 + Math.cos(t));
        const y = a * Math.sin(t);
        const z = 2 * a * Math.sin(t / 2);
        return point.set(x, y, z);
    }
}
class KnotCurve extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t *= 2 * Math.PI;
        const R = 10;
        const s = 50;
        const x = s * Math.sin(t);
        const y = Math.cos(t) * (R + s * Math.cos(t));
        const z = Math.sin(t) * (R + s * Math.cos(t));
        return point.set(x, y, z);
    }
}
class HelixCurve extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        const a = 30;
        const b = 150;
        const t2 = 2 * Math.PI * t * b / 30;
        const x = Math.cos(t2) * a;
        const y = Math.sin(t2) * a;
        const z = b * t;
        return point.set(x, y, z);
    }
}
class TrefoilKnot extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 10){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t *= Math.PI * 2;
        const x = (2 + Math.cos(3 * t)) * Math.cos(2 * t);
        const y = (2 + Math.cos(3 * t)) * Math.sin(2 * t);
        const z = Math.sin(3 * t);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class TorusKnot extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 10){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        const p = 3;
        const q = 4;
        t *= Math.PI * 2;
        const x = (2 + Math.cos(q * t)) * Math.cos(p * t);
        const y = (2 + Math.cos(q * t)) * Math.sin(p * t);
        const z = Math.sin(q * t);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class CinquefoilKnot extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 10){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        const p = 2;
        const q = 5;
        t *= Math.PI * 2;
        const x = (2 + Math.cos(q * t)) * Math.cos(p * t);
        const y = (2 + Math.cos(q * t)) * Math.sin(p * t);
        const z = Math.sin(q * t);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class TrefoilPolynomialKnot extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 10){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t = t * 4 - 2;
        const x = Math.pow(t, 3) - 3 * t;
        const y = Math.pow(t, 4) - 4 * t * t;
        const z = 1 / 5 * Math.pow(t, 5) - 2 * t;
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
function scaleTo(x, y, t) {
    const r = y - x;
    return t * r + x;
}
class FigureEightPolynomialKnot extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 1){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t = scaleTo(-4, 4, t);
        const x = 2 / 5 * t * (t * t - 7) * (t * t - 10);
        const y = Math.pow(t, 4) - 13 * t * t;
        const z = 1 / 10 * t * (t * t - 4) * (t * t - 9) * (t * t - 12);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class DecoratedTorusKnot4a extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 40){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        t *= Math.PI * 2;
        const x = Math.cos(2 * t) * (1 + 0.6 * (Math.cos(5 * t) + 0.75 * Math.cos(10 * t)));
        const y = Math.sin(2 * t) * (1 + 0.6 * (Math.cos(5 * t) + 0.75 * Math.cos(10 * t)));
        const z = 0.35 * Math.sin(5 * t);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class DecoratedTorusKnot4b extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 40){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        const fi = t * Math.PI * 2;
        const x = Math.cos(2 * fi) * (1 + 0.45 * Math.cos(3 * fi) + 0.4 * Math.cos(9 * fi));
        const y = Math.sin(2 * fi) * (1 + 0.45 * Math.cos(3 * fi) + 0.4 * Math.cos(9 * fi));
        const z = 0.2 * Math.sin(9 * fi);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class DecoratedTorusKnot5a extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 40){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        const fi = t * Math.PI * 2;
        const x = Math.cos(3 * fi) * (1 + 0.3 * Math.cos(5 * fi) + 0.5 * Math.cos(10 * fi));
        const y = Math.sin(3 * fi) * (1 + 0.3 * Math.cos(5 * fi) + 0.5 * Math.cos(10 * fi));
        const z = 0.2 * Math.sin(20 * fi);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
class DecoratedTorusKnot5c extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"] {
    constructor(scale = 40){
        super();
        this.scale = scale;
    }
    getPoint(t, optionalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()) {
        const point = optionalTarget;
        const fi = t * Math.PI * 2;
        const x = Math.cos(4 * fi) * (1 + 0.5 * (Math.cos(5 * fi) + 0.4 * Math.cos(20 * fi)));
        const y = Math.sin(4 * fi) * (1 + 0.5 * (Math.cos(5 * fi) + 0.4 * Math.cos(20 * fi)));
        const z = 0.35 * Math.sin(15 * fi);
        return point.set(x, y, z).multiplyScalar(this.scale);
    }
}
;
 //# sourceMappingURL=CurveExtras.js.map
}}),
"[project]/node_modules/three-stdlib/lines/LineSegmentsGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LineSegmentsGeometry": (()=>LineSegmentsGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _box = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
const _vector = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class LineSegmentsGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedBufferGeometry"] {
    constructor(){
        super();
        this.isLineSegmentsGeometry = true;
        this.type = "LineSegmentsGeometry";
        const positions = [
            -1,
            2,
            0,
            1,
            2,
            0,
            -1,
            1,
            0,
            1,
            1,
            0,
            -1,
            0,
            0,
            1,
            0,
            0,
            -1,
            -1,
            0,
            1,
            -1,
            0
        ];
        const uvs = [
            -1,
            2,
            1,
            2,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -2,
            1,
            -2
        ];
        const index = [
            0,
            2,
            1,
            2,
            3,
            1,
            2,
            4,
            3,
            4,
            5,
            3,
            4,
            6,
            5,
            6,
            7,
            5
        ];
        this.setIndex(index);
        this.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positions, 3));
        this.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uvs, 2));
    }
    applyMatrix4(matrix) {
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== void 0) {
            start.applyMatrix4(matrix);
            end.applyMatrix4(matrix);
            start.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        return this;
    }
    setPositions(array) {
        let lineSegments;
        if (array instanceof Float32Array) {
            lineSegments = array;
        } else if (Array.isArray(array)) {
            lineSegments = new Float32Array(array);
        }
        const instanceBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedInterleavedBuffer"](lineSegments, 6, 1);
        this.setAttribute("instanceStart", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](instanceBuffer, 3, 0));
        this.setAttribute("instanceEnd", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](instanceBuffer, 3, 3));
        this.computeBoundingBox();
        this.computeBoundingSphere();
        return this;
    }
    setColors(array, itemSize = 3) {
        let colors;
        if (array instanceof Float32Array) {
            colors = array;
        } else if (Array.isArray(array)) {
            colors = new Float32Array(array);
        }
        const instanceColorBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedInterleavedBuffer"](colors, itemSize * 2, 1);
        this.setAttribute("instanceColorStart", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](instanceColorBuffer, itemSize, 0));
        this.setAttribute("instanceColorEnd", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](instanceColorBuffer, itemSize, itemSize));
        return this;
    }
    fromWireframeGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
    }
    fromEdgesGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
    }
    fromMesh(mesh) {
        this.fromWireframeGeometry(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireframeGeometry"](mesh.geometry));
        return this;
    }
    fromLineSegments(lineSegments) {
        const geometry = lineSegments.geometry;
        this.setPositions(geometry.attributes.position.array);
        return this;
    }
    computeBoundingBox() {
        if (this.boundingBox === null) {
            this.boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
        }
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== void 0 && end !== void 0) {
            this.boundingBox.setFromBufferAttribute(start);
            _box.setFromBufferAttribute(end);
            this.boundingBox.union(_box);
        }
    }
    computeBoundingSphere() {
        if (this.boundingSphere === null) {
            this.boundingSphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"]();
        }
        if (this.boundingBox === null) {
            this.computeBoundingBox();
        }
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== void 0 && end !== void 0) {
            const center = this.boundingSphere.center;
            this.boundingBox.getCenter(center);
            let maxRadiusSq = 0;
            for(let i = 0, il = start.count; i < il; i++){
                _vector.fromBufferAttribute(start, i);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
                _vector.fromBufferAttribute(end, i);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
                console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
            }
        }
    }
    toJSON() {}
    applyMatrix(matrix) {
        console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
        return this.applyMatrix4(matrix);
    }
}
;
 //# sourceMappingURL=LineSegmentsGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/lines/LineGeometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LineGeometry": (()=>LineGeometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegmentsGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineSegmentsGeometry.js [app-client] (ecmascript)");
;
class LineGeometry extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegmentsGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegmentsGeometry"] {
    constructor(){
        super();
        this.isLineGeometry = true;
        this.type = "LineGeometry";
    }
    setPositions(array) {
        const length = array.length - 3;
        const points = new Float32Array(2 * length);
        for(let i = 0; i < length; i += 3){
            points[2 * i] = array[i];
            points[2 * i + 1] = array[i + 1];
            points[2 * i + 2] = array[i + 2];
            points[2 * i + 3] = array[i + 3];
            points[2 * i + 4] = array[i + 4];
            points[2 * i + 5] = array[i + 5];
        }
        super.setPositions(points);
        return this;
    }
    setColors(array, itemSize = 3) {
        const length = array.length - itemSize;
        const colors = new Float32Array(2 * length);
        if (itemSize === 3) {
            for(let i = 0; i < length; i += itemSize){
                colors[2 * i] = array[i];
                colors[2 * i + 1] = array[i + 1];
                colors[2 * i + 2] = array[i + 2];
                colors[2 * i + 3] = array[i + 3];
                colors[2 * i + 4] = array[i + 4];
                colors[2 * i + 5] = array[i + 5];
            }
        } else {
            for(let i = 0; i < length; i += itemSize){
                colors[2 * i] = array[i];
                colors[2 * i + 1] = array[i + 1];
                colors[2 * i + 2] = array[i + 2];
                colors[2 * i + 3] = array[i + 3];
                colors[2 * i + 4] = array[i + 4];
                colors[2 * i + 5] = array[i + 5];
                colors[2 * i + 6] = array[i + 6];
                colors[2 * i + 7] = array[i + 7];
            }
        }
        super.setColors(colors, itemSize);
        return this;
    }
    fromLine(line) {
        const geometry = line.geometry;
        this.setPositions(geometry.attributes.position.array);
        return this;
    }
}
;
 //# sourceMappingURL=LineGeometry.js.map
}}),
"[project]/node_modules/three-stdlib/lines/LineMaterial.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LineMaterial": (()=>LineMaterial)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
;
class LineMaterial extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"] {
    constructor(parameters){
        super({
            type: "LineMaterial",
            uniforms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].merge([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UniformsLib"].common,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UniformsLib"].fog,
                {
                    worldUnits: {
                        value: 1
                    },
                    linewidth: {
                        value: 1
                    },
                    resolution: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](1, 1)
                    },
                    dashOffset: {
                        value: 0
                    },
                    dashScale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    gapSize: {
                        value: 1
                    }
                }
            ])),
            vertexShader: /* glsl */ `
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,
            fragmentShader: /* glsl */ `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,
            clipping: true
        });
        this.isLineMaterial = true;
        this.onBeforeCompile = function() {
            if (this.transparent) {
                this.defines.USE_LINE_COLOR_ALPHA = "1";
            } else {
                delete this.defines.USE_LINE_COLOR_ALPHA;
            }
        };
        Object.defineProperties(this, {
            color: {
                enumerable: true,
                get: function() {
                    return this.uniforms.diffuse.value;
                },
                set: function(value) {
                    this.uniforms.diffuse.value = value;
                }
            },
            worldUnits: {
                enumerable: true,
                get: function() {
                    return "WORLD_UNITS" in this.defines;
                },
                set: function(value) {
                    if (value === true) {
                        this.defines.WORLD_UNITS = "";
                    } else {
                        delete this.defines.WORLD_UNITS;
                    }
                }
            },
            linewidth: {
                enumerable: true,
                get: function() {
                    return this.uniforms.linewidth.value;
                },
                set: function(value) {
                    this.uniforms.linewidth.value = value;
                }
            },
            dashed: {
                enumerable: true,
                get: function() {
                    return Boolean("USE_DASH" in this.defines);
                },
                set (value) {
                    if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
                        this.needsUpdate = true;
                    }
                    if (value === true) {
                        this.defines.USE_DASH = "";
                    } else {
                        delete this.defines.USE_DASH;
                    }
                }
            },
            dashScale: {
                enumerable: true,
                get: function() {
                    return this.uniforms.dashScale.value;
                },
                set: function(value) {
                    this.uniforms.dashScale.value = value;
                }
            },
            dashSize: {
                enumerable: true,
                get: function() {
                    return this.uniforms.dashSize.value;
                },
                set: function(value) {
                    this.uniforms.dashSize.value = value;
                }
            },
            dashOffset: {
                enumerable: true,
                get: function() {
                    return this.uniforms.dashOffset.value;
                },
                set: function(value) {
                    this.uniforms.dashOffset.value = value;
                }
            },
            gapSize: {
                enumerable: true,
                get: function() {
                    return this.uniforms.gapSize.value;
                },
                set: function(value) {
                    this.uniforms.gapSize.value = value;
                }
            },
            opacity: {
                enumerable: true,
                get: function() {
                    return this.uniforms.opacity.value;
                },
                set: function(value) {
                    this.uniforms.opacity.value = value;
                }
            },
            resolution: {
                enumerable: true,
                get: function() {
                    return this.uniforms.resolution.value;
                },
                set: function(value) {
                    this.uniforms.resolution.value.copy(value);
                }
            },
            alphaToCoverage: {
                enumerable: true,
                get: function() {
                    return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
                },
                set: function(value) {
                    if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
                        this.needsUpdate = true;
                    }
                    if (value === true) {
                        this.defines.USE_ALPHA_TO_COVERAGE = "";
                        this.extensions.derivatives = true;
                    } else {
                        delete this.defines.USE_ALPHA_TO_COVERAGE;
                        this.extensions.derivatives = false;
                    }
                }
            }
        });
        this.setValues(parameters);
    }
}
;
 //# sourceMappingURL=LineMaterial.js.map
}}),
"[project]/node_modules/three-stdlib/lines/LineSegments2.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LineSegments2": (()=>LineSegments2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegmentsGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineSegmentsGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineMaterial.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module '../_polyfill/uv1.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
;
const _viewport = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
const _start = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _end = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _start4 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
const _end4 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
const _ssOrigin = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
const _ssOrigin3 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _mvMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _line = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line3"]();
const _closestPoint = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _box = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
const _sphere = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"]();
const _clipToWorldVector = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
let _ray, _lineWidth;
function getWorldSpaceHalfWidth(camera, distance, resolution) {
    _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);
    _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
    _clipToWorldVector.x = _lineWidth / resolution.width;
    _clipToWorldVector.y = _lineWidth / resolution.height;
    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
    _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
    return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects) {
    const matrixWorld = lineSegments.matrixWorld;
    const geometry = lineSegments.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
    for(let i = 0, l = segmentCount; i < l; i++){
        _line.start.fromBufferAttribute(instanceStart, i);
        _line.end.fromBufferAttribute(instanceEnd, i);
        _line.applyMatrix4(matrixWorld);
        const pointOnLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
        const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;
        if (isInside) {
            intersects.push({
                point,
                pointOnLine,
                distance: _ray.origin.distanceTo(point),
                object: lineSegments,
                face: null,
                faceIndex: i,
                uv: null,
                [UV1]: null
            });
        }
    }
}
function raycastScreenSpace(lineSegments, camera, intersects) {
    const projectionMatrix = camera.projectionMatrix;
    const material = lineSegments.material;
    const resolution = material.resolution;
    const matrixWorld = lineSegments.matrixWorld;
    const geometry = lineSegments.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
    const near = -camera.near;
    _ray.at(1, _ssOrigin);
    _ssOrigin.w = 1;
    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
    _ssOrigin.applyMatrix4(projectionMatrix);
    _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
    _ssOrigin.x *= resolution.x / 2;
    _ssOrigin.y *= resolution.y / 2;
    _ssOrigin.z = 0;
    _ssOrigin3.copy(_ssOrigin);
    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
    for(let i = 0, l = segmentCount; i < l; i++){
        _start4.fromBufferAttribute(instanceStart, i);
        _end4.fromBufferAttribute(instanceEnd, i);
        _start4.w = 1;
        _end4.w = 1;
        _start4.applyMatrix4(_mvMatrix);
        _end4.applyMatrix4(_mvMatrix);
        const isBehindCameraNear = _start4.z > near && _end4.z > near;
        if (isBehindCameraNear) {
            continue;
        }
        if (_start4.z > near) {
            const deltaDist = _start4.z - _end4.z;
            const t = (_start4.z - near) / deltaDist;
            _start4.lerp(_end4, t);
        } else if (_end4.z > near) {
            const deltaDist = _end4.z - _start4.z;
            const t = (_end4.z - near) / deltaDist;
            _end4.lerp(_start4, t);
        }
        _start4.applyMatrix4(projectionMatrix);
        _end4.applyMatrix4(projectionMatrix);
        _start4.multiplyScalar(1 / _start4.w);
        _end4.multiplyScalar(1 / _end4.w);
        _start4.x *= resolution.x / 2;
        _start4.y *= resolution.y / 2;
        _end4.x *= resolution.x / 2;
        _end4.y *= resolution.y / 2;
        _line.start.copy(_start4);
        _line.start.z = 0;
        _line.end.copy(_end4);
        _line.end.z = 0;
        const param = _line.closestPointToPointParameter(_ssOrigin3, true);
        _line.at(param, _closestPoint);
        const zPos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(_start4.z, _end4.z, param);
        const isInClipSpace = zPos >= -1 && zPos <= 1;
        const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
        if (isInClipSpace && isInside) {
            _line.start.fromBufferAttribute(instanceStart, i);
            _line.end.fromBufferAttribute(instanceEnd, i);
            _line.start.applyMatrix4(matrixWorld);
            _line.end.applyMatrix4(matrixWorld);
            const pointOnLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
            intersects.push({
                point,
                pointOnLine,
                distance: _ray.origin.distanceTo(point),
                object: lineSegments,
                face: null,
                faceIndex: i,
                uv: null,
                [UV1]: null
            });
        }
    }
}
class LineSegments2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegmentsGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegmentsGeometry"](), material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineMaterial"]({
        color: Math.random() * 16777215
    })){
        super(geometry, material);
        this.isLineSegments2 = true;
        this.type = "LineSegments2";
    }
    // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
    computeLineDistances() {
        const geometry = this.geometry;
        const instanceStart = geometry.attributes.instanceStart;
        const instanceEnd = geometry.attributes.instanceEnd;
        const lineDistances = new Float32Array(2 * instanceStart.count);
        for(let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2){
            _start.fromBufferAttribute(instanceStart, i);
            _end.fromBufferAttribute(instanceEnd, i);
            lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
            lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
        }
        const instanceDistanceBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedInterleavedBuffer"](lineDistances, 2, 1);
        geometry.setAttribute("instanceDistanceStart", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](instanceDistanceBuffer, 1, 0));
        geometry.setAttribute("instanceDistanceEnd", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](instanceDistanceBuffer, 1, 1));
        return this;
    }
    raycast(raycaster, intersects) {
        const worldUnits = this.material.worldUnits;
        const camera = raycaster.camera;
        if (camera === null && !worldUnits) {
            console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
        }
        const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
        _ray = raycaster.ray;
        const matrixWorld = this.matrixWorld;
        const geometry = this.geometry;
        const material = this.material;
        _lineWidth = material.linewidth + threshold;
        if (geometry.boundingSphere === null) {
            geometry.computeBoundingSphere();
        }
        _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
        let sphereMargin;
        if (worldUnits) {
            sphereMargin = _lineWidth * 0.5;
        } else {
            const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));
            sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
        }
        _sphere.radius += sphereMargin;
        if (_ray.intersectsSphere(_sphere) === false) {
            return;
        }
        if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
        }
        _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
        let boxMargin;
        if (worldUnits) {
            boxMargin = _lineWidth * 0.5;
        } else {
            const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));
            boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
        }
        _box.expandByScalar(boxMargin);
        if (_ray.intersectsBox(_box) === false) {
            return;
        }
        if (worldUnits) {
            raycastWorldUnits(this, intersects);
        } else {
            raycastScreenSpace(this, camera, intersects);
        }
    }
    onBeforeRender(renderer) {
        const uniforms = this.material.uniforms;
        if (uniforms && uniforms.resolution) {
            renderer.getViewport(_viewport);
            this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);
        }
    }
}
;
 //# sourceMappingURL=LineSegments2.js.map
}}),
"[project]/node_modules/three-stdlib/lines/Line2.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Line2": (()=>Line2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegments2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineSegments2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineMaterial.js [app-client] (ecmascript)");
;
;
;
class Line2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegments2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments2"] {
    constructor(geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineGeometry"](), material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineMaterial"]({
        color: Math.random() * 16777215
    })){
        super(geometry, material);
        this.isLine2 = true;
        this.type = "Line2";
    }
}
;
 //# sourceMappingURL=Line2.js.map
}}),
"[project]/node_modules/three-stdlib/helpers/LightProbeHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LightProbeHelper": (()=>LightProbeHelper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class LightProbeHelper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(lightProbe, size){
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            type: "LightProbeHelperMaterial",
            uniforms: {
                sh: {
                    value: lightProbe.sh.coefficients
                },
                // by reference
                intensity: {
                    value: lightProbe.intensity
                }
            },
            vertexShader: [
                "varying vec3 vNormal;",
                "void main() {",
                "	vNormal = normalize( normalMatrix * normal );",
                "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                "}"
            ].join("\n"),
            fragmentShader: [
                "#define RECIPROCAL_PI 0.318309886",
                "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {",
                "	// matrix is assumed to be orthogonal",
                "	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );",
                "}",
                "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf",
                "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {",
                "	// normal is assumed to have unit length",
                "	float x = normal.x, y = normal.y, z = normal.z;",
                "	// band 0",
                "	vec3 result = shCoefficients[ 0 ] * 0.886227;",
                "	// band 1",
                "	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;",
                "	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;",
                "	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;",
                "	// band 2",
                "	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;",
                "	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;",
                "	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );",
                "	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;",
                "	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );",
                "	return result;",
                "}",
                "uniform vec3 sh[ 9 ]; // sh coefficients",
                "uniform float intensity; // light probe intensity",
                "varying vec3 vNormal;",
                "void main() {",
                "	vec3 normal = normalize( vNormal );",
                "	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );",
                "	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );",
                "	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;",
                "	gl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );",
                "}"
            ].join("\n")
        });
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SphereGeometry"](1, 32, 16);
        super(geometry, material);
        this.lightProbe = lightProbe;
        this.size = size;
        this.type = "LightProbeHelper";
        this.onBeforeRender();
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
    onBeforeRender() {
        this.position.copy(this.lightProbe.position);
        this.scale.set(1, 1, 1).multiplyScalar(this.size);
        this.material.uniforms.intensity.value = this.lightProbe.intensity;
    }
}
;
 //# sourceMappingURL=LightProbeHelper.js.map
}}),
"[project]/node_modules/three-stdlib/helpers/RaycasterHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RaycasterHelper": (()=>RaycasterHelper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
const _o = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
const _v = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class RaycasterHelper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(raycaster, numberOfHitsToVisualize = 20){
        super();
        __publicField(this, "raycaster");
        __publicField(this, "hits");
        __publicField(this, "origin");
        __publicField(this, "near");
        __publicField(this, "far");
        __publicField(this, "nearToFar");
        __publicField(this, "originToNear");
        __publicField(this, "hitPoints");
        __publicField(this, "colors", {
            near: 16777215,
            far: 16777215,
            originToNear: 3355443,
            nearToFar: 16777215,
            origin: [
                978050,
                16711771
            ]
        });
        __publicField(this, "setColors", (colors)=>{
            const _colors = {
                ...this.colors,
                ...colors
            };
            this.near.material.color.set(_colors.near);
            this.far.material.color.set(_colors.far);
            this.nearToFar.material.color.set(_colors.nearToFar);
            this.originToNear.material.color.set(_colors.originToNear);
        });
        __publicField(this, "update", ()=>{
            var _a;
            const origin = this.raycaster.ray.origin;
            const direction = this.raycaster.ray.direction;
            this.origin.position.copy(origin);
            this.near.position.copy(origin).add(direction.clone().multiplyScalar(this.raycaster.near));
            this.far.position.copy(origin).add(direction.clone().multiplyScalar(this.raycaster.far));
            this.far.lookAt(origin);
            this.near.lookAt(origin);
            let pos = this.nearToFar.geometry.getAttribute("position");
            pos.set([
                ...this.near.position.toArray(),
                ...this.far.position.toArray()
            ]);
            pos.needsUpdate = true;
            pos = this.originToNear.geometry.getAttribute("position");
            pos.set([
                ...origin.toArray(),
                ...this.near.position.toArray()
            ]);
            pos.needsUpdate = true;
            for(let i = 0; i < this.numberOfHitsToVisualize; i++){
                const hit = (_a = this.hits) == null ? void 0 : _a[i];
                if (hit) {
                    const { point } = hit;
                    _o.position.copy(point);
                    _o.scale.setScalar(1);
                } else {
                    _o.scale.setScalar(0);
                }
                _o.updateMatrix();
                this.hitPoints.setMatrixAt(i, _o.matrix);
            }
            this.hitPoints.instanceMatrix.needsUpdate = true;
            this.origin.material.color.set(this.hits.length > 0 ? this.colors.origin[0] : this.colors.origin[1]);
        });
        __publicField(this, "dispose", ()=>{
            this.origin.geometry.dispose();
            this.origin.material.dispose();
            this.near.geometry.dispose();
            this.near.material.dispose();
            this.far.geometry.dispose();
            this.far.material.dispose();
            this.nearToFar.geometry.dispose();
            this.nearToFar.material.dispose();
            this.originToNear.geometry.dispose();
            this.originToNear.material.dispose();
            this.hitPoints.dispose();
        });
        this.numberOfHitsToVisualize = numberOfHitsToVisualize;
        this.raycaster = raycaster;
        this.hits = [];
        this.origin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SphereGeometry"](0.04, 32), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]());
        this.origin.name = "RaycasterHelper_origin";
        this.origin.raycast = ()=>null;
        const size = 0.1;
        let geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"]([
            -size,
            size,
            0,
            size,
            size,
            0,
            size,
            -size,
            0,
            -size,
            -size,
            0,
            -size,
            size,
            0
        ], 3));
        this.near = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](geometry, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]());
        this.near.name = "RaycasterHelper_near";
        this.near.raycast = ()=>null;
        this.far = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](geometry, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]());
        this.far.name = "RaycasterHelper_far";
        this.far.raycast = ()=>null;
        this.nearToFar = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"](), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]());
        this.nearToFar.name = "RaycasterHelper_nearToFar";
        this.nearToFar.raycast = ()=>null;
        this.nearToFar.geometry.setFromPoints([
            _v,
            _v
        ]);
        this.originToNear = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](this.nearToFar.geometry.clone(), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]());
        this.originToNear.name = "RaycasterHelper_originToNear";
        this.originToNear.raycast = ()=>null;
        this.hitPoints = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedMesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SphereGeometry"](0.04), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"](), this.numberOfHitsToVisualize);
        this.hitPoints.name = "RaycasterHelper_hits";
        this.hitPoints.raycast = ()=>null;
        this.add(this.nearToFar);
        this.add(this.originToNear);
        this.add(this.near);
        this.add(this.far);
        this.add(this.origin);
        this.add(this.hitPoints);
        this.setColors();
    }
}
;
 //# sourceMappingURL=RaycasterHelper.js.map
}}),
"[project]/node_modules/three-stdlib/helpers/PositionalAudioHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PositionalAudioHelper": (()=>PositionalAudioHelper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class PositionalAudioHelper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"] {
    constructor(audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2){
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;
        const positions = new Float32Array((divisions * 3 + 3) * 3);
        geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](positions, 3));
        const materialInnerAngle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
            color: 65280
        });
        const materialOuterAngle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
            color: 16776960
        });
        super(geometry, [
            materialOuterAngle,
            materialInnerAngle
        ]);
        this.type = "PositionalAudioHelper";
        this.audio = audio;
        this.range = range;
        this.divisionsInnerAngle = divisionsInnerAngle;
        this.divisionsOuterAngle = divisionsOuterAngle;
        this.update();
    }
    update() {
        const audio = this.audio;
        const range = this.range;
        const divisionsInnerAngle = this.divisionsInnerAngle;
        const divisionsOuterAngle = this.divisionsOuterAngle;
        const coneInnerAngle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(audio.panner.coneInnerAngle);
        const coneOuterAngle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(audio.panner.coneOuterAngle);
        const halfConeInnerAngle = coneInnerAngle / 2;
        const halfConeOuterAngle = coneOuterAngle / 2;
        let start = 0;
        let count = 0;
        let i, stride;
        const geometry = this.geometry;
        const positionAttribute = geometry.attributes.position;
        geometry.clearGroups();
        function generateSegment(from, to, divisions, materialIndex) {
            const step = (to - from) / divisions;
            positionAttribute.setXYZ(start, 0, 0, 0);
            count++;
            for(i = from; i < to; i += step){
                stride = start + count;
                positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
                positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);
                positionAttribute.setXYZ(stride + 2, 0, 0, 0);
                count += 3;
            }
            geometry.addGroup(start, count, materialIndex);
            start += count;
            count = 0;
        }
        generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
        generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
        generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
        positionAttribute.needsUpdate = true;
        if (coneInnerAngle === coneOuterAngle) this.material[0].visible = false;
    }
    dispose() {
        this.geometry.dispose();
        this.material[0].dispose();
        this.material[1].dispose();
    }
}
;
 //# sourceMappingURL=PositionalAudioHelper.js.map
}}),
"[project]/node_modules/three-stdlib/helpers/RectAreaLightHelper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RectAreaLightHelper": (()=>RectAreaLightHelper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class RectAreaLightHelper extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"] {
    constructor(light, color){
        const positions = [
            1,
            1,
            0,
            -1,
            1,
            0,
            -1,
            -1,
            0,
            1,
            -1,
            0,
            1,
            1,
            0
        ];
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positions, 3));
        geometry.computeBoundingSphere();
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
            fog: false
        });
        super(geometry, material);
        this.light = light;
        this.color = color;
        this.type = "RectAreaLightHelper";
        const positions2 = [
            1,
            1,
            0,
            -1,
            1,
            0,
            -1,
            -1,
            0,
            1,
            1,
            0,
            -1,
            -1,
            0,
            1,
            -1,
            0
        ];
        const geometry2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        geometry2.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry2, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"],
            fog: false
        })));
    }
    updateMatrixWorld() {
        this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
        if (this.color !== void 0) {
            this.material.color.set(this.color);
            this.children[0].material.color.set(this.color);
        } else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            const c = this.material.color;
            const max = Math.max(c.r, c.g, c.b);
            if (max > 1) c.multiplyScalar(1 / max);
            this.children[0].material.color.copy(this.material.color);
        }
        this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld);
        this.children[0].matrixWorld.copy(this.matrixWorld);
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
}
;
 //# sourceMappingURL=RectAreaLightHelper.js.map
}}),
"[project]/node_modules/three-stdlib/deprecated/Geometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Face3": (()=>Face3),
    "Geometry": (()=>Geometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _m1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _obj = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
const _offset = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const Geometry = /* @__PURE__ */ (()=>{
    class Geometry2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventDispatcher"] {
        static createBufferGeometryFromObject(object) {
            let buffergeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            const geometry = object.geometry;
            if (object.isPoints || object.isLine) {
                const positions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.vertices.length * 3, 3);
                const colors = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.colors.length * 3, 3);
                buffergeometry.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
                buffergeometry.setAttribute("color", colors.copyColorsArray(geometry.colors));
                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    const lineDistances = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.lineDistances.length, 1);
                    buffergeometry.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
                }
                if (geometry.boundingSphere !== null) {
                    buffergeometry.boundingSphere = geometry.boundingSphere.clone();
                }
                if (geometry.boundingBox !== null) {
                    buffergeometry.boundingBox = geometry.boundingBox.clone();
                }
            } else if (object.isMesh) {
                buffergeometry = geometry.toBufferGeometry();
            }
            return buffergeometry;
        }
        constructor(){
            super();
            this.isGeometry = true;
            this.uuid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].generateUUID();
            this.name = "";
            this.type = "Geometry";
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [
                []
            ];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.elementsNeedUpdate = false;
            this.verticesNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.lineDistancesNeedUpdate = false;
            this.groupsNeedUpdate = false;
        }
        applyMatrix4(matrix) {
            const normalMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]().getNormalMatrix(matrix);
            for(let i = 0, il = this.vertices.length; i < il; i++){
                const vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }
            for(let i = 0, il = this.faces.length; i < il; i++){
                const face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for(let j = 0, jl = face.vertexNormals.length; j < jl; j++){
                    face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;
            return this;
        }
        rotateX(angle) {
            _m1.makeRotationX(angle);
            this.applyMatrix4(_m1);
            return this;
        }
        rotateY(angle) {
            _m1.makeRotationY(angle);
            this.applyMatrix4(_m1);
            return this;
        }
        rotateZ(angle) {
            _m1.makeRotationZ(angle);
            this.applyMatrix4(_m1);
            return this;
        }
        translate(x, y, z) {
            _m1.makeTranslation(x, y, z);
            this.applyMatrix4(_m1);
            return this;
        }
        scale(x, y, z) {
            _m1.makeScale(x, y, z);
            this.applyMatrix4(_m1);
            return this;
        }
        lookAt(vector) {
            _obj.lookAt(vector);
            _obj.updateMatrix();
            this.applyMatrix4(_obj.matrix);
            return this;
        }
        fromBufferGeometry(geometry) {
            const scope = this;
            const index = geometry.index !== null ? geometry.index : void 0;
            const attributes = geometry.attributes;
            if (attributes.position === void 0) {
                console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
                return this;
            }
            const position = attributes.position;
            const normal = attributes.normal;
            const color = attributes.color;
            const uv = attributes.uv;
            const uv2 = attributes.uv2;
            if (uv2 !== void 0) this.faceVertexUvs[1] = [];
            for(let i = 0; i < position.count; i++){
                scope.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(position, i));
                if (color !== void 0) {
                    scope.colors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromBufferAttribute(color, i));
                }
            }
            function addFace(a, b, c, materialIndex) {
                const vertexColors = color === void 0 ? [] : [
                    scope.colors[a].clone(),
                    scope.colors[b].clone(),
                    scope.colors[c].clone()
                ];
                const vertexNormals = normal === void 0 ? [] : [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(normal, a),
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(normal, b),
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromBufferAttribute(normal, c)
                ];
                const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face);
                if (uv !== void 0) {
                    scope.faceVertexUvs[0].push([
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]().fromBufferAttribute(uv, a),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]().fromBufferAttribute(uv, b),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]().fromBufferAttribute(uv, c)
                    ]);
                }
                if (uv2 !== void 0) {
                    scope.faceVertexUvs[1].push([
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]().fromBufferAttribute(uv2, a),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]().fromBufferAttribute(uv2, b),
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]().fromBufferAttribute(uv2, c)
                    ]);
                }
            }
            const groups = geometry.groups;
            if (groups.length > 0) {
                for(let i = 0; i < groups.length; i++){
                    const group = groups[i];
                    const start = group.start;
                    const count = group.count;
                    for(let j = start, jl = start + count; j < jl; j += 3){
                        if (index !== void 0) {
                            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
                        } else {
                            addFace(j, j + 1, j + 2, group.materialIndex);
                        }
                    }
                }
            } else {
                if (index !== void 0) {
                    for(let i = 0; i < index.count; i += 3){
                        addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));
                    }
                } else {
                    for(let i = 0; i < position.count; i += 3){
                        addFace(i, i + 1, i + 2);
                    }
                }
            }
            this.computeFaceNormals();
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            return this;
        }
        center() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(_offset).negate();
            this.translate(_offset.x, _offset.y, _offset.z);
            return this;
        }
        normalize() {
            this.computeBoundingSphere();
            const center = this.boundingSphere.center;
            const radius = this.boundingSphere.radius;
            const s = radius === 0 ? 1 : 1 / radius;
            const matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
            this.applyMatrix4(matrix);
            return this;
        }
        computeFaceNormals() {
            const cb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), ab = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const vA = this.vertices[face.a];
                const vB = this.vertices[face.b];
                const vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                face.normal.copy(cb);
            }
        }
        computeVertexNormals(areaWeighted = true) {
            const vertices = new Array(this.vertices.length);
            for(let v = 0, vl = this.vertices.length; v < vl; v++){
                vertices[v] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            }
            if (areaWeighted) {
                const cb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), ab = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                for(let f = 0, fl = this.faces.length; f < fl; f++){
                    const face = this.faces[f];
                    const vA = this.vertices[face.a];
                    const vB = this.vertices[face.b];
                    const vC = this.vertices[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);
                    vertices[face.a].add(cb);
                    vertices[face.b].add(cb);
                    vertices[face.c].add(cb);
                }
            } else {
                this.computeFaceNormals();
                for(let f = 0, fl = this.faces.length; f < fl; f++){
                    const face = this.faces[f];
                    vertices[face.a].add(face.normal);
                    vertices[face.b].add(face.normal);
                    vertices[face.c].add(face.normal);
                }
            }
            for(let v = 0, vl = this.vertices.length; v < vl; v++){
                vertices[v].normalize();
            }
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(vertices[face.a]);
                    vertexNormals[1].copy(vertices[face.b]);
                    vertexNormals[2].copy(vertices[face.c]);
                } else {
                    vertexNormals[0] = vertices[face.a].clone();
                    vertexNormals[1] = vertices[face.b].clone();
                    vertexNormals[2] = vertices[face.c].clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        }
        computeFlatVertexNormals() {
            this.computeFaceNormals();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(face.normal);
                    vertexNormals[1].copy(face.normal);
                    vertexNormals[2].copy(face.normal);
                } else {
                    vertexNormals[0] = face.normal.clone();
                    vertexNormals[1] = face.normal.clone();
                    vertexNormals[2] = face.normal.clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        }
        computeMorphNormals() {
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                if (!face.__originalFaceNormal) {
                    face.__originalFaceNormal = face.normal.clone();
                } else {
                    face.__originalFaceNormal.copy(face.normal);
                }
                if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
                for(let i = 0, il = face.vertexNormals.length; i < il; i++){
                    if (!face.__originalVertexNormals[i]) {
                        face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    } else {
                        face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                    }
                }
            }
            const tmpGeo = new Geometry2();
            tmpGeo.faces = this.faces;
            for(let i = 0, il = this.morphTargets.length; i < il; i++){
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {};
                    this.morphNormals[i].faceNormals = [];
                    this.morphNormals[i].vertexNormals = [];
                    const dstNormalsFace = this.morphNormals[i].faceNormals;
                    const dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    for(let f = 0, fl = this.faces.length; f < fl; f++){
                        const faceNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                        const vertexNormals = {
                            a: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                            b: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                            c: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
                        };
                        dstNormalsFace.push(faceNormal);
                        dstNormalsVertex.push(vertexNormals);
                    }
                }
                const morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices;
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
                for(let f = 0, fl = this.faces.length; f < fl; f++){
                    const face = this.faces[f];
                    const faceNormal = morphNormals.faceNormals[f];
                    const vertexNormals = morphNormals.vertexNormals[f];
                    faceNormal.copy(face.normal);
                    vertexNormals.a.copy(face.vertexNormals[0]);
                    vertexNormals.b.copy(face.vertexNormals[1]);
                    vertexNormals.c.copy(face.vertexNormals[2]);
                }
            }
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
            }
        }
        computeBoundingBox() {
            if (this.boundingBox === null) {
                this.boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
            }
            this.boundingBox.setFromPoints(this.vertices);
        }
        computeBoundingSphere() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"]();
            }
            this.boundingSphere.setFromPoints(this.vertices);
        }
        merge(geometry, matrix, materialIndexOffset = 0) {
            if (!(geometry && geometry.isGeometry)) {
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
                return;
            }
            let normalMatrix;
            const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
            if (matrix !== void 0) {
                normalMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]().getNormalMatrix(matrix);
            }
            for(let i = 0, il = vertices2.length; i < il; i++){
                const vertex = vertices2[i];
                const vertexCopy = vertex.clone();
                if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);
                vertices1.push(vertexCopy);
            }
            for(let i = 0, il = colors2.length; i < il; i++){
                colors1.push(colors2[i].clone());
            }
            for(let i = 0, il = faces2.length; i < il; i++){
                const face = faces2[i];
                let normal, color;
                const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);
                if (normalMatrix !== void 0) {
                    faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }
                for(let j = 0, jl = faceVertexNormals.length; j < jl; j++){
                    normal = faceVertexNormals[j].clone();
                    if (normalMatrix !== void 0) {
                        normal.applyMatrix3(normalMatrix).normalize();
                    }
                    faceCopy.vertexNormals.push(normal);
                }
                faceCopy.color.copy(face.color);
                for(let j = 0, jl = faceVertexColors.length; j < jl; j++){
                    color = faceVertexColors[j];
                    faceCopy.vertexColors.push(color.clone());
                }
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                faces1.push(faceCopy);
            }
            for(let i = 0, il = geometry.faceVertexUvs.length; i < il; i++){
                const faceVertexUvs2 = geometry.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === void 0) this.faceVertexUvs[i] = [];
                for(let j = 0, jl = faceVertexUvs2.length; j < jl; j++){
                    const uvs2 = faceVertexUvs2[j], uvsCopy = [];
                    for(let k = 0, kl = uvs2.length; k < kl; k++){
                        uvsCopy.push(uvs2[k].clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
        }
        mergeMesh(mesh) {
            if (!(mesh && mesh.isMesh)) {
                console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
                return;
            }
            if (mesh.matrixAutoUpdate) mesh.updateMatrix();
            this.merge(mesh.geometry, mesh.matrix);
        }
        /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */ mergeVertices(precisionPoints = 4) {
            const verticesMap = {};
            const unique = [], changes = [];
            const precision = Math.pow(10, precisionPoints);
            for(let i = 0, il = this.vertices.length; i < il; i++){
                const v = this.vertices[i];
                const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;
                if (verticesMap[key] === void 0) {
                    verticesMap[key] = i;
                    unique.push(this.vertices[i]);
                    changes[i] = unique.length - 1;
                } else {
                    changes[i] = changes[verticesMap[key]];
                }
            }
            const faceIndicesToRemove = [];
            for(let i = 0, il = this.faces.length; i < il; i++){
                const face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                const indices = [
                    face.a,
                    face.b,
                    face.c
                ];
                for(let n = 0; n < 3; n++){
                    if (indices[n] === indices[(n + 1) % 3]) {
                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }
            for(let i = faceIndicesToRemove.length - 1; i >= 0; i--){
                const idx = faceIndicesToRemove[i];
                this.faces.splice(idx, 1);
                for(let j = 0, jl = this.faceVertexUvs.length; j < jl; j++){
                    this.faceVertexUvs[j].splice(idx, 1);
                }
            }
            const diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
        }
        setFromPoints(points) {
            this.vertices = [];
            for(let i = 0, l = points.length; i < l; i++){
                const point = points[i];
                this.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](point.x, point.y, point.z || 0));
            }
            return this;
        }
        sortFacesByMaterialIndex() {
            const faces = this.faces;
            const length = faces.length;
            for(let i = 0; i < length; i++){
                faces[i]._id = i;
            }
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            faces.sort(materialIndexSort);
            const uvs1 = this.faceVertexUvs[0];
            const uvs2 = this.faceVertexUvs[1];
            let newUvs1, newUvs2;
            if (uvs1 && uvs1.length === length) newUvs1 = [];
            if (uvs2 && uvs2.length === length) newUvs2 = [];
            for(let i = 0; i < length; i++){
                const id = faces[i]._id;
                if (newUvs1) newUvs1.push(uvs1[id]);
                if (newUvs2) newUvs2.push(uvs2[id]);
            }
            if (newUvs1) this.faceVertexUvs[0] = newUvs1;
            if (newUvs2) this.faceVertexUvs[1] = newUvs2;
        }
        toJSON() {
            const data = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== "") data.name = this.name;
            if (this.parameters !== void 0) {
                const parameters = this.parameters;
                for(let key in parameters){
                    if (parameters[key] !== void 0) data[key] = parameters[key];
                }
                return data;
            }
            const vertices = [];
            for(let i = 0; i < this.vertices.length; i++){
                const vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            const faces = [];
            const normals = [];
            const normalsHash = {};
            const colors = [];
            const colorsHash = {};
            const uvs = [];
            const uvsHash = {};
            for(let i = 0; i < this.faces.length; i++){
                const face = this.faces[i];
                const hasMaterial = true;
                const hasFaceUv = false;
                const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;
                const hasFaceNormal = face.normal.length() > 0;
                const hasFaceVertexNormal = face.vertexNormals.length > 0;
                const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                const hasFaceVertexColor = face.vertexColors.length > 0;
                let faceType = 0;
                faceType = setBit(faceType, 0, 0);
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);
                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);
                if (hasFaceVertexUv) {
                    const faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal) {
                    faces.push(getNormalIndex(face.normal));
                }
                if (hasFaceVertexNormal) {
                    const vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor) {
                    faces.push(getColorIndex(face.color));
                }
                if (hasFaceVertexColor) {
                    const vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            function setBit(value, position, enabled) {
                return enabled ? value | 1 << position : value & ~(1 << position);
            }
            function getNormalIndex(normal) {
                const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                if (normalsHash[hash] !== void 0) {
                    return normalsHash[hash];
                }
                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);
                return normalsHash[hash];
            }
            function getColorIndex(color) {
                const hash = color.r.toString() + color.g.toString() + color.b.toString();
                if (colorsHash[hash] !== void 0) {
                    return colorsHash[hash];
                }
                colorsHash[hash] = colors.length;
                colors.push(color.getHex());
                return colorsHash[hash];
            }
            function getUvIndex(uv) {
                const hash = uv.x.toString() + uv.y.toString();
                if (uvsHash[hash] !== void 0) {
                    return uvsHash[hash];
                }
                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);
                return uvsHash[hash];
            }
            data.data = {};
            data.data.vertices = vertices;
            data.data.normals = normals;
            if (colors.length > 0) data.data.colors = colors;
            if (uvs.length > 0) data.data.uvs = [
                uvs
            ];
            data.data.faces = faces;
            return data;
        }
        clone() {
            return new Geometry2().copy(this);
        }
        copy(source) {
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [
                []
            ];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.name = source.name;
            const vertices = source.vertices;
            for(let i = 0, il = vertices.length; i < il; i++){
                this.vertices.push(vertices[i].clone());
            }
            const colors = source.colors;
            for(let i = 0, il = colors.length; i < il; i++){
                this.colors.push(colors[i].clone());
            }
            const faces = source.faces;
            for(let i = 0, il = faces.length; i < il; i++){
                this.faces.push(faces[i].clone());
            }
            for(let i = 0, il = source.faceVertexUvs.length; i < il; i++){
                const faceVertexUvs = source.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === void 0) {
                    this.faceVertexUvs[i] = [];
                }
                for(let j = 0, jl = faceVertexUvs.length; j < jl; j++){
                    const uvs = faceVertexUvs[j], uvsCopy = [];
                    for(let k = 0, kl = uvs.length; k < kl; k++){
                        const uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            const morphTargets = source.morphTargets;
            for(let i = 0, il = morphTargets.length; i < il; i++){
                const morphTarget = {};
                morphTarget.name = morphTargets[i].name;
                if (morphTargets[i].vertices !== void 0) {
                    morphTarget.vertices = [];
                    for(let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++){
                        morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                    }
                }
                if (morphTargets[i].normals !== void 0) {
                    morphTarget.normals = [];
                    for(let j = 0, jl = morphTargets[i].normals.length; j < jl; j++){
                        morphTarget.normals.push(morphTargets[i].normals[j].clone());
                    }
                }
                this.morphTargets.push(morphTarget);
            }
            const morphNormals = source.morphNormals;
            for(let i = 0, il = morphNormals.length; i < il; i++){
                const morphNormal = {};
                if (morphNormals[i].vertexNormals !== void 0) {
                    morphNormal.vertexNormals = [];
                    for(let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++){
                        const srcVertexNormal = morphNormals[i].vertexNormals[j];
                        const destVertexNormal = {};
                        destVertexNormal.a = srcVertexNormal.a.clone();
                        destVertexNormal.b = srcVertexNormal.b.clone();
                        destVertexNormal.c = srcVertexNormal.c.clone();
                        morphNormal.vertexNormals.push(destVertexNormal);
                    }
                }
                if (morphNormals[i].faceNormals !== void 0) {
                    morphNormal.faceNormals = [];
                    for(let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++){
                        morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                    }
                }
                this.morphNormals.push(morphNormal);
            }
            const skinWeights = source.skinWeights;
            for(let i = 0, il = skinWeights.length; i < il; i++){
                this.skinWeights.push(skinWeights[i].clone());
            }
            const skinIndices = source.skinIndices;
            for(let i = 0, il = skinIndices.length; i < il; i++){
                this.skinIndices.push(skinIndices[i].clone());
            }
            const lineDistances = source.lineDistances;
            for(let i = 0, il = lineDistances.length; i < il; i++){
                this.lineDistances.push(lineDistances[i]);
            }
            const boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            const boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            this.elementsNeedUpdate = source.elementsNeedUpdate;
            this.verticesNeedUpdate = source.verticesNeedUpdate;
            this.uvsNeedUpdate = source.uvsNeedUpdate;
            this.normalsNeedUpdate = source.normalsNeedUpdate;
            this.colorsNeedUpdate = source.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = source.groupsNeedUpdate;
            return this;
        }
        toBufferGeometry() {
            const geometry = new DirectGeometry().fromGeometry(this);
            const buffergeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            const positions = new Float32Array(geometry.vertices.length * 3);
            buffergeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](positions, 3).copyVector3sArray(geometry.vertices));
            if (geometry.normals.length > 0) {
                const normals = new Float32Array(geometry.normals.length * 3);
                buffergeometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                const colors = new Float32Array(geometry.colors.length * 3);
                buffergeometry.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                const uvs = new Float32Array(geometry.uvs.length * 2);
                buffergeometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                const uvs2 = new Float32Array(geometry.uvs2.length * 2);
                buffergeometry.setAttribute("uv2", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            buffergeometry.groups = geometry.groups;
            for(let name in geometry.morphTargets){
                const array = [];
                const morphTargets = geometry.morphTargets[name];
                for(let i = 0, l = morphTargets.length; i < l; i++){
                    const morphTarget = morphTargets[i];
                    const attribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](morphTarget.data.length * 3, 3);
                    attribute.name = morphTarget.name;
                    array.push(attribute.copyVector3sArray(morphTarget.data));
                }
                buffergeometry.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                const skinIndices = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.skinIndices.length * 4, 4);
                buffergeometry.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                const skinWeights = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.skinWeights.length * 4, 4);
                buffergeometry.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            if (geometry.boundingSphere !== null) {
                buffergeometry.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                buffergeometry.boundingBox = geometry.boundingBox.clone();
            }
            return buffergeometry;
        }
        computeTangents() {
            console.error("THREE.Geometry: .computeTangents() has been removed.");
        }
        computeLineDistances() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
        }
        applyMatrix(matrix) {
            console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
            return this.applyMatrix4(matrix);
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }
    return Geometry2;
})();
class DirectGeometry {
    constructor(){
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    computeGroups(geometry) {
        const groups = [];
        let group, i;
        let materialIndex = void 0;
        const faces = geometry.faces;
        for(i = 0; i < faces.length; i++){
            const face = faces[i];
            if (face.materialIndex !== materialIndex) {
                materialIndex = face.materialIndex;
                if (group !== void 0) {
                    group.count = i * 3 - group.start;
                    groups.push(group);
                }
                group = {
                    start: i * 3,
                    materialIndex
                };
            }
        }
        if (group !== void 0) {
            group.count = i * 3 - group.start;
            groups.push(group);
        }
        this.groups = groups;
    }
    fromGeometry(geometry) {
        const faces = geometry.faces;
        const vertices = geometry.vertices;
        const faceVertexUvs = geometry.faceVertexUvs;
        const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        const morphTargets = geometry.morphTargets;
        const morphTargetsLength = morphTargets.length;
        let morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for(let i = 0; i < morphTargetsLength; i++){
                morphTargetsPosition[i] = {
                    name: morphTargets[i].name,
                    data: []
                };
            }
            this.morphTargets.position = morphTargetsPosition;
        }
        const morphNormals = geometry.morphNormals;
        const morphNormalsLength = morphNormals.length;
        let morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for(let i = 0; i < morphNormalsLength; i++){
                morphTargetsNormal[i] = {
                    name: morphNormals[i].name,
                    data: []
                };
            }
            this.morphTargets.normal = morphTargetsNormal;
        }
        const skinIndices = geometry.skinIndices;
        const skinWeights = geometry.skinWeights;
        const hasSkinIndices = skinIndices.length === vertices.length;
        const hasSkinWeights = skinWeights.length === vertices.length;
        if (vertices.length > 0 && faces.length === 0) {
            console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        }
        for(let i = 0; i < faces.length; i++){
            const face = faces[i];
            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            } else {
                const normal = face.normal;
                this.normals.push(normal, normal, normal);
            }
            const vertexColors = face.vertexColors;
            if (vertexColors.length === 3) {
                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            } else {
                const color = face.color;
                this.colors.push(color, color, color);
            }
            if (hasFaceVertexUv === true) {
                const vertexUvs = faceVertexUvs[0][i];
                if (vertexUvs !== void 0) {
                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                } else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
                    this.uvs.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]());
                }
            }
            if (hasFaceVertexUv2 === true) {
                const vertexUvs = faceVertexUvs[1][i];
                if (vertexUvs !== void 0) {
                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                } else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
                    this.uvs2.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]());
                }
            }
            for(let j = 0; j < morphTargetsLength; j++){
                const morphTarget = morphTargets[j].vertices;
                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for(let j = 0; j < morphNormalsLength; j++){
                const morphNormal = morphNormals[j].vertexNormals[i];
                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            if (hasSkinIndices) {
                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            }
            if (hasSkinWeights) {
                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
            }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
    }
}
class Face3 {
    constructor(a, b, c, normal, color, materialIndex = 0){
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = normal && normal.isVector3 ? normal : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.vertexNormals = Array.isArray(normal) ? normal : [];
        this.color = color && color.isColor ? color : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        this.vertexColors = Array.isArray(color) ? color : [];
        this.materialIndex = materialIndex;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for(let i = 0, il = source.vertexNormals.length; i < il; i++){
            this.vertexNormals[i] = source.vertexNormals[i].clone();
        }
        for(let i = 0, il = source.vertexColors.length; i < il; i++){
            this.vertexColors[i] = source.vertexColors[i].clone();
        }
        return this;
    }
}
;
 //# sourceMappingURL=Geometry.js.map
}}),
"[project]/node_modules/three-stdlib/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/three-stdlib/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$MD2CharacterComplex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/MD2CharacterComplex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$ConvexObjectBreaker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/ConvexObjectBreaker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$MorphBlendMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/MorphBlendMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$GPUComputationRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/GPUComputationRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$Gyroscope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/Gyroscope.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$MorphAnimMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/MorphAnimMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$RollerCoaster$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/RollerCoaster.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './misc/Timer.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './misc/WebGL.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$MD2Character$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/MD2Character.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './misc/VolumeSlice.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './misc/TubePainter.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './misc/Volume.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$misc$2f$ProgressiveLightmap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/misc/ProgressiveLightmap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$renderers$2f$CSS2DRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/renderers/CSS2DRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$renderers$2f$CSS3DRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/renderers/CSS3DRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$renderers$2f$Projector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/renderers/Projector.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './renderers/SVGRenderer.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$textures$2f$FlakesTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/textures/FlakesTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$modifiers$2f$CurveModifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/modifiers/CurveModifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$modifiers$2f$SimplifyModifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/modifiers/SimplifyModifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$modifiers$2f$EdgeSplitModifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/modifiers/EdgeSplitModifier.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './modifiers/TessellateModifier.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$exporters$2f$GLTFExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/exporters/GLTFExporter.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './exporters/USDZExporter.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$exporters$2f$PLYExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/exporters/PLYExporter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$exporters$2f$DRACOExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/exporters/DRACOExporter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$exporters$2f$ColladaExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/exporters/ColladaExporter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$exporters$2f$MMDExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/exporters/MMDExporter.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './exporters/STLExporter.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$exporters$2f$OBJExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/exporters/OBJExporter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$environments$2f$RoomEnvironment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/environments/RoomEnvironment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$AnimationClipCreator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/animation/AnimationClipCreator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$CCDIKSolver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/animation/CCDIKSolver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$MMDPhysics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/animation/MMDPhysics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$animation$2f$MMDAnimationHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/animation/MMDAnimationHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$BatchedMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/BatchedMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$Reflector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/Reflector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$Refractor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/Refractor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$ShadowMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/ShadowMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$Lensflare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/Lensflare.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './objects/Water.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$MarchingCubes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/MarchingCubes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$LightningStorm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/LightningStorm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$ReflectorRTT$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/ReflectorRTT.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$ReflectorForSSRPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/ReflectorForSSRPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$Sky$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/Sky.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './objects/Water2.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$GroundProjectedEnv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/GroundProjectedEnv.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$SceneUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/SceneUtils.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './utils/UVsDebug.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$GeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/GeometryUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$RoughnessMipmapper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/RoughnessMipmapper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$SkeletonUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/SkeletonUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$ShadowMapViewer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/ShadowMapViewer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$GeometryCompressionUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/GeometryCompressionUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$cameras$2f$CinematicCamera$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/cameras/CinematicCamera.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$ConvexHull$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/ConvexHull.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$MeshSurfaceSampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/MeshSurfaceSampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$SimplexNoise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/SimplexNoise.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$OBB$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/OBB.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$Capsule$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/Capsule.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$ColorConverter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/ColorConverter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$ImprovedNoise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/ImprovedNoise.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$Octree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/Octree.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$math$2f$Lut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/math/Lut.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$experimental$2f$CameraControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/experimental/CameraControls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$FirstPersonControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/FirstPersonControls.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './controls/TransformControls.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$DragControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/DragControls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$PointerLockControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/PointerLockControls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$DeviceOrientationControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/DeviceOrientationControls.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './controls/TrackballControls.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$OrbitControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/OrbitControls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$ArcballControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/ArcballControls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$controls$2f$FlyControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/controls/FlyControls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$LUTPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/LUTPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$ClearPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/ClearPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$GlitchPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/GlitchPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$HalftonePass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/HalftonePass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$SMAAPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/SMAAPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$FilmPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/FilmPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$OutlinePass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/OutlinePass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$SSAOPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/SSAOPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$SavePass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/SavePass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$BokehPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/BokehPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$Pass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/Pass.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './postprocessing/TexturePass.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$AdaptiveToneMappingPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './postprocessing/UnrealBloomPass.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$CubeTexturePass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/CubeTexturePass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$SAOPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/SAOPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$AfterimagePass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/AfterimagePass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$MaskPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/MaskPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$EffectComposer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/EffectComposer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$DotScreenPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/DotScreenPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$SSRPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/SSRPass.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './postprocessing/TAARenderPass.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$ShaderPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/ShaderPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$SSAARenderPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/SSAARenderPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$RenderPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/RenderPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$RenderPixelatedPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/RenderPixelatedPass.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$postprocessing$2f$BloomPass$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/postprocessing/BloomPass.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './postprocessing/WaterPass.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$webxr$2f$ARButton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/webxr/ARButton.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$webxr$2f$OculusHandModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/webxr/OculusHandModel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$webxr$2f$OculusHandPointerModel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/webxr/OculusHandPointerModel.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './webxr/Text2D.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './webxr/VRButton.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './webxr/XRControllerModelFactory.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './webxr/XREstimatedLight.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './webxr/XRHandMeshModel.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './webxr/XRHandModelFactory.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './webxr/XRHandPrimitiveModel.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ParametricGeometries$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/ParametricGeometries.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ParametricGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/ParametricGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$ConvexGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/ConvexGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/LightningStrike.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$RoundedBoxGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$BoxLineGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/BoxLineGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$DecalGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/DecalGeometry.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './geometries/TeapotGeometry.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './geometries/TextGeometry.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSM$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/csm/CSM.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMFrustum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/csm/CSMFrustum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/csm/CSMHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$csm$2f$CSMShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/csm/CSMShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$ACESFilmicToneMappingShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$AfterimageShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/AfterimageShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BasicShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/BasicShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BleachBypassShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/BleachBypassShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BlendShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/BlendShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BokehShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/BokehShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BokehShader2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/BokehShader2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$BrightnessContrastShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/BrightnessContrastShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$ColorCorrectionShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/ColorCorrectionShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$ColorifyShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/ColorifyShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$ConvolutionShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/ConvolutionShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$CopyShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/CopyShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$DOFMipMapShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/DOFMipMapShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$DepthLimitedBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$DigitalGlitch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/DigitalGlitch.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$DotScreenShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/DotScreenShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$FXAAShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/FXAAShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$FilmShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/FilmShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$FocusShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/FocusShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$FreiChenShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/FreiChenShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$FresnelShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/FresnelShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$GammaCorrectionShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/GammaCorrectionShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$GodRaysShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/GodRaysShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$HalftoneShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/HalftoneShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$HorizontalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/HorizontalBlurShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$HorizontalTiltShiftShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$HueSaturationShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/HueSaturationShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$KaleidoShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/KaleidoShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$LuminosityHighPassShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/LuminosityHighPassShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$LuminosityShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/LuminosityShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$MirrorShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/MirrorShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$NormalMapShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/NormalMapShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$ParallaxShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/ParallaxShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$PixelShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/PixelShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$RGBShiftShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/RGBShiftShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$SAOShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/SAOShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$SMAAShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/SMAAShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$SSAOShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/SSAOShader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './shaders/SSRShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$SepiaShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/SepiaShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$SobelOperatorShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/shaders/SobelOperatorShader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './shaders/SubsurfaceScatteringShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/TechnicolorShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/ToneMapShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/ToonShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/TriangleBlurShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/UnpackDepthRGBAShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/VerticalBlurShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/VerticalTiltShiftShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/VignetteShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/VolumeShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './shaders/WaterRefractionShader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$interactive$2f$HTMLMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/interactive/HTMLMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$interactive$2f$InteractiveGroup$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/interactive/InteractiveGroup.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$interactive$2f$SelectionHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/interactive/SelectionHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$interactive$2f$SelectionBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/interactive/SelectionBox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$physics$2f$AmmoPhysics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/physics/AmmoPhysics.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$effects$2f$ParallaxBarrierEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/effects/ParallaxBarrierEffect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$effects$2f$PeppersGhostEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/effects/PeppersGhostEffect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$effects$2f$OutlineEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/effects/OutlineEffect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$effects$2f$AnaglyphEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/effects/AnaglyphEffect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$effects$2f$AsciiEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/effects/AsciiEffect.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './effects/StereoEffect.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$FBXLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/FBXLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$FontLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/FontLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/TGALoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$LUTCubeLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/LUTCubeLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$NRRDLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/NRRDLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/STLLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MTLLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/MTLLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/XLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$BVHLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/BVHLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$KMZLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/KMZLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/VRMLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './loaders/VRMLLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$KTX2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/KTX2Loader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$LottieLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/LottieLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/TTFLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$RGBELoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/RGBELoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$AssimpLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/AssimpLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$ColladaLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/ColladaLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MDDLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/MDDLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$EXRLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/EXRLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$3MFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/3MFLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/XYZLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './loaders/VTKLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$LUT3dlLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/LUT3dlLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$DDSLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/DDSLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$PVRLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/PVRLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$GCodeLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/GCodeLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$BasisTextureLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/BasisTextureLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/TDSLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$LDrawLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/LDrawLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$GLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/GLTFLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/SVGLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$3DMLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/3DMLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$OBJLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/OBJLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$AMFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/AMFLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MMDLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/MMDLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$MD2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/MD2Loader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$KTXLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/KTXLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/TiltLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$DRACOLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/DRACOLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$HDRCubeTextureLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/HDRCubeTextureLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$PDBLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/PDBLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$PRWMLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/PRWMLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$RGBMLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/RGBMLoader.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './loaders/VOXLoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$PCDLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/PCDLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$LWOLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/LWOLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$PLYLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/PLYLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegmentsGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineSegmentsGeometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineGeometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineGeometry.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './lines/Wireframe.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module './lines/WireframeGeometry2.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$Line2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/Line2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineMaterial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lines$2f$LineSegments2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lines/LineSegments2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$helpers$2f$LightProbeHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/helpers/LightProbeHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$helpers$2f$RaycasterHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/helpers/RaycasterHelper.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './helpers/VertexTangentsHelper.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$helpers$2f$PositionalAudioHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/helpers/PositionalAudioHelper.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module './helpers/VertexNormalsHelper.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$helpers$2f$RectAreaLightHelper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/helpers/RectAreaLightHelper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lights$2f$RectAreaLightUniformsLib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lights/RectAreaLightUniformsLib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$lights$2f$LightProbeGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/lights/LightProbeGenerator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/curves/NURBSUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSCurve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/curves/NURBSCurve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSSurface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/curves/NURBSSurface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$CurveExtras$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/curves/CurveExtras.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$deprecated$2f$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/deprecated/Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$MeshoptDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/libs/MeshoptDecoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$MotionControllers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/libs/MotionControllers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three-stdlib/index.js [app-client] (ecmascript) <locals>");
}}),
}]);

//# sourceMappingURL=node_modules_three-stdlib_9c2b18._.js.map