(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_three-stdlib_loaders_236009._.js", {

"[project]/node_modules/three-stdlib/loaders/MD2Loader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MD2Loader": (()=>MD2Loader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _normalData = [
    [
        -0.525731,
        0,
        0.850651
    ],
    [
        -0.442863,
        0.238856,
        0.864188
    ],
    [
        -0.295242,
        0,
        0.955423
    ],
    [
        -0.309017,
        0.5,
        0.809017
    ],
    [
        -0.16246,
        0.262866,
        0.951056
    ],
    [
        0,
        0,
        1
    ],
    [
        0,
        0.850651,
        0.525731
    ],
    [
        -0.147621,
        0.716567,
        0.681718
    ],
    [
        0.147621,
        0.716567,
        0.681718
    ],
    [
        0,
        0.525731,
        0.850651
    ],
    [
        0.309017,
        0.5,
        0.809017
    ],
    [
        0.525731,
        0,
        0.850651
    ],
    [
        0.295242,
        0,
        0.955423
    ],
    [
        0.442863,
        0.238856,
        0.864188
    ],
    [
        0.16246,
        0.262866,
        0.951056
    ],
    [
        -0.681718,
        0.147621,
        0.716567
    ],
    [
        -0.809017,
        0.309017,
        0.5
    ],
    [
        -0.587785,
        0.425325,
        0.688191
    ],
    [
        -0.850651,
        0.525731,
        0
    ],
    [
        -0.864188,
        0.442863,
        0.238856
    ],
    [
        -0.716567,
        0.681718,
        0.147621
    ],
    [
        -0.688191,
        0.587785,
        0.425325
    ],
    [
        -0.5,
        0.809017,
        0.309017
    ],
    [
        -0.238856,
        0.864188,
        0.442863
    ],
    [
        -0.425325,
        0.688191,
        0.587785
    ],
    [
        -0.716567,
        0.681718,
        -0.147621
    ],
    [
        -0.5,
        0.809017,
        -0.309017
    ],
    [
        -0.525731,
        0.850651,
        0
    ],
    [
        0,
        0.850651,
        -0.525731
    ],
    [
        -0.238856,
        0.864188,
        -0.442863
    ],
    [
        0,
        0.955423,
        -0.295242
    ],
    [
        -0.262866,
        0.951056,
        -0.16246
    ],
    [
        0,
        1,
        0
    ],
    [
        0,
        0.955423,
        0.295242
    ],
    [
        -0.262866,
        0.951056,
        0.16246
    ],
    [
        0.238856,
        0.864188,
        0.442863
    ],
    [
        0.262866,
        0.951056,
        0.16246
    ],
    [
        0.5,
        0.809017,
        0.309017
    ],
    [
        0.238856,
        0.864188,
        -0.442863
    ],
    [
        0.262866,
        0.951056,
        -0.16246
    ],
    [
        0.5,
        0.809017,
        -0.309017
    ],
    [
        0.850651,
        0.525731,
        0
    ],
    [
        0.716567,
        0.681718,
        0.147621
    ],
    [
        0.716567,
        0.681718,
        -0.147621
    ],
    [
        0.525731,
        0.850651,
        0
    ],
    [
        0.425325,
        0.688191,
        0.587785
    ],
    [
        0.864188,
        0.442863,
        0.238856
    ],
    [
        0.688191,
        0.587785,
        0.425325
    ],
    [
        0.809017,
        0.309017,
        0.5
    ],
    [
        0.681718,
        0.147621,
        0.716567
    ],
    [
        0.587785,
        0.425325,
        0.688191
    ],
    [
        0.955423,
        0.295242,
        0
    ],
    [
        1,
        0,
        0
    ],
    [
        0.951056,
        0.16246,
        0.262866
    ],
    [
        0.850651,
        -0.525731,
        0
    ],
    [
        0.955423,
        -0.295242,
        0
    ],
    [
        0.864188,
        -0.442863,
        0.238856
    ],
    [
        0.951056,
        -0.16246,
        0.262866
    ],
    [
        0.809017,
        -0.309017,
        0.5
    ],
    [
        0.681718,
        -0.147621,
        0.716567
    ],
    [
        0.850651,
        0,
        0.525731
    ],
    [
        0.864188,
        0.442863,
        -0.238856
    ],
    [
        0.809017,
        0.309017,
        -0.5
    ],
    [
        0.951056,
        0.16246,
        -0.262866
    ],
    [
        0.525731,
        0,
        -0.850651
    ],
    [
        0.681718,
        0.147621,
        -0.716567
    ],
    [
        0.681718,
        -0.147621,
        -0.716567
    ],
    [
        0.850651,
        0,
        -0.525731
    ],
    [
        0.809017,
        -0.309017,
        -0.5
    ],
    [
        0.864188,
        -0.442863,
        -0.238856
    ],
    [
        0.951056,
        -0.16246,
        -0.262866
    ],
    [
        0.147621,
        0.716567,
        -0.681718
    ],
    [
        0.309017,
        0.5,
        -0.809017
    ],
    [
        0.425325,
        0.688191,
        -0.587785
    ],
    [
        0.442863,
        0.238856,
        -0.864188
    ],
    [
        0.587785,
        0.425325,
        -0.688191
    ],
    [
        0.688191,
        0.587785,
        -0.425325
    ],
    [
        -0.147621,
        0.716567,
        -0.681718
    ],
    [
        -0.309017,
        0.5,
        -0.809017
    ],
    [
        0,
        0.525731,
        -0.850651
    ],
    [
        -0.525731,
        0,
        -0.850651
    ],
    [
        -0.442863,
        0.238856,
        -0.864188
    ],
    [
        -0.295242,
        0,
        -0.955423
    ],
    [
        -0.16246,
        0.262866,
        -0.951056
    ],
    [
        0,
        0,
        -1
    ],
    [
        0.295242,
        0,
        -0.955423
    ],
    [
        0.16246,
        0.262866,
        -0.951056
    ],
    [
        -0.442863,
        -0.238856,
        -0.864188
    ],
    [
        -0.309017,
        -0.5,
        -0.809017
    ],
    [
        -0.16246,
        -0.262866,
        -0.951056
    ],
    [
        0,
        -0.850651,
        -0.525731
    ],
    [
        -0.147621,
        -0.716567,
        -0.681718
    ],
    [
        0.147621,
        -0.716567,
        -0.681718
    ],
    [
        0,
        -0.525731,
        -0.850651
    ],
    [
        0.309017,
        -0.5,
        -0.809017
    ],
    [
        0.442863,
        -0.238856,
        -0.864188
    ],
    [
        0.16246,
        -0.262866,
        -0.951056
    ],
    [
        0.238856,
        -0.864188,
        -0.442863
    ],
    [
        0.5,
        -0.809017,
        -0.309017
    ],
    [
        0.425325,
        -0.688191,
        -0.587785
    ],
    [
        0.716567,
        -0.681718,
        -0.147621
    ],
    [
        0.688191,
        -0.587785,
        -0.425325
    ],
    [
        0.587785,
        -0.425325,
        -0.688191
    ],
    [
        0,
        -0.955423,
        -0.295242
    ],
    [
        0,
        -1,
        0
    ],
    [
        0.262866,
        -0.951056,
        -0.16246
    ],
    [
        0,
        -0.850651,
        0.525731
    ],
    [
        0,
        -0.955423,
        0.295242
    ],
    [
        0.238856,
        -0.864188,
        0.442863
    ],
    [
        0.262866,
        -0.951056,
        0.16246
    ],
    [
        0.5,
        -0.809017,
        0.309017
    ],
    [
        0.716567,
        -0.681718,
        0.147621
    ],
    [
        0.525731,
        -0.850651,
        0
    ],
    [
        -0.238856,
        -0.864188,
        -0.442863
    ],
    [
        -0.5,
        -0.809017,
        -0.309017
    ],
    [
        -0.262866,
        -0.951056,
        -0.16246
    ],
    [
        -0.850651,
        -0.525731,
        0
    ],
    [
        -0.716567,
        -0.681718,
        -0.147621
    ],
    [
        -0.716567,
        -0.681718,
        0.147621
    ],
    [
        -0.525731,
        -0.850651,
        0
    ],
    [
        -0.5,
        -0.809017,
        0.309017
    ],
    [
        -0.238856,
        -0.864188,
        0.442863
    ],
    [
        -0.262866,
        -0.951056,
        0.16246
    ],
    [
        -0.864188,
        -0.442863,
        0.238856
    ],
    [
        -0.809017,
        -0.309017,
        0.5
    ],
    [
        -0.688191,
        -0.587785,
        0.425325
    ],
    [
        -0.681718,
        -0.147621,
        0.716567
    ],
    [
        -0.442863,
        -0.238856,
        0.864188
    ],
    [
        -0.587785,
        -0.425325,
        0.688191
    ],
    [
        -0.309017,
        -0.5,
        0.809017
    ],
    [
        -0.147621,
        -0.716567,
        0.681718
    ],
    [
        -0.425325,
        -0.688191,
        0.587785
    ],
    [
        -0.16246,
        -0.262866,
        0.951056
    ],
    [
        0.442863,
        -0.238856,
        0.864188
    ],
    [
        0.16246,
        -0.262866,
        0.951056
    ],
    [
        0.309017,
        -0.5,
        0.809017
    ],
    [
        0.147621,
        -0.716567,
        0.681718
    ],
    [
        0,
        -0.525731,
        0.850651
    ],
    [
        0.425325,
        -0.688191,
        0.587785
    ],
    [
        0.587785,
        -0.425325,
        0.688191
    ],
    [
        0.688191,
        -0.587785,
        0.425325
    ],
    [
        -0.955423,
        0.295242,
        0
    ],
    [
        -0.951056,
        0.16246,
        0.262866
    ],
    [
        -1,
        0,
        0
    ],
    [
        -0.850651,
        0,
        0.525731
    ],
    [
        -0.955423,
        -0.295242,
        0
    ],
    [
        -0.951056,
        -0.16246,
        0.262866
    ],
    [
        -0.864188,
        0.442863,
        -0.238856
    ],
    [
        -0.951056,
        0.16246,
        -0.262866
    ],
    [
        -0.809017,
        0.309017,
        -0.5
    ],
    [
        -0.864188,
        -0.442863,
        -0.238856
    ],
    [
        -0.951056,
        -0.16246,
        -0.262866
    ],
    [
        -0.809017,
        -0.309017,
        -0.5
    ],
    [
        -0.681718,
        0.147621,
        -0.716567
    ],
    [
        -0.681718,
        -0.147621,
        -0.716567
    ],
    [
        -0.850651,
        0,
        -0.525731
    ],
    [
        -0.688191,
        0.587785,
        -0.425325
    ],
    [
        -0.587785,
        0.425325,
        -0.688191
    ],
    [
        -0.425325,
        0.688191,
        -0.587785
    ],
    [
        -0.425325,
        -0.688191,
        -0.587785
    ],
    [
        -0.587785,
        -0.425325,
        -0.688191
    ],
    [
        -0.688191,
        -0.587785,
        -0.425325
    ]
];
class MD2Loader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            try {
                onLoad(scope.parse(buffer));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(buffer) {
        const data = new DataView(buffer);
        const header = {};
        const headerNames = [
            "ident",
            "version",
            "skinwidth",
            "skinheight",
            "framesize",
            "num_skins",
            "num_vertices",
            "num_st",
            "num_tris",
            "num_glcmds",
            "num_frames",
            "offset_skins",
            "offset_st",
            "offset_tris",
            "offset_frames",
            "offset_glcmds",
            "offset_end"
        ];
        for(let i = 0; i < headerNames.length; i++){
            header[headerNames[i]] = data.getInt32(i * 4, true);
        }
        if (header.ident !== 844121161 || header.version !== 8) {
            console.error("Not a valid MD2 file");
            return;
        }
        if (header.offset_end !== data.byteLength) {
            console.error("Corrupted MD2 file");
            return;
        }
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        const uvsTemp = [];
        let offset = header.offset_st;
        for(let i = 0, l = header.num_st; i < l; i++){
            const u = data.getInt16(offset + 0, true);
            const v = data.getInt16(offset + 2, true);
            uvsTemp.push(u / header.skinwidth, 1 - v / header.skinheight);
            offset += 4;
        }
        offset = header.offset_tris;
        const vertexIndices = [];
        const uvIndices = [];
        for(let i = 0, l = header.num_tris; i < l; i++){
            vertexIndices.push(data.getUint16(offset + 0, true), data.getUint16(offset + 2, true), data.getUint16(offset + 4, true));
            uvIndices.push(data.getUint16(offset + 6, true), data.getUint16(offset + 8, true), data.getUint16(offset + 10, true));
            offset += 12;
        }
        const translation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const string = [];
        const frames = [];
        offset = header.offset_frames;
        for(let i = 0, l = header.num_frames; i < l; i++){
            scale.set(data.getFloat32(offset + 0, true), data.getFloat32(offset + 4, true), data.getFloat32(offset + 8, true));
            translation.set(data.getFloat32(offset + 12, true), data.getFloat32(offset + 16, true), data.getFloat32(offset + 20, true));
            offset += 24;
            for(let j = 0; j < 16; j++){
                const character = data.getUint8(offset + j, true);
                if (character === 0) break;
                string[j] = character;
            }
            const frame = {
                name: String.fromCharCode.apply(null, string),
                vertices: [],
                normals: []
            };
            offset += 16;
            for(let j = 0; j < header.num_vertices; j++){
                let x = data.getUint8(offset++, true);
                let y = data.getUint8(offset++, true);
                let z = data.getUint8(offset++, true);
                const n = _normalData[data.getUint8(offset++, true)];
                x = x * scale.x + translation.x;
                y = y * scale.y + translation.y;
                z = z * scale.z + translation.z;
                frame.vertices.push(x, z, y);
                frame.normals.push(n[0], n[2], n[1]);
            }
            frames.push(frame);
        }
        const positions = [];
        const normals = [];
        const uvs = [];
        const verticesTemp = frames[0].vertices;
        const normalsTemp = frames[0].normals;
        for(let i = 0, l = vertexIndices.length; i < l; i++){
            const vertexIndex = vertexIndices[i];
            let stride = vertexIndex * 3;
            const x = verticesTemp[stride];
            const y = verticesTemp[stride + 1];
            const z = verticesTemp[stride + 2];
            positions.push(x, y, z);
            const nx = normalsTemp[stride];
            const ny = normalsTemp[stride + 1];
            const nz = normalsTemp[stride + 2];
            normals.push(nx, ny, nz);
            const uvIndex = uvIndices[i];
            stride = uvIndex * 2;
            const u = uvsTemp[stride];
            const v = uvsTemp[stride + 1];
            uvs.push(u, v);
        }
        geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positions, 3));
        geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normals, 3));
        geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uvs, 2));
        const morphPositions = [];
        const morphNormals = [];
        for(let i = 0, l = frames.length; i < l; i++){
            const frame = frames[i];
            const attributeName = frame.name;
            if (frame.vertices.length > 0) {
                const positions2 = [];
                for(let j = 0, jl = vertexIndices.length; j < jl; j++){
                    const vertexIndex = vertexIndices[j];
                    const stride = vertexIndex * 3;
                    const x = frame.vertices[stride];
                    const y = frame.vertices[stride + 1];
                    const z = frame.vertices[stride + 2];
                    positions2.push(x, y, z);
                }
                const positionAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positions2, 3);
                positionAttribute.name = attributeName;
                morphPositions.push(positionAttribute);
            }
            if (frame.normals.length > 0) {
                const normals2 = [];
                for(let j = 0, jl = vertexIndices.length; j < jl; j++){
                    const vertexIndex = vertexIndices[j];
                    const stride = vertexIndex * 3;
                    const nx = frame.normals[stride];
                    const ny = frame.normals[stride + 1];
                    const nz = frame.normals[stride + 2];
                    normals2.push(nx, ny, nz);
                }
                const normalAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normals2, 3);
                normalAttribute.name = attributeName;
                morphNormals.push(normalAttribute);
            }
        }
        geometry.morphAttributes.position = morphPositions;
        geometry.morphAttributes.normal = morphNormals;
        geometry.morphTargetsRelative = false;
        geometry.animations = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"].CreateClipsFromMorphTargetSequences(frames, 10);
        return geometry;
    }
}
;
 //# sourceMappingURL=MD2Loader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/FBXLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "FBXLoader": (()=>FBXLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSCurve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/curves/NURBSCurve.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module '../_polyfill/uv1.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)");
;
;
;
;
;
let fbxTree;
let connections;
let sceneGraph;
class FBXLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = scope.path === "" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url) : scope.path;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            try {
                onLoad(scope.parse(buffer, path));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(FBXBuffer, path) {
        if (isFbxFormatBinary(FBXBuffer)) {
            fbxTree = new BinaryParser().parse(FBXBuffer);
        } else {
            const FBXText = convertArrayBufferToString(FBXBuffer);
            if (!isFbxFormatASCII(FBXText)) {
                throw new Error("THREE.FBXLoader: Unknown format.");
            }
            if (getFbxVersion(FBXText) < 7e3) {
                throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
            }
            fbxTree = new TextParser().parse(FBXText);
        }
        const textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
    }
}
class FBXTreeParser {
    constructor(textureLoader, manager){
        this.textureLoader = textureLoader;
        this.manager = manager;
    }
    parse() {
        connections = this.parseConnections();
        const images = this.parseImages();
        const textures = this.parseTextures(images);
        const materials = this.parseMaterials(textures);
        const deformers = this.parseDeformers();
        const geometryMap = new GeometryParser().parse(deformers);
        this.parseScene(deformers, geometryMap, materials);
        return sceneGraph;
    }
    // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
    // and details the connection type
    parseConnections() {
        const connectionMap = /* @__PURE__ */ new Map();
        if ("Connections" in fbxTree) {
            const rawConnections = fbxTree.Connections.connections;
            rawConnections.forEach(function(rawConnection) {
                const fromID = rawConnection[0];
                const toID = rawConnection[1];
                const relationship = rawConnection[2];
                if (!connectionMap.has(fromID)) {
                    connectionMap.set(fromID, {
                        parents: [],
                        children: []
                    });
                }
                const parentRelationship = {
                    ID: toID,
                    relationship
                };
                connectionMap.get(fromID).parents.push(parentRelationship);
                if (!connectionMap.has(toID)) {
                    connectionMap.set(toID, {
                        parents: [],
                        children: []
                    });
                }
                const childRelationship = {
                    ID: fromID,
                    relationship
                };
                connectionMap.get(toID).children.push(childRelationship);
            });
        }
        return connectionMap;
    }
    // Parse FBXTree.Objects.Video for embedded image data
    // These images are connected to textures in FBXTree.Objects.Textures
    // via FBXTree.Connections.
    parseImages() {
        const images = {};
        const blobs = {};
        if ("Video" in fbxTree.Objects) {
            const videoNodes = fbxTree.Objects.Video;
            for(const nodeID in videoNodes){
                const videoNode = videoNodes[nodeID];
                const id = parseInt(nodeID);
                images[id] = videoNode.RelativeFilename || videoNode.Filename;
                if ("Content" in videoNode) {
                    const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
                    const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
                    if (arrayBufferContent || base64Content) {
                        const image = this.parseImage(videoNodes[nodeID]);
                        blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
                    }
                }
            }
        }
        for(const id in images){
            const filename = images[id];
            if (blobs[filename] !== void 0) images[id] = blobs[filename];
            else images[id] = images[id].split("\\").pop();
        }
        return images;
    }
    // Parse embedded image data in FBXTree.Video.Content
    parseImage(videoNode) {
        const content = videoNode.Content;
        const fileName = videoNode.RelativeFilename || videoNode.Filename;
        const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
        let type;
        switch(extension){
            case "bmp":
                type = "image/bmp";
                break;
            case "jpg":
            case "jpeg":
                type = "image/jpeg";
                break;
            case "png":
                type = "image/png";
                break;
            case "tif":
                type = "image/tiff";
                break;
            case "tga":
                if (this.manager.getHandler(".tga") === null) {
                    console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
                }
                type = "image/tga";
                break;
            default:
                console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
                return;
        }
        if (typeof content === "string") {
            return "data:" + type + ";base64," + content;
        } else {
            const array = new Uint8Array(content);
            return window.URL.createObjectURL(new Blob([
                array
            ], {
                type
            }));
        }
    }
    // Parse nodes in FBXTree.Objects.Texture
    // These contain details such as UV scaling, cropping, rotation etc and are connected
    // to images in FBXTree.Objects.Video
    parseTextures(images) {
        const textureMap = /* @__PURE__ */ new Map();
        if ("Texture" in fbxTree.Objects) {
            const textureNodes = fbxTree.Objects.Texture;
            for(const nodeID in textureNodes){
                const texture = this.parseTexture(textureNodes[nodeID], images);
                textureMap.set(parseInt(nodeID), texture);
            }
        }
        return textureMap;
    }
    // Parse individual node in FBXTree.Objects.Texture
    parseTexture(textureNode, images) {
        const texture = this.loadTexture(textureNode, images);
        texture.ID = textureNode.id;
        texture.name = textureNode.attrName;
        const wrapModeU = textureNode.WrapModeU;
        const wrapModeV = textureNode.WrapModeV;
        const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
        const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
        texture.wrapS = valueU === 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture.wrapT = valueV === 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        if ("Scaling" in textureNode) {
            const values = textureNode.Scaling.value;
            texture.repeat.x = values[0];
            texture.repeat.y = values[1];
        }
        return texture;
    }
    // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
    loadTexture(textureNode, images) {
        let fileName;
        const currentPath = this.textureLoader.path;
        const children = connections.get(textureNode.id).children;
        if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
            fileName = images[children[0].ID];
            if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
                this.textureLoader.setPath(void 0);
            }
        }
        let texture;
        const extension = textureNode.FileName.slice(-3).toLowerCase();
        if (extension === "tga") {
            const loader = this.manager.getHandler(".tga");
            if (loader === null) {
                console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
                texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]();
            } else {
                loader.setPath(this.textureLoader.path);
                texture = loader.load(fileName);
            }
        } else if (extension === "psd") {
            console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
            texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]();
        } else {
            texture = this.textureLoader.load(fileName);
        }
        this.textureLoader.setPath(currentPath);
        return texture;
    }
    // Parse nodes in FBXTree.Objects.Material
    parseMaterials(textureMap) {
        const materialMap = /* @__PURE__ */ new Map();
        if ("Material" in fbxTree.Objects) {
            const materialNodes = fbxTree.Objects.Material;
            for(const nodeID in materialNodes){
                const material = this.parseMaterial(materialNodes[nodeID], textureMap);
                if (material !== null) materialMap.set(parseInt(nodeID), material);
            }
        }
        return materialMap;
    }
    // Parse single node in FBXTree.Objects.Material
    // Materials are connected to texture maps in FBXTree.Objects.Textures
    // FBX format currently only supports Lambert and Phong shading models
    parseMaterial(materialNode, textureMap) {
        const ID = materialNode.id;
        const name = materialNode.attrName;
        let type = materialNode.ShadingModel;
        if (typeof type === "object") {
            type = type.value;
        }
        if (!connections.has(ID)) return null;
        const parameters = this.parseParameters(materialNode, textureMap, ID);
        let material;
        switch(type.toLowerCase()){
            case "phong":
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]();
                break;
            case "lambert":
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]();
                break;
            default:
                console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]();
                break;
        }
        material.setValues(parameters);
        material.name = name;
        return material;
    }
    // Parse FBX material and return parameters suitable for a three.js material
    // Also parse the texture map and return any textures associated with the material
    parseParameters(materialNode, textureMap, ID) {
        const parameters = {};
        if (materialNode.BumpFactor) {
            parameters.bumpScale = materialNode.BumpFactor.value;
        }
        if (materialNode.Diffuse) {
            parameters.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(materialNode.Diffuse.value);
        } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
            parameters.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(materialNode.DiffuseColor.value);
        }
        if (materialNode.DisplacementFactor) {
            parameters.displacementScale = materialNode.DisplacementFactor.value;
        }
        if (materialNode.Emissive) {
            parameters.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(materialNode.Emissive.value);
        } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
            parameters.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(materialNode.EmissiveColor.value);
        }
        if (materialNode.EmissiveFactor) {
            parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
        }
        if (materialNode.Opacity) {
            parameters.opacity = parseFloat(materialNode.Opacity.value);
        }
        if (parameters.opacity < 1) {
            parameters.transparent = true;
        }
        if (materialNode.ReflectionFactor) {
            parameters.reflectivity = materialNode.ReflectionFactor.value;
        }
        if (materialNode.Shininess) {
            parameters.shininess = materialNode.Shininess.value;
        }
        if (materialNode.Specular) {
            parameters.specular = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(materialNode.Specular.value);
        } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
            parameters.specular = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(materialNode.SpecularColor.value);
        }
        const scope = this;
        connections.get(ID).children.forEach(function(child) {
            const type = child.relationship;
            switch(type){
                case "Bump":
                    parameters.bumpMap = scope.getTexture(textureMap, child.ID);
                    break;
                case "Maya|TEX_ao_map":
                    parameters.aoMap = scope.getTexture(textureMap, child.ID);
                    break;
                case "DiffuseColor":
                case "Maya|TEX_color_map":
                    parameters.map = scope.getTexture(textureMap, child.ID);
                    if (parameters.map !== void 0) {
                        if ("colorSpace" in parameters.map) parameters.map.colorSpace = "srgb";
                        else parameters.map.encoding = 3001;
                    }
                    break;
                case "DisplacementColor":
                    parameters.displacementMap = scope.getTexture(textureMap, child.ID);
                    break;
                case "EmissiveColor":
                    parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
                    if (parameters.emissiveMap !== void 0) {
                        if ("colorSpace" in parameters.emissiveMap) parameters.emissiveMap.colorSpace = "srgb";
                        else parameters.emissiveMap.encoding = 3001;
                    }
                    break;
                case "NormalMap":
                case "Maya|TEX_normal_map":
                    parameters.normalMap = scope.getTexture(textureMap, child.ID);
                    break;
                case "ReflectionColor":
                    parameters.envMap = scope.getTexture(textureMap, child.ID);
                    if (parameters.envMap !== void 0) {
                        parameters.envMap.mapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EquirectangularReflectionMapping"];
                        if ("colorSpace" in parameters.envMap) parameters.envMap.colorSpace = "srgb";
                        else parameters.envMap.encoding = 3001;
                    }
                    break;
                case "SpecularColor":
                    parameters.specularMap = scope.getTexture(textureMap, child.ID);
                    if (parameters.specularMap !== void 0) {
                        if ("colorSpace" in parameters.specularMap) parameters.specularMap.colorSpace = "srgb";
                        else parameters.specularMap.encoding = 3001;
                    }
                    break;
                case "TransparentColor":
                case "TransparencyFactor":
                    parameters.alphaMap = scope.getTexture(textureMap, child.ID);
                    parameters.transparent = true;
                    break;
                case "AmbientColor":
                case "ShininessExponent":
                case "SpecularFactor":
                case "VectorDisplacementColor":
                default:
                    console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
                    break;
            }
        });
        return parameters;
    }
    // get a texture from the textureMap for use by a material.
    getTexture(textureMap, id) {
        if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
            console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
            id = connections.get(id).children[0].ID;
        }
        return textureMap.get(id);
    }
    // Parse nodes in FBXTree.Objects.Deformer
    // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
    // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
    parseDeformers() {
        const skeletons = {};
        const morphTargets = {};
        if ("Deformer" in fbxTree.Objects) {
            const DeformerNodes = fbxTree.Objects.Deformer;
            for(const nodeID in DeformerNodes){
                const deformerNode = DeformerNodes[nodeID];
                const relationships = connections.get(parseInt(nodeID));
                if (deformerNode.attrType === "Skin") {
                    const skeleton = this.parseSkeleton(relationships, DeformerNodes);
                    skeleton.ID = nodeID;
                    if (relationships.parents.length > 1) {
                        console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
                    }
                    skeleton.geometryID = relationships.parents[0].ID;
                    skeletons[nodeID] = skeleton;
                } else if (deformerNode.attrType === "BlendShape") {
                    const morphTarget = {
                        id: nodeID
                    };
                    morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
                    morphTarget.id = nodeID;
                    if (relationships.parents.length > 1) {
                        console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
                    }
                    morphTargets[nodeID] = morphTarget;
                }
            }
        }
        return {
            skeletons,
            morphTargets
        };
    }
    // Parse single nodes in FBXTree.Objects.Deformer
    // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
    // Each skin node represents a skeleton and each cluster node represents a bone
    parseSkeleton(relationships, deformerNodes) {
        const rawBones = [];
        relationships.children.forEach(function(child) {
            const boneNode = deformerNodes[child.ID];
            if (boneNode.attrType !== "Cluster") return;
            const rawBone = {
                ID: child.ID,
                indices: [],
                weights: [],
                transformLink: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().fromArray(boneNode.TransformLink.a)
            };
            if ("Indexes" in boneNode) {
                rawBone.indices = boneNode.Indexes.a;
                rawBone.weights = boneNode.Weights.a;
            }
            rawBones.push(rawBone);
        });
        return {
            rawBones,
            bones: []
        };
    }
    // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
    parseMorphTargets(relationships, deformerNodes) {
        const rawMorphTargets = [];
        for(let i = 0; i < relationships.children.length; i++){
            const child = relationships.children[i];
            const morphTargetNode = deformerNodes[child.ID];
            const rawMorphTarget = {
                name: morphTargetNode.attrName,
                initialWeight: morphTargetNode.DeformPercent,
                id: morphTargetNode.id,
                fullWeights: morphTargetNode.FullWeights.a
            };
            if (morphTargetNode.attrType !== "BlendShapeChannel") return;
            rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
                return child2.relationship === void 0;
            })[0].ID;
            rawMorphTargets.push(rawMorphTarget);
        }
        return rawMorphTargets;
    }
    // create the main Group() to be returned by the loader
    parseScene(deformers, geometryMap, materialMap) {
        sceneGraph = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
        const modelNodes = fbxTree.Objects.Model;
        const scope = this;
        modelMap.forEach(function(model) {
            const modelNode = modelNodes[model.ID];
            scope.setLookAtProperties(model, modelNode);
            const parentConnections = connections.get(model.ID).parents;
            parentConnections.forEach(function(connection) {
                const parent = modelMap.get(connection.ID);
                if (parent !== void 0) parent.add(model);
            });
            if (model.parent === null) {
                sceneGraph.add(model);
            }
        });
        this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
        this.createAmbientLight();
        sceneGraph.traverse(function(node) {
            if (node.userData.transformData) {
                if (node.parent) {
                    node.userData.transformData.parentMatrix = node.parent.matrix;
                    node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
                }
                const transform = generateTransform(node.userData.transformData);
                node.applyMatrix4(transform);
                node.updateWorldMatrix();
            }
        });
        const animations = new AnimationParser().parse();
        if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
            sceneGraph.children[0].animations = animations;
            sceneGraph = sceneGraph.children[0];
        }
        sceneGraph.animations = animations;
    }
    // parse nodes in FBXTree.Objects.Model
    parseModels(skeletons, geometryMap, materialMap) {
        const modelMap = /* @__PURE__ */ new Map();
        const modelNodes = fbxTree.Objects.Model;
        for(const nodeID in modelNodes){
            const id = parseInt(nodeID);
            const node = modelNodes[nodeID];
            const relationships = connections.get(id);
            let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
            if (!model) {
                switch(node.attrType){
                    case "Camera":
                        model = this.createCamera(relationships);
                        break;
                    case "Light":
                        model = this.createLight(relationships);
                        break;
                    case "Mesh":
                        model = this.createMesh(relationships, geometryMap, materialMap);
                        break;
                    case "NurbsCurve":
                        model = this.createCurve(relationships, geometryMap);
                        break;
                    case "LimbNode":
                    case "Root":
                        model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]();
                        break;
                    case "Null":
                    default:
                        model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
                        break;
                }
                model.name = node.attrName ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PropertyBinding"].sanitizeNodeName(node.attrName) : "";
                model.ID = id;
            }
            this.getTransformData(model, node);
            modelMap.set(id, model);
        }
        return modelMap;
    }
    buildSkeleton(relationships, skeletons, id, name) {
        let bone = null;
        relationships.parents.forEach(function(parent) {
            for(const ID in skeletons){
                const skeleton = skeletons[ID];
                skeleton.rawBones.forEach(function(rawBone, i) {
                    if (rawBone.ID === parent.ID) {
                        const subBone = bone;
                        bone = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]();
                        bone.matrixWorld.copy(rawBone.transformLink);
                        bone.name = name ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PropertyBinding"].sanitizeNodeName(name) : "";
                        bone.ID = id;
                        skeleton.bones[i] = bone;
                        if (subBone !== null) {
                            bone.add(subBone);
                        }
                    }
                });
            }
        });
        return bone;
    }
    // create a PerspectiveCamera or OrthographicCamera
    createCamera(relationships) {
        let model;
        let cameraAttribute;
        relationships.children.forEach(function(child) {
            const attr = fbxTree.Objects.NodeAttribute[child.ID];
            if (attr !== void 0) {
                cameraAttribute = attr;
            }
        });
        if (cameraAttribute === void 0) {
            model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
        } else {
            let type = 0;
            if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
                type = 1;
            }
            let nearClippingPlane = 1;
            if (cameraAttribute.NearPlane !== void 0) {
                nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
            }
            let farClippingPlane = 1e3;
            if (cameraAttribute.FarPlane !== void 0) {
                farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
            }
            let width = window.innerWidth;
            let height = window.innerHeight;
            if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
                width = cameraAttribute.AspectWidth.value;
                height = cameraAttribute.AspectHeight.value;
            }
            const aspect = width / height;
            let fov = 45;
            if (cameraAttribute.FieldOfView !== void 0) {
                fov = cameraAttribute.FieldOfView.value;
            }
            const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
            switch(type){
                case 0:
                    model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"](fov, aspect, nearClippingPlane, farClippingPlane);
                    if (focalLength !== null) model.setFocalLength(focalLength);
                    break;
                case 1:
                    model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
                    break;
                default:
                    console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
                    model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
                    break;
            }
        }
        return model;
    }
    // Create a DirectionalLight, PointLight or SpotLight
    createLight(relationships) {
        let model;
        let lightAttribute;
        relationships.children.forEach(function(child) {
            const attr = fbxTree.Objects.NodeAttribute[child.ID];
            if (attr !== void 0) {
                lightAttribute = attr;
            }
        });
        if (lightAttribute === void 0) {
            model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
        } else {
            let type;
            if (lightAttribute.LightType === void 0) {
                type = 0;
            } else {
                type = lightAttribute.LightType.value;
            }
            let color = 16777215;
            if (lightAttribute.Color !== void 0) {
                color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(lightAttribute.Color.value);
            }
            let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
            if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
                intensity = 0;
            }
            let distance = 0;
            if (lightAttribute.FarAttenuationEnd !== void 0) {
                if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
                    distance = 0;
                } else {
                    distance = lightAttribute.FarAttenuationEnd.value;
                }
            }
            const decay = 1;
            switch(type){
                case 0:
                    model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"](color, intensity, distance, decay);
                    break;
                case 1:
                    model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DirectionalLight"](color, intensity);
                    break;
                case 2:
                    let angle = Math.PI / 3;
                    if (lightAttribute.InnerAngle !== void 0) {
                        angle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(lightAttribute.InnerAngle.value);
                    }
                    let penumbra = 0;
                    if (lightAttribute.OuterAngle !== void 0) {
                        penumbra = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(lightAttribute.OuterAngle.value);
                        penumbra = Math.max(penumbra, 1);
                    }
                    model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpotLight"](color, intensity, distance, angle, penumbra, decay);
                    break;
                default:
                    console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
                    model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"](color, intensity);
                    break;
            }
            if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
                model.castShadow = true;
            }
        }
        return model;
    }
    createMesh(relationships, geometryMap, materialMap) {
        let model;
        let geometry = null;
        let material = null;
        const materials = [];
        relationships.children.forEach(function(child) {
            if (geometryMap.has(child.ID)) {
                geometry = geometryMap.get(child.ID);
            }
            if (materialMap.has(child.ID)) {
                materials.push(materialMap.get(child.ID));
            }
        });
        if (materials.length > 1) {
            material = materials;
        } else if (materials.length > 0) {
            material = materials[0];
        } else {
            material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]({
                color: 13421772
            });
            materials.push(material);
        }
        if ("color" in geometry.attributes) {
            materials.forEach(function(material2) {
                material2.vertexColors = true;
            });
        }
        if (geometry.FBX_Deformer) {
            model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkinnedMesh"](geometry, material);
            model.normalizeSkinWeights();
        } else {
            model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
        }
        return model;
    }
    createCurve(relationships, geometryMap) {
        const geometry = relationships.children.reduce(function(geo, child) {
            if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);
            return geo;
        }, null);
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
            color: 3342591,
            linewidth: 1
        });
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](geometry, material);
    }
    // parse the model node for transform data
    getTransformData(model, modelNode) {
        const transformData = {};
        if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        else transformData.eulerOrder = "ZYX";
        if ("Lcl_Translation" in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
        if ("PreRotation" in modelNode) transformData.preRotation = modelNode.PreRotation.value;
        if ("Lcl_Rotation" in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
        if ("PostRotation" in modelNode) transformData.postRotation = modelNode.PostRotation.value;
        if ("Lcl_Scaling" in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
        if ("ScalingOffset" in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
        if ("ScalingPivot" in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
        if ("RotationOffset" in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
        if ("RotationPivot" in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;
        model.userData.transformData = transformData;
    }
    setLookAtProperties(model, modelNode) {
        if ("LookAtProperty" in modelNode) {
            const children = connections.get(model.ID).children;
            children.forEach(function(child) {
                if (child.relationship === "LookAtProperty") {
                    const lookAtTarget = fbxTree.Objects.Model[child.ID];
                    if ("Lcl_Translation" in lookAtTarget) {
                        const pos = lookAtTarget.Lcl_Translation.value;
                        if (model.target !== void 0) {
                            model.target.position.fromArray(pos);
                            sceneGraph.add(model.target);
                        } else {
                            model.lookAt(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(pos));
                        }
                    }
                }
            });
        }
    }
    bindSkeleton(skeletons, geometryMap, modelMap) {
        const bindMatrices = this.parsePoseNodes();
        for(const ID in skeletons){
            const skeleton = skeletons[ID];
            const parents = connections.get(parseInt(skeleton.ID)).parents;
            parents.forEach(function(parent) {
                if (geometryMap.has(parent.ID)) {
                    const geoID = parent.ID;
                    const geoRelationships = connections.get(geoID);
                    geoRelationships.parents.forEach(function(geoConnParent) {
                        if (modelMap.has(geoConnParent.ID)) {
                            const model = modelMap.get(geoConnParent.ID);
                            model.bind(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Skeleton"](skeleton.bones), bindMatrices[geoConnParent.ID]);
                        }
                    });
                }
            });
        }
    }
    parsePoseNodes() {
        const bindMatrices = {};
        if ("Pose" in fbxTree.Objects) {
            const BindPoseNode = fbxTree.Objects.Pose;
            for(const nodeID in BindPoseNode){
                if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
                    const poseNodes = BindPoseNode[nodeID].PoseNode;
                    if (Array.isArray(poseNodes)) {
                        poseNodes.forEach(function(poseNode) {
                            bindMatrices[poseNode.Node] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().fromArray(poseNode.Matrix.a);
                        });
                    } else {
                        bindMatrices[poseNodes.Node] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().fromArray(poseNodes.Matrix.a);
                    }
                }
            }
        }
        return bindMatrices;
    }
    // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
    createAmbientLight() {
        if ("GlobalSettings" in fbxTree && "AmbientColor" in fbxTree.GlobalSettings) {
            const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
            const r = ambientColor[0];
            const g = ambientColor[1];
            const b = ambientColor[2];
            if (r !== 0 || g !== 0 || b !== 0) {
                const color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](r, g, b);
                sceneGraph.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AmbientLight"](color, 1));
            }
        }
    }
}
class GeometryParser {
    // Parse nodes in FBXTree.Objects.Geometry
    parse(deformers) {
        const geometryMap = /* @__PURE__ */ new Map();
        if ("Geometry" in fbxTree.Objects) {
            const geoNodes = fbxTree.Objects.Geometry;
            for(const nodeID in geoNodes){
                const relationships = connections.get(parseInt(nodeID));
                const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
                geometryMap.set(parseInt(nodeID), geo);
            }
        }
        return geometryMap;
    }
    // Parse single node in FBXTree.Objects.Geometry
    parseGeometry(relationships, geoNode, deformers) {
        switch(geoNode.attrType){
            case "Mesh":
                return this.parseMeshGeometry(relationships, geoNode, deformers);
            case "NurbsCurve":
                return this.parseNurbsGeometry(geoNode);
        }
    }
    // Parse single node mesh geometry in FBXTree.Objects.Geometry
    parseMeshGeometry(relationships, geoNode, deformers) {
        const skeletons = deformers.skeletons;
        const morphTargets = [];
        const modelNodes = relationships.parents.map(function(parent) {
            return fbxTree.Objects.Model[parent.ID];
        });
        if (modelNodes.length === 0) return;
        const skeleton = relationships.children.reduce(function(skeleton2, child) {
            if (skeletons[child.ID] !== void 0) skeleton2 = skeletons[child.ID];
            return skeleton2;
        }, null);
        relationships.children.forEach(function(child) {
            if (deformers.morphTargets[child.ID] !== void 0) {
                morphTargets.push(deformers.morphTargets[child.ID]);
            }
        });
        const modelNode = modelNodes[0];
        const transformData = {};
        if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("GeometricTranslation" in modelNode) transformData.translation = modelNode.GeometricTranslation.value;
        if ("GeometricRotation" in modelNode) transformData.rotation = modelNode.GeometricRotation.value;
        if ("GeometricScaling" in modelNode) transformData.scale = modelNode.GeometricScaling.value;
        const transform = generateTransform(transformData);
        return this.genGeometry(geoNode, skeleton, morphTargets, transform);
    }
    // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
    genGeometry(geoNode, skeleton, morphTargets, preTransform) {
        const geo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        if (geoNode.attrName) geo.name = geoNode.attrName;
        const geoInfo = this.parseGeoNode(geoNode, skeleton);
        const buffers = this.genBuffers(geoInfo);
        const positionAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffers.vertex, 3);
        positionAttribute.applyMatrix4(preTransform);
        geo.setAttribute("position", positionAttribute);
        if (buffers.colors.length > 0) {
            geo.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffers.colors, 3));
        }
        if (skeleton) {
            geo.setAttribute("skinIndex", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Uint16BufferAttribute"](buffers.weightsIndices, 4));
            geo.setAttribute("skinWeight", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffers.vertexWeights, 4));
            geo.FBX_Deformer = skeleton;
        }
        if (buffers.normal.length > 0) {
            const normalMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]().getNormalMatrix(preTransform);
            const normalAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffers.normal, 3);
            normalAttribute.applyNormalMatrix(normalMatrix);
            geo.setAttribute("normal", normalAttribute);
        }
        buffers.uvs.forEach(function(uvBuffer, i) {
            if (UV1 === "uv2") i++;
            const name = i === 0 ? "uv" : `uv${i}`;
            geo.setAttribute(name, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffers.uvs[i], 2));
        });
        if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            let prevMaterialIndex = buffers.materialIndex[0];
            let startIndex = 0;
            buffers.materialIndex.forEach(function(currentIndex, i) {
                if (currentIndex !== prevMaterialIndex) {
                    geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
                    prevMaterialIndex = currentIndex;
                    startIndex = i;
                }
            });
            if (geo.groups.length > 0) {
                const lastGroup = geo.groups[geo.groups.length - 1];
                const lastIndex = lastGroup.start + lastGroup.count;
                if (lastIndex !== buffers.materialIndex.length) {
                    geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
                }
            }
            if (geo.groups.length === 0) {
                geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
            }
        }
        this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
        return geo;
    }
    parseGeoNode(geoNode, skeleton) {
        const geoInfo = {};
        geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
        geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
        if (geoNode.LayerElementColor) {
            geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
        }
        if (geoNode.LayerElementMaterial) {
            geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
        }
        if (geoNode.LayerElementNormal) {
            geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
        }
        if (geoNode.LayerElementUV) {
            geoInfo.uv = [];
            let i = 0;
            while(geoNode.LayerElementUV[i]){
                if (geoNode.LayerElementUV[i].UV) {
                    geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
                }
                i++;
            }
        }
        geoInfo.weightTable = {};
        if (skeleton !== null) {
            geoInfo.skeleton = skeleton;
            skeleton.rawBones.forEach(function(rawBone, i) {
                rawBone.indices.forEach(function(index, j) {
                    if (geoInfo.weightTable[index] === void 0) geoInfo.weightTable[index] = [];
                    geoInfo.weightTable[index].push({
                        id: i,
                        weight: rawBone.weights[j]
                    });
                });
            });
        }
        return geoInfo;
    }
    genBuffers(geoInfo) {
        const buffers = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
        };
        let polygonIndex = 0;
        let faceLength = 0;
        let displayedWeightsWarning = false;
        let facePositionIndexes = [];
        let faceNormals = [];
        let faceColors = [];
        let faceUVs = [];
        let faceWeights = [];
        let faceWeightIndices = [];
        const scope = this;
        geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
            let materialIndex;
            let endOfFace = false;
            if (vertexIndex < 0) {
                vertexIndex = vertexIndex ^ -1;
                endOfFace = true;
            }
            let weightIndices = [];
            let weights = [];
            facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
            if (geoInfo.color) {
                const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
                faceColors.push(data[0], data[1], data[2]);
            }
            if (geoInfo.skeleton) {
                if (geoInfo.weightTable[vertexIndex] !== void 0) {
                    geoInfo.weightTable[vertexIndex].forEach(function(wt) {
                        weights.push(wt.weight);
                        weightIndices.push(wt.id);
                    });
                }
                if (weights.length > 4) {
                    if (!displayedWeightsWarning) {
                        console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
                        displayedWeightsWarning = true;
                    }
                    const wIndex = [
                        0,
                        0,
                        0,
                        0
                    ];
                    const Weight = [
                        0,
                        0,
                        0,
                        0
                    ];
                    weights.forEach(function(weight, weightIndex) {
                        let currentWeight = weight;
                        let currentIndex = weightIndices[weightIndex];
                        Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
                            if (currentWeight > comparedWeight) {
                                comparedWeightArray[comparedWeightIndex] = currentWeight;
                                currentWeight = comparedWeight;
                                const tmp = wIndex[comparedWeightIndex];
                                wIndex[comparedWeightIndex] = currentIndex;
                                currentIndex = tmp;
                            }
                        });
                    });
                    weightIndices = wIndex;
                    weights = Weight;
                }
                while(weights.length < 4){
                    weights.push(0);
                    weightIndices.push(0);
                }
                for(let i = 0; i < 4; ++i){
                    faceWeights.push(weights[i]);
                    faceWeightIndices.push(weightIndices[i]);
                }
            }
            if (geoInfo.normal) {
                const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
                faceNormals.push(data[0], data[1], data[2]);
            }
            if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
                materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
            }
            if (geoInfo.uv) {
                geoInfo.uv.forEach(function(uv, i) {
                    const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
                    if (faceUVs[i] === void 0) {
                        faceUVs[i] = [];
                    }
                    faceUVs[i].push(data[0]);
                    faceUVs[i].push(data[1]);
                });
            }
            faceLength++;
            if (endOfFace) {
                scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
                polygonIndex++;
                faceLength = 0;
                facePositionIndexes = [];
                faceNormals = [];
                faceColors = [];
                faceUVs = [];
                faceWeights = [];
                faceWeightIndices = [];
            }
        });
        return buffers;
    }
    // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
    genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
        for(let i = 2; i < faceLength; i++){
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);
            if (geoInfo.skeleton) {
                buffers.vertexWeights.push(faceWeights[0]);
                buffers.vertexWeights.push(faceWeights[1]);
                buffers.vertexWeights.push(faceWeights[2]);
                buffers.vertexWeights.push(faceWeights[3]);
                buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);
                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);
                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);
                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);
                buffers.vertexWeights.push(faceWeights[i * 4]);
                buffers.vertexWeights.push(faceWeights[i * 4 + 1]);
                buffers.vertexWeights.push(faceWeights[i * 4 + 2]);
                buffers.vertexWeights.push(faceWeights[i * 4 + 3]);
                buffers.weightsIndices.push(faceWeightIndices[0]);
                buffers.weightsIndices.push(faceWeightIndices[1]);
                buffers.weightsIndices.push(faceWeightIndices[2]);
                buffers.weightsIndices.push(faceWeightIndices[3]);
                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);
                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);
                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);
                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);
                buffers.weightsIndices.push(faceWeightIndices[i * 4]);
                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);
                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);
                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);
            }
            if (geoInfo.color) {
                buffers.colors.push(faceColors[0]);
                buffers.colors.push(faceColors[1]);
                buffers.colors.push(faceColors[2]);
                buffers.colors.push(faceColors[(i - 1) * 3]);
                buffers.colors.push(faceColors[(i - 1) * 3 + 1]);
                buffers.colors.push(faceColors[(i - 1) * 3 + 2]);
                buffers.colors.push(faceColors[i * 3]);
                buffers.colors.push(faceColors[i * 3 + 1]);
                buffers.colors.push(faceColors[i * 3 + 2]);
            }
            if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
                buffers.materialIndex.push(materialIndex);
                buffers.materialIndex.push(materialIndex);
                buffers.materialIndex.push(materialIndex);
            }
            if (geoInfo.normal) {
                buffers.normal.push(faceNormals[0]);
                buffers.normal.push(faceNormals[1]);
                buffers.normal.push(faceNormals[2]);
                buffers.normal.push(faceNormals[(i - 1) * 3]);
                buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);
                buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);
                buffers.normal.push(faceNormals[i * 3]);
                buffers.normal.push(faceNormals[i * 3 + 1]);
                buffers.normal.push(faceNormals[i * 3 + 2]);
            }
            if (geoInfo.uv) {
                geoInfo.uv.forEach(function(uv, j) {
                    if (buffers.uvs[j] === void 0) buffers.uvs[j] = [];
                    buffers.uvs[j].push(faceUVs[j][0]);
                    buffers.uvs[j].push(faceUVs[j][1]);
                    buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);
                    buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);
                    buffers.uvs[j].push(faceUVs[j][i * 2]);
                    buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);
                });
            }
        }
    }
    addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
        if (morphTargets.length === 0) return;
        parentGeo.morphTargetsRelative = true;
        parentGeo.morphAttributes.position = [];
        const scope = this;
        morphTargets.forEach(function(morphTarget) {
            morphTarget.rawTargets.forEach(function(rawTarget) {
                const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
                if (morphGeoNode !== void 0) {
                    scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
                }
            });
        });
    }
    // a morph geometry node is similar to a standard  node, and the node is also contained
    // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
    // and a special attribute Index defining which vertices of the original geometry are affected
    // Normal and position attributes only have data for the vertices that are affected by the morph
    genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
        const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
        const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
        const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
        const length = parentGeo.attributes.position.count * 3;
        const morphPositions = new Float32Array(length);
        for(let i = 0; i < indices.length; i++){
            const morphIndex = indices[i] * 3;
            morphPositions[morphIndex] = morphPositionsSparse[i * 3];
            morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
            morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
        }
        const morphGeoInfo = {
            vertexIndices,
            vertexPositions: morphPositions
        };
        const morphBuffers = this.genBuffers(morphGeoInfo);
        const positionAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](morphBuffers.vertex, 3);
        positionAttribute.name = name || morphGeoNode.attrName;
        positionAttribute.applyMatrix4(preTransform);
        parentGeo.morphAttributes.position.push(positionAttribute);
    }
    // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
    parseNormals(NormalNode) {
        const mappingType = NormalNode.MappingInformationType;
        const referenceType = NormalNode.ReferenceInformationType;
        const buffer = NormalNode.Normals.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
            if ("NormalIndex" in NormalNode) {
                indexBuffer = NormalNode.NormalIndex.a;
            } else if ("NormalsIndex" in NormalNode) {
                indexBuffer = NormalNode.NormalsIndex.a;
            }
        }
        return {
            dataSize: 3,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
        };
    }
    // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
    parseUVs(UVNode) {
        const mappingType = UVNode.MappingInformationType;
        const referenceType = UVNode.ReferenceInformationType;
        const buffer = UVNode.UV.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
            indexBuffer = UVNode.UVIndex.a;
        }
        return {
            dataSize: 2,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
        };
    }
    // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
    parseVertexColors(ColorNode) {
        const mappingType = ColorNode.MappingInformationType;
        const referenceType = ColorNode.ReferenceInformationType;
        const buffer = ColorNode.Colors.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
            indexBuffer = ColorNode.ColorIndex.a;
        }
        return {
            dataSize: 4,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
        };
    }
    // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
    parseMaterialIndices(MaterialNode) {
        const mappingType = MaterialNode.MappingInformationType;
        const referenceType = MaterialNode.ReferenceInformationType;
        if (mappingType === "NoMappingInformation") {
            return {
                dataSize: 1,
                buffer: [
                    0
                ],
                indices: [
                    0
                ],
                mappingType: "AllSame",
                referenceType
            };
        }
        const materialIndexBuffer = MaterialNode.Materials.a;
        const materialIndices = [];
        for(let i = 0; i < materialIndexBuffer.length; ++i){
            materialIndices.push(i);
        }
        return {
            dataSize: 1,
            buffer: materialIndexBuffer,
            indices: materialIndices,
            mappingType,
            referenceType
        };
    }
    // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
    parseNurbsGeometry(geoNode) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSCurve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NURBSCurve"] === void 0) {
            console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.");
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        }
        const order = parseInt(geoNode.Order);
        if (isNaN(order)) {
            console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        }
        const degree = order - 1;
        const knots = geoNode.KnotVector.a;
        const controlPoints = [];
        const pointsValues = geoNode.Points.a;
        for(let i = 0, l = pointsValues.length; i < l; i += 4){
            controlPoints.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]().fromArray(pointsValues, i));
        }
        let startKnot, endKnot;
        if (geoNode.Form === "Closed") {
            controlPoints.push(controlPoints[0]);
        } else if (geoNode.Form === "Periodic") {
            startKnot = degree;
            endKnot = knots.length - 1 - startKnot;
            for(let i = 0; i < degree; ++i){
                controlPoints.push(controlPoints[i]);
            }
        }
        const curve = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$curves$2f$NURBSCurve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NURBSCurve"](degree, knots, controlPoints, startKnot, endKnot);
        const points = curve.getPoints(controlPoints.length * 12);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]().setFromPoints(points);
    }
}
class AnimationParser {
    // take raw animation clips and turn them into three.js animation clips
    parse() {
        const animationClips = [];
        const rawClips = this.parseClips();
        if (rawClips !== void 0) {
            for(const key in rawClips){
                const rawClip = rawClips[key];
                const clip = this.addClip(rawClip);
                animationClips.push(clip);
            }
        }
        return animationClips;
    }
    parseClips() {
        if (fbxTree.Objects.AnimationCurve === void 0) return void 0;
        const curveNodesMap = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(curveNodesMap);
        const layersMap = this.parseAnimationLayers(curveNodesMap);
        const rawClips = this.parseAnimStacks(layersMap);
        return rawClips;
    }
    // parse nodes in FBXTree.Objects.AnimationCurveNode
    // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
    // and is referenced by an AnimationLayer
    parseAnimationCurveNodes() {
        const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
        const curveNodesMap = /* @__PURE__ */ new Map();
        for(const nodeID in rawCurveNodes){
            const rawCurveNode = rawCurveNodes[nodeID];
            if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
                const curveNode = {
                    id: rawCurveNode.id,
                    attr: rawCurveNode.attrName,
                    curves: {}
                };
                curveNodesMap.set(curveNode.id, curveNode);
            }
        }
        return curveNodesMap;
    }
    // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
    // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
    // axis ( e.g. times and values of x rotation)
    parseAnimationCurves(curveNodesMap) {
        const rawCurves = fbxTree.Objects.AnimationCurve;
        for(const nodeID in rawCurves){
            const animationCurve = {
                id: rawCurves[nodeID].id,
                times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
                values: rawCurves[nodeID].KeyValueFloat.a
            };
            const relationships = connections.get(animationCurve.id);
            if (relationships !== void 0) {
                const animationCurveID = relationships.parents[0].ID;
                const animationCurveRelationship = relationships.parents[0].relationship;
                if (animationCurveRelationship.match(/X/)) {
                    curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
                } else if (animationCurveRelationship.match(/Y/)) {
                    curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
                } else if (animationCurveRelationship.match(/Z/)) {
                    curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
                } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
                    curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
                }
            }
        }
    }
    // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
    // to various AnimationCurveNodes and is referenced by an AnimationStack node
    // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
    parseAnimationLayers(curveNodesMap) {
        const rawLayers = fbxTree.Objects.AnimationLayer;
        const layersMap = /* @__PURE__ */ new Map();
        for(const nodeID in rawLayers){
            const layerCurveNodes = [];
            const connection = connections.get(parseInt(nodeID));
            if (connection !== void 0) {
                const children = connection.children;
                children.forEach(function(child, i) {
                    if (curveNodesMap.has(child.ID)) {
                        const curveNode = curveNodesMap.get(child.ID);
                        if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
                            if (layerCurveNodes[i] === void 0) {
                                const modelID = connections.get(child.ID).parents.filter(function(parent) {
                                    return parent.relationship !== void 0;
                                })[0].ID;
                                if (modelID !== void 0) {
                                    const rawModel = fbxTree.Objects.Model[modelID.toString()];
                                    if (rawModel === void 0) {
                                        console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                                        return;
                                    }
                                    const node = {
                                        modelName: rawModel.attrName ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PropertyBinding"].sanitizeNodeName(rawModel.attrName) : "",
                                        ID: rawModel.id,
                                        initialPosition: [
                                            0,
                                            0,
                                            0
                                        ],
                                        initialRotation: [
                                            0,
                                            0,
                                            0
                                        ],
                                        initialScale: [
                                            1,
                                            1,
                                            1
                                        ]
                                    };
                                    sceneGraph.traverse(function(child2) {
                                        if (child2.ID === rawModel.id) {
                                            node.transform = child2.matrix;
                                            if (child2.userData.transformData) node.eulerOrder = child2.userData.transformData.eulerOrder;
                                        }
                                    });
                                    if (!node.transform) node.transform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                                    if ("PreRotation" in rawModel) node.preRotation = rawModel.PreRotation.value;
                                    if ("PostRotation" in rawModel) node.postRotation = rawModel.PostRotation.value;
                                    layerCurveNodes[i] = node;
                                }
                            }
                            if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;
                        } else if (curveNode.curves.morph !== void 0) {
                            if (layerCurveNodes[i] === void 0) {
                                const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                                    return parent.relationship !== void 0;
                                })[0].ID;
                                const morpherID = connections.get(deformerID).parents[0].ID;
                                const geoID = connections.get(morpherID).parents[0].ID;
                                const modelID = connections.get(geoID).parents[0].ID;
                                const rawModel = fbxTree.Objects.Model[modelID];
                                const node = {
                                    modelName: rawModel.attrName ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PropertyBinding"].sanitizeNodeName(rawModel.attrName) : "",
                                    morphName: fbxTree.Objects.Deformer[deformerID].attrName
                                };
                                layerCurveNodes[i] = node;
                            }
                            layerCurveNodes[i][curveNode.attr] = curveNode;
                        }
                    }
                });
                layersMap.set(parseInt(nodeID), layerCurveNodes);
            }
        }
        return layersMap;
    }
    // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
    // hierarchy. Each Stack node will be used to create a AnimationClip
    parseAnimStacks(layersMap) {
        const rawStacks = fbxTree.Objects.AnimationStack;
        const rawClips = {};
        for(const nodeID in rawStacks){
            const children = connections.get(parseInt(nodeID)).children;
            if (children.length > 1) {
                console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            }
            const layer = layersMap.get(children[0].ID);
            rawClips[nodeID] = {
                name: rawStacks[nodeID].attrName,
                layer
            };
        }
        return rawClips;
    }
    addClip(rawClip) {
        let tracks = [];
        const scope = this;
        rawClip.layer.forEach(function(rawTracks) {
            tracks = tracks.concat(scope.generateTracks(rawTracks));
        });
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](rawClip.name, -1, tracks);
    }
    generateTracks(rawTracks) {
        const tracks = [];
        let initialPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        let initialRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        let initialScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
        initialPosition = initialPosition.toArray();
        initialRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"]().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
        initialScale = initialScale.toArray();
        if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
            const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
            if (positionTrack !== void 0) tracks.push(positionTrack);
        }
        if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
            const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
            if (rotationTrack !== void 0) tracks.push(rotationTrack);
        }
        if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
            const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
            if (scaleTrack !== void 0) tracks.push(scaleTrack);
        }
        if (rawTracks.DeformPercent !== void 0) {
            const morphTrack = this.generateMorphTrack(rawTracks);
            if (morphTrack !== void 0) tracks.push(morphTrack);
        }
        return tracks;
    }
    generateVectorTrack(modelName, curves, initialValue, type) {
        const times = this.getTimesForAllAxes(curves);
        const values = this.getKeyframeTrackValues(times, curves, initialValue);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](modelName + "." + type, times, values);
    }
    generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
        if (curves.x !== void 0) {
            this.interpolateRotations(curves.x);
            curves.x.values = curves.x.values.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
        }
        if (curves.y !== void 0) {
            this.interpolateRotations(curves.y);
            curves.y.values = curves.y.values.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
        }
        if (curves.z !== void 0) {
            this.interpolateRotations(curves.z);
            curves.z.values = curves.z.values.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
        }
        const times = this.getTimesForAllAxes(curves);
        const values = this.getKeyframeTrackValues(times, curves, initialValue);
        if (preRotation !== void 0) {
            preRotation = preRotation.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
            preRotation.push(eulerOrder);
            preRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"]().fromArray(preRotation);
            preRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]().setFromEuler(preRotation);
        }
        if (postRotation !== void 0) {
            postRotation = postRotation.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
            postRotation.push(eulerOrder);
            postRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"]().fromArray(postRotation);
            postRotation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]().setFromEuler(postRotation).invert();
        }
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        const euler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"]();
        const quaternionValues = [];
        for(let i = 0; i < values.length; i += 3){
            euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
            quaternion.setFromEuler(euler);
            if (preRotation !== void 0) quaternion.premultiply(preRotation);
            if (postRotation !== void 0) quaternion.multiply(postRotation);
            quaternion.toArray(quaternionValues, i / 3 * 4);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"](modelName + ".quaternion", times, quaternionValues);
    }
    generateMorphTrack(rawTracks) {
        const curves = rawTracks.DeformPercent.curves.morph;
        const values = curves.values.map(function(val) {
            return val / 100;
        });
        const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"](rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
    }
    // For all animated objects, times are defined separately for each axis
    // Here we'll combine the times into one sorted array without duplicates
    getTimesForAllAxes(curves) {
        let times = [];
        if (curves.x !== void 0) times = times.concat(curves.x.times);
        if (curves.y !== void 0) times = times.concat(curves.y.times);
        if (curves.z !== void 0) times = times.concat(curves.z.times);
        times = times.sort(function(a, b) {
            return a - b;
        });
        if (times.length > 1) {
            let targetIndex = 1;
            let lastValue = times[0];
            for(let i = 1; i < times.length; i++){
                const currentValue = times[i];
                if (currentValue !== lastValue) {
                    times[targetIndex] = currentValue;
                    lastValue = currentValue;
                    targetIndex++;
                }
            }
            times = times.slice(0, targetIndex);
        }
        return times;
    }
    getKeyframeTrackValues(times, curves, initialValue) {
        const prevValue = initialValue;
        const values = [];
        let xIndex = -1;
        let yIndex = -1;
        let zIndex = -1;
        times.forEach(function(time) {
            if (curves.x) xIndex = curves.x.times.indexOf(time);
            if (curves.y) yIndex = curves.y.times.indexOf(time);
            if (curves.z) zIndex = curves.z.times.indexOf(time);
            if (xIndex !== -1) {
                const xValue = curves.x.values[xIndex];
                values.push(xValue);
                prevValue[0] = xValue;
            } else {
                values.push(prevValue[0]);
            }
            if (yIndex !== -1) {
                const yValue = curves.y.values[yIndex];
                values.push(yValue);
                prevValue[1] = yValue;
            } else {
                values.push(prevValue[1]);
            }
            if (zIndex !== -1) {
                const zValue = curves.z.values[zIndex];
                values.push(zValue);
                prevValue[2] = zValue;
            } else {
                values.push(prevValue[2]);
            }
        });
        return values;
    }
    // Rotations are defined as Euler angles which can have values  of any size
    // These will be converted to quaternions which don't support values greater than
    // PI, so we'll interpolate large rotations
    interpolateRotations(curve) {
        for(let i = 1; i < curve.values.length; i++){
            const initialValue = curve.values[i - 1];
            const valuesSpan = curve.values[i] - initialValue;
            const absoluteSpan = Math.abs(valuesSpan);
            if (absoluteSpan >= 180) {
                const numSubIntervals = absoluteSpan / 180;
                const step = valuesSpan / numSubIntervals;
                let nextValue = initialValue + step;
                const initialTime = curve.times[i - 1];
                const timeSpan = curve.times[i] - initialTime;
                const interval = timeSpan / numSubIntervals;
                let nextTime = initialTime + interval;
                const interpolatedTimes = [];
                const interpolatedValues = [];
                while(nextTime < curve.times[i]){
                    interpolatedTimes.push(nextTime);
                    nextTime += interval;
                    interpolatedValues.push(nextValue);
                    nextValue += step;
                }
                curve.times = inject(curve.times, i, interpolatedTimes);
                curve.values = inject(curve.values, i, interpolatedValues);
            }
        }
    }
}
class TextParser {
    getPrevNode() {
        return this.nodeStack[this.currentIndent - 2];
    }
    getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1];
    }
    getCurrentProp() {
        return this.currentProp;
    }
    pushStack(node) {
        this.nodeStack.push(node);
        this.currentIndent += 1;
    }
    popStack() {
        this.nodeStack.pop();
        this.currentIndent -= 1;
    }
    setCurrentProp(val, name) {
        this.currentProp = val;
        this.currentPropName = name;
    }
    parse(text) {
        this.currentIndent = 0;
        this.allNodes = new FBXTree();
        this.nodeStack = [];
        this.currentProp = [];
        this.currentPropName = "";
        const scope = this;
        const split = text.split(/[\r\n]+/);
        split.forEach(function(line, i) {
            const matchComment = line.match(/^[\s\t]*;/);
            const matchEmpty = line.match(/^[\s\t]*$/);
            if (matchComment || matchEmpty) return;
            const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
            const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
            const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
            if (matchBeginning) {
                scope.parseNodeBegin(line, matchBeginning);
            } else if (matchProperty) {
                scope.parseNodeProperty(line, matchProperty, split[++i]);
            } else if (matchEnd) {
                scope.popStack();
            } else if (line.match(/^[^\s\t}]/)) {
                scope.parseNodePropertyContinued(line);
            }
        });
        return this.allNodes;
    }
    parseNodeBegin(line, property) {
        const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
        const nodeAttrs = property[2].split(",").map(function(attr) {
            return attr.trim().replace(/^"/, "").replace(/"$/, "");
        });
        const node = {
            name: nodeName
        };
        const attrs = this.parseNodeAttr(nodeAttrs);
        const currentNode = this.getCurrentNode();
        if (this.currentIndent === 0) {
            this.allNodes.add(nodeName, node);
        } else {
            if (nodeName in currentNode) {
                if (nodeName === "PoseNode") {
                    currentNode.PoseNode.push(node);
                } else if (currentNode[nodeName].id !== void 0) {
                    currentNode[nodeName] = {};
                    currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
                }
                if (attrs.id !== "") currentNode[nodeName][attrs.id] = node;
            } else if (typeof attrs.id === "number") {
                currentNode[nodeName] = {};
                currentNode[nodeName][attrs.id] = node;
            } else if (nodeName !== "Properties70") {
                if (nodeName === "PoseNode") currentNode[nodeName] = [
                    node
                ];
                else currentNode[nodeName] = node;
            }
        }
        if (typeof attrs.id === "number") node.id = attrs.id;
        if (attrs.name !== "") node.attrName = attrs.name;
        if (attrs.type !== "") node.attrType = attrs.type;
        this.pushStack(node);
    }
    parseNodeAttr(attrs) {
        let id = attrs[0];
        if (attrs[0] !== "") {
            id = parseInt(attrs[0]);
            if (isNaN(id)) {
                id = attrs[0];
            }
        }
        let name = "", type = "";
        if (attrs.length > 1) {
            name = attrs[1].replace(/^(\w+)::/, "");
            type = attrs[2];
        }
        return {
            id,
            name,
            type
        };
    }
    parseNodeProperty(line, property, contentLine) {
        let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
        let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
        if (propName === "Content" && propValue === ",") {
            propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
        }
        const currentNode = this.getCurrentNode();
        const parentName = currentNode.name;
        if (parentName === "Properties70") {
            this.parseNodeSpecialProperty(line, propName, propValue);
            return;
        }
        if (propName === "C") {
            const connProps = propValue.split(",").slice(1);
            const from = parseInt(connProps[0]);
            const to = parseInt(connProps[1]);
            let rest = propValue.split(",").slice(3);
            rest = rest.map(function(elem) {
                return elem.trim().replace(/^"/, "");
            });
            propName = "connections";
            propValue = [
                from,
                to
            ];
            append(propValue, rest);
            if (currentNode[propName] === void 0) {
                currentNode[propName] = [];
            }
        }
        if (propName === "Node") currentNode.id = propValue;
        if (propName in currentNode && Array.isArray(currentNode[propName])) {
            currentNode[propName].push(propValue);
        } else {
            if (propName !== "a") currentNode[propName] = propValue;
            else currentNode.a = propValue;
        }
        this.setCurrentProp(currentNode, propName);
        if (propName === "a" && propValue.slice(-1) !== ",") {
            currentNode.a = parseNumberArray(propValue);
        }
    }
    parseNodePropertyContinued(line) {
        const currentNode = this.getCurrentNode();
        currentNode.a += line;
        if (line.slice(-1) !== ",") {
            currentNode.a = parseNumberArray(currentNode.a);
        }
    }
    // parse "Property70"
    parseNodeSpecialProperty(line, propName, propValue) {
        const props = propValue.split('",').map(function(prop) {
            return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
        });
        const innerPropName = props[0];
        const innerPropType1 = props[1];
        const innerPropType2 = props[2];
        const innerPropFlag = props[3];
        let innerPropValue = props[4];
        switch(innerPropType1){
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
                innerPropValue = parseFloat(innerPropValue);
                break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
                innerPropValue = parseNumberArray(innerPropValue);
                break;
        }
        this.getPrevNode()[innerPropName] = {
            type: innerPropType1,
            type2: innerPropType2,
            flag: innerPropFlag,
            value: innerPropValue
        };
        this.setCurrentProp(this.getPrevNode(), innerPropName);
    }
}
class BinaryParser {
    parse(buffer) {
        const reader = new BinaryReader(buffer);
        reader.skip(23);
        const version = reader.getUint32();
        if (version < 6400) {
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
        }
        const allNodes = new FBXTree();
        while(!this.endOfContent(reader)){
            const node = this.parseNode(reader, version);
            if (node !== null) allNodes.add(node.name, node);
        }
        return allNodes;
    }
    // Check if reader has reached the end of content.
    endOfContent(reader) {
        if (reader.size() % 16 === 0) {
            return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
        } else {
            return reader.getOffset() + 160 + 16 >= reader.size();
        }
    }
    // recursively parse nodes until the end of the file is reached
    parseNode(reader, version) {
        const node = {};
        const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
        const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
        version >= 7500 ? reader.getUint64() : reader.getUint32();
        const nameLen = reader.getUint8();
        const name = reader.getString(nameLen);
        if (endOffset === 0) return null;
        const propertyList = [];
        for(let i = 0; i < numProperties; i++){
            propertyList.push(this.parseProperty(reader));
        }
        const id = propertyList.length > 0 ? propertyList[0] : "";
        const attrName = propertyList.length > 1 ? propertyList[1] : "";
        const attrType = propertyList.length > 2 ? propertyList[2] : "";
        node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
        while(endOffset > reader.getOffset()){
            const subNode = this.parseNode(reader, version);
            if (subNode !== null) this.parseSubNode(name, node, subNode);
        }
        node.propertyList = propertyList;
        if (typeof id === "number") node.id = id;
        if (attrName !== "") node.attrName = attrName;
        if (attrType !== "") node.attrType = attrType;
        if (name !== "") node.name = name;
        return node;
    }
    parseSubNode(name, node, subNode) {
        if (subNode.singleProperty === true) {
            const value = subNode.propertyList[0];
            if (Array.isArray(value)) {
                node[subNode.name] = subNode;
                subNode.a = value;
            } else {
                node[subNode.name] = value;
            }
        } else if (name === "Connections" && subNode.name === "C") {
            const array = [];
            subNode.propertyList.forEach(function(property, i) {
                if (i !== 0) array.push(property);
            });
            if (node.connections === void 0) {
                node.connections = [];
            }
            node.connections.push(array);
        } else if (subNode.name === "Properties70") {
            const keys = Object.keys(subNode);
            keys.forEach(function(key) {
                node[key] = subNode[key];
            });
        } else if (name === "Properties70" && subNode.name === "P") {
            let innerPropName = subNode.propertyList[0];
            let innerPropType1 = subNode.propertyList[1];
            const innerPropType2 = subNode.propertyList[2];
            const innerPropFlag = subNode.propertyList[3];
            let innerPropValue;
            if (innerPropName.indexOf("Lcl ") === 0) innerPropName = innerPropName.replace("Lcl ", "Lcl_");
            if (innerPropType1.indexOf("Lcl ") === 0) innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
            if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
                innerPropValue = [
                    subNode.propertyList[4],
                    subNode.propertyList[5],
                    subNode.propertyList[6]
                ];
            } else {
                innerPropValue = subNode.propertyList[4];
            }
            node[innerPropName] = {
                type: innerPropType1,
                type2: innerPropType2,
                flag: innerPropFlag,
                value: innerPropValue
            };
        } else if (node[subNode.name] === void 0) {
            if (typeof subNode.id === "number") {
                node[subNode.name] = {};
                node[subNode.name][subNode.id] = subNode;
            } else {
                node[subNode.name] = subNode;
            }
        } else {
            if (subNode.name === "PoseNode") {
                if (!Array.isArray(node[subNode.name])) {
                    node[subNode.name] = [
                        node[subNode.name]
                    ];
                }
                node[subNode.name].push(subNode);
            } else if (node[subNode.name][subNode.id] === void 0) {
                node[subNode.name][subNode.id] = subNode;
            }
        }
    }
    parseProperty(reader) {
        const type = reader.getString(1);
        let length;
        switch(type){
            case "C":
                return reader.getBoolean();
            case "D":
                return reader.getFloat64();
            case "F":
                return reader.getFloat32();
            case "I":
                return reader.getInt32();
            case "L":
                return reader.getInt64();
            case "R":
                length = reader.getUint32();
                return reader.getArrayBuffer(length);
            case "S":
                length = reader.getUint32();
                return reader.getString(length);
            case "Y":
                return reader.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
                const arrayLength = reader.getUint32();
                const encoding = reader.getUint32();
                const compressedLength = reader.getUint32();
                if (encoding === 0) {
                    switch(type){
                        case "b":
                        case "c":
                            return reader.getBooleanArray(arrayLength);
                        case "d":
                            return reader.getFloat64Array(arrayLength);
                        case "f":
                            return reader.getFloat32Array(arrayLength);
                        case "i":
                            return reader.getInt32Array(arrayLength);
                        case "l":
                            return reader.getInt64Array(arrayLength);
                    }
                }
                const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(new Uint8Array(reader.getArrayBuffer(compressedLength)));
                const reader2 = new BinaryReader(data.buffer);
                switch(type){
                    case "b":
                    case "c":
                        return reader2.getBooleanArray(arrayLength);
                    case "d":
                        return reader2.getFloat64Array(arrayLength);
                    case "f":
                        return reader2.getFloat32Array(arrayLength);
                    case "i":
                        return reader2.getInt32Array(arrayLength);
                    case "l":
                        return reader2.getInt64Array(arrayLength);
                }
            default:
                throw new Error("THREE.FBXLoader: Unknown property type " + type);
        }
    }
}
class BinaryReader {
    constructor(buffer, littleEndian){
        this.dv = new DataView(buffer);
        this.offset = 0;
        this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    }
    getOffset() {
        return this.offset;
    }
    size() {
        return this.dv.buffer.byteLength;
    }
    skip(length) {
        this.offset += length;
    }
    // seems like true/false representation depends on exporter.
    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
    // then sees LSB.
    getBoolean() {
        return (this.getUint8() & 1) === 1;
    }
    getBooleanArray(size) {
        const a = [];
        for(let i = 0; i < size; i++){
            a.push(this.getBoolean());
        }
        return a;
    }
    getUint8() {
        const value = this.dv.getUint8(this.offset);
        this.offset += 1;
        return value;
    }
    getInt16() {
        const value = this.dv.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }
    getInt32() {
        const value = this.dv.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    getInt32Array(size) {
        const a = [];
        for(let i = 0; i < size; i++){
            a.push(this.getInt32());
        }
        return a;
    }
    getUint32() {
        const value = this.dv.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    // JavaScript doesn't support 64-bit integer so calculate this here
    // 1 << 32 will return 1 so using multiply operation instead here.
    // There's a possibility that this method returns wrong value if the value
    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
    // TODO: safely handle 64-bit integer
    getInt64() {
        let low, high;
        if (this.littleEndian) {
            low = this.getUint32();
            high = this.getUint32();
        } else {
            high = this.getUint32();
            low = this.getUint32();
        }
        if (high & 2147483648) {
            high = ~high & 4294967295;
            low = ~low & 4294967295;
            if (low === 4294967295) high = high + 1 & 4294967295;
            low = low + 1 & 4294967295;
            return -(high * 4294967296 + low);
        }
        return high * 4294967296 + low;
    }
    getInt64Array(size) {
        const a = [];
        for(let i = 0; i < size; i++){
            a.push(this.getInt64());
        }
        return a;
    }
    // Note: see getInt64() comment
    getUint64() {
        let low, high;
        if (this.littleEndian) {
            low = this.getUint32();
            high = this.getUint32();
        } else {
            high = this.getUint32();
            low = this.getUint32();
        }
        return high * 4294967296 + low;
    }
    getFloat32() {
        const value = this.dv.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    getFloat32Array(size) {
        const a = [];
        for(let i = 0; i < size; i++){
            a.push(this.getFloat32());
        }
        return a;
    }
    getFloat64() {
        const value = this.dv.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    getFloat64Array(size) {
        const a = [];
        for(let i = 0; i < size; i++){
            a.push(this.getFloat64());
        }
        return a;
    }
    getArrayBuffer(size) {
        const value = this.dv.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return value;
    }
    getString(size) {
        let a = [];
        for(let i = 0; i < size; i++){
            a[i] = this.getUint8();
        }
        const nullByte = a.indexOf(0);
        if (nullByte >= 0) a = a.slice(0, nullByte);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(a));
    }
}
class FBXTree {
    add(key, val) {
        this[key] = val;
    }
}
function isFbxFormatBinary(buffer) {
    const CORRECT = "Kaydara FBX Binary  \0";
    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
    const CORRECT = [
        "K",
        "a",
        "y",
        "d",
        "a",
        "r",
        "a",
        "\\",
        "F",
        "B",
        "X",
        "\\",
        "B",
        "i",
        "n",
        "a",
        "r",
        "y",
        "\\",
        "\\"
    ];
    let cursor = 0;
    function read(offset) {
        const result = text[offset - 1];
        text = text.slice(cursor + offset);
        cursor++;
        return result;
    }
    for(let i = 0; i < CORRECT.length; ++i){
        const num = read(1);
        if (num === CORRECT[i]) {
            return false;
        }
    }
    return true;
}
function getFbxVersion(text) {
    const versionRegExp = /FBXVersion: (\d+)/;
    const match = text.match(versionRegExp);
    if (match) {
        const version = parseInt(match[1]);
        return version;
    }
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
    return time / 46186158e3;
}
const dataArray = [];
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
    let index;
    switch(infoObject.mappingType){
        case "ByPolygonVertex":
            index = polygonVertexIndex;
            break;
        case "ByPolygon":
            index = polygonIndex;
            break;
        case "ByVertice":
            index = vertexIndex;
            break;
        case "AllSame":
            index = infoObject.indices[0];
            break;
        default:
            console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
    }
    if (infoObject.referenceType === "IndexToDirect") index = infoObject.indices[index];
    const from = index * infoObject.dataSize;
    const to = from + infoObject.dataSize;
    return slice(dataArray, infoObject.buffer, from, to);
}
const tempEuler = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"]();
const tempVec = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
function generateTransform(transformData) {
    const lTranslationM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lPreRotationM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lRotationM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lPostRotationM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lScalingM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lScalingPivotM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lScalingOffsetM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lRotationOffsetM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lRotationPivotM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lParentGX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lParentLX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const lGlobalT = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    const inheritType = transformData.inheritType ? transformData.inheritType : 0;
    if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
    if (transformData.preRotation) {
        const array = transformData.preRotation.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
        array.push(transformData.eulerOrder);
        lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    }
    if (transformData.rotation) {
        const array = transformData.rotation.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
        array.push(transformData.eulerOrder);
        lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    }
    if (transformData.postRotation) {
        const array = transformData.postRotation.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad);
        array.push(transformData.eulerOrder);
        lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
        lPostRotationM.invert();
    }
    if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));
    if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
    if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
    if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
    if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
    if (transformData.parentMatrixWorld) {
        lParentLX.copy(transformData.parentMatrix);
        lParentGX.copy(transformData.parentMatrixWorld);
    }
    const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
    const lParentGRM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    lParentGRM.extractRotation(lParentGX);
    const lParentTM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    lParentTM.copyPosition(lParentGX);
    const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
    const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
    const lLSM = lScalingM;
    const lGlobalRS = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
    if (inheritType === 0) {
        lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
    } else if (inheritType === 1) {
        lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
    } else {
        const lParentLSM = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().scale(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().setFromMatrixScale(lParentLX));
        const lParentLSM_inv = lParentLSM.clone().invert();
        const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
        lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
    }
    const lRotationPivotM_inv = lRotationPivotM.clone().invert();
    const lScalingPivotM_inv = lScalingPivotM.clone().invert();
    let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
    const lLocalTWithAllPivotAndOffsetInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().copyPosition(lTransform);
    const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
    lGlobalT.copyPosition(lGlobalTranslation);
    lTransform = lGlobalT.clone().multiply(lGlobalRS);
    lTransform.premultiply(lParentGX.invert());
    return lTransform;
}
function getEulerOrder(order) {
    order = order || 0;
    const enums = [
        "ZYX",
        // -> XYZ extrinsic
        "YZX",
        // -> XZY extrinsic
        "XZY",
        // -> YZX extrinsic
        "ZXY",
        // -> YXZ extrinsic
        "YXZ",
        // -> ZXY extrinsic
        "XYZ"
    ];
    if (order === 6) {
        console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
        return enums[0];
    }
    return enums[order];
}
function parseNumberArray(value) {
    const array = value.split(",").map(function(val) {
        return parseFloat(val);
    });
    return array;
}
function convertArrayBufferToString(buffer, from, to) {
    if (from === void 0) from = 0;
    if (to === void 0) to = buffer.byteLength;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(buffer, from, to));
}
function append(a, b) {
    for(let i = 0, j = a.length, l = b.length; i < l; i++, j++){
        a[j] = b[i];
    }
}
function slice(a, b, from, to) {
    for(let i = from, j = 0; i < to; i++, j++){
        a[j] = b[i];
    }
    return a;
}
function inject(a1, index, a2) {
    return a1.slice(0, index).concat(a2).concat(a1.slice(index));
}
;
 //# sourceMappingURL=FBXLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/FontLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Font": (()=>Font),
    "FontLoader": (()=>FontLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
class FontLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, (response)=>{
            if (typeof response !== "string") throw new Error("unsupported data type");
            const json = JSON.parse(response);
            const font = this.parse(json);
            if (onLoad) onLoad(font);
        }, onProgress, onError);
    }
    loadAsync(url, onProgress) {
        return super.loadAsync(url, onProgress);
    }
    parse(json) {
        return new Font(json);
    }
}
class Font {
    constructor(data){
        __publicField(this, "data");
        __publicField(this, "isFont", true);
        __publicField(this, "type", "Font");
        this.data = data;
    }
    generateShapes(text, size = 100, _options) {
        const shapes = [];
        const options = {
            letterSpacing: 0,
            lineHeight: 1,
            ..._options
        };
        const paths = createPaths(text, size, this.data, options);
        for(let p = 0, pl = paths.length; p < pl; p++){
            Array.prototype.push.apply(shapes, paths[p].toShapes(false));
        }
        return shapes;
    }
}
function createPaths(text, size, data, options) {
    const chars = Array.from(text);
    const scale = size / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i = 0; i < chars.length; i++){
        const char = chars[i];
        if (char === "\n") {
            offsetX = 0;
            offsetY -= line_height * options.lineHeight;
        } else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            if (ret) {
                offsetX += ret.offsetX + options.letterSpacing;
                paths.push(ret.path);
            }
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs["?"];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
        return;
    }
    const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShapePath"]();
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
        for(let i = 0, l = outline.length; i < l;){
            const action = outline[i++];
            switch(action){
                case "m":
                    x = parseInt(outline[i++]) * scale + offsetX;
                    y = parseInt(outline[i++]) * scale + offsetY;
                    path.moveTo(x, y);
                    break;
                case "l":
                    x = parseInt(outline[i++]) * scale + offsetX;
                    y = parseInt(outline[i++]) * scale + offsetY;
                    path.lineTo(x, y);
                    break;
                case "q":
                    cpx = parseInt(outline[i++]) * scale + offsetX;
                    cpy = parseInt(outline[i++]) * scale + offsetY;
                    cpx1 = parseInt(outline[i++]) * scale + offsetX;
                    cpy1 = parseInt(outline[i++]) * scale + offsetY;
                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case "b":
                    cpx = parseInt(outline[i++]) * scale + offsetX;
                    cpy = parseInt(outline[i++]) * scale + offsetY;
                    cpx1 = parseInt(outline[i++]) * scale + offsetX;
                    cpy1 = parseInt(outline[i++]) * scale + offsetY;
                    cpx2 = parseInt(outline[i++]) * scale + offsetX;
                    cpy2 = parseInt(outline[i++]) * scale + offsetY;
                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path
    };
}
;
 //# sourceMappingURL=FontLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/LUTCubeLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LUTCubeLoader": (()=>LUTCubeLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$Data3DTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/Data3DTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class LUTCubeLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    load(url, onLoad, onProgress, onError) {
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setResponseType("text");
        loader.load(url, (text)=>{
            try {
                onLoad(this.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                this.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(str) {
        str = str.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
        let title = null;
        let size = null;
        const domainMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0);
        const domainMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1);
        const lines = str.split(/[\n\r]+/g);
        let data = null;
        let currIndex = 0;
        for(let i = 0, l = lines.length; i < l; i++){
            const line = lines[i].trim();
            const split = line.split(/\s/g);
            switch(split[0]){
                case "TITLE":
                    title = line.substring(7, line.length - 1);
                    break;
                case "LUT_3D_SIZE":
                    const sizeToken = split[1];
                    size = parseFloat(sizeToken);
                    data = new Uint8Array(size * size * size * 4);
                    break;
                case "DOMAIN_MIN":
                    domainMin.x = parseFloat(split[1]);
                    domainMin.y = parseFloat(split[2]);
                    domainMin.z = parseFloat(split[3]);
                    break;
                case "DOMAIN_MAX":
                    domainMax.x = parseFloat(split[1]);
                    domainMax.y = parseFloat(split[2]);
                    domainMax.z = parseFloat(split[3]);
                    break;
                default:
                    const r = parseFloat(split[0]);
                    const g = parseFloat(split[1]);
                    const b = parseFloat(split[2]);
                    if (r > 1 || r < 0 || g > 1 || g < 0 || b > 1 || b < 0) {
                        throw new Error("LUTCubeLoader : Non normalized values not supported.");
                    }
                    data[currIndex + 0] = r * 255;
                    data[currIndex + 1] = g * 255;
                    data[currIndex + 2] = b * 255;
                    data[currIndex + 3] = 255;
                    currIndex += 4;
            }
        }
        const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"]();
        texture.image.data = data;
        texture.image.width = size;
        texture.image.height = size * size;
        texture.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"];
        texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture.generateMipmaps = false;
        texture.needsUpdate = true;
        const texture3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$Data3DTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Data3DTexture"]();
        texture3D.image.data = data;
        texture3D.image.width = size;
        texture3D.image.height = size;
        texture3D.image.depth = size;
        texture3D.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"];
        texture3D.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture3D.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture3D.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture3D.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture3D.wrapR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture3D.generateMipmaps = false;
        texture3D.needsUpdate = true;
        return {
            title,
            size,
            domainMin,
            domainMax,
            texture,
            texture3D
        };
    }
}
;
 //# sourceMappingURL=LUTCubeLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/NRRDLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "NRRDLoader": (()=>NRRDLoader)
});
(()=>{
    const e = new Error("Cannot find module '../misc/Volume.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)");
;
;
;
class NRRDLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(data) {
            try {
                onLoad(scope.parse(data));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(data) {
        let _data = data;
        let _dataPointer = 0;
        const _nativeLittleEndian = new Int8Array(new Int16Array([
            1
        ]).buffer)[0] > 0;
        const _littleEndian = true;
        const headerObject = {};
        function scan(type, chunks) {
            if (chunks === void 0 || chunks === null) {
                chunks = 1;
            }
            let _chunkSize = 1;
            let _array_type = Uint8Array;
            switch(type){
                case "uchar":
                    break;
                case "schar":
                    _array_type = Int8Array;
                    break;
                case "ushort":
                    _array_type = Uint16Array;
                    _chunkSize = 2;
                    break;
                case "sshort":
                    _array_type = Int16Array;
                    _chunkSize = 2;
                    break;
                case "uint":
                    _array_type = Uint32Array;
                    _chunkSize = 4;
                    break;
                case "sint":
                    _array_type = Int32Array;
                    _chunkSize = 4;
                    break;
                case "float":
                    _array_type = Float32Array;
                    _chunkSize = 4;
                    break;
                case "complex":
                    _array_type = Float64Array;
                    _chunkSize = 8;
                    break;
                case "double":
                    _array_type = Float64Array;
                    _chunkSize = 8;
                    break;
            }
            let _bytes2 = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));
            if (_nativeLittleEndian != _littleEndian) {
                _bytes2 = flipEndianness(_bytes2, _chunkSize);
            }
            if (chunks == 1) {
                return _bytes2[0];
            }
            return _bytes2;
        }
        function flipEndianness(array, chunkSize) {
            const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
            for(let i2 = 0; i2 < array.byteLength; i2 += chunkSize){
                for(let j = i2 + chunkSize - 1, k = i2; j > k; j--, k++){
                    const tmp = u8[k];
                    u8[k] = u8[j];
                    u8[j] = tmp;
                }
            }
            return array;
        }
        function parseHeader(header) {
            let data2, field, fn, i2, l, m, _i, _len;
            const lines = header.split(/\r?\n/);
            for(_i = 0, _len = lines.length; _i < _len; _i++){
                l = lines[_i];
                if (l.match(/NRRD\d+/)) {
                    headerObject.isNrrd = true;
                } else if (l.match(/^#/)) ;
                else if (m = l.match(/(.*):(.*)/)) {
                    field = m[1].trim();
                    data2 = m[2].trim();
                    fn = _fieldFunctions[field];
                    if (fn) {
                        fn.call(headerObject, data2);
                    } else {
                        headerObject[field] = data2;
                    }
                }
            }
            if (!headerObject.isNrrd) {
                throw new Error("Not an NRRD file");
            }
            if (headerObject.encoding === "bz2" || headerObject.encoding === "bzip2") {
                throw new Error("Bzip is not supported");
            }
            if (!headerObject.vectors) {
                headerObject.vectors = [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0),
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0),
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1)
                ];
                if (headerObject.spacings) {
                    for(i2 = 0; i2 <= 2; i2++){
                        if (!isNaN(headerObject.spacings[i2])) {
                            headerObject.vectors[i2].multiplyScalar(headerObject.spacings[i2]);
                        }
                    }
                }
            }
        }
        function parseDataAsText(data2, start, end) {
            let number = "";
            start = start || 0;
            end = end || data2.length;
            let value;
            const lengthOfTheResult = headerObject.sizes.reduce(function(previous, current) {
                return previous * current;
            }, 1);
            let base = 10;
            if (headerObject.encoding === "hex") {
                base = 16;
            }
            const result = new headerObject.__array(lengthOfTheResult);
            let resultIndex = 0;
            let parsingFunction = parseInt;
            if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {
                parsingFunction = parseFloat;
            }
            for(let i2 = start; i2 < end; i2++){
                value = data2[i2];
                if ((value < 9 || value > 13) && value !== 32) {
                    number += String.fromCharCode(value);
                } else {
                    if (number !== "") {
                        result[resultIndex] = parsingFunction(number, base);
                        resultIndex++;
                    }
                    number = "";
                }
            }
            if (number !== "") {
                result[resultIndex] = parsingFunction(number, base);
                resultIndex++;
            }
            return result;
        }
        const _bytes = scan("uchar", data.byteLength);
        const _length = _bytes.length;
        let _header = null;
        let _data_start = 0;
        let i;
        for(i = 1; i < _length; i++){
            if (_bytes[i - 1] == 10 && _bytes[i] == 10) {
                _header = this.parseChars(_bytes, 0, i - 2);
                _data_start = i + 1;
                break;
            }
        }
        parseHeader(_header);
        _data = _bytes.subarray(_data_start);
        if (headerObject.encoding.substring(0, 2) === "gz") {
            _data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gunzipSync"])(new Uint8Array(_data));
        } else if (headerObject.encoding === "ascii" || headerObject.encoding === "text" || headerObject.encoding === "txt" || headerObject.encoding === "hex") {
            _data = parseDataAsText(_data);
        } else if (headerObject.encoding === "raw") {
            const _copy = new Uint8Array(_data.length);
            for(let i2 = 0; i2 < _data.length; i2++){
                _copy[i2] = _data[i2];
            }
            _data = _copy;
        }
        _data = _data.buffer;
        const volume = new Volume();
        volume.header = headerObject;
        volume.data = new headerObject.__array(_data);
        const min_max = volume.computeMinMax();
        const min = min_max[0];
        const max = min_max[1];
        volume.windowLow = min;
        volume.windowHigh = max;
        volume.dimensions = [
            headerObject.sizes[0],
            headerObject.sizes[1],
            headerObject.sizes[2]
        ];
        volume.xLength = volume.dimensions[0];
        volume.yLength = volume.dimensions[1];
        volume.zLength = volume.dimensions[2];
        const spacingX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();
        const spacingY = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();
        const spacingZ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();
        volume.spacing = [
            spacingX,
            spacingY,
            spacingZ
        ];
        volume.matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        let _spaceX = 1;
        let _spaceY = 1;
        const _spaceZ = 1;
        if (headerObject.space == "left-posterior-superior") {
            _spaceX = -1;
            _spaceY = -1;
        } else if (headerObject.space === "left-anterior-superior") {
            _spaceX = -1;
        }
        if (!headerObject.vectors) {
            volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);
        } else {
            const v = headerObject.vectors;
            volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);
        }
        volume.inverseMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        volume.inverseMatrix.copy(volume.matrix).invert();
        volume.RASDimensions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);
        if (volume.lowerThreshold === -Infinity) {
            volume.lowerThreshold = min;
        }
        if (volume.upperThreshold === Infinity) {
            volume.upperThreshold = max;
        }
        return volume;
    }
    parseChars(array, start, end) {
        if (start === void 0) {
            start = 0;
        }
        if (end === void 0) {
            end = array.length;
        }
        let output = "";
        let i = 0;
        for(i = start; i < end; ++i){
            output += String.fromCharCode(array[i]);
        }
        return output;
    }
}
const _fieldFunctions = {
    type: function(data) {
        switch(data){
            case "uchar":
            case "unsigned char":
            case "uint8":
            case "uint8_t":
                this.__array = Uint8Array;
                break;
            case "signed char":
            case "int8":
            case "int8_t":
                this.__array = Int8Array;
                break;
            case "short":
            case "short int":
            case "signed short":
            case "signed short int":
            case "int16":
            case "int16_t":
                this.__array = Int16Array;
                break;
            case "ushort":
            case "unsigned short":
            case "unsigned short int":
            case "uint16":
            case "uint16_t":
                this.__array = Uint16Array;
                break;
            case "int":
            case "signed int":
            case "int32":
            case "int32_t":
                this.__array = Int32Array;
                break;
            case "uint":
            case "unsigned int":
            case "uint32":
            case "uint32_t":
                this.__array = Uint32Array;
                break;
            case "float":
                this.__array = Float32Array;
                break;
            case "double":
                this.__array = Float64Array;
                break;
            default:
                throw new Error("Unsupported NRRD data type: " + data);
        }
        return this.type = data;
    },
    endian: function(data) {
        return this.endian = data;
    },
    encoding: function(data) {
        return this.encoding = data;
    },
    dimension: function(data) {
        return this.dim = parseInt(data, 10);
    },
    sizes: function(data) {
        let i;
        return this.sizes = function() {
            const _ref = data.split(/\s+/);
            const _results = [];
            for(let _i = 0, _len = _ref.length; _i < _len; _i++){
                i = _ref[_i];
                _results.push(parseInt(i, 10));
            }
            return _results;
        }();
    },
    space: function(data) {
        return this.space = data;
    },
    "space origin": function(data) {
        return this.space_origin = data.split("(")[1].split(")")[0].split(",");
    },
    "space directions": function(data) {
        let f, v;
        const parts = data.match(/\(.*?\)/g);
        return this.vectors = function() {
            const _results = [];
            for(let _i = 0, _len = parts.length; _i < _len; _i++){
                v = parts[_i];
                _results.push(function() {
                    const _ref = v.slice(1, -1).split(/,/);
                    const _results2 = [];
                    for(let _j = 0, _len2 = _ref.length; _j < _len2; _j++){
                        f = _ref[_j];
                        _results2.push(parseFloat(f));
                    }
                    return _results2;
                }());
            }
            return _results;
        }();
    },
    spacings: function(data) {
        let f;
        const parts = data.split(/\s+/);
        return this.spacings = function() {
            const _results = [];
            for(let _i = 0, _len = parts.length; _i < _len; _i++){
                f = parts[_i];
                _results.push(parseFloat(f));
            }
            return _results;
        }();
    }
};
;
 //# sourceMappingURL=NRRDLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/MTLLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MTLLoader": (()=>MTLLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class MTLLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to load.
   */ load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = this.path === "" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url) : this.path;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text, path));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    setMaterialOptions(value) {
        this.materialOptions = value;
        return this;
    }
    /**
   * Parses a MTL file.
   *
   * @param {String} text - Content of MTL file
   * @return {MaterialCreator}
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to parse.
   */ parse(text, path) {
        const lines = text.split("\n");
        let info = {};
        const delimiter_pattern = /\s+/;
        const materialsInfo = {};
        for(let i = 0; i < lines.length; i++){
            let line = lines[i];
            line = line.trim();
            if (line.length === 0 || line.charAt(0) === "#") {
                continue;
            }
            const pos = line.indexOf(" ");
            let key = pos >= 0 ? line.substring(0, pos) : line;
            key = key.toLowerCase();
            let value = pos >= 0 ? line.substring(pos + 1) : "";
            value = value.trim();
            if (key === "newmtl") {
                info = {
                    name: value
                };
                materialsInfo[value] = info;
            } else {
                if (key === "ka" || key === "kd" || key === "ks" || key === "ke") {
                    const ss = value.split(delimiter_pattern, 3);
                    info[key] = [
                        parseFloat(ss[0]),
                        parseFloat(ss[1]),
                        parseFloat(ss[2])
                    ];
                } else {
                    info[key] = value;
                }
            }
        }
        const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);
        materialCreator.setCrossOrigin(this.crossOrigin);
        materialCreator.setManager(this.manager);
        materialCreator.setMaterials(materialsInfo);
        return materialCreator;
    }
}
class MaterialCreator {
    constructor(baseUrl = "", options = {}){
        this.baseUrl = baseUrl;
        this.options = options;
        this.materialsInfo = {};
        this.materials = {};
        this.materialsArray = [];
        this.nameLookup = {};
        this.crossOrigin = "anonymous";
        this.side = this.options.side !== void 0 ? this.options.side : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"];
        this.wrap = this.options.wrap !== void 0 ? this.options.wrap : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
    }
    setCrossOrigin(value) {
        this.crossOrigin = value;
        return this;
    }
    setManager(value) {
        this.manager = value;
    }
    setMaterials(materialsInfo) {
        this.materialsInfo = this.convert(materialsInfo);
        this.materials = {};
        this.materialsArray = [];
        this.nameLookup = {};
    }
    convert(materialsInfo) {
        if (!this.options) return materialsInfo;
        const converted = {};
        for(const mn in materialsInfo){
            const mat = materialsInfo[mn];
            const covmat = {};
            converted[mn] = covmat;
            for(const prop in mat){
                let save = true;
                let value = mat[prop];
                const lprop = prop.toLowerCase();
                switch(lprop){
                    case "kd":
                    case "ka":
                    case "ks":
                        if (this.options && this.options.normalizeRGB) {
                            value = [
                                value[0] / 255,
                                value[1] / 255,
                                value[2] / 255
                            ];
                        }
                        if (this.options && this.options.ignoreZeroRGBs) {
                            if (value[0] === 0 && value[1] === 0 && value[2] === 0) {
                                save = false;
                            }
                        }
                        break;
                }
                if (save) {
                    covmat[lprop] = value;
                }
            }
        }
        return converted;
    }
    preload() {
        for(const mn in this.materialsInfo){
            this.create(mn);
        }
    }
    getIndex(materialName) {
        return this.nameLookup[materialName];
    }
    getAsArray() {
        let index = 0;
        for(const mn in this.materialsInfo){
            this.materialsArray[index] = this.create(mn);
            this.nameLookup[mn] = index;
            index++;
        }
        return this.materialsArray;
    }
    create(materialName) {
        if (this.materials[materialName] === void 0) {
            this.createMaterial_(materialName);
        }
        return this.materials[materialName];
    }
    createMaterial_(materialName) {
        const scope = this;
        const mat = this.materialsInfo[materialName];
        const params = {
            name: materialName,
            side: this.side
        };
        function resolveURL(baseUrl, url) {
            if (typeof url !== "string" || url === "") return "";
            if (/^https?:\/\//i.test(url)) return url;
            return baseUrl + url;
        }
        function setMapForType(mapType, value) {
            if (params[mapType]) return;
            const texParams = scope.getTextureParams(value, params);
            const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
            map.repeat.copy(texParams.scale);
            map.offset.copy(texParams.offset);
            map.wrapS = scope.wrap;
            map.wrapT = scope.wrap;
            params[mapType] = map;
        }
        for(const prop in mat){
            const value = mat[prop];
            let n;
            if (value === "") continue;
            switch(prop.toLowerCase()){
                case "kd":
                    params.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(value);
                    break;
                case "ks":
                    params.specular = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(value);
                    break;
                case "ke":
                    params.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(value);
                    break;
                case "map_kd":
                    setMapForType("map", value);
                    break;
                case "map_ks":
                    setMapForType("specularMap", value);
                    break;
                case "map_ke":
                    setMapForType("emissiveMap", value);
                    break;
                case "norm":
                    setMapForType("normalMap", value);
                    break;
                case "map_bump":
                case "bump":
                    setMapForType("bumpMap", value);
                    break;
                case "map_d":
                    setMapForType("alphaMap", value);
                    params.transparent = true;
                    break;
                case "ns":
                    params.shininess = parseFloat(value);
                    break;
                case "d":
                    n = parseFloat(value);
                    if (n < 1) {
                        params.opacity = n;
                        params.transparent = true;
                    }
                    break;
                case "tr":
                    n = parseFloat(value);
                    if (this.options && this.options.invertTrProperty) n = 1 - n;
                    if (n > 0) {
                        params.opacity = 1 - n;
                        params.transparent = true;
                    }
                    break;
            }
        }
        this.materials[materialName] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"](params);
        return this.materials[materialName];
    }
    getTextureParams(value, matParams) {
        const texParams = {
            scale: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](1, 1),
            offset: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](0, 0)
        };
        const items = value.split(/\s+/);
        let pos;
        pos = items.indexOf("-bm");
        if (pos >= 0) {
            matParams.bumpScale = parseFloat(items[pos + 1]);
            items.splice(pos, 2);
        }
        pos = items.indexOf("-s");
        if (pos >= 0) {
            texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4);
        }
        pos = items.indexOf("-o");
        if (pos >= 0) {
            texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4);
        }
        texParams.url = items.join(" ").trim();
        return texParams;
    }
    loadTexture(url, mapping, onLoad, onProgress, onError) {
        const manager = this.manager !== void 0 ? this.manager : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DefaultLoadingManager"];
        let loader = manager.getHandler(url);
        if (loader === null) {
            loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](manager);
        }
        if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);
        const texture = loader.load(url, onLoad, onProgress, onError);
        if (mapping !== void 0) texture.mapping = mapping;
        return texture;
    }
}
;
 //# sourceMappingURL=MTLLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/BVHLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BVHLoader": (()=>BVHLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class BVHLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.animateBonePositions = true;
        this.animateBoneRotations = true;
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(text) {
        function readBvh(lines2) {
            if (nextLine(lines2) !== "HIERARCHY") {
                console.error("THREE.BVHLoader: HIERARCHY expected.");
            }
            const list = [];
            const root = readNode(lines2, nextLine(lines2), list);
            if (nextLine(lines2) !== "MOTION") {
                console.error("THREE.BVHLoader: MOTION expected.");
            }
            let tokens = nextLine(lines2).split(/[\s]+/);
            const numFrames = parseInt(tokens[1]);
            if (isNaN(numFrames)) {
                console.error("THREE.BVHLoader: Failed to read number of frames.");
            }
            tokens = nextLine(lines2).split(/[\s]+/);
            const frameTime = parseFloat(tokens[2]);
            if (isNaN(frameTime)) {
                console.error("THREE.BVHLoader: Failed to read frame time.");
            }
            for(let i = 0; i < numFrames; i++){
                tokens = nextLine(lines2).split(/[\s]+/);
                readFrameData(tokens, i * frameTime, root);
            }
            return list;
        }
        function readFrameData(data, frameTime, bone) {
            if (bone.type === "ENDSITE") return;
            const keyframe = {
                time: frameTime,
                position: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                rotation: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]()
            };
            bone.frames.push(keyframe);
            const quat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
            const vx = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0);
            const vy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
            const vz = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1);
            for(let i = 0; i < bone.channels.length; i++){
                switch(bone.channels[i]){
                    case "Xposition":
                        keyframe.position.x = parseFloat(data.shift().trim());
                        break;
                    case "Yposition":
                        keyframe.position.y = parseFloat(data.shift().trim());
                        break;
                    case "Zposition":
                        keyframe.position.z = parseFloat(data.shift().trim());
                        break;
                    case "Xrotation":
                        quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);
                        keyframe.rotation.multiply(quat);
                        break;
                    case "Yrotation":
                        quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);
                        keyframe.rotation.multiply(quat);
                        break;
                    case "Zrotation":
                        quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);
                        keyframe.rotation.multiply(quat);
                        break;
                    default:
                        console.warn("THREE.BVHLoader: Invalid channel type.");
                }
            }
            for(let i = 0; i < bone.children.length; i++){
                readFrameData(data, frameTime, bone.children[i]);
            }
        }
        function readNode(lines2, firstline, list) {
            const node = {
                name: "",
                type: "",
                frames: []
            };
            list.push(node);
            let tokens = firstline.split(/[\s]+/);
            if (tokens[0].toUpperCase() === "END" && tokens[1].toUpperCase() === "SITE") {
                node.type = "ENDSITE";
                node.name = "ENDSITE";
            } else {
                node.name = tokens[1];
                node.type = tokens[0].toUpperCase();
            }
            if (nextLine(lines2) !== "{") {
                console.error("THREE.BVHLoader: Expected opening { after type & name");
            }
            tokens = nextLine(lines2).split(/[\s]+/);
            if (tokens[0] !== "OFFSET") {
                console.error("THREE.BVHLoader: Expected OFFSET but got: " + tokens[0]);
            }
            if (tokens.length !== 4) {
                console.error("THREE.BVHLoader: Invalid number of values for OFFSET.");
            }
            const offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
            if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {
                console.error("THREE.BVHLoader: Invalid values of OFFSET.");
            }
            node.offset = offset;
            if (node.type !== "ENDSITE") {
                tokens = nextLine(lines2).split(/[\s]+/);
                if (tokens[0] !== "CHANNELS") {
                    console.error("THREE.BVHLoader: Expected CHANNELS definition.");
                }
                const numChannels = parseInt(tokens[1]);
                node.channels = tokens.splice(2, numChannels);
                node.children = [];
            }
            while(true){
                const line = nextLine(lines2);
                if (line === "}") {
                    return node;
                } else {
                    node.children.push(readNode(lines2, line, list));
                }
            }
        }
        function toTHREEBone(source, list) {
            const bone = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]();
            list.push(bone);
            bone.position.add(source.offset);
            bone.name = source.name;
            if (source.type !== "ENDSITE") {
                for(let i = 0; i < source.children.length; i++){
                    bone.add(toTHREEBone(source.children[i], list));
                }
            }
            return bone;
        }
        function toTHREEAnimation(bones2) {
            const tracks = [];
            for(let i = 0; i < bones2.length; i++){
                const bone = bones2[i];
                if (bone.type === "ENDSITE") continue;
                const times = [];
                const positions = [];
                const rotations = [];
                for(let j = 0; j < bone.frames.length; j++){
                    const frame = bone.frames[j];
                    times.push(frame.time);
                    positions.push(frame.position.x + bone.offset.x);
                    positions.push(frame.position.y + bone.offset.y);
                    positions.push(frame.position.z + bone.offset.z);
                    rotations.push(frame.rotation.x);
                    rotations.push(frame.rotation.y);
                    rotations.push(frame.rotation.z);
                    rotations.push(frame.rotation.w);
                }
                if (scope.animateBonePositions) {
                    tracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](".bones[" + bone.name + "].position", times, positions));
                }
                if (scope.animateBoneRotations) {
                    tracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"](".bones[" + bone.name + "].quaternion", times, rotations));
                }
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"]("animation", -1, tracks);
        }
        function nextLine(lines2) {
            let line;
            while((line = lines2.shift().trim()).length === 0){}
            return line;
        }
        const scope = this;
        const lines = text.split(/[\r\n]+/g);
        const bones = readBvh(lines);
        const threeBones = [];
        toTHREEBone(bones[0], threeBones);
        const threeClip = toTHREEAnimation(bones);
        return {
            skeleton: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Skeleton"](threeBones),
            clip: threeClip
        };
    }
}
;
 //# sourceMappingURL=BVHLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/ColladaLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ColladaLoader": (()=>ColladaLoader)
});
(()=>{
    const e = new Error("Cannot find module './TGALoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
(()=>{
    const e = new Error("Cannot find module '../_polyfill/uv1.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
class ColladaLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = scope.path === "" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url) : scope.path;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text, path));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(text, path) {
        function getElementsByTagName(xml2, name) {
            const array = [];
            const childNodes = xml2.childNodes;
            for(let i = 0, l = childNodes.length; i < l; i++){
                const child = childNodes[i];
                if (child.nodeName === name) {
                    array.push(child);
                }
            }
            return array;
        }
        function parseStrings(text2) {
            if (text2.length === 0) return [];
            const parts = text2.trim().split(/\s+/);
            const array = new Array(parts.length);
            for(let i = 0, l = parts.length; i < l; i++){
                array[i] = parts[i];
            }
            return array;
        }
        function parseFloats(text2) {
            if (text2.length === 0) return [];
            const parts = text2.trim().split(/\s+/);
            const array = new Array(parts.length);
            for(let i = 0, l = parts.length; i < l; i++){
                array[i] = parseFloat(parts[i]);
            }
            return array;
        }
        function parseInts(text2) {
            if (text2.length === 0) return [];
            const parts = text2.trim().split(/\s+/);
            const array = new Array(parts.length);
            for(let i = 0, l = parts.length; i < l; i++){
                array[i] = parseInt(parts[i]);
            }
            return array;
        }
        function parseId(text2) {
            return text2.substring(1);
        }
        function generateId() {
            return "three_default_" + count++;
        }
        function isEmpty(object) {
            return Object.keys(object).length === 0;
        }
        function parseAsset(xml2) {
            return {
                unit: parseAssetUnit(getElementsByTagName(xml2, "unit")[0]),
                upAxis: parseAssetUpAxis(getElementsByTagName(xml2, "up_axis")[0])
            };
        }
        function parseAssetUnit(xml2) {
            if (xml2 !== void 0 && xml2.hasAttribute("meter") === true) {
                return parseFloat(xml2.getAttribute("meter"));
            } else {
                return 1;
            }
        }
        function parseAssetUpAxis(xml2) {
            return xml2 !== void 0 ? xml2.textContent : "Y_UP";
        }
        function parseLibrary(xml2, libraryName, nodeName, parser) {
            const library2 = getElementsByTagName(xml2, libraryName)[0];
            if (library2 !== void 0) {
                const elements = getElementsByTagName(library2, nodeName);
                for(let i = 0; i < elements.length; i++){
                    parser(elements[i]);
                }
            }
        }
        function buildLibrary(data, builder) {
            for(const name in data){
                const object = data[name];
                object.build = builder(data[name]);
            }
        }
        function getBuild(data, builder) {
            if (data.build !== void 0) return data.build;
            data.build = builder(data);
            return data.build;
        }
        function parseAnimation(xml2) {
            const data = {
                sources: {},
                samplers: {},
                channels: {}
            };
            let hasChildren = false;
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                let id;
                switch(child.nodeName){
                    case "source":
                        id = child.getAttribute("id");
                        data.sources[id] = parseSource(child);
                        break;
                    case "sampler":
                        id = child.getAttribute("id");
                        data.samplers[id] = parseAnimationSampler(child);
                        break;
                    case "channel":
                        id = child.getAttribute("target");
                        data.channels[id] = parseAnimationChannel(child);
                        break;
                    case "animation":
                        parseAnimation(child);
                        hasChildren = true;
                        break;
                    default:
                        console.log(child);
                }
            }
            if (hasChildren === false) {
                library.animations[xml2.getAttribute("id") || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].generateUUID()] = data;
            }
        }
        function parseAnimationSampler(xml2) {
            const data = {
                inputs: {}
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        const id = parseId(child.getAttribute("source"));
                        const semantic = child.getAttribute("semantic");
                        data.inputs[semantic] = id;
                        break;
                }
            }
            return data;
        }
        function parseAnimationChannel(xml2) {
            const data = {};
            const target = xml2.getAttribute("target");
            let parts = target.split("/");
            const id = parts.shift();
            let sid = parts.shift();
            const arraySyntax = sid.indexOf("(") !== -1;
            const memberSyntax = sid.indexOf(".") !== -1;
            if (memberSyntax) {
                parts = sid.split(".");
                sid = parts.shift();
                data.member = parts.shift();
            } else if (arraySyntax) {
                const indices = sid.split("(");
                sid = indices.shift();
                for(let i = 0; i < indices.length; i++){
                    indices[i] = parseInt(indices[i].replace(/\)/, ""));
                }
                data.indices = indices;
            }
            data.id = id;
            data.sid = sid;
            data.arraySyntax = arraySyntax;
            data.memberSyntax = memberSyntax;
            data.sampler = parseId(xml2.getAttribute("source"));
            return data;
        }
        function buildAnimation(data) {
            const tracks = [];
            const channels = data.channels;
            const samplers = data.samplers;
            const sources = data.sources;
            for(const target in channels){
                if (channels.hasOwnProperty(target)) {
                    const channel = channels[target];
                    const sampler = samplers[channel.sampler];
                    const inputId = sampler.inputs.INPUT;
                    const outputId = sampler.inputs.OUTPUT;
                    const inputSource = sources[inputId];
                    const outputSource = sources[outputId];
                    const animation = buildAnimationChannel(channel, inputSource, outputSource);
                    createKeyframeTracks(animation, tracks);
                }
            }
            return tracks;
        }
        function getAnimation(id) {
            return getBuild(library.animations[id], buildAnimation);
        }
        function buildAnimationChannel(channel, inputSource, outputSource) {
            const node = library.nodes[channel.id];
            const object3D = getNode(node.id);
            const transform = node.transforms[channel.sid];
            const defaultMatrix = node.matrix.clone().transpose();
            let time, stride;
            let i, il, j, jl;
            const data = {};
            switch(transform){
                case "matrix":
                    for(i = 0, il = inputSource.array.length; i < il; i++){
                        time = inputSource.array[i];
                        stride = i * outputSource.stride;
                        if (data[time] === void 0) data[time] = {};
                        if (channel.arraySyntax === true) {
                            const value = outputSource.array[stride];
                            const index = channel.indices[0] + 4 * channel.indices[1];
                            data[time][index] = value;
                        } else {
                            for(j = 0, jl = outputSource.stride; j < jl; j++){
                                data[time][j] = outputSource.array[stride + j];
                            }
                        }
                    }
                    break;
                case "translate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                    break;
                case "rotate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                    break;
                case "scale":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                    break;
            }
            const keyframes = prepareAnimationData(data, defaultMatrix);
            const animation = {
                name: object3D.uuid,
                keyframes
            };
            return animation;
        }
        function prepareAnimationData(data, defaultMatrix) {
            const keyframes = [];
            for(const time in data){
                keyframes.push({
                    time: parseFloat(time),
                    value: data[time]
                });
            }
            keyframes.sort(ascending);
            for(let i = 0; i < 16; i++){
                transformAnimationData(keyframes, i, defaultMatrix.elements[i]);
            }
            return keyframes;
            "TURBOPACK unreachable";
            function ascending(a, b) {
                return a.time - b.time;
            }
        }
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        function createKeyframeTracks(animation, tracks) {
            const keyframes = animation.keyframes;
            const name = animation.name;
            const times = [];
            const positionData = [];
            const quaternionData = [];
            const scaleData = [];
            for(let i = 0, l = keyframes.length; i < l; i++){
                const keyframe = keyframes[i];
                const time = keyframe.time;
                const value = keyframe.value;
                matrix.fromArray(value).transpose();
                matrix.decompose(position, quaternion, scale);
                times.push(time);
                positionData.push(position.x, position.y, position.z);
                quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
                scaleData.push(scale.x, scale.y, scale.z);
            }
            if (positionData.length > 0) tracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](name + ".position", times, positionData));
            if (quaternionData.length > 0) {
                tracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"](name + ".quaternion", times, quaternionData));
            }
            if (scaleData.length > 0) tracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"](name + ".scale", times, scaleData));
            return tracks;
        }
        function transformAnimationData(keyframes, property, defaultValue) {
            let keyframe;
            let empty = true;
            let i, l;
            for(i = 0, l = keyframes.length; i < l; i++){
                keyframe = keyframes[i];
                if (keyframe.value[property] === void 0) {
                    keyframe.value[property] = null;
                } else {
                    empty = false;
                }
            }
            if (empty === true) {
                for(i = 0, l = keyframes.length; i < l; i++){
                    keyframe = keyframes[i];
                    keyframe.value[property] = defaultValue;
                }
            } else {
                createMissingKeyframes(keyframes, property);
            }
        }
        function createMissingKeyframes(keyframes, property) {
            let prev, next;
            for(let i = 0, l = keyframes.length; i < l; i++){
                const keyframe = keyframes[i];
                if (keyframe.value[property] === null) {
                    prev = getPrev(keyframes, i, property);
                    next = getNext(keyframes, i, property);
                    if (prev === null) {
                        keyframe.value[property] = next.value[property];
                        continue;
                    }
                    if (next === null) {
                        keyframe.value[property] = prev.value[property];
                        continue;
                    }
                    interpolate(keyframe, prev, next, property);
                }
            }
        }
        function getPrev(keyframes, i, property) {
            while(i >= 0){
                const keyframe = keyframes[i];
                if (keyframe.value[property] !== null) return keyframe;
                i--;
            }
            return null;
        }
        function getNext(keyframes, i, property) {
            while(i < keyframes.length){
                const keyframe = keyframes[i];
                if (keyframe.value[property] !== null) return keyframe;
                i++;
            }
            return null;
        }
        function interpolate(key, prev, next, property) {
            if (next.time - prev.time === 0) {
                key.value[property] = prev.value[property];
                return;
            }
            key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];
        }
        function parseAnimationClip(xml2) {
            const data = {
                name: xml2.getAttribute("id") || "default",
                start: parseFloat(xml2.getAttribute("start") || 0),
                end: parseFloat(xml2.getAttribute("end") || 0),
                animations: []
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "instance_animation":
                        data.animations.push(parseId(child.getAttribute("url")));
                        break;
                }
            }
            library.clips[xml2.getAttribute("id")] = data;
        }
        function buildAnimationClip(data) {
            const tracks = [];
            const name = data.name;
            const duration = data.end - data.start || -1;
            const animations2 = data.animations;
            for(let i = 0, il = animations2.length; i < il; i++){
                const animationTracks = getAnimation(animations2[i]);
                for(let j = 0, jl = animationTracks.length; j < jl; j++){
                    tracks.push(animationTracks[j]);
                }
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](name, duration, tracks);
        }
        function getAnimationClip(id) {
            return getBuild(library.clips[id], buildAnimationClip);
        }
        function parseController(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "skin":
                        data.id = parseId(child.getAttribute("source"));
                        data.skin = parseSkin(child);
                        break;
                    case "morph":
                        data.id = parseId(child.getAttribute("source"));
                        console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                        break;
                }
            }
            library.controllers[xml2.getAttribute("id")] = data;
        }
        function parseSkin(xml2) {
            const data = {
                sources: {}
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "bind_shape_matrix":
                        data.bindShapeMatrix = parseFloats(child.textContent);
                        break;
                    case "source":
                        const id = child.getAttribute("id");
                        data.sources[id] = parseSource(child);
                        break;
                    case "joints":
                        data.joints = parseJoints(child);
                        break;
                    case "vertex_weights":
                        data.vertexWeights = parseVertexWeights(child);
                        break;
                }
            }
            return data;
        }
        function parseJoints(xml2) {
            const data = {
                inputs: {}
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        const semantic = child.getAttribute("semantic");
                        const id = parseId(child.getAttribute("source"));
                        data.inputs[semantic] = id;
                        break;
                }
            }
            return data;
        }
        function parseVertexWeights(xml2) {
            const data = {
                inputs: {}
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        const semantic = child.getAttribute("semantic");
                        const id = parseId(child.getAttribute("source"));
                        const offset = parseInt(child.getAttribute("offset"));
                        data.inputs[semantic] = {
                            id,
                            offset
                        };
                        break;
                    case "vcount":
                        data.vcount = parseInts(child.textContent);
                        break;
                    case "v":
                        data.v = parseInts(child.textContent);
                        break;
                }
            }
            return data;
        }
        function buildController(data) {
            const build = {
                id: data.id
            };
            const geometry = library.geometries[build.id];
            if (data.skin !== void 0) {
                build.skin = buildSkin(data.skin);
                geometry.sources.skinIndices = build.skin.indices;
                geometry.sources.skinWeights = build.skin.weights;
            }
            return build;
        }
        function buildSkin(data) {
            const BONE_LIMIT = 4;
            const build = {
                joints: [],
                // this must be an array to preserve the joint order
                indices: {
                    array: [],
                    stride: BONE_LIMIT
                },
                weights: {
                    array: [],
                    stride: BONE_LIMIT
                }
            };
            const sources = data.sources;
            const vertexWeights = data.vertexWeights;
            const vcount = vertexWeights.vcount;
            const v = vertexWeights.v;
            const jointOffset = vertexWeights.inputs.JOINT.offset;
            const weightOffset = vertexWeights.inputs.WEIGHT.offset;
            const jointSource = data.sources[data.joints.inputs.JOINT];
            const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];
            const weights = sources[vertexWeights.inputs.WEIGHT.id].array;
            let stride = 0;
            let i, j, l;
            for(i = 0, l = vcount.length; i < l; i++){
                const jointCount = vcount[i];
                const vertexSkinData = [];
                for(j = 0; j < jointCount; j++){
                    const skinIndex = v[stride + jointOffset];
                    const weightId = v[stride + weightOffset];
                    const skinWeight = weights[weightId];
                    vertexSkinData.push({
                        index: skinIndex,
                        weight: skinWeight
                    });
                    stride += 2;
                }
                vertexSkinData.sort(descending);
                for(j = 0; j < BONE_LIMIT; j++){
                    const d = vertexSkinData[j];
                    if (d !== void 0) {
                        build.indices.array.push(d.index);
                        build.weights.array.push(d.weight);
                    } else {
                        build.indices.array.push(0);
                        build.weights.array.push(0);
                    }
                }
            }
            if (data.bindShapeMatrix) {
                build.bindMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().fromArray(data.bindShapeMatrix).transpose();
            } else {
                build.bindMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().identity();
            }
            for(i = 0, l = jointSource.array.length; i < l; i++){
                const name = jointSource.array[i];
                const boneInverse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().fromArray(inverseSource.array, i * inverseSource.stride).transpose();
                build.joints.push({
                    name,
                    boneInverse
                });
            }
            return build;
            "TURBOPACK unreachable";
            function descending(a, b) {
                return b.weight - a.weight;
            }
        }
        function getController(id) {
            return getBuild(library.controllers[id], buildController);
        }
        function parseImage(xml2) {
            const data = {
                init_from: getElementsByTagName(xml2, "init_from")[0].textContent
            };
            library.images[xml2.getAttribute("id")] = data;
        }
        function buildImage(data) {
            if (data.build !== void 0) return data.build;
            return data.init_from;
        }
        function getImage(id) {
            const data = library.images[id];
            if (data !== void 0) {
                return getBuild(data, buildImage);
            }
            console.warn("THREE.ColladaLoader: Couldn't find image with ID:", id);
            return null;
        }
        function parseEffect(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "profile_COMMON":
                        data.profile = parseEffectProfileCOMMON(child);
                        break;
                }
            }
            library.effects[xml2.getAttribute("id")] = data;
        }
        function parseEffectProfileCOMMON(xml2) {
            const data = {
                surfaces: {},
                samplers: {}
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "newparam":
                        parseEffectNewparam(child, data);
                        break;
                    case "technique":
                        data.technique = parseEffectTechnique(child);
                        break;
                    case "extra":
                        data.extra = parseEffectExtra(child);
                        break;
                }
            }
            return data;
        }
        function parseEffectNewparam(xml2, data) {
            const sid = xml2.getAttribute("sid");
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "surface":
                        data.surfaces[sid] = parseEffectSurface(child);
                        break;
                    case "sampler2D":
                        data.samplers[sid] = parseEffectSampler(child);
                        break;
                }
            }
        }
        function parseEffectSurface(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "init_from":
                        data.init_from = child.textContent;
                        break;
                }
            }
            return data;
        }
        function parseEffectSampler(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "source":
                        data.source = child.textContent;
                        break;
                }
            }
            return data;
        }
        function parseEffectTechnique(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "constant":
                    case "lambert":
                    case "blinn":
                    case "phong":
                        data.type = child.nodeName;
                        data.parameters = parseEffectParameters(child);
                        break;
                    case "extra":
                        data.extra = parseEffectExtra(child);
                        break;
                }
            }
            return data;
        }
        function parseEffectParameters(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "emission":
                    case "diffuse":
                    case "specular":
                    case "bump":
                    case "ambient":
                    case "shininess":
                    case "transparency":
                        data[child.nodeName] = parseEffectParameter(child);
                        break;
                    case "transparent":
                        data[child.nodeName] = {
                            opaque: child.hasAttribute("opaque") ? child.getAttribute("opaque") : "A_ONE",
                            data: parseEffectParameter(child)
                        };
                        break;
                }
            }
            return data;
        }
        function parseEffectParameter(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "color":
                        data[child.nodeName] = parseFloats(child.textContent);
                        break;
                    case "float":
                        data[child.nodeName] = parseFloat(child.textContent);
                        break;
                    case "texture":
                        data[child.nodeName] = {
                            id: child.getAttribute("texture"),
                            extra: parseEffectParameterTexture(child)
                        };
                        break;
                }
            }
            return data;
        }
        function parseEffectParameterTexture(xml2) {
            const data = {
                technique: {}
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "extra":
                        parseEffectParameterTextureExtra(child, data);
                        break;
                }
            }
            return data;
        }
        function parseEffectParameterTextureExtra(xml2, data) {
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique":
                        parseEffectParameterTextureExtraTechnique(child, data);
                        break;
                }
            }
        }
        function parseEffectParameterTextureExtraTechnique(xml2, data) {
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "repeatU":
                    case "repeatV":
                    case "offsetU":
                    case "offsetV":
                        data.technique[child.nodeName] = parseFloat(child.textContent);
                        break;
                    case "wrapU":
                    case "wrapV":
                        if (child.textContent.toUpperCase() === "TRUE") {
                            data.technique[child.nodeName] = 1;
                        } else if (child.textContent.toUpperCase() === "FALSE") {
                            data.technique[child.nodeName] = 0;
                        } else {
                            data.technique[child.nodeName] = parseInt(child.textContent);
                        }
                        break;
                    case "bump":
                        data[child.nodeName] = parseEffectExtraTechniqueBump(child);
                        break;
                }
            }
        }
        function parseEffectExtra(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique":
                        data.technique = parseEffectExtraTechnique(child);
                        break;
                }
            }
            return data;
        }
        function parseEffectExtraTechnique(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "double_sided":
                        data[child.nodeName] = parseInt(child.textContent);
                        break;
                    case "bump":
                        data[child.nodeName] = parseEffectExtraTechniqueBump(child);
                        break;
                }
            }
            return data;
        }
        function parseEffectExtraTechniqueBump(xml2) {
            var data = {};
            for(var i = 0, l = xml2.childNodes.length; i < l; i++){
                var child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "texture":
                        data[child.nodeName] = {
                            id: child.getAttribute("texture"),
                            texcoord: child.getAttribute("texcoord"),
                            extra: parseEffectParameterTexture(child)
                        };
                        break;
                }
            }
            return data;
        }
        function buildEffect(data) {
            return data;
        }
        function getEffect(id) {
            return getBuild(library.effects[id], buildEffect);
        }
        function parseMaterial(xml2) {
            const data = {
                name: xml2.getAttribute("name")
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "instance_effect":
                        data.url = parseId(child.getAttribute("url"));
                        break;
                }
            }
            library.materials[xml2.getAttribute("id")] = data;
        }
        function getTextureLoader(image) {
            let loader;
            let extension = image.slice((image.lastIndexOf(".") - 1 >>> 0) + 2);
            extension = extension.toLowerCase();
            switch(extension){
                case "tga":
                    loader = tgaLoader;
                    break;
                default:
                    loader = textureLoader;
            }
            return loader;
        }
        function buildMaterial(data) {
            const effect = getEffect(data.url);
            const technique = effect.profile.technique;
            let material;
            switch(technique.type){
                case "phong":
                case "blinn":
                    material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]();
                    break;
                case "lambert":
                    material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]();
                    break;
                default:
                    material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]();
                    break;
            }
            material.name = data.name || "";
            function getTexture(textureObject) {
                const sampler = effect.profile.samplers[textureObject.id];
                let image = null;
                if (sampler !== void 0) {
                    const surface = effect.profile.surfaces[sampler.source];
                    image = getImage(surface.init_from);
                } else {
                    console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).");
                    image = getImage(textureObject.id);
                }
                if (image !== null) {
                    const loader = getTextureLoader(image);
                    if (loader !== void 0) {
                        const texture = loader.load(image);
                        const extra = textureObject.extra;
                        if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {
                            const technique2 = extra.technique;
                            texture.wrapS = technique2.wrapU ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
                            texture.wrapT = technique2.wrapV ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
                            texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);
                            texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);
                        } else {
                            texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                            texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                        }
                        return texture;
                    } else {
                        console.warn("THREE.ColladaLoader: Loader for texture %s not found.", image);
                        return null;
                    }
                } else {
                    console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", textureObject.id);
                    return null;
                }
            }
            const parameters = technique.parameters;
            for(const key in parameters){
                const parameter = parameters[key];
                switch(key){
                    case "diffuse":
                        if (parameter.color) material.color.fromArray(parameter.color);
                        if (parameter.texture) material.map = getTexture(parameter.texture);
                        break;
                    case "specular":
                        if (parameter.color && material.specular) material.specular.fromArray(parameter.color);
                        if (parameter.texture) material.specularMap = getTexture(parameter.texture);
                        break;
                    case "bump":
                        if (parameter.texture) material.normalMap = getTexture(parameter.texture);
                        break;
                    case "ambient":
                        if (parameter.texture) material.lightMap = getTexture(parameter.texture);
                        break;
                    case "shininess":
                        if (parameter.float && material.shininess) material.shininess = parameter.float;
                        break;
                    case "emission":
                        if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);
                        if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);
                        break;
                }
            }
            let transparent = parameters["transparent"];
            let transparency = parameters["transparency"];
            if (transparency === void 0 && transparent) {
                transparency = {
                    float: 1
                };
            }
            if (transparent === void 0 && transparency) {
                transparent = {
                    opaque: "A_ONE",
                    data: {
                        color: [
                            1,
                            1,
                            1,
                            1
                        ]
                    }
                };
            }
            if (transparent && transparency) {
                if (transparent.data.texture) {
                    material.transparent = true;
                } else {
                    const color = transparent.data.color;
                    switch(transparent.opaque){
                        case "A_ONE":
                            material.opacity = color[3] * transparency.float;
                            break;
                        case "RGB_ZERO":
                            material.opacity = 1 - color[0] * transparency.float;
                            break;
                        case "A_ZERO":
                            material.opacity = 1 - color[3] * transparency.float;
                            break;
                        case "RGB_ONE":
                            material.opacity = color[0] * transparency.float;
                            break;
                        default:
                            console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);
                    }
                    if (material.opacity < 1) material.transparent = true;
                }
            }
            if (technique.extra !== void 0 && technique.extra.technique !== void 0) {
                const techniques = technique.extra.technique;
                for(const k in techniques){
                    const v = techniques[k];
                    switch(k){
                        case "double_sided":
                            material.side = v === 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"];
                            break;
                        case "bump":
                            material.normalMap = getTexture(v.texture);
                            material.normalScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](1, 1);
                            break;
                    }
                }
            }
            return material;
        }
        function getMaterial(id) {
            return getBuild(library.materials[id], buildMaterial);
        }
        function parseCamera(xml2) {
            const data = {
                name: xml2.getAttribute("name")
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "optics":
                        data.optics = parseCameraOptics(child);
                        break;
                }
            }
            library.cameras[xml2.getAttribute("id")] = data;
        }
        function parseCameraOptics(xml2) {
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                switch(child.nodeName){
                    case "technique_common":
                        return parseCameraTechnique(child);
                }
            }
            return {};
        }
        function parseCameraTechnique(xml2) {
            const data = {};
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                switch(child.nodeName){
                    case "perspective":
                    case "orthographic":
                        data.technique = child.nodeName;
                        data.parameters = parseCameraParameters(child);
                        break;
                }
            }
            return data;
        }
        function parseCameraParameters(xml2) {
            const data = {};
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                switch(child.nodeName){
                    case "xfov":
                    case "yfov":
                    case "xmag":
                    case "ymag":
                    case "znear":
                    case "zfar":
                    case "aspect_ratio":
                        data[child.nodeName] = parseFloat(child.textContent);
                        break;
                }
            }
            return data;
        }
        function buildCamera(data) {
            let camera;
            switch(data.optics.technique){
                case "perspective":
                    camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"](data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);
                    break;
                case "orthographic":
                    let ymag = data.optics.parameters.ymag;
                    let xmag = data.optics.parameters.xmag;
                    const aspectRatio = data.optics.parameters.aspect_ratio;
                    xmag = xmag === void 0 ? ymag * aspectRatio : xmag;
                    ymag = ymag === void 0 ? xmag / aspectRatio : ymag;
                    xmag *= 0.5;
                    ymag *= 0.5;
                    camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-xmag, xmag, ymag, -ymag, // left, right, top, bottom
                    data.optics.parameters.znear, data.optics.parameters.zfar);
                    break;
                default:
                    camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
                    break;
            }
            camera.name = data.name || "";
            return camera;
        }
        function getCamera(id) {
            const data = library.cameras[id];
            if (data !== void 0) {
                return getBuild(data, buildCamera);
            }
            console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", id);
            return null;
        }
        function parseLight(xml2) {
            let data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique_common":
                        data = parseLightTechnique(child);
                        break;
                }
            }
            library.lights[xml2.getAttribute("id")] = data;
        }
        function parseLightTechnique(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "directional":
                    case "point":
                    case "spot":
                    case "ambient":
                        data.technique = child.nodeName;
                        data.parameters = parseLightParameters(child);
                }
            }
            return data;
        }
        function parseLightParameters(xml2) {
            const data = {};
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "color":
                        const array = parseFloats(child.textContent);
                        data.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(array);
                        break;
                    case "falloff_angle":
                        data.falloffAngle = parseFloat(child.textContent);
                        break;
                    case "quadratic_attenuation":
                        const f = parseFloat(child.textContent);
                        data.distance = f ? Math.sqrt(1 / f) : 0;
                        break;
                }
            }
            return data;
        }
        function buildLight(data) {
            let light;
            switch(data.technique){
                case "directional":
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DirectionalLight"]();
                    break;
                case "point":
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"]();
                    break;
                case "spot":
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpotLight"]();
                    break;
                case "ambient":
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AmbientLight"]();
                    break;
            }
            if (data.parameters.color) light.color.copy(data.parameters.color);
            if (data.parameters.distance) light.distance = data.parameters.distance;
            return light;
        }
        function getLight(id) {
            const data = library.lights[id];
            if (data !== void 0) {
                return getBuild(data, buildLight);
            }
            console.warn("THREE.ColladaLoader: Couldn't find light with ID:", id);
            return null;
        }
        function parseGeometry(xml2) {
            const data = {
                name: xml2.getAttribute("name"),
                sources: {},
                vertices: {},
                primitives: []
            };
            const mesh = getElementsByTagName(xml2, "mesh")[0];
            if (mesh === void 0) return;
            for(let i = 0; i < mesh.childNodes.length; i++){
                const child = mesh.childNodes[i];
                if (child.nodeType !== 1) continue;
                const id = child.getAttribute("id");
                switch(child.nodeName){
                    case "source":
                        data.sources[id] = parseSource(child);
                        break;
                    case "vertices":
                        data.vertices = parseGeometryVertices(child);
                        break;
                    case "polygons":
                        console.warn("THREE.ColladaLoader: Unsupported primitive type: ", child.nodeName);
                        break;
                    case "lines":
                    case "linestrips":
                    case "polylist":
                    case "triangles":
                        data.primitives.push(parseGeometryPrimitive(child));
                        break;
                    default:
                        console.log(child);
                }
            }
            library.geometries[xml2.getAttribute("id")] = data;
        }
        function parseSource(xml2) {
            const data = {
                array: [],
                stride: 3
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "float_array":
                        data.array = parseFloats(child.textContent);
                        break;
                    case "Name_array":
                        data.array = parseStrings(child.textContent);
                        break;
                    case "technique_common":
                        const accessor = getElementsByTagName(child, "accessor")[0];
                        if (accessor !== void 0) {
                            data.stride = parseInt(accessor.getAttribute("stride"));
                        }
                        break;
                }
            }
            return data;
        }
        function parseGeometryVertices(xml2) {
            const data = {};
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                data[child.getAttribute("semantic")] = parseId(child.getAttribute("source"));
            }
            return data;
        }
        function parseGeometryPrimitive(xml2) {
            const primitive = {
                type: xml2.nodeName,
                material: xml2.getAttribute("material"),
                count: parseInt(xml2.getAttribute("count")),
                inputs: {},
                stride: 0,
                hasUV: false
            };
            for(let i = 0, l = xml2.childNodes.length; i < l; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        const id = parseId(child.getAttribute("source"));
                        const semantic = child.getAttribute("semantic");
                        const offset = parseInt(child.getAttribute("offset"));
                        const set = parseInt(child.getAttribute("set"));
                        const inputname = set > 0 ? semantic + set : semantic;
                        primitive.inputs[inputname] = {
                            id,
                            offset
                        };
                        primitive.stride = Math.max(primitive.stride, offset + 1);
                        if (semantic === "TEXCOORD") primitive.hasUV = true;
                        break;
                    case "vcount":
                        primitive.vcount = parseInts(child.textContent);
                        break;
                    case "p":
                        primitive.p = parseInts(child.textContent);
                        break;
                }
            }
            return primitive;
        }
        function groupPrimitives(primitives) {
            const build = {};
            for(let i = 0; i < primitives.length; i++){
                const primitive = primitives[i];
                if (build[primitive.type] === void 0) build[primitive.type] = [];
                build[primitive.type].push(primitive);
            }
            return build;
        }
        function checkUVCoordinates(primitives) {
            let count2 = 0;
            for(let i = 0, l = primitives.length; i < l; i++){
                const primitive = primitives[i];
                if (primitive.hasUV === true) {
                    count2++;
                }
            }
            if (count2 > 0 && count2 < primitives.length) {
                primitives.uvsNeedsFix = true;
            }
        }
        function buildGeometry(data) {
            const build = {};
            const sources = data.sources;
            const vertices = data.vertices;
            const primitives = data.primitives;
            if (primitives.length === 0) return {};
            const groupedPrimitives = groupPrimitives(primitives);
            for(const type in groupedPrimitives){
                const primitiveType = groupedPrimitives[type];
                checkUVCoordinates(primitiveType);
                build[type] = buildGeometryType(primitiveType, sources, vertices);
            }
            return build;
        }
        function buildGeometryType(primitives, sources, vertices) {
            const build = {};
            const position2 = {
                array: [],
                stride: 0
            };
            const normal = {
                array: [],
                stride: 0
            };
            const uv = {
                array: [],
                stride: 0
            };
            const uv1 = {
                array: [],
                stride: 0
            };
            const color = {
                array: [],
                stride: 0
            };
            const skinIndex = {
                array: [],
                stride: 4
            };
            const skinWeight = {
                array: [],
                stride: 4
            };
            const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            const materialKeys = [];
            let start = 0;
            for(let p = 0; p < primitives.length; p++){
                const primitive = primitives[p];
                const inputs = primitive.inputs;
                let count2 = 0;
                switch(primitive.type){
                    case "lines":
                    case "linestrips":
                        count2 = primitive.count * 2;
                        break;
                    case "triangles":
                        count2 = primitive.count * 3;
                        break;
                    case "polylist":
                        for(let g = 0; g < primitive.count; g++){
                            const vc = primitive.vcount[g];
                            switch(vc){
                                case 3:
                                    count2 += 3;
                                    break;
                                case 4:
                                    count2 += 6;
                                    break;
                                default:
                                    count2 += (vc - 2) * 3;
                                    break;
                            }
                        }
                        break;
                    default:
                        console.warn("THREE.ColladaLoader: Unknow primitive type:", primitive.type);
                }
                geometry.addGroup(start, count2, p);
                start += count2;
                if (primitive.material) {
                    materialKeys.push(primitive.material);
                }
                for(const name in inputs){
                    const input = inputs[name];
                    switch(name){
                        case "VERTEX":
                            for(const key in vertices){
                                const id = vertices[key];
                                switch(key){
                                    case "POSITION":
                                        const prevLength = position2.array.length;
                                        buildGeometryData(primitive, sources[id], input.offset, position2.array);
                                        position2.stride = sources[id].stride;
                                        if (sources.skinWeights && sources.skinIndices) {
                                            buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
                                            buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
                                        }
                                        if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {
                                            const count3 = (position2.array.length - prevLength) / position2.stride;
                                            for(let i = 0; i < count3; i++){
                                                uv.array.push(0, 0);
                                            }
                                        }
                                        break;
                                    case "NORMAL":
                                        buildGeometryData(primitive, sources[id], input.offset, normal.array);
                                        normal.stride = sources[id].stride;
                                        break;
                                    case "COLOR":
                                        buildGeometryData(primitive, sources[id], input.offset, color.array);
                                        color.stride = sources[id].stride;
                                        break;
                                    case "TEXCOORD":
                                        buildGeometryData(primitive, sources[id], input.offset, uv.array);
                                        uv.stride = sources[id].stride;
                                        break;
                                    case "TEXCOORD1":
                                        buildGeometryData(primitive, sources[id], input.offset, uv1.array);
                                        uv.stride = sources[id].stride;
                                        break;
                                    default:
                                        console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);
                                }
                            }
                            break;
                        case "NORMAL":
                            buildGeometryData(primitive, sources[input.id], input.offset, normal.array);
                            normal.stride = sources[input.id].stride;
                            break;
                        case "COLOR":
                            buildGeometryData(primitive, sources[input.id], input.offset, color.array);
                            color.stride = sources[input.id].stride;
                            break;
                        case "TEXCOORD":
                            buildGeometryData(primitive, sources[input.id], input.offset, uv.array);
                            uv.stride = sources[input.id].stride;
                            break;
                        case "TEXCOORD1":
                            buildGeometryData(primitive, sources[input.id], input.offset, uv1.array);
                            uv1.stride = sources[input.id].stride;
                            break;
                    }
                }
            }
            if (position2.array.length > 0) {
                geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](position2.array, position2.stride));
            }
            if (normal.array.length > 0) {
                geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normal.array, normal.stride));
            }
            if (color.array.length > 0) geometry.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](color.array, color.stride));
            if (uv.array.length > 0) geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uv.array, uv.stride));
            if (uv1.array.length > 0) geometry.setAttribute(UV1, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uv1.array, uv1.stride));
            if (skinIndex.array.length > 0) {
                geometry.setAttribute("skinIndex", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](skinIndex.array, skinIndex.stride));
            }
            if (skinWeight.array.length > 0) {
                geometry.setAttribute("skinWeight", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](skinWeight.array, skinWeight.stride));
            }
            build.data = geometry;
            build.type = primitives[0].type;
            build.materialKeys = materialKeys;
            return build;
        }
        function buildGeometryData(primitive, source, offset, array) {
            const indices = primitive.p;
            const stride = primitive.stride;
            const vcount = primitive.vcount;
            function pushVector(i) {
                let index = indices[i + offset] * sourceStride;
                const length = index + sourceStride;
                for(; index < length; index++){
                    array.push(sourceArray[index]);
                }
            }
            const sourceArray = source.array;
            const sourceStride = source.stride;
            if (primitive.vcount !== void 0) {
                let index = 0;
                for(let i = 0, l = vcount.length; i < l; i++){
                    const count2 = vcount[i];
                    if (count2 === 4) {
                        const a = index + stride * 0;
                        const b = index + stride * 1;
                        const c = index + stride * 2;
                        const d = index + stride * 3;
                        pushVector(a);
                        pushVector(b);
                        pushVector(d);
                        pushVector(b);
                        pushVector(c);
                        pushVector(d);
                    } else if (count2 === 3) {
                        const a = index + stride * 0;
                        const b = index + stride * 1;
                        const c = index + stride * 2;
                        pushVector(a);
                        pushVector(b);
                        pushVector(c);
                    } else if (count2 > 4) {
                        for(let k = 1, kl = count2 - 2; k <= kl; k++){
                            const a = index + stride * 0;
                            const b = index + stride * k;
                            const c = index + stride * (k + 1);
                            pushVector(a);
                            pushVector(b);
                            pushVector(c);
                        }
                    }
                    index += stride * count2;
                }
            } else {
                for(let i = 0, l = indices.length; i < l; i += stride){
                    pushVector(i);
                }
            }
        }
        function getGeometry(id) {
            return getBuild(library.geometries[id], buildGeometry);
        }
        function parseKinematicsModel(xml2) {
            const data = {
                name: xml2.getAttribute("name") || "",
                joints: {},
                links: []
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique_common":
                        parseKinematicsTechniqueCommon(child, data);
                        break;
                }
            }
            library.kinematicsModels[xml2.getAttribute("id")] = data;
        }
        function buildKinematicsModel(data) {
            if (data.build !== void 0) return data.build;
            return data;
        }
        function getKinematicsModel(id) {
            return getBuild(library.kinematicsModels[id], buildKinematicsModel);
        }
        function parseKinematicsTechniqueCommon(xml2, data) {
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "joint":
                        data.joints[child.getAttribute("sid")] = parseKinematicsJoint(child);
                        break;
                    case "link":
                        data.links.push(parseKinematicsLink(child));
                        break;
                }
            }
        }
        function parseKinematicsJoint(xml2) {
            let data;
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "prismatic":
                    case "revolute":
                        data = parseKinematicsJointParameter(child);
                        break;
                }
            }
            return data;
        }
        function parseKinematicsJointParameter(xml2) {
            const data = {
                sid: xml2.getAttribute("sid"),
                name: xml2.getAttribute("name") || "",
                axis: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                limits: {
                    min: 0,
                    max: 0
                },
                type: xml2.nodeName,
                static: false,
                zeroPosition: 0,
                middlePosition: 0
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "axis":
                        const array = parseFloats(child.textContent);
                        data.axis.fromArray(array);
                        break;
                    case "limits":
                        const max = child.getElementsByTagName("max")[0];
                        const min = child.getElementsByTagName("min")[0];
                        data.limits.max = parseFloat(max.textContent);
                        data.limits.min = parseFloat(min.textContent);
                        break;
                }
            }
            if (data.limits.min >= data.limits.max) {
                data.static = true;
            }
            data.middlePosition = (data.limits.min + data.limits.max) / 2;
            return data;
        }
        function parseKinematicsLink(xml2) {
            const data = {
                sid: xml2.getAttribute("sid"),
                name: xml2.getAttribute("name") || "",
                attachments: [],
                transforms: []
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "attachment_full":
                        data.attachments.push(parseKinematicsAttachment(child));
                        break;
                    case "matrix":
                    case "translate":
                    case "rotate":
                        data.transforms.push(parseKinematicsTransform(child));
                        break;
                }
            }
            return data;
        }
        function parseKinematicsAttachment(xml2) {
            const data = {
                joint: xml2.getAttribute("joint").split("/").pop(),
                transforms: [],
                links: []
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "link":
                        data.links.push(parseKinematicsLink(child));
                        break;
                    case "matrix":
                    case "translate":
                    case "rotate":
                        data.transforms.push(parseKinematicsTransform(child));
                        break;
                }
            }
            return data;
        }
        function parseKinematicsTransform(xml2) {
            const data = {
                type: xml2.nodeName
            };
            const array = parseFloats(xml2.textContent);
            switch(data.type){
                case "matrix":
                    data.obj = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                    data.obj.fromArray(array).transpose();
                    break;
                case "translate":
                    data.obj = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                    data.obj.fromArray(array);
                    break;
                case "rotate":
                    data.obj = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                    data.obj.fromArray(array);
                    data.angle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(array[3]);
                    break;
            }
            return data;
        }
        function parsePhysicsModel(xml2) {
            const data = {
                name: xml2.getAttribute("name") || "",
                rigidBodies: {}
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "rigid_body":
                        data.rigidBodies[child.getAttribute("name")] = {};
                        parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute("name")]);
                        break;
                }
            }
            library.physicsModels[xml2.getAttribute("id")] = data;
        }
        function parsePhysicsRigidBody(xml2, data) {
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique_common":
                        parsePhysicsTechniqueCommon(child, data);
                        break;
                }
            }
        }
        function parsePhysicsTechniqueCommon(xml2, data) {
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "inertia":
                        data.inertia = parseFloats(child.textContent);
                        break;
                    case "mass":
                        data.mass = parseFloats(child.textContent)[0];
                        break;
                }
            }
        }
        function parseKinematicsScene(xml2) {
            const data = {
                bindJointAxis: []
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "bind_joint_axis":
                        data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
                        break;
                }
            }
            library.kinematicsScenes[parseId(xml2.getAttribute("url"))] = data;
        }
        function parseKinematicsBindJointAxis(xml2) {
            const data = {
                target: xml2.getAttribute("target").split("/").pop()
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "axis":
                        const param = child.getElementsByTagName("param")[0];
                        data.axis = param.textContent;
                        const tmpJointIndex = data.axis.split("inst_").pop().split("axis")[0];
                        data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);
                        break;
                }
            }
            return data;
        }
        function buildKinematicsScene(data) {
            if (data.build !== void 0) return data.build;
            return data;
        }
        function getKinematicsScene(id) {
            return getBuild(library.kinematicsScenes[id], buildKinematicsScene);
        }
        function setupKinematics() {
            const kinematicsModelId = Object.keys(library.kinematicsModels)[0];
            const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
            const visualSceneId = Object.keys(library.visualScenes)[0];
            if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;
            const kinematicsModel = getKinematicsModel(kinematicsModelId);
            const kinematicsScene = getKinematicsScene(kinematicsSceneId);
            const visualScene = getVisualScene(visualSceneId);
            const bindJointAxis = kinematicsScene.bindJointAxis;
            const jointMap = {};
            for(let i = 0, l = bindJointAxis.length; i < l; i++){
                const axis = bindJointAxis[i];
                const targetElement = collada.querySelector('[sid="' + axis.target + '"]');
                if (targetElement) {
                    const parentVisualElement = targetElement.parentElement;
                    connect(axis.jointIndex, parentVisualElement);
                }
            }
            function connect(jointIndex, visualElement) {
                const visualElementName = visualElement.getAttribute("name");
                const joint = kinematicsModel.joints[jointIndex];
                visualScene.traverse(function(object) {
                    if (object.name === visualElementName) {
                        jointMap[jointIndex] = {
                            object,
                            transforms: buildTransformList(visualElement),
                            joint,
                            position: joint.zeroPosition
                        };
                    }
                });
            }
            const m0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            kinematics = {
                joints: kinematicsModel && kinematicsModel.joints,
                getJointValue: function(jointIndex) {
                    const jointData = jointMap[jointIndex];
                    if (jointData) {
                        return jointData.position;
                    } else {
                        console.warn("THREE.ColladaLoader: Joint " + jointIndex + " doesn't exist.");
                    }
                },
                setJointValue: function(jointIndex, value) {
                    const jointData = jointMap[jointIndex];
                    if (jointData) {
                        const joint = jointData.joint;
                        if (value > joint.limits.max || value < joint.limits.min) {
                            console.warn("THREE.ColladaLoader: Joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ").");
                        } else if (joint.static) {
                            console.warn("THREE.ColladaLoader: Joint " + jointIndex + " is static.");
                        } else {
                            const object = jointData.object;
                            const axis = joint.axis;
                            const transforms = jointData.transforms;
                            matrix.identity();
                            for(let i = 0; i < transforms.length; i++){
                                const transform = transforms[i];
                                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {
                                    switch(joint.type){
                                        case "revolute":
                                            matrix.multiply(m0.makeRotationAxis(axis, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(value)));
                                            break;
                                        case "prismatic":
                                            matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
                                            break;
                                        default:
                                            console.warn("THREE.ColladaLoader: Unknown joint type: " + joint.type);
                                            break;
                                    }
                                } else {
                                    switch(transform.type){
                                        case "matrix":
                                            matrix.multiply(transform.obj);
                                            break;
                                        case "translate":
                                            matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                                            break;
                                        case "scale":
                                            matrix.scale(transform.obj);
                                            break;
                                        case "rotate":
                                            matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));
                                            break;
                                    }
                                }
                            }
                            object.matrix.copy(matrix);
                            object.matrix.decompose(object.position, object.quaternion, object.scale);
                            jointMap[jointIndex].position = value;
                        }
                    } else {
                        console.log("THREE.ColladaLoader: " + jointIndex + " does not exist.");
                    }
                }
            };
        }
        function buildTransformList(node) {
            const transforms = [];
            const xml2 = collada.querySelector('[id="' + node.id + '"]');
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                let array, vector2;
                switch(child.nodeName){
                    case "matrix":
                        array = parseFloats(child.textContent);
                        const matrix2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().fromArray(array).transpose();
                        transforms.push({
                            sid: child.getAttribute("sid"),
                            type: child.nodeName,
                            obj: matrix2
                        });
                        break;
                    case "translate":
                    case "scale":
                        array = parseFloats(child.textContent);
                        vector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(array);
                        transforms.push({
                            sid: child.getAttribute("sid"),
                            type: child.nodeName,
                            obj: vector2
                        });
                        break;
                    case "rotate":
                        array = parseFloats(child.textContent);
                        vector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(array);
                        const angle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(array[3]);
                        transforms.push({
                            sid: child.getAttribute("sid"),
                            type: child.nodeName,
                            obj: vector2,
                            angle
                        });
                        break;
                }
            }
            return transforms;
        }
        function prepareNodes(xml2) {
            const elements = xml2.getElementsByTagName("node");
            for(let i = 0; i < elements.length; i++){
                const element = elements[i];
                if (element.hasAttribute("id") === false) {
                    element.setAttribute("id", generateId());
                }
            }
        }
        const matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        const vector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        function parseNode(xml2) {
            const data = {
                name: xml2.getAttribute("name") || "",
                type: xml2.getAttribute("type"),
                id: xml2.getAttribute("id"),
                sid: xml2.getAttribute("sid"),
                matrix: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"](),
                nodes: [],
                instanceCameras: [],
                instanceControllers: [],
                instanceLights: [],
                instanceGeometries: [],
                instanceNodes: [],
                transforms: {}
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                if (child.nodeType !== 1) continue;
                let array;
                switch(child.nodeName){
                    case "node":
                        data.nodes.push(child.getAttribute("id"));
                        parseNode(child);
                        break;
                    case "instance_camera":
                        data.instanceCameras.push(parseId(child.getAttribute("url")));
                        break;
                    case "instance_controller":
                        data.instanceControllers.push(parseNodeInstance(child));
                        break;
                    case "instance_light":
                        data.instanceLights.push(parseId(child.getAttribute("url")));
                        break;
                    case "instance_geometry":
                        data.instanceGeometries.push(parseNodeInstance(child));
                        break;
                    case "instance_node":
                        data.instanceNodes.push(parseId(child.getAttribute("url")));
                        break;
                    case "matrix":
                        array = parseFloats(child.textContent);
                        data.matrix.multiply(matrix.fromArray(array).transpose());
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "translate":
                        array = parseFloats(child.textContent);
                        vector.fromArray(array);
                        data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "rotate":
                        array = parseFloats(child.textContent);
                        const angle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(array[3]);
                        data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "scale":
                        array = parseFloats(child.textContent);
                        data.matrix.scale(vector.fromArray(array));
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(child);
                }
            }
            if (hasNode(data.id)) {
                console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", data.id);
            } else {
                library.nodes[data.id] = data;
            }
            return data;
        }
        function parseNodeInstance(xml2) {
            const data = {
                id: parseId(xml2.getAttribute("url")),
                materials: {},
                skeletons: []
            };
            for(let i = 0; i < xml2.childNodes.length; i++){
                const child = xml2.childNodes[i];
                switch(child.nodeName){
                    case "bind_material":
                        const instances = child.getElementsByTagName("instance_material");
                        for(let j = 0; j < instances.length; j++){
                            const instance = instances[j];
                            const symbol = instance.getAttribute("symbol");
                            const target = instance.getAttribute("target");
                            data.materials[symbol] = parseId(target);
                        }
                        break;
                    case "skeleton":
                        data.skeletons.push(parseId(child.textContent));
                        break;
                }
            }
            return data;
        }
        function buildSkeleton(skeletons, joints) {
            const boneData = [];
            const sortedBoneData = [];
            let i, j, data;
            for(i = 0; i < skeletons.length; i++){
                const skeleton = skeletons[i];
                let root;
                if (hasNode(skeleton)) {
                    root = getNode(skeleton);
                    buildBoneHierarchy(root, joints, boneData);
                } else if (hasVisualScene(skeleton)) {
                    const visualScene = library.visualScenes[skeleton];
                    const children = visualScene.children;
                    for(let j2 = 0; j2 < children.length; j2++){
                        const child = children[j2];
                        if (child.type === "JOINT") {
                            const root2 = getNode(child.id);
                            buildBoneHierarchy(root2, joints, boneData);
                        }
                    }
                } else {
                    console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", skeleton);
                }
            }
            for(i = 0; i < joints.length; i++){
                for(j = 0; j < boneData.length; j++){
                    data = boneData[j];
                    if (data.bone.name === joints[i].name) {
                        sortedBoneData[i] = data;
                        data.processed = true;
                        break;
                    }
                }
            }
            for(i = 0; i < boneData.length; i++){
                data = boneData[i];
                if (data.processed === false) {
                    sortedBoneData.push(data);
                    data.processed = true;
                }
            }
            const bones = [];
            const boneInverses = [];
            for(i = 0; i < sortedBoneData.length; i++){
                data = sortedBoneData[i];
                bones.push(data.bone);
                boneInverses.push(data.boneInverse);
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Skeleton"](bones, boneInverses);
        }
        function buildBoneHierarchy(root, joints, boneData) {
            root.traverse(function(object) {
                if (object.isBone === true) {
                    let boneInverse;
                    for(let i = 0; i < joints.length; i++){
                        const joint = joints[i];
                        if (joint.name === object.name) {
                            boneInverse = joint.boneInverse;
                            break;
                        }
                    }
                    if (boneInverse === void 0) {
                        boneInverse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                    }
                    boneData.push({
                        bone: object,
                        boneInverse,
                        processed: false
                    });
                }
            });
        }
        function buildNode(data) {
            const objects = [];
            const matrix2 = data.matrix;
            const nodes = data.nodes;
            const type = data.type;
            const instanceCameras = data.instanceCameras;
            const instanceControllers = data.instanceControllers;
            const instanceLights = data.instanceLights;
            const instanceGeometries = data.instanceGeometries;
            const instanceNodes = data.instanceNodes;
            for(let i = 0, l = nodes.length; i < l; i++){
                objects.push(getNode(nodes[i]));
            }
            for(let i = 0, l = instanceCameras.length; i < l; i++){
                const instanceCamera = getCamera(instanceCameras[i]);
                if (instanceCamera !== null) {
                    objects.push(instanceCamera.clone());
                }
            }
            for(let i = 0, l = instanceControllers.length; i < l; i++){
                const instance = instanceControllers[i];
                const controller = getController(instance.id);
                const geometries = getGeometry(controller.id);
                const newObjects = buildObjects(geometries, instance.materials);
                const skeletons = instance.skeletons;
                const joints = controller.skin.joints;
                const skeleton = buildSkeleton(skeletons, joints);
                for(let j = 0, jl = newObjects.length; j < jl; j++){
                    const object2 = newObjects[j];
                    if (object2.isSkinnedMesh) {
                        object2.bind(skeleton, controller.skin.bindMatrix);
                        object2.normalizeSkinWeights();
                    }
                    objects.push(object2);
                }
            }
            for(let i = 0, l = instanceLights.length; i < l; i++){
                const instanceLight = getLight(instanceLights[i]);
                if (instanceLight !== null) {
                    objects.push(instanceLight.clone());
                }
            }
            for(let i = 0, l = instanceGeometries.length; i < l; i++){
                const instance = instanceGeometries[i];
                const geometries = getGeometry(instance.id);
                const newObjects = buildObjects(geometries, instance.materials);
                for(let j = 0, jl = newObjects.length; j < jl; j++){
                    objects.push(newObjects[j]);
                }
            }
            for(let i = 0, l = instanceNodes.length; i < l; i++){
                objects.push(getNode(instanceNodes[i]).clone());
            }
            let object;
            if (nodes.length === 0 && objects.length === 1) {
                object = objects[0];
            } else {
                object = type === "JOINT" ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
                for(let i = 0; i < objects.length; i++){
                    object.add(objects[i]);
                }
            }
            object.name = type === "JOINT" ? data.sid : data.name;
            object.matrix.copy(matrix2);
            object.matrix.decompose(object.position, object.quaternion, object.scale);
            return object;
        }
        const fallbackMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: 16711935
        });
        function resolveMaterialBinding(keys, instanceMaterials) {
            const materials = [];
            for(let i = 0, l = keys.length; i < l; i++){
                const id = instanceMaterials[keys[i]];
                if (id === void 0) {
                    console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", keys[i]);
                    materials.push(fallbackMaterial);
                } else {
                    materials.push(getMaterial(id));
                }
            }
            return materials;
        }
        function buildObjects(geometries, instanceMaterials) {
            const objects = [];
            for(const type in geometries){
                const geometry = geometries[type];
                const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);
                if (materials.length === 0) {
                    if (type === "lines" || type === "linestrips") {
                        materials.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]());
                    } else {
                        materials.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]());
                    }
                }
                const skinning = geometry.data.attributes.skinIndex !== void 0;
                const material = materials.length === 1 ? materials[0] : materials;
                let object;
                switch(type){
                    case "lines":
                        object = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](geometry.data, material);
                        break;
                    case "linestrips":
                        object = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](geometry.data, material);
                        break;
                    case "triangles":
                    case "polylist":
                        if (skinning) {
                            object = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkinnedMesh"](geometry.data, material);
                        } else {
                            object = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry.data, material);
                        }
                        break;
                }
                objects.push(object);
            }
            return objects;
        }
        function hasNode(id) {
            return library.nodes[id] !== void 0;
        }
        function getNode(id) {
            return getBuild(library.nodes[id], buildNode);
        }
        function parseVisualScene(xml2) {
            const data = {
                name: xml2.getAttribute("name"),
                children: []
            };
            prepareNodes(xml2);
            const elements = getElementsByTagName(xml2, "node");
            for(let i = 0; i < elements.length; i++){
                data.children.push(parseNode(elements[i]));
            }
            library.visualScenes[xml2.getAttribute("id")] = data;
        }
        function buildVisualScene(data) {
            const group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            group.name = data.name;
            const children = data.children;
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                group.add(getNode(child.id));
            }
            return group;
        }
        function hasVisualScene(id) {
            return library.visualScenes[id] !== void 0;
        }
        function getVisualScene(id) {
            return getBuild(library.visualScenes[id], buildVisualScene);
        }
        function parseScene(xml2) {
            const instance = getElementsByTagName(xml2, "instance_visual_scene")[0];
            return getVisualScene(parseId(instance.getAttribute("url")));
        }
        function setupAnimations() {
            const clips = library.clips;
            if (isEmpty(clips) === true) {
                if (isEmpty(library.animations) === false) {
                    const tracks = [];
                    for(const id in library.animations){
                        const animationTracks = getAnimation(id);
                        for(let i = 0, l = animationTracks.length; i < l; i++){
                            tracks.push(animationTracks[i]);
                        }
                    }
                    animations.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"]("default", -1, tracks));
                }
            } else {
                for(const id in clips){
                    animations.push(getAnimationClip(id));
                }
            }
        }
        function parserErrorToText(parserError2) {
            let result = "";
            const stack = [
                parserError2
            ];
            while(stack.length){
                const node = stack.shift();
                if (node.nodeType === Node.TEXT_NODE) {
                    result += node.textContent;
                } else {
                    result += "\n";
                    stack.push.apply(stack, node.childNodes);
                }
            }
            return result.trim();
        }
        if (text.length === 0) {
            return {
                scene: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]()
            };
        }
        const xml = new DOMParser().parseFromString(text, "application/xml");
        const collada = getElementsByTagName(xml, "COLLADA")[0];
        const parserError = xml.getElementsByTagName("parsererror")[0];
        if (parserError !== void 0) {
            const errorElement = getElementsByTagName(parserError, "div")[0];
            let errorText;
            if (errorElement) {
                errorText = errorElement.textContent;
            } else {
                errorText = parserErrorToText(parserError);
            }
            console.error("THREE.ColladaLoader: Failed to parse collada file.\n", errorText);
            return null;
        }
        const version = collada.getAttribute("version");
        console.log("THREE.ColladaLoader: File version", version);
        const asset = parseAsset(getElementsByTagName(collada, "asset")[0]);
        const textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.manager);
        textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        let tgaLoader;
        if (TGALoader) {
            tgaLoader = new TGALoader(this.manager);
            tgaLoader.setPath(this.resourcePath || path);
        }
        const animations = [];
        let kinematics = {};
        let count = 0;
        const library = {
            animations: {},
            clips: {},
            controllers: {},
            images: {},
            effects: {},
            materials: {},
            cameras: {},
            lights: {},
            geometries: {},
            nodes: {},
            visualScenes: {},
            kinematicsModels: {},
            physicsModels: {},
            kinematicsScenes: {}
        };
        parseLibrary(collada, "library_animations", "animation", parseAnimation);
        parseLibrary(collada, "library_animation_clips", "animation_clip", parseAnimationClip);
        parseLibrary(collada, "library_controllers", "controller", parseController);
        parseLibrary(collada, "library_images", "image", parseImage);
        parseLibrary(collada, "library_effects", "effect", parseEffect);
        parseLibrary(collada, "library_materials", "material", parseMaterial);
        parseLibrary(collada, "library_cameras", "camera", parseCamera);
        parseLibrary(collada, "library_lights", "light", parseLight);
        parseLibrary(collada, "library_geometries", "geometry", parseGeometry);
        parseLibrary(collada, "library_nodes", "node", parseNode);
        parseLibrary(collada, "library_visual_scenes", "visual_scene", parseVisualScene);
        parseLibrary(collada, "library_kinematics_models", "kinematics_model", parseKinematicsModel);
        parseLibrary(collada, "library_physics_models", "physics_model", parsePhysicsModel);
        parseLibrary(collada, "scene", "instance_kinematics_scene", parseKinematicsScene);
        buildLibrary(library.animations, buildAnimation);
        buildLibrary(library.clips, buildAnimationClip);
        buildLibrary(library.controllers, buildController);
        buildLibrary(library.images, buildImage);
        buildLibrary(library.effects, buildEffect);
        buildLibrary(library.materials, buildMaterial);
        buildLibrary(library.cameras, buildCamera);
        buildLibrary(library.lights, buildLight);
        buildLibrary(library.geometries, buildGeometry);
        buildLibrary(library.visualScenes, buildVisualScene);
        setupAnimations();
        setupKinematics();
        const scene = parseScene(getElementsByTagName(collada, "scene")[0]);
        scene.animations = animations;
        if (asset.upAxis === "Z_UP") {
            scene.quaternion.setFromEuler(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"](-Math.PI / 2, 0, 0));
        }
        scene.scale.multiplyScalar(asset.unit);
        return {
            get animations () {
                console.warn("THREE.ColladaLoader: Please access animations over scene.animations now.");
                return animations;
            },
            kinematics,
            library,
            scene
        };
    }
}
;
 //# sourceMappingURL=ColladaLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/KMZLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "KMZLoader": (()=>KMZLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$ColladaLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/ColladaLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)");
;
;
;
class KMZLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(data) {
        function findFile(url) {
            for(const path in zip){
                if (path.substr(-url.length) === url) {
                    return zip[path];
                }
            }
        }
        const manager = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoadingManager"]();
        manager.setURLModifier(function(url) {
            const image = findFile(url);
            if (image) {
                console.log("Loading", url);
                const blob = new Blob([
                    image.buffer
                ], {
                    type: "application/octet-stream"
                });
                return URL.createObjectURL(blob);
            }
            return url;
        });
        const zip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzipSync"])(new Uint8Array(data));
        if (zip["doc.kml"]) {
            const xml = new DOMParser().parseFromString(fflate.strFromU8(zip["doc.kml"]), "application/xml");
            const model = xml.querySelector("Placemark Model Link href");
            if (model) {
                const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$ColladaLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ColladaLoader"](manager);
                return loader.parse(fflate.strFromU8(zip[model.textContent]));
            }
        } else {
            console.warn("KMZLoader: Missing doc.kml file.");
            for(const path in zip){
                const extension = path.split(".").pop().toLowerCase();
                if (extension === "dae") {
                    const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$ColladaLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ColladaLoader"](manager);
                    return loader.parse(fflate.strFromU8(zip[path]));
                }
            }
        }
        console.error("KMZLoader: Couldn't find .dae file.");
        return {
            scene: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]()
        };
    }
}
;
 //# sourceMappingURL=KMZLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/KTX2Loader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "KTX2Loader": (()=>KTX2Loader)
});
(()=>{
    const e = new Error("Cannot find module '../utils/WorkerPool.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/libs/ktx-parse.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module '../libs/zstddec.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$CompressedCubeTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/CompressedCubeTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$CompressedArrayTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/CompressedArrayTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$Data3DTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/Data3DTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
;
;
;
;
;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const NoColorSpace = "";
const DisplayP3ColorSpace = "display-p3";
const LinearDisplayP3ColorSpace = "display-p3-linear";
const LinearSRGBColorSpace = "srgb-linear";
const SRGBColorSpace = "srgb";
const _taskCache = /* @__PURE__ */ new WeakMap();
let _activeLoaders = 0;
let _zstd;
const KTX2Loader = /* @__PURE__ */ (()=>{
    const _KTX2Loader = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
        constructor(manager){
            super(manager);
            this.transcoderPath = "";
            this.transcoderBinary = null;
            this.transcoderPending = null;
            this.workerPool = new WorkerPool();
            this.workerSourceURL = "";
            this.workerConfig = null;
            if (typeof MSC_TRANSCODER !== "undefined") {
                console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
            }
        }
        setTranscoderPath(path) {
            this.transcoderPath = path;
            return this;
        }
        setWorkerLimit(num) {
            this.workerPool.setWorkerLimit(num);
            return this;
        }
        detectSupport(renderer) {
            this.workerConfig = {
                astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
                etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
                etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
                dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
                bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
                pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
            };
            if (renderer.capabilities.isWebGL2) {
                this.workerConfig.etc1Supported = false;
            }
            return this;
        }
        init() {
            if (!this.transcoderPending) {
                const jsLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
                jsLoader.setPath(this.transcoderPath);
                jsLoader.setWithCredentials(this.withCredentials);
                const jsContent = jsLoader.loadAsync("basis_transcoder.js");
                const binaryLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
                binaryLoader.setPath(this.transcoderPath);
                binaryLoader.setResponseType("arraybuffer");
                binaryLoader.setWithCredentials(this.withCredentials);
                const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
                this.transcoderPending = Promise.all([
                    jsContent,
                    binaryContent
                ]).then(([jsContent2, binaryContent2])=>{
                    const fn = _KTX2Loader.BasisWorker.toString();
                    const body = [
                        "/* constants */",
                        "let _EngineFormat = " + JSON.stringify(_KTX2Loader.EngineFormat),
                        "let _TranscoderFormat = " + JSON.stringify(_KTX2Loader.TranscoderFormat),
                        "let _BasisFormat = " + JSON.stringify(_KTX2Loader.BasisFormat),
                        "/* basis_transcoder.js */",
                        jsContent2,
                        "/* worker */",
                        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
                    ].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([
                        body
                    ]));
                    this.transcoderBinary = binaryContent2;
                    this.workerPool.setWorkerCreator(()=>{
                        const worker = new Worker(this.workerSourceURL);
                        const transcoderBinary = this.transcoderBinary.slice(0);
                        worker.postMessage({
                            type: "init",
                            config: this.workerConfig,
                            transcoderBinary
                        }, [
                            transcoderBinary
                        ]);
                        return worker;
                    });
                });
                if (_activeLoaders > 0) {
                    console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.");
                }
                _activeLoaders++;
            }
            return this.transcoderPending;
        }
        load(url, onLoad, onProgress, onError) {
            if (this.workerConfig === null) {
                throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
            }
            const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
            loader.setResponseType("arraybuffer");
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, (buffer)=>{
                if (_taskCache.has(buffer)) {
                    const cachedTask = _taskCache.get(buffer);
                    return cachedTask.promise.then(onLoad).catch(onError);
                }
                this._createTexture(buffer).then((texture)=>onLoad ? onLoad(texture) : null).catch(onError);
            }, onProgress, onError);
        }
        _createTextureFrom(transcodeResult, container) {
            const { faces, width, height, format, type, error, dfdFlags } = transcodeResult;
            if (type === "error") return Promise.reject(error);
            let texture;
            if (container.faceCount === 6) {
                texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$CompressedCubeTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedCubeTexture"](faces, format, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"]);
            } else {
                const mipmaps = faces[0].mipmaps;
                texture = container.layerCount > 1 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$CompressedArrayTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedArrayTexture"](mipmaps, width, height, container.layerCount, format, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"]) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTexture"](mipmaps, width, height, format, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"]);
            }
            texture.minFilter = faces[0].mipmaps.length === 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"];
            texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
            texture.generateMipmaps = false;
            texture.needsUpdate = true;
            const colorSpace = parseColorSpace(container);
            if ("colorSpace" in texture) texture.colorSpace = colorSpace;
            else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
            texture.premultiplyAlpha = !!(dfdFlags & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_DF_FLAG_ALPHA_PREMULTIPLIED"]);
            return texture;
        }
        /**
     * @param {ArrayBuffer} buffer
     * @param {object?} config
     * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
     */ async _createTexture(buffer, config = {}) {
            const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["read"])(new Uint8Array(buffer));
            if (container.vkFormat !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_UNDEFINED"]) {
                return createRawTexture(container);
            }
            const taskConfig = config;
            const texturePending = this.init().then(()=>{
                return this.workerPool.postMessage({
                    type: "transcode",
                    buffer,
                    taskConfig
                }, [
                    buffer
                ]);
            }).then((e)=>this._createTextureFrom(e.data, container));
            _taskCache.set(buffer, {
                promise: texturePending
            });
            return texturePending;
        }
        dispose() {
            this.workerPool.dispose();
            if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);
            _activeLoaders--;
            return this;
        }
    };
    let KTX2Loader2 = _KTX2Loader;
    /* CONSTANTS */ __publicField(KTX2Loader2, "BasisFormat", {
        ETC1S: 0,
        UASTC_4x4: 1
    });
    __publicField(KTX2Loader2, "TranscoderFormat", {
        ETC1: 0,
        ETC2: 1,
        BC1: 2,
        BC3: 3,
        BC4: 4,
        BC5: 5,
        BC7_M6_OPAQUE_ONLY: 6,
        BC7_M5: 7,
        PVRTC1_4_RGB: 8,
        PVRTC1_4_RGBA: 9,
        ASTC_4x4: 10,
        ATC_RGB: 11,
        ATC_RGBA_INTERPOLATED_ALPHA: 12,
        RGBA32: 13,
        RGB565: 14,
        BGR565: 15,
        RGBA4444: 16
    });
    __publicField(KTX2Loader2, "EngineFormat", {
        RGBAFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
        RGBA_ASTC_4x4_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_ASTC_4x4_Format"],
        RGBA_BPTC_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_BPTC_Format"],
        RGBA_ETC2_EAC_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_ETC2_EAC_Format"],
        RGBA_PVRTC_4BPPV1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_PVRTC_4BPPV1_Format"],
        RGBA_S3TC_DXT5_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_S3TC_DXT5_Format"],
        RGB_ETC1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_ETC1_Format"],
        RGB_ETC2_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_ETC2_Format"],
        RGB_PVRTC_4BPPV1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_PVRTC_4BPPV1_Format"],
        RGB_S3TC_DXT1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_S3TC_DXT1_Format"]
    });
    /* WEB WORKER */ __publicField(KTX2Loader2, "BasisWorker", function() {
        let config;
        let transcoderPending;
        let BasisModule;
        const EngineFormat = _EngineFormat;
        const TranscoderFormat = _TranscoderFormat;
        const BasisFormat = _BasisFormat;
        self.addEventListener("message", function(e) {
            const message = e.data;
            switch(message.type){
                case "init":
                    config = message.config;
                    init(message.transcoderBinary);
                    break;
                case "transcode":
                    transcoderPending.then(()=>{
                        try {
                            const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode(message.buffer);
                            self.postMessage({
                                type: "transcode",
                                id: message.id,
                                faces,
                                width,
                                height,
                                hasAlpha,
                                format,
                                dfdFlags
                            }, buffers);
                        } catch (error) {
                            console.error(error);
                            self.postMessage({
                                type: "error",
                                id: message.id,
                                error: error.message
                            });
                        }
                    });
                    break;
            }
        });
        function init(wasmBinary) {
            transcoderPending = new Promise((resolve)=>{
                BasisModule = {
                    wasmBinary,
                    onRuntimeInitialized: resolve
                };
                BASIS(BasisModule);
            }).then(()=>{
                BasisModule.initializeBasis();
                if (BasisModule.KTX2File === void 0) {
                    console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
                }
            });
        }
        function transcode(buffer) {
            const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
            function cleanup() {
                ktx2File.close();
                ktx2File.delete();
            }
            if (!ktx2File.isValid()) {
                cleanup();
                throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
            }
            const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
            const width = ktx2File.getWidth();
            const height = ktx2File.getHeight();
            const layerCount = ktx2File.getLayers() || 1;
            const levelCount = ktx2File.getLevels();
            const faceCount = ktx2File.getFaces();
            const hasAlpha = ktx2File.getHasAlpha();
            const dfdFlags = ktx2File.getDFDFlags();
            const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
            if (!width || !height || !levelCount) {
                cleanup();
                throw new Error("THREE.KTX2Loader:	Invalid texture");
            }
            if (!ktx2File.startTranscoding()) {
                cleanup();
                throw new Error("THREE.KTX2Loader: .startTranscoding failed");
            }
            const faces = [];
            const buffers = [];
            for(let face = 0; face < faceCount; face++){
                const mipmaps = [];
                for(let mip = 0; mip < levelCount; mip++){
                    const layerMips = [];
                    let mipWidth, mipHeight;
                    for(let layer = 0; layer < layerCount; layer++){
                        const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
                        if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {
                            console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.");
                        }
                        if (levelCount > 1) {
                            mipWidth = levelInfo.origWidth;
                            mipHeight = levelInfo.origHeight;
                        } else {
                            mipWidth = levelInfo.width;
                            mipHeight = levelInfo.height;
                        }
                        const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
                        const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);
                        if (!status) {
                            cleanup();
                            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
                        }
                        layerMips.push(dst);
                    }
                    const mipData = concat(layerMips);
                    mipmaps.push({
                        data: mipData,
                        width: mipWidth,
                        height: mipHeight
                    });
                    buffers.push(mipData.buffer);
                }
                faces.push({
                    mipmaps,
                    width,
                    height,
                    format: engineFormat
                });
            }
            cleanup();
            return {
                faces,
                buffers,
                width,
                height,
                hasAlpha,
                format: engineFormat,
                dfdFlags
            };
        }
        const FORMAT_OPTIONS = [
            {
                if: "astcSupported",
                basisFormat: [
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.ASTC_4x4,
                    TranscoderFormat.ASTC_4x4
                ],
                engineFormat: [
                    EngineFormat.RGBA_ASTC_4x4_Format,
                    EngineFormat.RGBA_ASTC_4x4_Format
                ],
                priorityETC1S: Infinity,
                priorityUASTC: 1,
                needsPowerOfTwo: false
            },
            {
                if: "bptcSupported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.BC7_M5,
                    TranscoderFormat.BC7_M5
                ],
                engineFormat: [
                    EngineFormat.RGBA_BPTC_Format,
                    EngineFormat.RGBA_BPTC_Format
                ],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: false
            },
            {
                if: "dxtSupported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.BC1,
                    TranscoderFormat.BC3
                ],
                engineFormat: [
                    EngineFormat.RGB_S3TC_DXT1_Format,
                    EngineFormat.RGBA_S3TC_DXT5_Format
                ],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: false
            },
            {
                if: "etc2Supported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.ETC1,
                    TranscoderFormat.ETC2
                ],
                engineFormat: [
                    EngineFormat.RGB_ETC2_Format,
                    EngineFormat.RGBA_ETC2_EAC_Format
                ],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: false
            },
            {
                if: "etc1Supported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.ETC1
                ],
                engineFormat: [
                    EngineFormat.RGB_ETC1_Format
                ],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: false
            },
            {
                if: "pvrtcSupported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.PVRTC1_4_RGB,
                    TranscoderFormat.PVRTC1_4_RGBA
                ],
                engineFormat: [
                    EngineFormat.RGB_PVRTC_4BPPV1_Format,
                    EngineFormat.RGBA_PVRTC_4BPPV1_Format
                ],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: true
            }
        ];
        const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
            return a.priorityETC1S - b.priorityETC1S;
        });
        const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
            return a.priorityUASTC - b.priorityUASTC;
        });
        function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
            let transcoderFormat;
            let engineFormat;
            const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
            for(let i = 0; i < options.length; i++){
                const opt = options[i];
                if (!config[opt.if]) continue;
                if (!opt.basisFormat.includes(basisFormat)) continue;
                if (hasAlpha && opt.transcoderFormat.length < 2) continue;
                if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;
                transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
                engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
                return {
                    transcoderFormat,
                    engineFormat
                };
            }
            console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
            transcoderFormat = TranscoderFormat.RGBA32;
            engineFormat = EngineFormat.RGBAFormat;
            return {
                transcoderFormat,
                engineFormat
            };
        }
        function isPowerOfTwo(value) {
            if (value <= 2) return true;
            return (value & value - 1) === 0 && value !== 0;
        }
        function concat(arrays) {
            if (arrays.length === 1) return arrays[0];
            let totalByteLength = 0;
            for(let i = 0; i < arrays.length; i++){
                const array = arrays[i];
                totalByteLength += array.byteLength;
            }
            const result = new Uint8Array(totalByteLength);
            let byteOffset = 0;
            for(let i = 0; i < arrays.length; i++){
                const array = arrays[i];
                result.set(array, byteOffset);
                byteOffset += array.byteLength;
            }
            return result;
        }
    });
    return KTX2Loader2;
})();
const UNCOMPRESSED_FORMATS = /* @__PURE__ */ new Set([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGFormat"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedFormat"]
]);
const FORMAT_MAP = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R32G32B32A32_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R16G16B16A16_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8B8A8_UNORM"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8B8A8_SRGB"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R32G32_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R16G16_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8_UNORM"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8_SRGB"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R32_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R16_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8_SRGB"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8_UNORM"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedFormat"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_ASTC_6x6_SRGB_BLOCK"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_ASTC_6x6_Format"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_ASTC_6x6_UNORM_BLOCK"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_ASTC_6x6_Format"]
};
const TYPE_MAP = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R32G32B32A32_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R16G16B16A16_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8B8A8_UNORM"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8B8A8_SRGB"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R32G32_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R16G16_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8_UNORM"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8G8_SRGB"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R32_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R16_SFLOAT"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8_SRGB"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_R8_UNORM"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_ASTC_6x6_SRGB_BLOCK"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"],
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VK_FORMAT_ASTC_6x6_UNORM_BLOCK"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"]
};
async function createRawTexture(container) {
    const { vkFormat } = container;
    if (FORMAT_MAP[vkFormat] === void 0) {
        throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
    }
    let zstd;
    if (container.supercompressionScheme === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_SUPERCOMPRESSION_ZSTD"]) {
        if (!_zstd) {
            _zstd = new Promise(async (resolve)=>{
                const zstd2 = new ZSTDDecoder();
                await zstd2.init();
                resolve(zstd2);
            });
        }
        zstd = await _zstd;
    }
    const mipmaps = [];
    for(let levelIndex = 0; levelIndex < container.levels.length; levelIndex++){
        const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);
        const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);
        const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;
        const level = container.levels[levelIndex];
        let levelData;
        if (container.supercompressionScheme === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_SUPERCOMPRESSION_NONE"]) {
            levelData = level.levelData;
        } else if (container.supercompressionScheme === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_SUPERCOMPRESSION_ZSTD"]) {
            levelData = zstd.decode(level.levelData, level.uncompressedByteLength);
        } else {
            throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
        }
        let data;
        if (TYPE_MAP[vkFormat] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]) {
            data = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);
        } else if (TYPE_MAP[vkFormat] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]) {
            data = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);
        } else {
            data = levelData;
        }
        mipmaps.push({
            data,
            width: levelWidth,
            height: levelHeight,
            depth: levelDepth
        });
    }
    let texture;
    if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {
        texture = container.pixelDepth === 0 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"](mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$Data3DTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Data3DTexture"](mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);
    } else {
        if (container.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
        texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTexture"](mipmaps, container.pixelWidth, container.pixelHeight);
    }
    texture.mipmaps = mipmaps;
    texture.type = TYPE_MAP[vkFormat];
    texture.format = FORMAT_MAP[vkFormat];
    texture.needsUpdate = true;
    const colorSpace = parseColorSpace(container);
    if ("colorSpace" in texture) texture.colorSpace = colorSpace;
    else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
    return Promise.resolve(texture);
}
function parseColorSpace(container) {
    const dfd = container.dataFormatDescriptor[0];
    if (dfd.colorPrimaries === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_DF_PRIMARIES_BT709"]) {
        return dfd.transferFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_DF_TRANSFER_SRGB"] ? SRGBColorSpace : LinearSRGBColorSpace;
    } else if (dfd.colorPrimaries === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_DF_PRIMARIES_DISPLAYP3"]) {
        return dfd.transferFunction === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_DF_TRANSFER_SRGB"] ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;
    } else if (dfd.colorPrimaries === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$ktx$2d$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KHR_DF_PRIMARIES_UNSPECIFIED"]) {
        return NoColorSpace;
    } else {
        console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${dfd.colorPrimaries}"`);
        return NoColorSpace;
    }
}
;
 //# sourceMappingURL=KTX2Loader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/LottieLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LottieLoader": (()=>LottieLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$lottie$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/libs/lottie.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class LottieLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    setQuality(value) {
        this._quality = value;
    }
    load(url, onLoad, onProgress, onError) {
        const quality = this._quality || 1;
        const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CanvasTexture"]();
        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            const data = JSON.parse(text);
            const container = document.createElement("div");
            container.style.width = data.w + "px";
            container.style.height = data.h + "px";
            document.body.appendChild(container);
            const animation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$lottie$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].loadAnimation({
                container,
                animType: "canvas",
                loop: true,
                autoplay: true,
                animationData: data,
                rendererSettings: {
                    dpr: quality
                }
            });
            texture.animation = animation;
            texture.image = animation.container;
            animation.addEventListener("enterFrame", function() {
                texture.needsUpdate = true;
            });
            container.style.display = "none";
            if (onLoad !== void 0) {
                onLoad(texture);
            }
        }, onProgress, onError);
        return texture;
    }
}
;
 //# sourceMappingURL=LottieLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/RGBELoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RGBELoader": (()=>RGBELoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class RGBELoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTextureLoader"] {
    constructor(manager){
        super(manager);
        this.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
    }
    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
    parse(buffer) {
        const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
            switch(rgbe_error_code){
                case rgbe_read_error:
                    throw new Error("THREE.RGBELoader: Read Error: " + (msg || ""));
                case rgbe_write_error:
                    throw new Error("THREE.RGBELoader: Write Error: " + (msg || ""));
                case rgbe_format_error:
                    throw new Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
                default:
                case rgbe_memory_error:
                    throw new Error("THREE.RGBELoader: Memory Error: " + (msg || ""));
            }
        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
            const chunkSize = 128;
            lineLimit = !lineLimit ? 1024 : lineLimit;
            let p = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){
                s += chunk;
                len += chunk.length;
                p += chunkSize;
                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
            }
            if (-1 < i) {
                if (false !== consume) buffer2.pos += len + i + 1;
                return s + chunk.slice(0, i);
            }
            return false;
        }, RGBE_ReadHeader = function(buffer2) {
            const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let line, match;
            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
                rgbe_error(rgbe_read_error, "no header found");
            }
            if (!(match = line.match(magic_token_re))) {
                rgbe_error(rgbe_format_error, "bad initial token");
            }
            header.valid |= RGBE_VALID_PROGRAMTYPE;
            header.programtype = match[1];
            header.string += line + "\n";
            while(true){
                line = fgets(buffer2);
                if (false === line) break;
                header.string += line + "\n";
                if ("#" === line.charAt(0)) {
                    header.comments += line + "\n";
                    continue;
                }
                if (match = line.match(gamma_re)) {
                    header.gamma = parseFloat(match[1]);
                }
                if (match = line.match(exposure_re)) {
                    header.exposure = parseFloat(match[1]);
                }
                if (match = line.match(format_re)) {
                    header.valid |= RGBE_VALID_FORMAT;
                    header.format = match[1];
                }
                if (match = line.match(dimensions_re)) {
                    header.valid |= RGBE_VALID_DIMENSIONS;
                    header.height = parseInt(match[1], 10);
                    header.width = parseInt(match[2], 10);
                }
                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
            }
            if (!(header.valid & RGBE_VALID_FORMAT)) {
                rgbe_error(rgbe_format_error, "missing format specifier");
            }
            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
                rgbe_error(rgbe_format_error, "missing image size specifier");
            }
            return header;
        }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {
            const scanline_width = w2;
            if (// run length encoding is not allowed so read flat
            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {
                return new Uint8Array(buffer2);
            }
            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
                rgbe_error(rgbe_format_error, "wrong scanline width");
            }
            const data_rgba = new Uint8Array(4 * w2 * h2);
            if (!data_rgba.length) {
                rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
            }
            let offset = 0, pos = 0;
            const ptr_end = 4 * scanline_width;
            const rgbeStart = new Uint8Array(4);
            const scanline_buffer = new Uint8Array(ptr_end);
            let num_scanlines = h2;
            while(num_scanlines > 0 && pos < buffer2.byteLength){
                if (pos + 4 > buffer2.byteLength) {
                    rgbe_error(rgbe_read_error);
                }
                rgbeStart[0] = buffer2[pos++];
                rgbeStart[1] = buffer2[pos++];
                rgbeStart[2] = buffer2[pos++];
                rgbeStart[3] = buffer2[pos++];
                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
                    rgbe_error(rgbe_format_error, "bad rgbe scanline format");
                }
                let ptr = 0, count;
                while(ptr < ptr_end && pos < buffer2.byteLength){
                    count = buffer2[pos++];
                    const isEncodedRun = count > 128;
                    if (isEncodedRun) count -= 128;
                    if (0 === count || ptr + count > ptr_end) {
                        rgbe_error(rgbe_format_error, "bad scanline data");
                    }
                    if (isEncodedRun) {
                        const byteValue = buffer2[pos++];
                        for(let i = 0; i < count; i++){
                            scanline_buffer[ptr++] = byteValue;
                        }
                    } else {
                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
                        ptr += count;
                        pos += count;
                    }
                }
                const l = scanline_width;
                for(let i = 0; i < l; i++){
                    let off = 0;
                    data_rgba[offset] = scanline_buffer[i + off];
                    off += scanline_width;
                    data_rgba[offset + 1] = scanline_buffer[i + off];
                    off += scanline_width;
                    data_rgba[offset + 2] = scanline_buffer[i + off];
                    off += scanline_width;
                    data_rgba[offset + 3] = scanline_buffer[i + off];
                    offset += 4;
                }
                num_scanlines--;
            }
            return data_rgba;
        };
        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
            const e = sourceArray[sourceOffset + 3];
            const scale = Math.pow(2, e - 128) / 255;
            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
            destArray[destOffset + 3] = 1;
        };
        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
            const e = sourceArray[sourceOffset + 3];
            const scale = Math.pow(2, e - 128) / 255;
            destArray[destOffset + 0] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
            destArray[destOffset + 1] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
            destArray[destOffset + 2] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
            destArray[destOffset + 3] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(1);
        };
        const byteArray = new Uint8Array(buffer);
        byteArray.pos = 0;
        const rgbe_header_info = RGBE_ReadHeader(byteArray);
        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
        let data, type;
        let numElements;
        switch(this.type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                numElements = image_rgba_data.length / 4;
                const floatArray = new Float32Array(numElements * 4);
                for(let j = 0; j < numElements; j++){
                    RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
                }
                data = floatArray;
                type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"];
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                numElements = image_rgba_data.length / 4;
                const halfArray = new Uint16Array(numElements * 4);
                for(let j = 0; j < numElements; j++){
                    RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
                }
                data = halfArray;
                type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
                break;
            default:
                throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
        }
        return {
            width: w,
            height: h,
            data,
            header: rgbe_header_info.string,
            gamma: rgbe_header_info.gamma,
            exposure: rgbe_header_info.exposure,
            type
        };
    }
    setDataType(value) {
        this.type = value;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        function onLoadCallback(texture, texData) {
            switch(texture.type){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                    if ("colorSpace" in texture) texture.colorSpace = "srgb-linear";
                    else texture.encoding = 3e3;
                    texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                    texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                    texture.generateMipmaps = false;
                    texture.flipY = true;
                    break;
            }
            if (onLoad) onLoad(texture, texData);
        }
        return super.load(url, onLoadCallback, onProgress, onError);
    }
}
;
 //# sourceMappingURL=RGBELoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/AssimpLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AssimpLoader": (()=>AssimpLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class AssimpLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    load(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = scope.path === "" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url) : scope.path;
        var loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            try {
                onLoad(scope.parse(buffer, path));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(buffer, path) {
        var textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.manager);
        textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        var Virtulous = {};
        Virtulous.KeyFrame = class {
            constructor(time, matrix){
                this.time = time;
                this.matrix = matrix.clone();
                this.position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                this.quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
                this.scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1);
                this.matrix.decompose(this.position, this.quaternion, this.scale);
                this.clone = function() {
                    var n = new Virtulous.KeyFrame(this.time, this.matrix);
                    return n;
                };
                this.lerp = function(nextKey, time2) {
                    time2 -= this.time;
                    var dist = nextKey.time - this.time;
                    var l = time2 / dist;
                    var l2 = 1 - l;
                    var keypos = this.position;
                    var keyrot = this.quaternion;
                    var key2pos = nextKey.position;
                    var key2rot = nextKey.quaternion;
                    Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;
                    Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;
                    Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;
                    Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);
                    Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);
                    return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);
                };
            }
        };
        Virtulous.KeyFrame.tempAniPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        Virtulous.KeyFrame.tempAniQuat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        Virtulous.KeyFrame.tempAniScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1);
        Virtulous.KeyFrame.tempAniMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
        Virtulous.KeyFrameTrack = function() {
            this.keys = [];
            this.target = null;
            this.time = 0;
            this.length = 0;
            this._accelTable = {};
            this.fps = 20;
            this.addKey = function(key) {
                this.keys.push(key);
            };
            this.init = function() {
                this.sortKeys();
                if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;
                else this.length = 0;
                if (!this.fps) return;
                for(let j = 0; j < this.length * this.fps; j++){
                    for(let i = 0; i < this.keys.length; i++){
                        if (this.keys[i].time == j) {
                            this._accelTable[j] = i;
                            break;
                        } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {
                            this._accelTable[j] = i;
                            break;
                        }
                    }
                }
            };
            this.parseFromThree = function(data) {
                var fps = data.fps;
                this.target = data.node;
                var track = data.hierarchy[0].keys;
                for(let i = 0; i < track.length; i++){
                    this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));
                }
                this.init();
            };
            this.parseFromCollada = function(data) {
                var track = data.keys;
                var fps = this.fps;
                for(let i = 0; i < track.length; i++){
                    this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));
                }
                this.init();
            };
            this.sortKeys = function() {
                this.keys.sort(this.keySortFunc);
            };
            this.keySortFunc = function(a, b) {
                return a.time - b.time;
            };
            this.clone = function() {
                var t = new Virtulous.KeyFrameTrack();
                t.target = this.target;
                t.time = this.time;
                t.length = this.length;
                for(let i = 0; i < this.keys.length; i++){
                    t.addKey(this.keys[i].clone());
                }
                t.init();
                return t;
            };
            this.reTarget = function(root, compareitor) {
                if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;
                this.target = compareitor(root, this.target);
            };
            this.keySearchAccel = function(time) {
                time *= this.fps;
                time = Math.floor(time);
                return this._accelTable[time] || 0;
            };
            this.setTime = function(time) {
                time = Math.abs(time);
                if (this.length) time = time % this.length + 0.05;
                var key0 = null;
                var key1 = null;
                for(let i = this.keySearchAccel(time); i < this.keys.length; i++){
                    if (this.keys[i].time == time) {
                        key0 = this.keys[i];
                        key1 = this.keys[i];
                        break;
                    } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {
                        key0 = this.keys[i];
                        key1 = this.keys[i + 1];
                        break;
                    } else if (this.keys[i].time < time && i == this.keys.length - 1) {
                        key0 = this.keys[i];
                        key1 = this.keys[0].clone();
                        key1.time += this.length + 0.05;
                        break;
                    }
                }
                if (key0 && key1 && key0 !== key1) {
                    this.target.matrixAutoUpdate = false;
                    this.target.matrix.copy(key0.lerp(key1, time));
                    this.target.matrixWorldNeedsUpdate = true;
                    return;
                }
                if (key0 && key1 && key0 == key1) {
                    this.target.matrixAutoUpdate = false;
                    this.target.matrix.copy(key0.matrix);
                    this.target.matrixWorldNeedsUpdate = true;
                    return;
                }
            };
        };
        Virtulous.TrackTargetNodeNameCompare = function(root, target) {
            function find(node, name) {
                if (node.name == name) return node;
                for(let i = 0; i < node.children.length; i++){
                    var r = find(node.children[i], name);
                    if (r) return r;
                }
                return null;
            }
            return find(root, target.name);
        };
        Virtulous.Animation = function() {
            this.tracks = [];
            this.length = 0;
            this.addTrack = function(track) {
                this.tracks.push(track);
                this.length = Math.max(track.length, this.length);
            };
            this.setTime = function(time) {
                this.time = time;
                for(let i = 0; i < this.tracks.length; i++)this.tracks[i].setTime(time);
            };
            this.clone = function(target, compareitor) {
                if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;
                var n = new Virtulous.Animation();
                n.target = target;
                for(let i = 0; i < this.tracks.length; i++){
                    var track = this.tracks[i].clone();
                    track.reTarget(target, compareitor);
                    n.addTrack(track);
                }
                return n;
            };
        };
        var ASSBIN_CHUNK_AICAMERA = 4660;
        var ASSBIN_CHUNK_AILIGHT = 4661;
        var ASSBIN_CHUNK_AITEXTURE = 4662;
        var ASSBIN_CHUNK_AIMESH = 4663;
        var ASSBIN_CHUNK_AINODEANIM = 4664;
        var ASSBIN_CHUNK_AISCENE = 4665;
        var ASSBIN_CHUNK_AIBONE = 4666;
        var ASSBIN_CHUNK_AIANIMATION = 4667;
        var ASSBIN_CHUNK_AINODE = 4668;
        var ASSBIN_CHUNK_AIMATERIAL = 4669;
        var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;
        var ASSBIN_MESH_HAS_POSITIONS = 1;
        var ASSBIN_MESH_HAS_NORMALS = 2;
        var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;
        var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;
        var ASSBIN_MESH_HAS_COLOR_BASE = 65536;
        var AI_MAX_NUMBER_OF_COLOR_SETS = 1;
        var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;
        //! A directional light source has a well-defined direction
        //! but is infinitely far away. That's quite a good
        //! approximation for sun light.
        var aiLightSource_DIRECTIONAL = 1;
        //! A point light source has a well-defined position
        //! in space but no direction - it emits light in all
        //! directions. A normal bulb is a point light.
        //! A spot light source emits light in a specific
        //! angle. It has a position and a direction it is pointing to.
        //! A good example for a spot light is a light spot in
        //! sport arenas.
        var aiLightSource_SPOT = 3;
        //! The generic light level of the world, including the bounces
        //! of all other lightsources.
        //! Typically, there's at most one ambient light in a scene.
        //! This light type doesn't have a valid position, direction, or
        //! other properties, just a color.
        var aiTextureType_DIFFUSE = 1;
        var aiTextureType_NORMALS = 6;
        var aiTextureType_OPACITY = 8;
        var aiTextureType_LIGHTMAP = 10;
        var BONESPERVERT = 4;
        function ASSBIN_MESH_HAS_TEXCOORD(n) {
            return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;
        }
        function ASSBIN_MESH_HAS_COLOR(n) {
            return ASSBIN_MESH_HAS_COLOR_BASE << n;
        }
        function markBones(scene) {
            for(let i in scene.mMeshes){
                var mesh = scene.mMeshes[i];
                for(let k in mesh.mBones){
                    var boneNode = scene.findNode(mesh.mBones[k].mName);
                    if (boneNode) boneNode.isBone = true;
                }
            }
        }
        function cloneTreeToBones(root, scene) {
            var rootBone = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]();
            rootBone.matrix.copy(root.matrix);
            rootBone.matrixWorld.copy(root.matrixWorld);
            rootBone.position.copy(root.position);
            rootBone.quaternion.copy(root.quaternion);
            rootBone.scale.copy(root.scale);
            scene.nodeCount++;
            rootBone.name = "bone_" + root.name + scene.nodeCount.toString();
            if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];
            scene.nodeToBoneMap[root.name].push(rootBone);
            for(let i in root.children){
                var child = cloneTreeToBones(root.children[i], scene);
                rootBone.add(child);
            }
            return rootBone;
        }
        function sortWeights(indexes, weights) {
            var pairs = [];
            for(let i = 0; i < indexes.length; i++){
                pairs.push({
                    i: indexes[i],
                    w: weights[i]
                });
            }
            pairs.sort(function(a, b) {
                return b.w - a.w;
            });
            while(pairs.length < 4){
                pairs.push({
                    i: 0,
                    w: 0
                });
            }
            if (pairs.length > 4) pairs.length = 4;
            var sum = 0;
            for(let i = 0; i < 4; i++){
                sum += pairs[i].w * pairs[i].w;
            }
            sum = Math.sqrt(sum);
            for(let i = 0; i < 4; i++){
                pairs[i].w = pairs[i].w / sum;
                indexes[i] = pairs[i].i;
                weights[i] = pairs[i].w;
            }
        }
        function findMatchingBone(root, name) {
            if (root.name.indexOf("bone_" + name) == 0) return root;
            for(let i in root.children){
                var ret = findMatchingBone(root.children[i], name);
                if (ret) return ret;
            }
            return void 0;
        }
        class aiMesh {
            constructor(){
                this.mPrimitiveTypes = 0;
                this.mNumVertices = 0;
                this.mNumFaces = 0;
                this.mNumBones = 0;
                this.mMaterialIndex = 0;
                this.mVertices = [];
                this.mNormals = [];
                this.mTangents = [];
                this.mBitangents = [];
                this.mColors = [
                    []
                ];
                this.mTextureCoords = [
                    []
                ];
                this.mFaces = [];
                this.mBones = [];
                this.hookupSkeletons = function(scene) {
                    if (this.mBones.length == 0) return;
                    var allBones = [];
                    var offsetMatrix = [];
                    var skeletonRoot = scene.findNode(this.mBones[0].mName);
                    while(skeletonRoot.mParent && skeletonRoot.mParent.isBone){
                        skeletonRoot = skeletonRoot.mParent;
                    }
                    var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
                    var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
                    this.threeNode.add(threeSkeletonRootBone);
                    for(let i = 0; i < this.mBones.length; i++){
                        var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);
                        if (bone) {
                            var tbone = bone;
                            allBones.push(tbone);
                            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());
                        } else {
                            var skeletonRoot = scene.findNode(this.mBones[i].mName);
                            if (!skeletonRoot) return;
                            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
                            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
                            this.threeNode.add(threeSkeletonRootBone);
                            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);
                            var tbone = bone;
                            allBones.push(tbone);
                            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());
                        }
                    }
                    var skeleton = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Skeleton"](allBones, offsetMatrix);
                    this.threeNode.bind(skeleton, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]());
                    this.threeNode.material.skinning = true;
                };
                this.toTHREE = function(scene) {
                    if (this.threeNode) return this.threeNode;
                    var geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
                    var mat;
                    if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);
                    else mat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]();
                    geometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Uint32Array(this.mIndexArray), 1));
                    geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.mVertexBuffer, 3));
                    if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {
                        geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.mNormalBuffer, 3));
                    }
                    if (this.mColorBuffer && this.mColorBuffer.length > 0) {
                        geometry.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.mColorBuffer, 4));
                    }
                    if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {
                        geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(this.mTexCoordsBuffers[0]), 2));
                    }
                    if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {
                        geometry.setAttribute("uv1", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(this.mTexCoordsBuffers[1]), 2));
                    }
                    if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {
                        geometry.setAttribute("tangents", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.mTangentBuffer, 3));
                    }
                    if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {
                        geometry.setAttribute("bitangents", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.mBitangentBuffer, 3));
                    }
                    if (this.mBones.length > 0) {
                        var weights = [];
                        var bones = [];
                        for(let i = 0; i < this.mBones.length; i++){
                            for(let j = 0; j < this.mBones[i].mWeights.length; j++){
                                var weight = this.mBones[i].mWeights[j];
                                if (weight) {
                                    if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];
                                    if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];
                                    weights[weight.mVertexId].push(weight.mWeight);
                                    bones[weight.mVertexId].push(parseInt(i));
                                }
                            }
                        }
                        for(let i in bones){
                            sortWeights(bones[i], weights[i]);
                        }
                        var _weights = [];
                        var _bones = [];
                        for(let i = 0; i < weights.length; i++){
                            for(let j = 0; j < 4; j++){
                                if (weights[i] && bones[i]) {
                                    _weights.push(weights[i][j]);
                                    _bones.push(bones[i][j]);
                                } else {
                                    _weights.push(0);
                                    _bones.push(0);
                                }
                            }
                        }
                        geometry.setAttribute("skinWeight", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(_weights), BONESPERVERT));
                        geometry.setAttribute("skinIndex", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](new Float32Array(_bones), BONESPERVERT));
                    }
                    var mesh;
                    if (this.mBones.length == 0) mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, mat);
                    if (this.mBones.length > 0) {
                        mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkinnedMesh"](geometry, mat);
                        mesh.normalizeSkinWeights();
                    }
                    this.threeNode = mesh;
                    return mesh;
                };
            }
        }
        class aiFace {
            constructor(){
                this.mNumIndices = 0;
                this.mIndices = [];
            }
        }
        class aiVector3D {
            constructor(){
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.toTHREE = function() {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](this.x, this.y, this.z);
                };
            }
        }
        class aiColor3D {
            constructor(){
                this.r = 0;
                this.g = 0;
                this.b = 0;
                this.a = 0;
                this.toTHREE = function() {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](this.r, this.g, this.b);
                };
            }
        }
        class aiQuaternion {
            constructor(){
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
                this.toTHREE = function() {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"](this.x, this.y, this.z, this.w);
                };
            }
        }
        class aiVertexWeight {
            constructor(){
                this.mVertexId = 0;
                this.mWeight = 0;
            }
        }
        class aiString {
            constructor(){
                this.data = [];
                this.toString = function() {
                    var str = "";
                    this.data.forEach(function(i) {
                        str += String.fromCharCode(i);
                    });
                    return str.replace(/[^\x20-\x7E]+/g, "");
                };
            }
        }
        class aiVectorKey {
            constructor(){
                this.mTime = 0;
                this.mValue = null;
            }
        }
        class aiQuatKey {
            constructor(){
                this.mTime = 0;
                this.mValue = null;
            }
        }
        class aiNode {
            constructor(){
                this.mName = "";
                this.mTransformation = [];
                this.mNumChildren = 0;
                this.mNumMeshes = 0;
                this.mMeshes = [];
                this.mChildren = [];
                this.toTHREE = function(scene) {
                    if (this.threeNode) return this.threeNode;
                    var o = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
                    o.name = this.mName;
                    o.matrix = this.mTransformation.toTHREE();
                    for(let i = 0; i < this.mChildren.length; i++){
                        o.add(this.mChildren[i].toTHREE(scene));
                    }
                    for(let i = 0; i < this.mMeshes.length; i++){
                        o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));
                    }
                    this.threeNode = o;
                    o.matrix.decompose(o.position, o.quaternion, o.scale);
                    return o;
                };
            }
        }
        class aiBone {
            constructor(){
                this.mName = "";
                this.mNumWeights = 0;
                this.mOffsetMatrix = 0;
            }
        }
        class aiMaterialProperty {
            constructor(){
                this.mKey = "";
                this.mSemantic = 0;
                this.mIndex = 0;
                this.mData = [];
                this.mDataLength = 0;
                this.mType = 0;
                this.dataAsColor = function() {
                    var array = new Uint8Array(this.mData).buffer;
                    var reader = new DataView(array);
                    var r = reader.getFloat32(0, true);
                    var g = reader.getFloat32(4, true);
                    var b = reader.getFloat32(8, true);
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](r, g, b);
                };
                this.dataAsFloat = function() {
                    var array = new Uint8Array(this.mData).buffer;
                    var reader = new DataView(array);
                    var r = reader.getFloat32(0, true);
                    return r;
                };
                this.dataAsBool = function() {
                    var array = new Uint8Array(this.mData).buffer;
                    var reader = new DataView(array);
                    var r = reader.getFloat32(0, true);
                    return !!r;
                };
                this.dataAsString = function() {
                    var s = new aiString();
                    s.data = this.mData;
                    return s.toString();
                };
                this.dataAsMap = function() {
                    var s = new aiString();
                    s.data = this.mData;
                    var path2 = s.toString();
                    path2 = path2.replace(/\\/g, "/");
                    if (path2.indexOf("/") != -1) {
                        path2 = path2.substr(path2.lastIndexOf("/") + 1);
                    }
                    return textureLoader.load(path2);
                };
            }
        }
        var namePropMapping = {
            "?mat.name": "name",
            "$mat.shadingm": "shading",
            "$mat.twosided": "twoSided",
            "$mat.wireframe": "wireframe",
            "$clr.ambient": "ambient",
            "$clr.diffuse": "color",
            "$clr.specular": "specular",
            "$clr.emissive": "emissive",
            "$clr.transparent": "transparent",
            "$clr.reflective": "reflect",
            "$mat.shininess": "shininess",
            "$mat.reflectivity": "reflectivity",
            "$mat.refracti": "refraction",
            "$tex.file": "map"
        };
        var nameTypeMapping = {
            "?mat.name": "string",
            "$mat.shadingm": "bool",
            "$mat.twosided": "bool",
            "$mat.wireframe": "bool",
            "$clr.ambient": "color",
            "$clr.diffuse": "color",
            "$clr.specular": "color",
            "$clr.emissive": "color",
            "$clr.transparent": "color",
            "$clr.reflective": "color",
            "$mat.shininess": "float",
            "$mat.reflectivity": "float",
            "$mat.refracti": "float",
            "$tex.file": "map"
        };
        class aiMaterial {
            constructor(){
                this.mNumAllocated = 0;
                this.mNumProperties = 0;
                this.mProperties = [];
                this.toTHREE = function() {
                    var mat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]();
                    for(let i = 0; i < this.mProperties.length; i++){
                        if (nameTypeMapping[this.mProperties[i].mKey] == "float") {
                            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();
                        }
                        if (nameTypeMapping[this.mProperties[i].mKey] == "color") {
                            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();
                        }
                        if (nameTypeMapping[this.mProperties[i].mKey] == "bool") {
                            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();
                        }
                        if (nameTypeMapping[this.mProperties[i].mKey] == "string") {
                            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();
                        }
                        if (nameTypeMapping[this.mProperties[i].mKey] == "map") {
                            var prop = this.mProperties[i];
                            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();
                            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();
                            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();
                            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();
                        }
                    }
                    mat.ambient.r = 0.53;
                    mat.ambient.g = 0.53;
                    mat.ambient.b = 0.53;
                    mat.color.r = 1;
                    mat.color.g = 1;
                    mat.color.b = 1;
                    return mat;
                };
            }
        }
        function veclerp(v1, v2, l) {
            var v = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            var lm1 = 1 - l;
            v.x = v1.x * l + v2.x * lm1;
            v.y = v1.y * l + v2.y * lm1;
            v.z = v1.z * l + v2.z * lm1;
            return v;
        }
        function quatlerp(q1, q2, l) {
            return q1.clone().slerp(q2, 1 - l);
        }
        function sampleTrack(keys, time, lne, lerp) {
            if (keys.length == 1) return keys[0].mValue.toTHREE();
            var dist = Infinity;
            var key = null;
            var nextKey = null;
            for(let i = 0; i < keys.length; i++){
                var timeDist = Math.abs(keys[i].mTime - time);
                if (timeDist < dist && keys[i].mTime <= time) {
                    dist = timeDist;
                    key = keys[i];
                    nextKey = keys[i + 1];
                }
            }
            if (!key) {
                return null;
            } else if (nextKey) {
                var dT = nextKey.mTime - key.mTime;
                var T = key.mTime - time;
                var l = T / dT;
                return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
            } else {
                nextKey = keys[0].clone();
                nextKey.mTime += lne;
                var dT = nextKey.mTime - key.mTime;
                var T = key.mTime - time;
                var l = T / dT;
                return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
            }
        }
        class aiNodeAnim {
            constructor(){
                this.mNodeName = "";
                this.mNumPositionKeys = 0;
                this.mNumRotationKeys = 0;
                this.mNumScalingKeys = 0;
                this.mPositionKeys = [];
                this.mRotationKeys = [];
                this.mScalingKeys = [];
                this.mPreState = "";
                this.mPostState = "";
                this.init = function(tps) {
                    if (!tps) tps = 1;
                    function t(t2) {
                        t2.mTime /= tps;
                    }
                    this.mPositionKeys.forEach(t);
                    this.mRotationKeys.forEach(t);
                    this.mScalingKeys.forEach(t);
                };
                this.sortKeys = function() {
                    function comp(a, b) {
                        return a.mTime - b.mTime;
                    }
                    this.mPositionKeys.sort(comp);
                    this.mRotationKeys.sort(comp);
                    this.mScalingKeys.sort(comp);
                };
                this.getLength = function() {
                    return Math.max(Math.max.apply(null, this.mPositionKeys.map(function(a) {
                        return a.mTime;
                    })), Math.max.apply(null, this.mRotationKeys.map(function(a) {
                        return a.mTime;
                    })), Math.max.apply(null, this.mScalingKeys.map(function(a) {
                        return a.mTime;
                    })));
                };
                this.toTHREE = function(o) {
                    this.sortKeys();
                    var length = this.getLength();
                    var track = new Virtulous.KeyFrameTrack();
                    for(let i = 0; i < length; i += 0.05){
                        var matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                        var time = i;
                        var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);
                        var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);
                        var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);
                        matrix.compose(pos, rotation, scale);
                        var key = new Virtulous.KeyFrame(time, matrix);
                        track.addKey(key);
                    }
                    track.target = o.findNode(this.mNodeName).toTHREE();
                    var tracks = [
                        track
                    ];
                    if (o.nodeToBoneMap[this.mNodeName]) {
                        for(let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++){
                            var t2 = track.clone();
                            t2.target = o.nodeToBoneMap[this.mNodeName][i];
                            tracks.push(t2);
                        }
                    }
                    return tracks;
                };
            }
        }
        class aiAnimation {
            constructor(){
                this.mName = "";
                this.mDuration = 0;
                this.mTicksPerSecond = 0;
                this.mNumChannels = 0;
                this.mChannels = [];
                this.toTHREE = function(root) {
                    var animationHandle = new Virtulous.Animation();
                    for(let i in this.mChannels){
                        this.mChannels[i].init(this.mTicksPerSecond);
                        var tracks = this.mChannels[i].toTHREE(root);
                        for(let j in tracks){
                            tracks[j].init();
                            animationHandle.addTrack(tracks[j]);
                        }
                    }
                    animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function(e) {
                        return e.length;
                    }));
                    return animationHandle;
                };
            }
        }
        class aiTexture {
            constructor(){
                this.mWidth = 0;
                this.mHeight = 0;
                this.texAchFormatHint = [];
                this.pcData = [];
            }
        }
        class aiLight {
            constructor(){
                this.mName = "";
                this.mType = 0;
                this.mAttenuationConstant = 0;
                this.mAttenuationLinear = 0;
                this.mAttenuationQuadratic = 0;
                this.mAngleInnerCone = 0;
                this.mAngleOuterCone = 0;
                this.mColorDiffuse = null;
                this.mColorSpecular = null;
                this.mColorAmbient = null;
            }
        }
        class aiCamera {
            constructor(){
                this.mName = "";
                this.mPosition = null;
                this.mLookAt = null;
                this.mUp = null;
                this.mHorizontalFOV = 0;
                this.mClipPlaneNear = 0;
                this.mClipPlaneFar = 0;
                this.mAspect = 0;
            }
        }
        class aiScene {
            constructor(){
                this.versionMajor = 0;
                this.versionMinor = 0;
                this.versionRevision = 0;
                this.compileFlags = 0;
                this.mFlags = 0;
                this.mNumMeshes = 0;
                this.mNumMaterials = 0;
                this.mNumAnimations = 0;
                this.mNumTextures = 0;
                this.mNumLights = 0;
                this.mNumCameras = 0;
                this.mRootNode = null;
                this.mMeshes = [];
                this.mMaterials = [];
                this.mAnimations = [];
                this.mLights = [];
                this.mCameras = [];
                this.nodeToBoneMap = {};
                this.findNode = function(name, root) {
                    if (!root) {
                        root = this.mRootNode;
                    }
                    if (root.mName == name) {
                        return root;
                    }
                    for(let i = 0; i < root.mChildren.length; i++){
                        var ret = this.findNode(name, root.mChildren[i]);
                        if (ret) return ret;
                    }
                    return null;
                };
                this.toTHREE = function() {
                    this.nodeCount = 0;
                    markBones(this);
                    var o = this.mRootNode.toTHREE(this);
                    for(let i in this.mMeshes)this.mMeshes[i].hookupSkeletons(this);
                    if (this.mAnimations.length > 0) {
                        var a = this.mAnimations[0].toTHREE(this);
                    }
                    return {
                        object: o,
                        animation: a
                    };
                };
            }
        }
        class aiMatrix4 {
            constructor(){
                this.elements = [
                    [],
                    [],
                    [],
                    []
                ];
                this.toTHREE = function() {
                    var m = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                    for(let i = 0; i < 4; ++i){
                        for(let i2 = 0; i2 < 4; ++i2){
                            m.elements[i * 4 + i2] = this.elements[i2][i];
                        }
                    }
                    return m;
                };
            }
        }
        var littleEndian = true;
        function readFloat(dataview) {
            var val = dataview.getFloat32(dataview.readOffset, littleEndian);
            dataview.readOffset += 4;
            return val;
        }
        function Read_double(dataview) {
            var val = dataview.getFloat64(dataview.readOffset, littleEndian);
            dataview.readOffset += 8;
            return val;
        }
        function Read_uint8_t(dataview) {
            var val = dataview.getUint8(dataview.readOffset);
            dataview.readOffset += 1;
            return val;
        }
        function Read_uint16_t(dataview) {
            var val = dataview.getUint16(dataview.readOffset, littleEndian);
            dataview.readOffset += 2;
            return val;
        }
        function Read_unsigned_int(dataview) {
            var val = dataview.getUint32(dataview.readOffset, littleEndian);
            dataview.readOffset += 4;
            return val;
        }
        function Read_uint32_t(dataview) {
            var val = dataview.getUint32(dataview.readOffset, littleEndian);
            dataview.readOffset += 4;
            return val;
        }
        function Read_aiVector3D(stream) {
            var v = new aiVector3D();
            v.x = readFloat(stream);
            v.y = readFloat(stream);
            v.z = readFloat(stream);
            return v;
        }
        function Read_aiColor3D(stream) {
            var c = new aiColor3D();
            c.r = readFloat(stream);
            c.g = readFloat(stream);
            c.b = readFloat(stream);
            return c;
        }
        function Read_aiQuaternion(stream) {
            var v = new aiQuaternion();
            v.w = readFloat(stream);
            v.x = readFloat(stream);
            v.y = readFloat(stream);
            v.z = readFloat(stream);
            return v;
        }
        function Read_aiString(stream) {
            var s = new aiString();
            var stringlengthbytes = Read_unsigned_int(stream);
            stream.ReadBytes(s.data, 1, stringlengthbytes);
            return s.toString();
        }
        function Read_aiVertexWeight(stream) {
            var w = new aiVertexWeight();
            w.mVertexId = Read_unsigned_int(stream);
            w.mWeight = readFloat(stream);
            return w;
        }
        function Read_aiMatrix4x4(stream) {
            var m = new aiMatrix4();
            for(let i = 0; i < 4; ++i){
                for(let i2 = 0; i2 < 4; ++i2){
                    m.elements[i][i2] = readFloat(stream);
                }
            }
            return m;
        }
        function Read_aiVectorKey(stream) {
            var v = new aiVectorKey();
            v.mTime = Read_double(stream);
            v.mValue = Read_aiVector3D(stream);
            return v;
        }
        function Read_aiQuatKey(stream) {
            var v = new aiQuatKey();
            v.mTime = Read_double(stream);
            v.mValue = Read_aiQuaternion(stream);
            return v;
        }
        function ReadArray_aiVertexWeight(stream, data, size) {
            for(let i = 0; i < size; i++)data[i] = Read_aiVertexWeight(stream);
        }
        function ReadArray_aiVectorKey(stream, data, size) {
            for(let i = 0; i < size; i++)data[i] = Read_aiVectorKey(stream);
        }
        function ReadArray_aiQuatKey(stream, data, size) {
            for(let i = 0; i < size; i++)data[i] = Read_aiQuatKey(stream);
        }
        function ReadBounds(stream, T, n) {
            return stream.Seek(sizeof(T) * n, aiOrigin_CUR);
        }
        function ai_assert(bool) {
            if (!bool) throw "asset failed";
        }
        function ReadBinaryNode(stream, parent, depth) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AINODE);
            Read_uint32_t(stream);
            var node = new aiNode();
            node.mParent = parent;
            node.mDepth = depth;
            node.mName = Read_aiString(stream);
            node.mTransformation = Read_aiMatrix4x4(stream);
            node.mNumChildren = Read_unsigned_int(stream);
            node.mNumMeshes = Read_unsigned_int(stream);
            if (node.mNumMeshes) {
                node.mMeshes = [];
                for(let i = 0; i < node.mNumMeshes; ++i){
                    node.mMeshes[i] = Read_unsigned_int(stream);
                }
            }
            if (node.mNumChildren) {
                node.mChildren = [];
                for(let i = 0; i < node.mNumChildren; ++i){
                    var node2 = ReadBinaryNode(stream, node, depth++);
                    node.mChildren[i] = node2;
                }
            }
            return node;
        }
        function ReadBinaryBone(stream, b) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);
            Read_uint32_t(stream);
            b.mName = Read_aiString(stream);
            b.mNumWeights = Read_unsigned_int(stream);
            b.mOffsetMatrix = Read_aiMatrix4x4(stream);
            if (shortened) {
                ReadBounds(stream, b.mWeights, b.mNumWeights);
            } else {
                b.mWeights = [];
                ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);
            }
            return b;
        }
        function ReadBinaryMesh(stream, mesh) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);
            Read_uint32_t(stream);
            mesh.mPrimitiveTypes = Read_unsigned_int(stream);
            mesh.mNumVertices = Read_unsigned_int(stream);
            mesh.mNumFaces = Read_unsigned_int(stream);
            mesh.mNumBones = Read_unsigned_int(stream);
            mesh.mMaterialIndex = Read_unsigned_int(stream);
            mesh.mNumUVComponents = [];
            var c = Read_unsigned_int(stream);
            if (c & ASSBIN_MESH_HAS_POSITIONS) {
                if (shortened) {
                    ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);
                } else {
                    mesh.mVertices = [];
                    mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
                    stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
                }
            }
            if (c & ASSBIN_MESH_HAS_NORMALS) {
                if (shortened) {
                    ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);
                } else {
                    mesh.mNormals = [];
                    mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
                    stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
                }
            }
            if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {
                if (shortened) {
                    ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);
                    ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);
                } else {
                    mesh.mTangents = [];
                    mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
                    stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
                    mesh.mBitangents = [];
                    mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
                    stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
                }
            }
            for(let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n){
                if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;
                if (shortened) {
                    ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);
                } else {
                    mesh.mColors[n] = [];
                    mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);
                    stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);
                }
            }
            mesh.mTexCoordsBuffers = [];
            for(let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n){
                if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break;
                mesh.mNumUVComponents[n] = Read_unsigned_int(stream);
                if (shortened) {
                    ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);
                } else {
                    mesh.mTextureCoords[n] = [];
                    mesh.mTexCoordsBuffers[n] = [];
                    for(let uv = 0; uv < mesh.mNumVertices; uv++){
                        mesh.mTexCoordsBuffers[n].push(readFloat(stream));
                        mesh.mTexCoordsBuffers[n].push(readFloat(stream));
                        readFloat(stream);
                    }
                }
            }
            if (shortened) {
                Read_unsigned_int(stream);
            } else {
                mesh.mFaces = [];
                mesh.mIndexArray = [];
                for(let i = 0; i < mesh.mNumFaces; ++i){
                    var f = mesh.mFaces[i] = new aiFace();
                    f.mNumIndices = Read_uint16_t(stream);
                    f.mIndices = [];
                    for(let a = 0; a < f.mNumIndices; ++a){
                        if (mesh.mNumVertices < 1 << 16) {
                            f.mIndices[a] = Read_uint16_t(stream);
                        } else {
                            f.mIndices[a] = Read_unsigned_int(stream);
                        }
                    }
                    if (f.mNumIndices === 3) {
                        mesh.mIndexArray.push(f.mIndices[0]);
                        mesh.mIndexArray.push(f.mIndices[1]);
                        mesh.mIndexArray.push(f.mIndices[2]);
                    } else if (f.mNumIndices === 4) {
                        mesh.mIndexArray.push(f.mIndices[0]);
                        mesh.mIndexArray.push(f.mIndices[1]);
                        mesh.mIndexArray.push(f.mIndices[2]);
                        mesh.mIndexArray.push(f.mIndices[2]);
                        mesh.mIndexArray.push(f.mIndices[3]);
                        mesh.mIndexArray.push(f.mIndices[0]);
                    } else {
                        throw new Error("Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.");
                    }
                }
            }
            if (mesh.mNumBones) {
                mesh.mBones = [];
                for(let a = 0; a < mesh.mNumBones; ++a){
                    mesh.mBones[a] = new aiBone();
                    ReadBinaryBone(stream, mesh.mBones[a]);
                }
            }
        }
        function ReadBinaryMaterialProperty(stream, prop) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);
            Read_uint32_t(stream);
            prop.mKey = Read_aiString(stream);
            prop.mSemantic = Read_unsigned_int(stream);
            prop.mIndex = Read_unsigned_int(stream);
            prop.mDataLength = Read_unsigned_int(stream);
            prop.mType = Read_unsigned_int(stream);
            prop.mData = [];
            stream.ReadBytes(prop.mData, 1, prop.mDataLength);
        }
        function ReadBinaryMaterial(stream, mat) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);
            Read_uint32_t(stream);
            mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);
            if (mat.mNumProperties) {
                if (mat.mProperties) {
                    delete mat.mProperties;
                }
                mat.mProperties = [];
                for(let i = 0; i < mat.mNumProperties; ++i){
                    mat.mProperties[i] = new aiMaterialProperty();
                    ReadBinaryMaterialProperty(stream, mat.mProperties[i]);
                }
            }
        }
        function ReadBinaryNodeAnim(stream, nd) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);
            Read_uint32_t(stream);
            nd.mNodeName = Read_aiString(stream);
            nd.mNumPositionKeys = Read_unsigned_int(stream);
            nd.mNumRotationKeys = Read_unsigned_int(stream);
            nd.mNumScalingKeys = Read_unsigned_int(stream);
            nd.mPreState = Read_unsigned_int(stream);
            nd.mPostState = Read_unsigned_int(stream);
            if (nd.mNumPositionKeys) {
                if (shortened) {
                    ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);
                } else {
                    nd.mPositionKeys = [];
                    ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);
                }
            }
            if (nd.mNumRotationKeys) {
                if (shortened) {
                    ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);
                } else {
                    nd.mRotationKeys = [];
                    ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);
                }
            }
            if (nd.mNumScalingKeys) {
                if (shortened) {
                    ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);
                } else {
                    nd.mScalingKeys = [];
                    ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);
                }
            }
        }
        function ReadBinaryAnim(stream, anim) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);
            Read_uint32_t(stream);
            anim.mName = Read_aiString(stream);
            anim.mDuration = Read_double(stream);
            anim.mTicksPerSecond = Read_double(stream);
            anim.mNumChannels = Read_unsigned_int(stream);
            if (anim.mNumChannels) {
                anim.mChannels = [];
                for(let a = 0; a < anim.mNumChannels; ++a){
                    anim.mChannels[a] = new aiNodeAnim();
                    ReadBinaryNodeAnim(stream, anim.mChannels[a]);
                }
            }
        }
        function ReadBinaryTexture(stream, tex) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);
            Read_uint32_t(stream);
            tex.mWidth = Read_unsigned_int(stream);
            tex.mHeight = Read_unsigned_int(stream);
            stream.ReadBytes(tex.achFormatHint, 1, 4);
            if (!shortened) {
                if (!tex.mHeight) {
                    tex.pcData = [];
                    stream.ReadBytes(tex.pcData, 1, tex.mWidth);
                } else {
                    tex.pcData = [];
                    stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);
                }
            }
        }
        function ReadBinaryLight(stream, l) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);
            Read_uint32_t(stream);
            l.mName = Read_aiString(stream);
            l.mType = Read_unsigned_int(stream);
            if (l.mType != aiLightSource_DIRECTIONAL) {
                l.mAttenuationConstant = readFloat(stream);
                l.mAttenuationLinear = readFloat(stream);
                l.mAttenuationQuadratic = readFloat(stream);
            }
            l.mColorDiffuse = Read_aiColor3D(stream);
            l.mColorSpecular = Read_aiColor3D(stream);
            l.mColorAmbient = Read_aiColor3D(stream);
            if (l.mType == aiLightSource_SPOT) {
                l.mAngleInnerCone = readFloat(stream);
                l.mAngleOuterCone = readFloat(stream);
            }
        }
        function ReadBinaryCamera(stream, cam) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);
            Read_uint32_t(stream);
            cam.mName = Read_aiString(stream);
            cam.mPosition = Read_aiVector3D(stream);
            cam.mLookAt = Read_aiVector3D(stream);
            cam.mUp = Read_aiVector3D(stream);
            cam.mHorizontalFOV = readFloat(stream);
            cam.mClipPlaneNear = readFloat(stream);
            cam.mClipPlaneFar = readFloat(stream);
            cam.mAspect = readFloat(stream);
        }
        function ReadBinaryScene(stream, scene) {
            var chunkID = Read_uint32_t(stream);
            ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);
            Read_uint32_t(stream);
            scene.mFlags = Read_unsigned_int(stream);
            scene.mNumMeshes = Read_unsigned_int(stream);
            scene.mNumMaterials = Read_unsigned_int(stream);
            scene.mNumAnimations = Read_unsigned_int(stream);
            scene.mNumTextures = Read_unsigned_int(stream);
            scene.mNumLights = Read_unsigned_int(stream);
            scene.mNumCameras = Read_unsigned_int(stream);
            scene.mRootNode = new aiNode();
            scene.mRootNode = ReadBinaryNode(stream, null, 0);
            if (scene.mNumMeshes) {
                scene.mMeshes = [];
                for(let i = 0; i < scene.mNumMeshes; ++i){
                    scene.mMeshes[i] = new aiMesh();
                    ReadBinaryMesh(stream, scene.mMeshes[i]);
                }
            }
            if (scene.mNumMaterials) {
                scene.mMaterials = [];
                for(let i = 0; i < scene.mNumMaterials; ++i){
                    scene.mMaterials[i] = new aiMaterial();
                    ReadBinaryMaterial(stream, scene.mMaterials[i]);
                }
            }
            if (scene.mNumAnimations) {
                scene.mAnimations = [];
                for(let i = 0; i < scene.mNumAnimations; ++i){
                    scene.mAnimations[i] = new aiAnimation();
                    ReadBinaryAnim(stream, scene.mAnimations[i]);
                }
            }
            if (scene.mNumTextures) {
                scene.mTextures = [];
                for(let i = 0; i < scene.mNumTextures; ++i){
                    scene.mTextures[i] = new aiTexture();
                    ReadBinaryTexture(stream, scene.mTextures[i]);
                }
            }
            if (scene.mNumLights) {
                scene.mLights = [];
                for(let i = 0; i < scene.mNumLights; ++i){
                    scene.mLights[i] = new aiLight();
                    ReadBinaryLight(stream, scene.mLights[i]);
                }
            }
            if (scene.mNumCameras) {
                scene.mCameras = [];
                for(let i = 0; i < scene.mNumCameras; ++i){
                    scene.mCameras[i] = new aiCamera();
                    ReadBinaryCamera(stream, scene.mCameras[i]);
                }
            }
        }
        var aiOrigin_CUR = 0;
        var aiOrigin_BEG = 1;
        function extendStream(stream) {
            stream.readOffset = 0;
            stream.Seek = function(off, ori) {
                if (ori == aiOrigin_CUR) {
                    stream.readOffset += off;
                }
                if (ori == aiOrigin_BEG) {
                    stream.readOffset = off;
                }
            };
            stream.ReadBytes = function(buff, size, n) {
                var bytes = size * n;
                for(let i = 0; i < bytes; i++)buff[i] = Read_uint8_t(this);
            };
            stream.subArray32 = function(start, end) {
                var buff = this.buffer;
                var newbuff = buff.slice(start, end);
                return new Float32Array(newbuff);
            };
            stream.subArrayUint16 = function(start, end) {
                var buff = this.buffer;
                var newbuff = buff.slice(start, end);
                return new Uint16Array(newbuff);
            };
            stream.subArrayUint8 = function(start, end) {
                var buff = this.buffer;
                var newbuff = buff.slice(start, end);
                return new Uint8Array(newbuff);
            };
            stream.subArrayUint32 = function(start, end) {
                var buff = this.buffer;
                var newbuff = buff.slice(start, end);
                return new Uint32Array(newbuff);
            };
        }
        var shortened, compressed;
        function InternReadFile(pFiledata) {
            var pScene = new aiScene();
            var stream = new DataView(pFiledata);
            extendStream(stream);
            stream.Seek(44, aiOrigin_CUR);
            pScene.versionMajor = Read_unsigned_int(stream);
            pScene.versionMinor = Read_unsigned_int(stream);
            pScene.versionRevision = Read_unsigned_int(stream);
            pScene.compileFlags = Read_unsigned_int(stream);
            shortened = Read_uint16_t(stream) > 0;
            compressed = Read_uint16_t(stream) > 0;
            if (shortened) throw "Shortened binaries are not supported!";
            stream.Seek(256, aiOrigin_CUR);
            stream.Seek(128, aiOrigin_CUR);
            stream.Seek(64, aiOrigin_CUR);
            if (compressed) {
                var uncompressedSize = Read_uint32_t(stream);
                var compressedSize = stream.FileSize() - stream.Tell();
                var compressedData = [];
                stream.Read(compressedData, 1, compressedSize);
                var uncompressedData = [];
                uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);
                var buff = new ArrayBuffer(uncompressedData);
                ReadBinaryScene(buff, pScene);
            } else {
                ReadBinaryScene(stream, pScene);
            }
            return pScene.toTHREE();
        }
        return InternReadFile(buffer);
    }
}
;
 //# sourceMappingURL=AssimpLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/MDDLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MDDLoader": (()=>MDDLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class MDDLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.load(url, function(data) {
            onLoad(scope.parse(data));
        }, onProgress, onError);
    }
    parse(data) {
        const view = new DataView(data);
        const totalFrames = view.getUint32(0);
        const totalPoints = view.getUint32(4);
        let offset = 8;
        const times = new Float32Array(totalFrames);
        const values = new Float32Array(totalFrames * totalFrames).fill(0);
        for(let i = 0; i < totalFrames; i++){
            times[i] = view.getFloat32(offset);
            offset += 4;
            values[totalFrames * i + i] = 1;
        }
        const track = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"](".morphTargetInfluences", times, values);
        const clip = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"]("default", times[times.length - 1], [
            track
        ]);
        const morphTargets = [];
        for(let i = 0; i < totalFrames; i++){
            const morphTarget = new Float32Array(totalPoints * 3);
            for(let j = 0; j < totalPoints; j++){
                const stride = j * 3;
                morphTarget[stride + 0] = view.getFloat32(offset);
                offset += 4;
                morphTarget[stride + 1] = view.getFloat32(offset);
                offset += 4;
                morphTarget[stride + 2] = view.getFloat32(offset);
                offset += 4;
            }
            const attribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](morphTarget, 3);
            attribute.name = "morph_" + i;
            morphTargets.push(attribute);
        }
        return {
            morphTargets,
            clip
        };
    }
}
;
 //# sourceMappingURL=MDDLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/EXRLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "EXRLoader": (()=>EXRLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)");
;
;
;
const hasColorSpace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 152;
class EXRLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTextureLoader"] {
    constructor(manager){
        super(manager);
        this.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
    }
    parse(buffer) {
        const USHORT_RANGE = 1 << 16;
        const BITMAP_SIZE = USHORT_RANGE >> 3;
        const HUF_ENCBITS = 16;
        const HUF_DECBITS = 14;
        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
        const HUF_DECSIZE = 1 << HUF_DECBITS;
        const HUF_DECMASK = HUF_DECSIZE - 1;
        const NBITS = 16;
        const A_OFFSET = 1 << NBITS - 1;
        const MOD_MASK = (1 << NBITS) - 1;
        const SHORT_ZEROCODE_RUN = 59;
        const LONG_ZEROCODE_RUN = 63;
        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
        const ULONG_SIZE = 8;
        const FLOAT32_SIZE = 4;
        const INT32_SIZE = 4;
        const INT16_SIZE = 2;
        const INT8_SIZE = 1;
        const STATIC_HUFFMAN = 0;
        const DEFLATE = 1;
        const UNKNOWN = 0;
        const LOSSY_DCT = 1;
        const RLE = 2;
        const logBase = Math.pow(2.7182818, 2.2);
        function reverseLutFromBitmap(bitmap, lut) {
            var k = 0;
            for(var i = 0; i < USHORT_RANGE; ++i){
                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {
                    lut[k++] = i;
                }
            }
            var n = k - 1;
            while(k < USHORT_RANGE)lut[k++] = 0;
            return n;
        }
        function hufClearDecTable(hdec) {
            for(var i = 0; i < HUF_DECSIZE; i++){
                hdec[i] = {};
                hdec[i].len = 0;
                hdec[i].lit = 0;
                hdec[i].p = null;
            }
        }
        const getBitsReturn = {
            l: 0,
            c: 0,
            lc: 0
        };
        function getBits(nBits, c, lc, uInt8Array2, inOffset) {
            while(lc < nBits){
                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
                lc += 8;
            }
            lc -= nBits;
            getBitsReturn.l = c >> lc & (1 << nBits) - 1;
            getBitsReturn.c = c;
            getBitsReturn.lc = lc;
        }
        const hufTableBuffer = new Array(59);
        function hufCanonicalCodeTable(hcode) {
            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;
            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;
            var c = 0;
            for(var i = 58; i > 0; --i){
                var nc = c + hufTableBuffer[i] >> 1;
                hufTableBuffer[i] = c;
                c = nc;
            }
            for(var i = 0; i < HUF_ENCSIZE; ++i){
                var l = hcode[i];
                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;
            }
        }
        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {
            var p = inOffset;
            var c = 0;
            var lc = 0;
            for(; im <= iM; im++){
                if (p.value - inOffset.value > ni) return false;
                getBits(6, c, lc, uInt8Array2, p);
                var l = getBitsReturn.l;
                c = getBitsReturn.c;
                lc = getBitsReturn.lc;
                hcode[im] = l;
                if (l == LONG_ZEROCODE_RUN) {
                    if (p.value - inOffset.value > ni) {
                        throw "Something wrong with hufUnpackEncTable";
                    }
                    getBits(8, c, lc, uInt8Array2, p);
                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
                    c = getBitsReturn.c;
                    lc = getBitsReturn.lc;
                    if (im + zerun > iM + 1) {
                        throw "Something wrong with hufUnpackEncTable";
                    }
                    while(zerun--)hcode[im++] = 0;
                    im--;
                } else if (l >= SHORT_ZEROCODE_RUN) {
                    var zerun = l - SHORT_ZEROCODE_RUN + 2;
                    if (im + zerun > iM + 1) {
                        throw "Something wrong with hufUnpackEncTable";
                    }
                    while(zerun--)hcode[im++] = 0;
                    im--;
                }
            }
            hufCanonicalCodeTable(hcode);
        }
        function hufLength(code) {
            return code & 63;
        }
        function hufCode(code) {
            return code >> 6;
        }
        function hufBuildDecTable(hcode, im, iM, hdecod) {
            for(; im <= iM; im++){
                var c = hufCode(hcode[im]);
                var l = hufLength(hcode[im]);
                if (c >> l) {
                    throw "Invalid table entry";
                }
                if (l > HUF_DECBITS) {
                    var pl = hdecod[c >> l - HUF_DECBITS];
                    if (pl.len) {
                        throw "Invalid table entry";
                    }
                    pl.lit++;
                    if (pl.p) {
                        var p = pl.p;
                        pl.p = new Array(pl.lit);
                        for(var i = 0; i < pl.lit - 1; ++i){
                            pl.p[i] = p[i];
                        }
                    } else {
                        pl.p = new Array(1);
                    }
                    pl.p[pl.lit - 1] = im;
                } else if (l) {
                    var plOffset = 0;
                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){
                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];
                        if (pl.len || pl.p) {
                            throw "Invalid table entry";
                        }
                        pl.len = l;
                        pl.lit = im;
                        plOffset++;
                    }
                }
            }
            return true;
        }
        const getCharReturn = {
            c: 0,
            lc: 0
        };
        function getChar(c, lc, uInt8Array2, inOffset) {
            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
            lc += 8;
            getCharReturn.c = c;
            getCharReturn.lc = lc;
        }
        const getCodeReturn = {
            c: 0,
            lc: 0
        };
        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {
            if (po == rlc) {
                if (lc < 8) {
                    getChar(c, lc, uInt8Array2, inOffset);
                    c = getCharReturn.c;
                    lc = getCharReturn.lc;
                }
                lc -= 8;
                var cs = c >> lc;
                var cs = new Uint8Array([
                    cs
                ])[0];
                if (outBufferOffset.value + cs > outBufferEndOffset) {
                    return false;
                }
                var s = outBuffer[outBufferOffset.value - 1];
                while(cs-- > 0){
                    outBuffer[outBufferOffset.value++] = s;
                }
            } else if (outBufferOffset.value < outBufferEndOffset) {
                outBuffer[outBufferOffset.value++] = po;
            } else {
                return false;
            }
            getCodeReturn.c = c;
            getCodeReturn.lc = lc;
        }
        function UInt16(value) {
            return value & 65535;
        }
        function Int16(value) {
            var ref = UInt16(value);
            return ref > 32767 ? ref - 65536 : ref;
        }
        const wdec14Return = {
            a: 0,
            b: 0
        };
        function wdec14(l, h) {
            var ls = Int16(l);
            var hs = Int16(h);
            var hi = hs;
            var ai = ls + (hi & 1) + (hi >> 1);
            var as = ai;
            var bs = ai - hi;
            wdec14Return.a = as;
            wdec14Return.b = bs;
        }
        function wdec16(l, h) {
            var m = UInt16(l);
            var d = UInt16(h);
            var bb = m - (d >> 1) & MOD_MASK;
            var aa = d + bb - A_OFFSET & MOD_MASK;
            wdec14Return.a = aa;
            wdec14Return.b = bb;
        }
        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {
            var w14 = mx < 1 << 14;
            var n = nx > ny ? ny : nx;
            var p = 1;
            var p2;
            while(p <= n)p <<= 1;
            p >>= 1;
            p2 = p;
            p >>= 1;
            while(p >= 1){
                var py = 0;
                var ey = py + oy * (ny - p2);
                var oy1 = oy * p;
                var oy2 = oy * p2;
                var ox1 = ox * p;
                var ox2 = ox * p2;
                var i00, i01, i10, i11;
                for(; py <= ey; py += oy2){
                    var px = py;
                    var ex = py + ox * (nx - p2);
                    for(; px <= ex; px += ox2){
                        var p01 = px + ox1;
                        var p10 = px + oy1;
                        var p11 = p10 + ox1;
                        if (w14) {
                            wdec14(buffer2[px + j], buffer2[p10 + j]);
                            i00 = wdec14Return.a;
                            i10 = wdec14Return.b;
                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);
                            i01 = wdec14Return.a;
                            i11 = wdec14Return.b;
                            wdec14(i00, i01);
                            buffer2[px + j] = wdec14Return.a;
                            buffer2[p01 + j] = wdec14Return.b;
                            wdec14(i10, i11);
                            buffer2[p10 + j] = wdec14Return.a;
                            buffer2[p11 + j] = wdec14Return.b;
                        } else {
                            wdec16(buffer2[px + j], buffer2[p10 + j]);
                            i00 = wdec14Return.a;
                            i10 = wdec14Return.b;
                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);
                            i01 = wdec14Return.a;
                            i11 = wdec14Return.b;
                            wdec16(i00, i01);
                            buffer2[px + j] = wdec14Return.a;
                            buffer2[p01 + j] = wdec14Return.b;
                            wdec16(i10, i11);
                            buffer2[p10 + j] = wdec14Return.a;
                            buffer2[p11 + j] = wdec14Return.b;
                        }
                    }
                    if (nx & p) {
                        var p10 = px + oy1;
                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);
                        else wdec16(buffer2[px + j], buffer2[p10 + j]);
                        i00 = wdec14Return.a;
                        buffer2[p10 + j] = wdec14Return.b;
                        buffer2[px + j] = i00;
                    }
                }
                if (ny & p) {
                    var px = py;
                    var ex = py + ox * (nx - p2);
                    for(; px <= ex; px += ox2){
                        var p01 = px + ox1;
                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);
                        else wdec16(buffer2[px + j], buffer2[p01 + j]);
                        i00 = wdec14Return.a;
                        buffer2[p01 + j] = wdec14Return.b;
                        buffer2[px + j] = i00;
                    }
                }
                p2 = p;
                p >>= 1;
            }
            return py;
        }
        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {
            var c = 0;
            var lc = 0;
            var outBufferEndOffset = no;
            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);
            while(inOffset.value < inOffsetEnd){
                getChar(c, lc, uInt8Array2, inOffset);
                c = getCharReturn.c;
                lc = getCharReturn.lc;
                while(lc >= HUF_DECBITS){
                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;
                    var pl = decodingTable[index];
                    if (pl.len) {
                        lc -= pl.len;
                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                        c = getCodeReturn.c;
                        lc = getCodeReturn.lc;
                    } else {
                        if (!pl.p) {
                            throw "hufDecode issues";
                        }
                        var j;
                        for(j = 0; j < pl.lit; j++){
                            var l = hufLength(encodingTable[pl.p[j]]);
                            while(lc < l && inOffset.value < inOffsetEnd){
                                getChar(c, lc, uInt8Array2, inOffset);
                                c = getCharReturn.c;
                                lc = getCharReturn.lc;
                            }
                            if (lc >= l) {
                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {
                                    lc -= l;
                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                                    c = getCodeReturn.c;
                                    lc = getCodeReturn.lc;
                                    break;
                                }
                            }
                        }
                        if (j == pl.lit) {
                            throw "hufDecode issues";
                        }
                    }
                }
            }
            var i = 8 - ni & 7;
            c >>= i;
            lc -= i;
            while(lc > 0){
                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];
                if (pl.len) {
                    lc -= pl.len;
                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                    c = getCodeReturn.c;
                    lc = getCodeReturn.lc;
                } else {
                    throw "hufDecode issues";
                }
            }
            return true;
        }
        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {
            var outOffset = {
                value: 0
            };
            var initialInOffset = inOffset.value;
            var im = parseUint32(inDataView, inOffset);
            var iM = parseUint32(inDataView, inOffset);
            inOffset.value += 4;
            var nBits = parseUint32(inDataView, inOffset);
            inOffset.value += 4;
            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {
                throw "Something wrong with HUF_ENCSIZE";
            }
            var freq = new Array(HUF_ENCSIZE);
            var hdec = new Array(HUF_DECSIZE);
            hufClearDecTable(hdec);
            var ni = nCompressed - (inOffset.value - initialInOffset);
            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);
            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {
                throw "Something wrong with hufUncompress";
            }
            hufBuildDecTable(freq, im, iM, hdec);
            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
        }
        function applyLut(lut, data, nData) {
            for(var i = 0; i < nData; ++i){
                data[i] = lut[data[i]];
            }
        }
        function predictor(source) {
            for(var t = 1; t < source.length; t++){
                var d = source[t - 1] + source[t] - 128;
                source[t] = d;
            }
        }
        function interleaveScalar(source, out) {
            var t1 = 0;
            var t2 = Math.floor((source.length + 1) / 2);
            var s = 0;
            var stop = source.length - 1;
            while(true){
                if (s > stop) break;
                out[s++] = source[t1++];
                if (s > stop) break;
                out[s++] = source[t2++];
            }
        }
        function decodeRunLength(source) {
            var size = source.byteLength;
            var out = new Array();
            var p = 0;
            var reader = new DataView(source);
            while(size > 0){
                var l = reader.getInt8(p++);
                if (l < 0) {
                    var count = -l;
                    size -= count + 1;
                    for(var i = 0; i < count; i++){
                        out.push(reader.getUint8(p++));
                    }
                } else {
                    var count = l;
                    size -= 2;
                    var value = reader.getUint8(p++);
                    for(var i = 0; i < count + 1; i++){
                        out.push(value);
                    }
                }
            }
            return out;
        }
        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {
            var dataView = new DataView(outBuffer.buffer);
            var width = channelData[cscSet.idx[0]].width;
            var height = channelData[cscSet.idx[0]].height;
            var numComp = 3;
            var numFullBlocksX = Math.floor(width / 8);
            var numBlocksX = Math.ceil(width / 8);
            var numBlocksY = Math.ceil(height / 8);
            var leftoverX = width - (numBlocksX - 1) * 8;
            var leftoverY = height - (numBlocksY - 1) * 8;
            var currAcComp = {
                value: 0
            };
            var currDcComp = new Array(numComp);
            var dctData = new Array(numComp);
            var halfZigBlock = new Array(numComp);
            var rowBlock = new Array(numComp);
            var rowOffsets = new Array(numComp);
            for(let comp2 = 0; comp2 < numComp; ++comp2){
                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];
                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;
                dctData[comp2] = new Float32Array(64);
                halfZigBlock[comp2] = new Uint16Array(64);
                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);
            }
            for(let blocky = 0; blocky < numBlocksY; ++blocky){
                var maxY = 8;
                if (blocky == numBlocksY - 1) maxY = leftoverY;
                var maxX = 8;
                for(let blockx = 0; blockx < numBlocksX; ++blockx){
                    if (blockx == numBlocksX - 1) maxX = leftoverX;
                    for(let comp2 = 0; comp2 < numComp; ++comp2){
                        halfZigBlock[comp2].fill(0);
                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];
                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);
                        unZigZag(halfZigBlock[comp2], dctData[comp2]);
                        dctInverse(dctData[comp2]);
                    }
                    {
                        csc709Inverse(dctData);
                    }
                    for(let comp2 = 0; comp2 < numComp; ++comp2){
                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);
                    }
                }
                let offset2 = 0;
                for(let comp2 = 0; comp2 < numComp; ++comp2){
                    const type2 = channelData[cscSet.idx[comp2]].type;
                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){
                        offset2 = rowOffsets[comp2][y2];
                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){
                            const src = blockx * 64 + (y2 & 7) * 8;
                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);
                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);
                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);
                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);
                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);
                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);
                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);
                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);
                            offset2 += 8 * INT16_SIZE * type2;
                        }
                    }
                    if (numFullBlocksX != numBlocksX) {
                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){
                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;
                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;
                            for(let x2 = 0; x2 < maxX; ++x2){
                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);
                            }
                        }
                    }
                }
            }
            var halfRow = new Uint16Array(width);
            var dataView = new DataView(outBuffer.buffer);
            for(var comp = 0; comp < numComp; ++comp){
                channelData[cscSet.idx[comp]].decoded = true;
                var type = channelData[cscSet.idx[comp]].type;
                if (channelData[comp].type != 2) continue;
                for(var y = 0; y < height; ++y){
                    const offset2 = rowOffsets[comp][y];
                    for(var x = 0; x < width; ++x){
                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);
                    }
                    for(var x = 0; x < width; ++x){
                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);
                    }
                }
            }
        }
        function unRleAC(currAcComp, acBuffer, halfZigBlock) {
            var acValue;
            var dctComp = 1;
            while(dctComp < 64){
                acValue = acBuffer[currAcComp.value];
                if (acValue == 65280) {
                    dctComp = 64;
                } else if (acValue >> 8 == 255) {
                    dctComp += acValue & 255;
                } else {
                    halfZigBlock[dctComp] = acValue;
                    dctComp++;
                }
                currAcComp.value++;
            }
        }
        function unZigZag(src, dst) {
            dst[0] = decodeFloat16(src[0]);
            dst[1] = decodeFloat16(src[1]);
            dst[2] = decodeFloat16(src[5]);
            dst[3] = decodeFloat16(src[6]);
            dst[4] = decodeFloat16(src[14]);
            dst[5] = decodeFloat16(src[15]);
            dst[6] = decodeFloat16(src[27]);
            dst[7] = decodeFloat16(src[28]);
            dst[8] = decodeFloat16(src[2]);
            dst[9] = decodeFloat16(src[4]);
            dst[10] = decodeFloat16(src[7]);
            dst[11] = decodeFloat16(src[13]);
            dst[12] = decodeFloat16(src[16]);
            dst[13] = decodeFloat16(src[26]);
            dst[14] = decodeFloat16(src[29]);
            dst[15] = decodeFloat16(src[42]);
            dst[16] = decodeFloat16(src[3]);
            dst[17] = decodeFloat16(src[8]);
            dst[18] = decodeFloat16(src[12]);
            dst[19] = decodeFloat16(src[17]);
            dst[20] = decodeFloat16(src[25]);
            dst[21] = decodeFloat16(src[30]);
            dst[22] = decodeFloat16(src[41]);
            dst[23] = decodeFloat16(src[43]);
            dst[24] = decodeFloat16(src[9]);
            dst[25] = decodeFloat16(src[11]);
            dst[26] = decodeFloat16(src[18]);
            dst[27] = decodeFloat16(src[24]);
            dst[28] = decodeFloat16(src[31]);
            dst[29] = decodeFloat16(src[40]);
            dst[30] = decodeFloat16(src[44]);
            dst[31] = decodeFloat16(src[53]);
            dst[32] = decodeFloat16(src[10]);
            dst[33] = decodeFloat16(src[19]);
            dst[34] = decodeFloat16(src[23]);
            dst[35] = decodeFloat16(src[32]);
            dst[36] = decodeFloat16(src[39]);
            dst[37] = decodeFloat16(src[45]);
            dst[38] = decodeFloat16(src[52]);
            dst[39] = decodeFloat16(src[54]);
            dst[40] = decodeFloat16(src[20]);
            dst[41] = decodeFloat16(src[22]);
            dst[42] = decodeFloat16(src[33]);
            dst[43] = decodeFloat16(src[38]);
            dst[44] = decodeFloat16(src[46]);
            dst[45] = decodeFloat16(src[51]);
            dst[46] = decodeFloat16(src[55]);
            dst[47] = decodeFloat16(src[60]);
            dst[48] = decodeFloat16(src[21]);
            dst[49] = decodeFloat16(src[34]);
            dst[50] = decodeFloat16(src[37]);
            dst[51] = decodeFloat16(src[47]);
            dst[52] = decodeFloat16(src[50]);
            dst[53] = decodeFloat16(src[56]);
            dst[54] = decodeFloat16(src[59]);
            dst[55] = decodeFloat16(src[61]);
            dst[56] = decodeFloat16(src[35]);
            dst[57] = decodeFloat16(src[36]);
            dst[58] = decodeFloat16(src[48]);
            dst[59] = decodeFloat16(src[49]);
            dst[60] = decodeFloat16(src[57]);
            dst[61] = decodeFloat16(src[58]);
            dst[62] = decodeFloat16(src[62]);
            dst[63] = decodeFloat16(src[63]);
        }
        function dctInverse(data) {
            const a = 0.5 * Math.cos(3.14159 / 4);
            const b = 0.5 * Math.cos(3.14159 / 16);
            const c = 0.5 * Math.cos(3.14159 / 8);
            const d = 0.5 * Math.cos(3 * 3.14159 / 16);
            const e = 0.5 * Math.cos(5 * 3.14159 / 16);
            const f = 0.5 * Math.cos(3 * 3.14159 / 8);
            const g = 0.5 * Math.cos(7 * 3.14159 / 16);
            var alpha = new Array(4);
            var beta = new Array(4);
            var theta = new Array(4);
            var gamma = new Array(4);
            for(var row = 0; row < 8; ++row){
                var rowPtr = row * 8;
                alpha[0] = c * data[rowPtr + 2];
                alpha[1] = f * data[rowPtr + 2];
                alpha[2] = c * data[rowPtr + 6];
                alpha[3] = f * data[rowPtr + 6];
                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];
                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];
                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];
                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];
                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);
                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);
                theta[1] = alpha[0] + alpha[3];
                theta[2] = alpha[1] - alpha[2];
                gamma[0] = theta[0] + theta[1];
                gamma[1] = theta[3] + theta[2];
                gamma[2] = theta[3] - theta[2];
                gamma[3] = theta[0] - theta[1];
                data[rowPtr + 0] = gamma[0] + beta[0];
                data[rowPtr + 1] = gamma[1] + beta[1];
                data[rowPtr + 2] = gamma[2] + beta[2];
                data[rowPtr + 3] = gamma[3] + beta[3];
                data[rowPtr + 4] = gamma[3] - beta[3];
                data[rowPtr + 5] = gamma[2] - beta[2];
                data[rowPtr + 6] = gamma[1] - beta[1];
                data[rowPtr + 7] = gamma[0] - beta[0];
            }
            for(var column = 0; column < 8; ++column){
                alpha[0] = c * data[16 + column];
                alpha[1] = f * data[16 + column];
                alpha[2] = c * data[48 + column];
                alpha[3] = f * data[48 + column];
                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];
                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];
                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];
                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];
                theta[0] = a * (data[column] + data[32 + column]);
                theta[3] = a * (data[column] - data[32 + column]);
                theta[1] = alpha[0] + alpha[3];
                theta[2] = alpha[1] - alpha[2];
                gamma[0] = theta[0] + theta[1];
                gamma[1] = theta[3] + theta[2];
                gamma[2] = theta[3] - theta[2];
                gamma[3] = theta[0] - theta[1];
                data[0 + column] = gamma[0] + beta[0];
                data[8 + column] = gamma[1] + beta[1];
                data[16 + column] = gamma[2] + beta[2];
                data[24 + column] = gamma[3] + beta[3];
                data[32 + column] = gamma[3] - beta[3];
                data[40 + column] = gamma[2] - beta[2];
                data[48 + column] = gamma[1] - beta[1];
                data[56 + column] = gamma[0] - beta[0];
            }
        }
        function csc709Inverse(data) {
            for(var i = 0; i < 64; ++i){
                var y = data[0][i];
                var cb = data[1][i];
                var cr = data[2][i];
                data[0][i] = y + 1.5747 * cr;
                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;
                data[2][i] = y + 1.8556 * cb;
            }
        }
        function convertToHalf(src, dst, idx) {
            for(var i = 0; i < 64; ++i){
                dst[idx + i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(toLinear(src[i]));
            }
        }
        function toLinear(float) {
            if (float <= 1) {
                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);
            } else {
                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);
            }
        }
        function uncompressRAW(info) {
            return new DataView(info.array.buffer, info.offset.value, info.size);
        }
        function uncompressRLE(info) {
            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);
            var rawBuffer = new Uint8Array(decodeRunLength(compressed));
            var tmpBuffer = new Uint8Array(rawBuffer.length);
            predictor(rawBuffer);
            interleaveScalar(rawBuffer, tmpBuffer);
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressZIP(info) {
            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
            var rawBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
            var tmpBuffer = new Uint8Array(rawBuffer.length);
            predictor(rawBuffer);
            interleaveScalar(rawBuffer, tmpBuffer);
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressPIZ(info) {
            var inDataView = info.viewer;
            var inOffset = {
                value: info.offset.value
            };
            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));
            var bitmap = new Uint8Array(BITMAP_SIZE);
            var outBufferEnd = 0;
            var pizChannelData = new Array(info.channels);
            for(var i = 0; i < info.channels; i++){
                pizChannelData[i] = {};
                pizChannelData[i]["start"] = outBufferEnd;
                pizChannelData[i]["end"] = pizChannelData[i]["start"];
                pizChannelData[i]["nx"] = info.width;
                pizChannelData[i]["ny"] = info.lines;
                pizChannelData[i]["size"] = info.type;
                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;
            }
            var minNonZero = parseUint16(inDataView, inOffset);
            var maxNonZero = parseUint16(inDataView, inOffset);
            if (maxNonZero >= BITMAP_SIZE) {
                throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
            }
            if (minNonZero <= maxNonZero) {
                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){
                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);
                }
            }
            var lut = new Uint16Array(USHORT_RANGE);
            var maxValue = reverseLutFromBitmap(bitmap, lut);
            var length = parseUint32(inDataView, inOffset);
            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);
            for(var i = 0; i < info.channels; ++i){
                var cd = pizChannelData[i];
                for(var j = 0; j < pizChannelData[i].size; ++j){
                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);
                }
            }
            applyLut(lut, outBuffer, outBufferEnd);
            var tmpOffset2 = 0;
            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
            for(var y = 0; y < info.lines; y++){
                for(var c = 0; c < info.channels; c++){
                    var cd = pizChannelData[c];
                    var n = cd.nx * cd.size;
                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);
                    tmpBuffer.set(cp, tmpOffset2);
                    tmpOffset2 += n * INT16_SIZE;
                    cd.end += n;
                }
            }
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressPXR(info) {
            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
            var rawBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
            const sz = info.lines * info.channels * info.width;
            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);
            let tmpBufferEnd = 0;
            let writePtr = 0;
            const ptr = new Array(4);
            for(let y = 0; y < info.lines; y++){
                for(let c = 0; c < info.channels; c++){
                    let pixel = 0;
                    switch(info.type){
                        case 1:
                            ptr[0] = tmpBufferEnd;
                            ptr[1] = ptr[0] + info.width;
                            tmpBufferEnd = ptr[1] + info.width;
                            for(let j = 0; j < info.width; ++j){
                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];
                                pixel += diff;
                                tmpBuffer[writePtr] = pixel;
                                writePtr++;
                            }
                            break;
                        case 2:
                            ptr[0] = tmpBufferEnd;
                            ptr[1] = ptr[0] + info.width;
                            ptr[2] = ptr[1] + info.width;
                            tmpBufferEnd = ptr[2] + info.width;
                            for(let j = 0; j < info.width; ++j){
                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;
                                pixel += diff;
                                tmpBuffer[writePtr] = pixel;
                                writePtr++;
                            }
                            break;
                    }
                }
            }
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressDWA(info) {
            var inDataView = info.viewer;
            var inOffset = {
                value: info.offset.value
            };
            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));
            var dwaHeader = {
                version: parseInt64(inDataView, inOffset),
                unknownUncompressedSize: parseInt64(inDataView, inOffset),
                unknownCompressedSize: parseInt64(inDataView, inOffset),
                acCompressedSize: parseInt64(inDataView, inOffset),
                dcCompressedSize: parseInt64(inDataView, inOffset),
                rleCompressedSize: parseInt64(inDataView, inOffset),
                rleUncompressedSize: parseInt64(inDataView, inOffset),
                rleRawSize: parseInt64(inDataView, inOffset),
                totalAcUncompressedCount: parseInt64(inDataView, inOffset),
                totalDcUncompressedCount: parseInt64(inDataView, inOffset),
                acCompression: parseInt64(inDataView, inOffset)
            };
            if (dwaHeader.version < 2) {
                throw "EXRLoader.parse: " + EXRHeader.compression + " version " + dwaHeader.version + " is unsupported";
            }
            var channelRules = new Array();
            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;
            while(ruleSize > 0){
                var name = parseNullTerminatedString(inDataView.buffer, inOffset);
                var value = parseUint8(inDataView, inOffset);
                var compression = value >> 2 & 3;
                var csc = (value >> 4) - 1;
                var index = new Int8Array([
                    csc
                ])[0];
                var type = parseUint8(inDataView, inOffset);
                channelRules.push({
                    name,
                    index,
                    type,
                    compression
                });
                ruleSize -= name.length + 3;
            }
            var channels = EXRHeader.channels;
            var channelData = new Array(info.channels);
            for(var i = 0; i < info.channels; ++i){
                var cd = channelData[i] = {};
                var channel = channels[i];
                cd.name = channel.name;
                cd.compression = UNKNOWN;
                cd.decoded = false;
                cd.type = channel.pixelType;
                cd.pLinear = channel.pLinear;
                cd.width = info.width;
                cd.height = info.lines;
            }
            var cscSet = {
                idx: new Array(3)
            };
            for(var offset2 = 0; offset2 < info.channels; ++offset2){
                var cd = channelData[offset2];
                for(var i = 0; i < channelRules.length; ++i){
                    var rule = channelRules[i];
                    if (cd.name == rule.name) {
                        cd.compression = rule.compression;
                        if (rule.index >= 0) {
                            cscSet.idx[rule.index] = offset2;
                        }
                        cd.offset = offset2;
                    }
                }
            }
            if (dwaHeader.acCompressedSize > 0) {
                switch(dwaHeader.acCompression){
                    case STATIC_HUFFMAN:
                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);
                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);
                        break;
                    case DEFLATE:
                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);
                        var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                        var acBuffer = new Uint16Array(data.buffer);
                        inOffset.value += dwaHeader.totalAcUncompressedCount;
                        break;
                }
            }
            if (dwaHeader.dcCompressedSize > 0) {
                var zlibInfo = {
                    array: info.array,
                    offset: inOffset,
                    size: dwaHeader.dcCompressedSize
                };
                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);
                inOffset.value += dwaHeader.dcCompressedSize;
            }
            if (dwaHeader.rleRawSize > 0) {
                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);
                var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                var rleBuffer = decodeRunLength(data.buffer);
                inOffset.value += dwaHeader.rleCompressedSize;
            }
            var outBufferEnd = 0;
            var rowOffsets = new Array(channelData.length);
            for(var i = 0; i < rowOffsets.length; ++i){
                rowOffsets[i] = new Array();
            }
            for(var y = 0; y < info.lines; ++y){
                for(var chan = 0; chan < channelData.length; ++chan){
                    rowOffsets[chan].push(outBufferEnd);
                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;
                }
            }
            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);
            for(var i = 0; i < channelData.length; ++i){
                var cd = channelData[i];
                if (cd.decoded) continue;
                switch(cd.compression){
                    case RLE:
                        var row = 0;
                        var rleOffset = 0;
                        for(var y = 0; y < info.lines; ++y){
                            var rowOffsetBytes = rowOffsets[i][row];
                            for(var x = 0; x < cd.width; ++x){
                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){
                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];
                                }
                                rleOffset++;
                            }
                            row++;
                        }
                        break;
                    case LOSSY_DCT:
                    default:
                        throw "EXRLoader.parse: unsupported channel compression";
                }
            }
            return new DataView(outBuffer.buffer);
        }
        function parseNullTerminatedString(buffer2, offset2) {
            var uintBuffer = new Uint8Array(buffer2);
            var endOffset = 0;
            while(uintBuffer[offset2.value + endOffset] != 0){
                endOffset += 1;
            }
            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));
            offset2.value = offset2.value + endOffset + 1;
            return stringValue;
        }
        function parseFixedLengthString(buffer2, offset2, size) {
            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));
            offset2.value = offset2.value + size;
            return stringValue;
        }
        function parseRational(dataView, offset2) {
            var x = parseInt32(dataView, offset2);
            var y = parseUint32(dataView, offset2);
            return [
                x,
                y
            ];
        }
        function parseTimecode(dataView, offset2) {
            var x = parseUint32(dataView, offset2);
            var y = parseUint32(dataView, offset2);
            return [
                x,
                y
            ];
        }
        function parseInt32(dataView, offset2) {
            var Int32 = dataView.getInt32(offset2.value, true);
            offset2.value = offset2.value + INT32_SIZE;
            return Int32;
        }
        function parseUint32(dataView, offset2) {
            var Uint32 = dataView.getUint32(offset2.value, true);
            offset2.value = offset2.value + INT32_SIZE;
            return Uint32;
        }
        function parseUint8Array(uInt8Array2, offset2) {
            var Uint8 = uInt8Array2[offset2.value];
            offset2.value = offset2.value + INT8_SIZE;
            return Uint8;
        }
        function parseUint8(dataView, offset2) {
            var Uint8 = dataView.getUint8(offset2.value);
            offset2.value = offset2.value + INT8_SIZE;
            return Uint8;
        }
        const parseInt64 = function(dataView, offset2) {
            let int;
            if ("getBigInt64" in DataView.prototype) {
                int = Number(dataView.getBigInt64(offset2.value, true));
            } else {
                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);
            }
            offset2.value += ULONG_SIZE;
            return int;
        };
        function parseFloat32(dataView, offset2) {
            var float = dataView.getFloat32(offset2.value, true);
            offset2.value += FLOAT32_SIZE;
            return float;
        }
        function decodeFloat32(dataView, offset2) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(parseFloat32(dataView, offset2));
        }
        function decodeFloat16(binary) {
            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;
            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
        }
        function parseUint16(dataView, offset2) {
            var Uint16 = dataView.getUint16(offset2.value, true);
            offset2.value += INT16_SIZE;
            return Uint16;
        }
        function parseFloat16(buffer2, offset2) {
            return decodeFloat16(parseUint16(buffer2, offset2));
        }
        function parseChlist(dataView, buffer2, offset2, size) {
            var startOffset = offset2.value;
            var channels = [];
            while(offset2.value < startOffset + size - 1){
                var name = parseNullTerminatedString(buffer2, offset2);
                var pixelType = parseInt32(dataView, offset2);
                var pLinear = parseUint8(dataView, offset2);
                offset2.value += 3;
                var xSampling = parseInt32(dataView, offset2);
                var ySampling = parseInt32(dataView, offset2);
                channels.push({
                    name,
                    pixelType,
                    pLinear,
                    xSampling,
                    ySampling
                });
            }
            offset2.value += 1;
            return channels;
        }
        function parseChromaticities(dataView, offset2) {
            var redX = parseFloat32(dataView, offset2);
            var redY = parseFloat32(dataView, offset2);
            var greenX = parseFloat32(dataView, offset2);
            var greenY = parseFloat32(dataView, offset2);
            var blueX = parseFloat32(dataView, offset2);
            var blueY = parseFloat32(dataView, offset2);
            var whiteX = parseFloat32(dataView, offset2);
            var whiteY = parseFloat32(dataView, offset2);
            return {
                redX,
                redY,
                greenX,
                greenY,
                blueX,
                blueY,
                whiteX,
                whiteY
            };
        }
        function parseCompression(dataView, offset2) {
            var compressionCodes = [
                "NO_COMPRESSION",
                "RLE_COMPRESSION",
                "ZIPS_COMPRESSION",
                "ZIP_COMPRESSION",
                "PIZ_COMPRESSION",
                "PXR24_COMPRESSION",
                "B44_COMPRESSION",
                "B44A_COMPRESSION",
                "DWAA_COMPRESSION",
                "DWAB_COMPRESSION"
            ];
            var compression = parseUint8(dataView, offset2);
            return compressionCodes[compression];
        }
        function parseBox2i(dataView, offset2) {
            var xMin = parseUint32(dataView, offset2);
            var yMin = parseUint32(dataView, offset2);
            var xMax = parseUint32(dataView, offset2);
            var yMax = parseUint32(dataView, offset2);
            return {
                xMin,
                yMin,
                xMax,
                yMax
            };
        }
        function parseLineOrder(dataView, offset2) {
            var lineOrders = [
                "INCREASING_Y"
            ];
            var lineOrder = parseUint8(dataView, offset2);
            return lineOrders[lineOrder];
        }
        function parseV2f(dataView, offset2) {
            var x = parseFloat32(dataView, offset2);
            var y = parseFloat32(dataView, offset2);
            return [
                x,
                y
            ];
        }
        function parseV3f(dataView, offset2) {
            var x = parseFloat32(dataView, offset2);
            var y = parseFloat32(dataView, offset2);
            var z = parseFloat32(dataView, offset2);
            return [
                x,
                y,
                z
            ];
        }
        function parseValue(dataView, buffer2, offset2, type, size) {
            if (type === "string" || type === "stringvector" || type === "iccProfile") {
                return parseFixedLengthString(buffer2, offset2, size);
            } else if (type === "chlist") {
                return parseChlist(dataView, buffer2, offset2, size);
            } else if (type === "chromaticities") {
                return parseChromaticities(dataView, offset2);
            } else if (type === "compression") {
                return parseCompression(dataView, offset2);
            } else if (type === "box2i") {
                return parseBox2i(dataView, offset2);
            } else if (type === "lineOrder") {
                return parseLineOrder(dataView, offset2);
            } else if (type === "float") {
                return parseFloat32(dataView, offset2);
            } else if (type === "v2f") {
                return parseV2f(dataView, offset2);
            } else if (type === "v3f") {
                return parseV3f(dataView, offset2);
            } else if (type === "int") {
                return parseInt32(dataView, offset2);
            } else if (type === "rational") {
                return parseRational(dataView, offset2);
            } else if (type === "timecode") {
                return parseTimecode(dataView, offset2);
            } else if (type === "preview") {
                offset2.value += size;
                return "skipped";
            } else {
                offset2.value += size;
                return void 0;
            }
        }
        function parseHeader(dataView, buffer2, offset2) {
            const EXRHeader2 = {};
            if (dataView.getUint32(0, true) != 20000630) {
                throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
            }
            EXRHeader2.version = dataView.getUint8(4);
            const spec = dataView.getUint8(5);
            EXRHeader2.spec = {
                singleTile: !!(spec & 2),
                longName: !!(spec & 4),
                deepFormat: !!(spec & 8),
                multiPart: !!(spec & 16)
            };
            offset2.value = 8;
            var keepReading = true;
            while(keepReading){
                var attributeName = parseNullTerminatedString(buffer2, offset2);
                if (attributeName == 0) {
                    keepReading = false;
                } else {
                    var attributeType = parseNullTerminatedString(buffer2, offset2);
                    var attributeSize = parseUint32(dataView, offset2);
                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);
                    if (attributeValue === void 0) {
                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);
                    } else {
                        EXRHeader2[attributeName] = attributeValue;
                    }
                }
            }
            if ((spec & ~4) != 0) {
                console.error("EXRHeader:", EXRHeader2);
                throw "THREE.EXRLoader: provided file is currently unsupported.";
            }
            return EXRHeader2;
        }
        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {
            const EXRDecoder2 = {
                size: 0,
                viewer: dataView,
                array: uInt8Array2,
                offset: offset2,
                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,
                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,
                channels: EXRHeader2.channels.length,
                bytesPerLine: null,
                lines: null,
                inputSize: null,
                type: EXRHeader2.channels[0].pixelType,
                uncompress: null,
                getter: null,
                format: null,
                [hasColorSpace ? "colorSpace" : "encoding"]: null
            };
            switch(EXRHeader2.compression){
                case "NO_COMPRESSION":
                    EXRDecoder2.lines = 1;
                    EXRDecoder2.uncompress = uncompressRAW;
                    break;
                case "RLE_COMPRESSION":
                    EXRDecoder2.lines = 1;
                    EXRDecoder2.uncompress = uncompressRLE;
                    break;
                case "ZIPS_COMPRESSION":
                    EXRDecoder2.lines = 1;
                    EXRDecoder2.uncompress = uncompressZIP;
                    break;
                case "ZIP_COMPRESSION":
                    EXRDecoder2.lines = 16;
                    EXRDecoder2.uncompress = uncompressZIP;
                    break;
                case "PIZ_COMPRESSION":
                    EXRDecoder2.lines = 32;
                    EXRDecoder2.uncompress = uncompressPIZ;
                    break;
                case "PXR24_COMPRESSION":
                    EXRDecoder2.lines = 16;
                    EXRDecoder2.uncompress = uncompressPXR;
                    break;
                case "DWAA_COMPRESSION":
                    EXRDecoder2.lines = 32;
                    EXRDecoder2.uncompress = uncompressDWA;
                    break;
                case "DWAB_COMPRESSION":
                    EXRDecoder2.lines = 256;
                    EXRDecoder2.uncompress = uncompressDWA;
                    break;
                default:
                    throw "EXRLoader.parse: " + EXRHeader2.compression + " is unsupported";
            }
            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;
            if (EXRDecoder2.type == 1) {
                switch(outputType){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                        EXRDecoder2.getter = parseFloat16;
                        EXRDecoder2.inputSize = INT16_SIZE;
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                        EXRDecoder2.getter = parseUint16;
                        EXRDecoder2.inputSize = INT16_SIZE;
                        break;
                }
            } else if (EXRDecoder2.type == 2) {
                switch(outputType){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                        EXRDecoder2.getter = parseFloat32;
                        EXRDecoder2.inputSize = FLOAT32_SIZE;
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                        EXRDecoder2.getter = decodeFloat32;
                        EXRDecoder2.inputSize = FLOAT32_SIZE;
                }
            } else {
                throw "EXRLoader.parse: unsupported pixelType " + EXRDecoder2.type + " for " + EXRHeader2.compression + ".";
            }
            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;
            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);
            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;
            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;
            switch(outputType){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                    EXRDecoder2.byteArray = new Float32Array(size);
                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                    EXRDecoder2.byteArray = new Uint16Array(size);
                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);
                    break;
                default:
                    console.error("THREE.EXRLoader: unsupported type: ", outputType);
                    break;
            }
            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;
            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"];
            else EXRDecoder2.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedFormat"];
            if (hasColorSpace) EXRDecoder2.colorSpace = "srgb-linear";
            else EXRDecoder2.encoding = 3e3;
            return EXRDecoder2;
        }
        const bufferDataView = new DataView(buffer);
        const uInt8Array = new Uint8Array(buffer);
        const offset = {
            value: 0
        };
        const EXRHeader = parseHeader(bufferDataView, buffer, offset);
        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);
        const tmpOffset = {
            value: 0
        };
        const channelOffsets = {
            R: 0,
            G: 1,
            B: 2,
            A: 3,
            Y: 0
        };
        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){
            const line = parseUint32(bufferDataView, offset);
            EXRDecoder.size = parseUint32(bufferDataView, offset);
            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;
            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);
            offset.value += EXRDecoder.size;
            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){
                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
                if (true_y >= EXRDecoder.height) break;
                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){
                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];
                    for(let x = 0; x < EXRDecoder.width; x++){
                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;
                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;
                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);
                    }
                }
            }
        }
        return {
            header: EXRHeader,
            width: EXRDecoder.width,
            height: EXRDecoder.height,
            data: EXRDecoder.byteArray,
            format: EXRDecoder.format,
            [hasColorSpace ? "colorSpace" : "encoding"]: EXRDecoder[hasColorSpace ? "colorSpace" : "encoding"],
            type: this.type
        };
    }
    setDataType(value) {
        this.type = value;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        function onLoadCallback(texture, texData) {
            if (hasColorSpace) texture.colorSpace = texData.colorSpace;
            else texture.encoding = texData.encoding;
            texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
            texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
            texture.generateMipmaps = false;
            texture.flipY = false;
            if (onLoad) onLoad(texture, texData);
        }
        return super.load(url, onLoadCallback, onProgress, onError);
    }
}
;
 //# sourceMappingURL=EXRLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/3MFLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ThreeMFLoader": (()=>ThreeMFLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)");
;
;
;
class ThreeMFLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.availableExtensions = [];
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            try {
                onLoad(scope.parse(buffer));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(data) {
        const scope = this;
        const textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.manager);
        function loadDocument(data2) {
            let zip = null;
            let file = null;
            let relsName;
            let modelRelsName;
            const modelPartNames = [];
            const texturesPartNames = [];
            let modelRels;
            const modelParts = {};
            const printTicketParts = {};
            const texturesParts = {};
            const otherParts = {};
            try {
                zip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzipSync"])(new Uint8Array(data2));
            } catch (e) {
                if (e instanceof ReferenceError) {
                    console.error("THREE.3MFLoader: fflate missing and file is compressed.");
                    return null;
                }
            }
            for(file in zip){
                if (file.match(/\_rels\/.rels$/)) {
                    relsName = file;
                } else if (file.match(/3D\/_rels\/.*\.model\.rels$/)) {
                    modelRelsName = file;
                } else if (file.match(/^3D\/.*\.model$/)) {
                    modelPartNames.push(file);
                } else if (file.match(/^3D\/Metadata\/.*\.xml$/)) ;
                else if (file.match(/^3D\/Textures?\/.*/)) {
                    texturesPartNames.push(file);
                } else if (file.match(/^3D\/Other\/.*/)) ;
            }
            const relsView = zip[relsName];
            const relsFileText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(relsView);
            const rels = parseRelsXml(relsFileText);
            if (modelRelsName) {
                const relsView2 = zip[modelRelsName];
                const relsFileText2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(relsView2);
                modelRels = parseRelsXml(relsFileText2);
            }
            for(let i = 0; i < modelPartNames.length; i++){
                const modelPart = modelPartNames[i];
                const view = zip[modelPart];
                const fileText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(view);
                const xmlData = new DOMParser().parseFromString(fileText, "application/xml");
                if (xmlData.documentElement.nodeName.toLowerCase() !== "model") {
                    console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ", modelPart);
                }
                const modelNode = xmlData.querySelector("model");
                const extensions = {};
                for(let i2 = 0; i2 < modelNode.attributes.length; i2++){
                    const attr = modelNode.attributes[i2];
                    if (attr.name.match(/^xmlns:(.+)$/)) {
                        extensions[attr.value] = RegExp.$1;
                    }
                }
                const modelData = parseModelNode(modelNode);
                modelData["xml"] = modelNode;
                if (0 < Object.keys(extensions).length) {
                    modelData["extensions"] = extensions;
                }
                modelParts[modelPart] = modelData;
            }
            for(let i = 0; i < texturesPartNames.length; i++){
                const texturesPartName = texturesPartNames[i];
                texturesParts[texturesPartName] = zip[texturesPartName].buffer;
            }
            return {
                rels,
                modelRels,
                model: modelParts,
                printTicket: printTicketParts,
                texture: texturesParts,
                other: otherParts
            };
        }
        function parseRelsXml(relsFileText) {
            const relationships = [];
            const relsXmlData = new DOMParser().parseFromString(relsFileText, "application/xml");
            const relsNodes = relsXmlData.querySelectorAll("Relationship");
            for(let i = 0; i < relsNodes.length; i++){
                const relsNode = relsNodes[i];
                const relationship = {
                    target: relsNode.getAttribute("Target"),
                    //required
                    id: relsNode.getAttribute("Id"),
                    //required
                    type: relsNode.getAttribute("Type")
                };
                relationships.push(relationship);
            }
            return relationships;
        }
        function parseMetadataNodes(metadataNodes) {
            const metadataData = {};
            for(let i = 0; i < metadataNodes.length; i++){
                const metadataNode = metadataNodes[i];
                const name = metadataNode.getAttribute("name");
                const validNames = [
                    "Title",
                    "Designer",
                    "Description",
                    "Copyright",
                    "LicenseTerms",
                    "Rating",
                    "CreationDate",
                    "ModificationDate"
                ];
                if (0 <= validNames.indexOf(name)) {
                    metadataData[name] = metadataNode.textContent;
                }
            }
            return metadataData;
        }
        function parseBasematerialsNode(basematerialsNode) {
            const basematerialsData = {
                id: basematerialsNode.getAttribute("id"),
                // required
                basematerials: []
            };
            const basematerialNodes = basematerialsNode.querySelectorAll("base");
            for(let i = 0; i < basematerialNodes.length; i++){
                const basematerialNode = basematerialNodes[i];
                const basematerialData = parseBasematerialNode(basematerialNode);
                basematerialData.index = i;
                basematerialsData.basematerials.push(basematerialData);
            }
            return basematerialsData;
        }
        function parseTexture2DNode(texture2DNode) {
            const texture2dData = {
                id: texture2DNode.getAttribute("id"),
                // required
                path: texture2DNode.getAttribute("path"),
                // required
                contenttype: texture2DNode.getAttribute("contenttype"),
                // required
                tilestyleu: texture2DNode.getAttribute("tilestyleu"),
                tilestylev: texture2DNode.getAttribute("tilestylev"),
                filter: texture2DNode.getAttribute("filter")
            };
            return texture2dData;
        }
        function parseTextures2DGroupNode(texture2DGroupNode) {
            const texture2DGroupData = {
                id: texture2DGroupNode.getAttribute("id"),
                // required
                texid: texture2DGroupNode.getAttribute("texid"),
                // required
                displaypropertiesid: texture2DGroupNode.getAttribute("displaypropertiesid")
            };
            const tex2coordNodes = texture2DGroupNode.querySelectorAll("tex2coord");
            const uvs = [];
            for(let i = 0; i < tex2coordNodes.length; i++){
                const tex2coordNode = tex2coordNodes[i];
                const u = tex2coordNode.getAttribute("u");
                const v = tex2coordNode.getAttribute("v");
                uvs.push(parseFloat(u), parseFloat(v));
            }
            texture2DGroupData["uvs"] = new Float32Array(uvs);
            return texture2DGroupData;
        }
        function parseColorGroupNode(colorGroupNode) {
            const colorGroupData = {
                id: colorGroupNode.getAttribute("id"),
                // required
                displaypropertiesid: colorGroupNode.getAttribute("displaypropertiesid")
            };
            const colorNodes = colorGroupNode.querySelectorAll("color");
            const colors = [];
            const colorObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
            for(let i = 0; i < colorNodes.length; i++){
                const colorNode = colorNodes[i];
                const color = colorNode.getAttribute("color");
                colorObject.setStyle(color.substring(0, 7));
                colorObject.convertSRGBToLinear();
                colors.push(colorObject.r, colorObject.g, colorObject.b);
            }
            colorGroupData["colors"] = new Float32Array(colors);
            return colorGroupData;
        }
        function parseMetallicDisplaypropertiesNode(metallicDisplaypropetiesNode) {
            const metallicDisplaypropertiesData = {
                id: metallicDisplaypropetiesNode.getAttribute("id")
            };
            const metallicNodes = metallicDisplaypropetiesNode.querySelectorAll("pbmetallic");
            const metallicData = [];
            for(let i = 0; i < metallicNodes.length; i++){
                const metallicNode = metallicNodes[i];
                metallicData.push({
                    name: metallicNode.getAttribute("name"),
                    // required
                    metallicness: parseFloat(metallicNode.getAttribute("metallicness")),
                    // required
                    roughness: parseFloat(metallicNode.getAttribute("roughness"))
                });
            }
            metallicDisplaypropertiesData.data = metallicData;
            return metallicDisplaypropertiesData;
        }
        function parseBasematerialNode(basematerialNode) {
            const basematerialData = {};
            basematerialData["name"] = basematerialNode.getAttribute("name");
            basematerialData["displaycolor"] = basematerialNode.getAttribute("displaycolor");
            basematerialData["displaypropertiesid"] = basematerialNode.getAttribute("displaypropertiesid");
            return basematerialData;
        }
        function parseMeshNode(meshNode) {
            const meshData = {};
            const vertices = [];
            const vertexNodes = meshNode.querySelectorAll("vertices vertex");
            for(let i = 0; i < vertexNodes.length; i++){
                const vertexNode = vertexNodes[i];
                const x = vertexNode.getAttribute("x");
                const y = vertexNode.getAttribute("y");
                const z = vertexNode.getAttribute("z");
                vertices.push(parseFloat(x), parseFloat(y), parseFloat(z));
            }
            meshData["vertices"] = new Float32Array(vertices);
            const triangleProperties = [];
            const triangles = [];
            const triangleNodes = meshNode.querySelectorAll("triangles triangle");
            for(let i = 0; i < triangleNodes.length; i++){
                const triangleNode = triangleNodes[i];
                const v1 = triangleNode.getAttribute("v1");
                const v2 = triangleNode.getAttribute("v2");
                const v3 = triangleNode.getAttribute("v3");
                const p1 = triangleNode.getAttribute("p1");
                const p2 = triangleNode.getAttribute("p2");
                const p3 = triangleNode.getAttribute("p3");
                const pid = triangleNode.getAttribute("pid");
                const triangleProperty = {};
                triangleProperty["v1"] = parseInt(v1, 10);
                triangleProperty["v2"] = parseInt(v2, 10);
                triangleProperty["v3"] = parseInt(v3, 10);
                triangles.push(triangleProperty["v1"], triangleProperty["v2"], triangleProperty["v3"]);
                if (p1) {
                    triangleProperty["p1"] = parseInt(p1, 10);
                }
                if (p2) {
                    triangleProperty["p2"] = parseInt(p2, 10);
                }
                if (p3) {
                    triangleProperty["p3"] = parseInt(p3, 10);
                }
                if (pid) {
                    triangleProperty["pid"] = pid;
                }
                if (0 < Object.keys(triangleProperty).length) {
                    triangleProperties.push(triangleProperty);
                }
            }
            meshData["triangleProperties"] = triangleProperties;
            meshData["triangles"] = new Uint32Array(triangles);
            return meshData;
        }
        function parseComponentsNode(componentsNode) {
            const components = [];
            const componentNodes = componentsNode.querySelectorAll("component");
            for(let i = 0; i < componentNodes.length; i++){
                const componentNode = componentNodes[i];
                const componentData = parseComponentNode(componentNode);
                components.push(componentData);
            }
            return components;
        }
        function parseComponentNode(componentNode) {
            const componentData = {};
            componentData["objectId"] = componentNode.getAttribute("objectid");
            const transform = componentNode.getAttribute("transform");
            if (transform) {
                componentData["transform"] = parseTransform(transform);
            }
            return componentData;
        }
        function parseTransform(transform) {
            const t = [];
            transform.split(" ").forEach(function(s) {
                t.push(parseFloat(s));
            });
            const matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            matrix.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0, 0, 0, 1);
            return matrix;
        }
        function parseObjectNode(objectNode) {
            const objectData = {
                type: objectNode.getAttribute("type")
            };
            const id = objectNode.getAttribute("id");
            if (id) {
                objectData["id"] = id;
            }
            const pid = objectNode.getAttribute("pid");
            if (pid) {
                objectData["pid"] = pid;
            }
            const pindex = objectNode.getAttribute("pindex");
            if (pindex) {
                objectData["pindex"] = pindex;
            }
            const thumbnail = objectNode.getAttribute("thumbnail");
            if (thumbnail) {
                objectData["thumbnail"] = thumbnail;
            }
            const partnumber = objectNode.getAttribute("partnumber");
            if (partnumber) {
                objectData["partnumber"] = partnumber;
            }
            const name = objectNode.getAttribute("name");
            if (name) {
                objectData["name"] = name;
            }
            const meshNode = objectNode.querySelector("mesh");
            if (meshNode) {
                objectData["mesh"] = parseMeshNode(meshNode);
            }
            const componentsNode = objectNode.querySelector("components");
            if (componentsNode) {
                objectData["components"] = parseComponentsNode(componentsNode);
            }
            return objectData;
        }
        function parseResourcesNode(resourcesNode) {
            const resourcesData = {};
            resourcesData["basematerials"] = {};
            const basematerialsNodes = resourcesNode.querySelectorAll("basematerials");
            for(let i = 0; i < basematerialsNodes.length; i++){
                const basematerialsNode = basematerialsNodes[i];
                const basematerialsData = parseBasematerialsNode(basematerialsNode);
                resourcesData["basematerials"][basematerialsData["id"]] = basematerialsData;
            }
            resourcesData["texture2d"] = {};
            const textures2DNodes = resourcesNode.querySelectorAll("texture2d");
            for(let i = 0; i < textures2DNodes.length; i++){
                const textures2DNode = textures2DNodes[i];
                const texture2DData = parseTexture2DNode(textures2DNode);
                resourcesData["texture2d"][texture2DData["id"]] = texture2DData;
            }
            resourcesData["colorgroup"] = {};
            const colorGroupNodes = resourcesNode.querySelectorAll("colorgroup");
            for(let i = 0; i < colorGroupNodes.length; i++){
                const colorGroupNode = colorGroupNodes[i];
                const colorGroupData = parseColorGroupNode(colorGroupNode);
                resourcesData["colorgroup"][colorGroupData["id"]] = colorGroupData;
            }
            resourcesData["pbmetallicdisplayproperties"] = {};
            const pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll("pbmetallicdisplayproperties");
            for(let i = 0; i < pbmetallicdisplaypropertiesNodes.length; i++){
                const pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[i];
                const pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode(pbmetallicdisplaypropertiesNode);
                resourcesData["pbmetallicdisplayproperties"][pbmetallicdisplaypropertiesData["id"]] = pbmetallicdisplaypropertiesData;
            }
            resourcesData["texture2dgroup"] = {};
            const textures2DGroupNodes = resourcesNode.querySelectorAll("texture2dgroup");
            for(let i = 0; i < textures2DGroupNodes.length; i++){
                const textures2DGroupNode = textures2DGroupNodes[i];
                const textures2DGroupData = parseTextures2DGroupNode(textures2DGroupNode);
                resourcesData["texture2dgroup"][textures2DGroupData["id"]] = textures2DGroupData;
            }
            resourcesData["object"] = {};
            const objectNodes = resourcesNode.querySelectorAll("object");
            for(let i = 0; i < objectNodes.length; i++){
                const objectNode = objectNodes[i];
                const objectData = parseObjectNode(objectNode);
                resourcesData["object"][objectData["id"]] = objectData;
            }
            return resourcesData;
        }
        function parseBuildNode(buildNode) {
            const buildData = [];
            const itemNodes = buildNode.querySelectorAll("item");
            for(let i = 0; i < itemNodes.length; i++){
                const itemNode = itemNodes[i];
                const buildItem = {
                    objectId: itemNode.getAttribute("objectid")
                };
                const transform = itemNode.getAttribute("transform");
                if (transform) {
                    buildItem["transform"] = parseTransform(transform);
                }
                buildData.push(buildItem);
            }
            return buildData;
        }
        function parseModelNode(modelNode) {
            const modelData = {
                unit: modelNode.getAttribute("unit") || "millimeter"
            };
            const metadataNodes = modelNode.querySelectorAll("metadata");
            if (metadataNodes) {
                modelData["metadata"] = parseMetadataNodes(metadataNodes);
            }
            const resourcesNode = modelNode.querySelector("resources");
            if (resourcesNode) {
                modelData["resources"] = parseResourcesNode(resourcesNode);
            }
            const buildNode = modelNode.querySelector("build");
            if (buildNode) {
                modelData["build"] = parseBuildNode(buildNode);
            }
            return modelData;
        }
        function buildTexture(texture2dgroup, objects2, modelData, textureData) {
            const texid = texture2dgroup.texid;
            const texture2ds = modelData.resources.texture2d;
            const texture2d = texture2ds[texid];
            if (texture2d) {
                const data2 = textureData[texture2d.path];
                const type = texture2d.contenttype;
                const blob = new Blob([
                    data2
                ], {
                    type
                });
                const sourceURI = URL.createObjectURL(blob);
                const texture = textureLoader.load(sourceURI, function() {
                    URL.revokeObjectURL(sourceURI);
                });
                if ("colorSpace" in texture) texture.colorSpace = "srgb";
                else texture.encoding = 3001;
                switch(texture2d.tilestyleu){
                    case "wrap":
                        texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                        break;
                    case "mirror":
                        texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MirroredRepeatWrapping"];
                        break;
                    case "none":
                    case "clamp":
                        texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
                        break;
                    default:
                        texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                }
                switch(texture2d.tilestylev){
                    case "wrap":
                        texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                        break;
                    case "mirror":
                        texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MirroredRepeatWrapping"];
                        break;
                    case "none":
                    case "clamp":
                        texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
                        break;
                    default:
                        texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
                }
                switch(texture2d.filter){
                    case "auto":
                        texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"];
                        break;
                    case "linear":
                        texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                        break;
                    case "nearest":
                        texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
                        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
                        break;
                    default:
                        texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"];
                }
                return texture;
            } else {
                return null;
            }
        }
        function buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData) {
            const objectPindex = objectData.pindex;
            const materialMap = {};
            for(let i = 0, l = triangleProperties.length; i < l; i++){
                const triangleProperty = triangleProperties[i];
                const pindex = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectPindex;
                if (materialMap[pindex] === void 0) materialMap[pindex] = [];
                materialMap[pindex].push(triangleProperty);
            }
            const keys = Object.keys(materialMap);
            const meshes = [];
            for(let i = 0, l = keys.length; i < l; i++){
                const materialIndex = keys[i];
                const trianglePropertiesProps = materialMap[materialIndex];
                const basematerialData = basematerials.basematerials[materialIndex];
                const material = getBuild(basematerialData, objects2, modelData, textureData, objectData, buildBasematerial);
                const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
                const positionData = [];
                const vertices = meshData.vertices;
                for(let j = 0, jl = trianglePropertiesProps.length; j < jl; j++){
                    const triangleProperty = trianglePropertiesProps[j];
                    positionData.push(vertices[triangleProperty.v1 * 3 + 0]);
                    positionData.push(vertices[triangleProperty.v1 * 3 + 1]);
                    positionData.push(vertices[triangleProperty.v1 * 3 + 2]);
                    positionData.push(vertices[triangleProperty.v2 * 3 + 0]);
                    positionData.push(vertices[triangleProperty.v2 * 3 + 1]);
                    positionData.push(vertices[triangleProperty.v2 * 3 + 2]);
                    positionData.push(vertices[triangleProperty.v3 * 3 + 0]);
                    positionData.push(vertices[triangleProperty.v3 * 3 + 1]);
                    positionData.push(vertices[triangleProperty.v3 * 3 + 2]);
                }
                geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positionData, 3));
                const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
                meshes.push(mesh);
            }
            return meshes;
        }
        function buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData) {
            const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            const positionData = [];
            const uvData = [];
            const vertices = meshData.vertices;
            const uvs = texture2dgroup.uvs;
            for(let i = 0, l = triangleProperties.length; i < l; i++){
                const triangleProperty = triangleProperties[i];
                positionData.push(vertices[triangleProperty.v1 * 3 + 0]);
                positionData.push(vertices[triangleProperty.v1 * 3 + 1]);
                positionData.push(vertices[triangleProperty.v1 * 3 + 2]);
                positionData.push(vertices[triangleProperty.v2 * 3 + 0]);
                positionData.push(vertices[triangleProperty.v2 * 3 + 1]);
                positionData.push(vertices[triangleProperty.v2 * 3 + 2]);
                positionData.push(vertices[triangleProperty.v3 * 3 + 0]);
                positionData.push(vertices[triangleProperty.v3 * 3 + 1]);
                positionData.push(vertices[triangleProperty.v3 * 3 + 2]);
                uvData.push(uvs[triangleProperty.p1 * 2 + 0]);
                uvData.push(uvs[triangleProperty.p1 * 2 + 1]);
                uvData.push(uvs[triangleProperty.p2 * 2 + 0]);
                uvData.push(uvs[triangleProperty.p2 * 2 + 1]);
                uvData.push(uvs[triangleProperty.p3 * 2 + 0]);
                uvData.push(uvs[triangleProperty.p3 * 2 + 1]);
            }
            geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positionData, 3));
            geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uvData, 2));
            const texture = getBuild(texture2dgroup, objects2, modelData, textureData, objectData, buildTexture);
            const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]({
                map: texture,
                flatShading: true
            });
            const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
            return mesh;
        }
        function buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData) {
            const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            const positionData = [];
            const colorData = [];
            const vertices = meshData.vertices;
            const colors = colorgroup.colors;
            for(let i = 0, l = triangleProperties.length; i < l; i++){
                const triangleProperty = triangleProperties[i];
                const v1 = triangleProperty.v1;
                const v2 = triangleProperty.v2;
                const v3 = triangleProperty.v3;
                positionData.push(vertices[v1 * 3 + 0]);
                positionData.push(vertices[v1 * 3 + 1]);
                positionData.push(vertices[v1 * 3 + 2]);
                positionData.push(vertices[v2 * 3 + 0]);
                positionData.push(vertices[v2 * 3 + 1]);
                positionData.push(vertices[v2 * 3 + 2]);
                positionData.push(vertices[v3 * 3 + 0]);
                positionData.push(vertices[v3 * 3 + 1]);
                positionData.push(vertices[v3 * 3 + 2]);
                const p1 = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectData.pindex;
                const p2 = triangleProperty.p2 !== void 0 ? triangleProperty.p2 : p1;
                const p3 = triangleProperty.p3 !== void 0 ? triangleProperty.p3 : p1;
                colorData.push(colors[p1 * 3 + 0]);
                colorData.push(colors[p1 * 3 + 1]);
                colorData.push(colors[p1 * 3 + 2]);
                colorData.push(colors[p2 * 3 + 0]);
                colorData.push(colors[p2 * 3 + 1]);
                colorData.push(colors[p2 * 3 + 2]);
                colorData.push(colors[p3 * 3 + 0]);
                colorData.push(colors[p3 * 3 + 1]);
                colorData.push(colors[p3 * 3 + 2]);
            }
            geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positionData, 3));
            geometry.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](colorData, 3));
            const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]({
                vertexColors: true,
                flatShading: true
            });
            const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
            return mesh;
        }
        function buildDefaultMesh(meshData) {
            const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            geometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](meshData["triangles"], 1));
            geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](meshData["vertices"], 3));
            const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]({
                color: 11184895,
                flatShading: true
            });
            const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
            return mesh;
        }
        function buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData) {
            const keys = Object.keys(resourceMap);
            const meshes = [];
            for(let i = 0, il = keys.length; i < il; i++){
                const resourceId = keys[i];
                const triangleProperties = resourceMap[resourceId];
                const resourceType = getResourceType(resourceId, modelData);
                switch(resourceType){
                    case "material":
                        const basematerials = modelData.resources.basematerials[resourceId];
                        const newMeshes = buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData);
                        for(let j = 0, jl = newMeshes.length; j < jl; j++){
                            meshes.push(newMeshes[j]);
                        }
                        break;
                    case "texture":
                        const texture2dgroup = modelData.resources.texture2dgroup[resourceId];
                        meshes.push(buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData));
                        break;
                    case "vertexColors":
                        const colorgroup = modelData.resources.colorgroup[resourceId];
                        meshes.push(buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData));
                        break;
                    case "default":
                        meshes.push(buildDefaultMesh(meshData));
                        break;
                    default:
                        console.error("THREE.3MFLoader: Unsupported resource type.");
                }
            }
            return meshes;
        }
        function getResourceType(pid, modelData) {
            if (modelData.resources.texture2dgroup[pid] !== void 0) {
                return "texture";
            } else if (modelData.resources.basematerials[pid] !== void 0) {
                return "material";
            } else if (modelData.resources.colorgroup[pid] !== void 0) {
                return "vertexColors";
            } else if (pid === "default") {
                return "default";
            } else {
                return void 0;
            }
        }
        function analyzeObject(modelData, meshData, objectData) {
            const resourceMap = {};
            const triangleProperties = meshData["triangleProperties"];
            const objectPid = objectData.pid;
            for(let i = 0, l = triangleProperties.length; i < l; i++){
                const triangleProperty = triangleProperties[i];
                let pid = triangleProperty.pid !== void 0 ? triangleProperty.pid : objectPid;
                if (pid === void 0) pid = "default";
                if (resourceMap[pid] === void 0) resourceMap[pid] = [];
                resourceMap[pid].push(triangleProperty);
            }
            return resourceMap;
        }
        function buildGroup(meshData, objects2, modelData, textureData, objectData) {
            const group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            const resourceMap = analyzeObject(modelData, meshData, objectData);
            const meshes = buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData);
            for(let i = 0, l = meshes.length; i < l; i++){
                group.add(meshes[i]);
            }
            return group;
        }
        function applyExtensions(extensions, meshData, modelXml) {
            if (!extensions) {
                return;
            }
            const availableExtensions = [];
            const keys = Object.keys(extensions);
            for(let i = 0; i < keys.length; i++){
                const ns = keys[i];
                for(let j = 0; j < scope.availableExtensions.length; j++){
                    const extension = scope.availableExtensions[j];
                    if (extension.ns === ns) {
                        availableExtensions.push(extension);
                    }
                }
            }
            for(let i = 0; i < availableExtensions.length; i++){
                const extension = availableExtensions[i];
                extension.apply(modelXml, extensions[extension["ns"]], meshData);
            }
        }
        function getBuild(data2, objects2, modelData, textureData, objectData, builder) {
            if (data2.build !== void 0) return data2.build;
            data2.build = builder(data2, objects2, modelData, textureData, objectData);
            return data2.build;
        }
        function buildBasematerial(materialData, objects2, modelData) {
            let material;
            const displaypropertiesid = materialData.displaypropertiesid;
            const pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties;
            if (displaypropertiesid !== null && pbmetallicdisplayproperties[displaypropertiesid] !== void 0) {
                const pbmetallicdisplayproperty = pbmetallicdisplayproperties[displaypropertiesid];
                const metallicData = pbmetallicdisplayproperty.data[materialData.index];
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                    flatShading: true,
                    roughness: metallicData.roughness,
                    metalness: metallicData.metallicness
                });
            } else {
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]({
                    flatShading: true
                });
            }
            material.name = materialData.name;
            const displaycolor = materialData.displaycolor;
            const color = displaycolor.substring(0, 7);
            material.color.setStyle(color);
            material.color.convertSRGBToLinear();
            if (displaycolor.length === 9) {
                material.opacity = parseInt(displaycolor.charAt(7) + displaycolor.charAt(8), 16) / 255;
            }
            return material;
        }
        function buildComposite(compositeData, objects2, modelData, textureData) {
            const composite = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            for(let j = 0; j < compositeData.length; j++){
                const component = compositeData[j];
                let build2 = objects2[component.objectId];
                if (build2 === void 0) {
                    buildObject(component.objectId, objects2, modelData, textureData);
                    build2 = objects2[component.objectId];
                }
                const object3D = build2.clone();
                const transform = component.transform;
                if (transform) {
                    object3D.applyMatrix4(transform);
                }
                composite.add(object3D);
            }
            return composite;
        }
        function buildObject(objectId, objects2, modelData, textureData) {
            const objectData = modelData["resources"]["object"][objectId];
            if (objectData["mesh"]) {
                const meshData = objectData["mesh"];
                const extensions = modelData["extensions"];
                const modelXml = modelData["xml"];
                applyExtensions(extensions, meshData, modelXml);
                objects2[objectData.id] = getBuild(meshData, objects2, modelData, textureData, objectData, buildGroup);
            } else {
                const compositeData = objectData["components"];
                objects2[objectData.id] = getBuild(compositeData, objects2, modelData, textureData, objectData, buildComposite);
            }
        }
        function buildObjects(data3mf2) {
            const modelsData = data3mf2.model;
            const modelRels = data3mf2.modelRels;
            const objects2 = {};
            const modelsKeys = Object.keys(modelsData);
            const textureData = {};
            if (modelRels) {
                for(let i = 0, l = modelRels.length; i < l; i++){
                    const modelRel = modelRels[i];
                    const textureKey = modelRel.target.substring(1);
                    if (data3mf2.texture[textureKey]) {
                        textureData[modelRel.target] = data3mf2.texture[textureKey];
                    }
                }
            }
            for(let i = 0; i < modelsKeys.length; i++){
                const modelsKey = modelsKeys[i];
                const modelData = modelsData[modelsKey];
                const objectIds = Object.keys(modelData["resources"]["object"]);
                for(let j = 0; j < objectIds.length; j++){
                    const objectId = objectIds[j];
                    buildObject(objectId, objects2, modelData, textureData);
                }
            }
            return objects2;
        }
        function fetch3DModelPart(rels) {
            for(let i = 0; i < rels.length; i++){
                const rel = rels[i];
                const extension = rel.target.split(".").pop();
                if (extension.toLowerCase() === "model") return rel;
            }
        }
        function build(objects2, data3mf2) {
            const group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            const relationship = fetch3DModelPart(data3mf2["rels"]);
            const buildData = data3mf2.model[relationship["target"].substring(1)]["build"];
            for(let i = 0; i < buildData.length; i++){
                const buildItem = buildData[i];
                const object3D = objects2[buildItem["objectId"]];
                const transform = buildItem["transform"];
                if (transform) {
                    object3D.applyMatrix4(transform);
                }
                group.add(object3D);
            }
            return group;
        }
        const data3mf = loadDocument(data);
        const objects = buildObjects(data3mf);
        return build(objects, data3mf);
    }
    addExtension(extension) {
        this.availableExtensions.push(extension);
    }
}
;
 //# sourceMappingURL=3MFLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/LUT3dlLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LUT3dlLoader": (()=>LUT3dlLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$Data3DTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/Data3DTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class LUT3dlLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    load(url, onLoad, onProgress, onError) {
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setResponseType("text");
        loader.load(url, (text)=>{
            try {
                onLoad(this.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                this.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(str) {
        str = str.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
        const lines = str.split(/[\n\r]+/g);
        const gridLines = lines[0].trim().split(/\s+/g).map((e)=>parseFloat(e));
        const gridStep = gridLines[1] - gridLines[0];
        const size = gridLines.length;
        for(let i = 1, l = gridLines.length; i < l; i++){
            if (gridStep !== gridLines[i] - gridLines[i - 1]) {
                throw new Error("LUT3dlLoader: Inconsistent grid size not supported.");
            }
        }
        const dataArray = new Array(size * size * size * 4);
        let index = 0;
        let maxOutputValue = 0;
        for(let i = 1, l = lines.length; i < l; i++){
            const line = lines[i].trim();
            const split = line.split(/\s/g);
            const r = parseFloat(split[0]);
            const g = parseFloat(split[1]);
            const b = parseFloat(split[2]);
            maxOutputValue = Math.max(maxOutputValue, r, g, b);
            const bLayer = index % size;
            const gLayer = Math.floor(index / size) % size;
            const rLayer = Math.floor(index / (size * size)) % size;
            const pixelIndex = bLayer * size * size + gLayer * size + rLayer;
            dataArray[4 * pixelIndex + 0] = r;
            dataArray[4 * pixelIndex + 1] = g;
            dataArray[4 * pixelIndex + 2] = b;
            dataArray[4 * pixelIndex + 3] = 1;
            index += 1;
        }
        const bits = Math.ceil(Math.log2(maxOutputValue));
        const maxBitValue = Math.pow(2, bits);
        for(let i = 0, l = dataArray.length; i < l; i += 4){
            const r = dataArray[i + 0];
            const g = dataArray[i + 1];
            const b = dataArray[i + 2];
            dataArray[i + 0] = 255 * r / maxBitValue;
            dataArray[i + 1] = 255 * g / maxBitValue;
            dataArray[i + 2] = 255 * b / maxBitValue;
        }
        const data = new Uint8Array(dataArray);
        const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"]();
        texture.image.data = data;
        texture.image.width = size;
        texture.image.height = size * size;
        texture.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"];
        texture.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"];
        texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture.generateMipmaps = false;
        texture.needsUpdate = true;
        const texture3D = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$Data3DTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Data3DTexture"]();
        texture3D.image.data = data;
        texture3D.image.width = size;
        texture3D.image.height = size;
        texture3D.image.depth = size;
        texture3D.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"];
        texture3D.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"];
        texture3D.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture3D.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture3D.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture3D.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture3D.wrapR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        texture3D.generateMipmaps = false;
        texture3D.needsUpdate = true;
        return {
            size,
            texture,
            texture3D
        };
    }
}
;
 //# sourceMappingURL=LUT3dlLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/DDSLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DDSLoader": (()=>DDSLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class DDSLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTextureLoader"] {
    constructor(manager){
        super(manager);
    }
    parse(buffer, loadMipmaps) {
        const dds = {
            mipmaps: [],
            width: 0,
            height: 0,
            format: null,
            mipmapCount: 1
        };
        const DDS_MAGIC = 542327876;
        const DDSD_MIPMAPCOUNT = 131072;
        const DDSCAPS2_CUBEMAP = 512;
        const DDSCAPS2_CUBEMAP_POSITIVEX = 1024;
        const DDSCAPS2_CUBEMAP_NEGATIVEX = 2048;
        const DDSCAPS2_CUBEMAP_POSITIVEY = 4096;
        const DDSCAPS2_CUBEMAP_NEGATIVEY = 8192;
        const DDSCAPS2_CUBEMAP_POSITIVEZ = 16384;
        const DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768;
        const DDPF_FOURCC = 4;
        function fourCCToInt32(value) {
            return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
        }
        function int32ToFourCC(value) {
            return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
        }
        function loadARGBMip(buffer2, dataOffset2, width, height) {
            const dataLength = width * height * 4;
            const srcBuffer = new Uint8Array(buffer2, dataOffset2, dataLength);
            const byteArray = new Uint8Array(dataLength);
            let dst = 0;
            let src = 0;
            for(let y = 0; y < height; y++){
                for(let x = 0; x < width; x++){
                    const b = srcBuffer[src];
                    src++;
                    const g = srcBuffer[src];
                    src++;
                    const r = srcBuffer[src];
                    src++;
                    const a = srcBuffer[src];
                    src++;
                    byteArray[dst] = r;
                    dst++;
                    byteArray[dst] = g;
                    dst++;
                    byteArray[dst] = b;
                    dst++;
                    byteArray[dst] = a;
                    dst++;
                }
            }
            return byteArray;
        }
        const FOURCC_DXT1 = fourCCToInt32("DXT1");
        const FOURCC_DXT3 = fourCCToInt32("DXT3");
        const FOURCC_DXT5 = fourCCToInt32("DXT5");
        const FOURCC_ETC1 = fourCCToInt32("ETC1");
        const headerLengthInt = 31;
        const off_magic = 0;
        const off_size = 1;
        const off_flags = 2;
        const off_height = 3;
        const off_width = 4;
        const off_mipmapCount = 7;
        const off_pfFlags = 20;
        const off_pfFourCC = 21;
        const off_RGBBitCount = 22;
        const off_RBitMask = 23;
        const off_GBitMask = 24;
        const off_BBitMask = 25;
        const off_ABitMask = 26;
        const off_caps2 = 28;
        const header = new Int32Array(buffer, 0, headerLengthInt);
        if (header[off_magic] !== DDS_MAGIC) {
            console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header.");
            return dds;
        }
        if (!header[off_pfFlags] & DDPF_FOURCC) {
            console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.");
            return dds;
        }
        let blockBytes;
        const fourCC = header[off_pfFourCC];
        let isRGBAUncompressed = false;
        switch(fourCC){
            case FOURCC_DXT1:
                blockBytes = 8;
                dds.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_S3TC_DXT1_Format"];
                break;
            case FOURCC_DXT3:
                blockBytes = 16;
                dds.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_S3TC_DXT3_Format"];
                break;
            case FOURCC_DXT5:
                blockBytes = 16;
                dds.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_S3TC_DXT5_Format"];
                break;
            case FOURCC_ETC1:
                blockBytes = 8;
                dds.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_ETC1_Format"];
                break;
            default:
                if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 16711680 && header[off_GBitMask] & 65280 && header[off_BBitMask] & 255 && header[off_ABitMask] & 4278190080) {
                    isRGBAUncompressed = true;
                    blockBytes = 64;
                    dds.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"];
                } else {
                    console.error("THREE.DDSLoader.parse: Unsupported FourCC code ", int32ToFourCC(fourCC));
                    return dds;
                }
        }
        dds.mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        const caps2 = header[off_caps2];
        dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
        if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {
            console.error("THREE.DDSLoader.parse: Incomplete cubemap faces");
            return dds;
        }
        dds.width = header[off_width];
        dds.height = header[off_height];
        let dataOffset = header[off_size] + 4;
        const faces = dds.isCubemap ? 6 : 1;
        for(let face = 0; face < faces; face++){
            let width = dds.width;
            let height = dds.height;
            for(let i = 0; i < dds.mipmapCount; i++){
                let byteArray, dataLength;
                if (isRGBAUncompressed) {
                    byteArray = loadARGBMip(buffer, dataOffset, width, height);
                    dataLength = byteArray.length;
                } else {
                    dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                    byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                }
                const mipmap = {
                    data: byteArray,
                    width,
                    height
                };
                dds.mipmaps.push(mipmap);
                dataOffset += dataLength;
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
            }
        }
        return dds;
    }
}
;
 //# sourceMappingURL=DDSLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/PVRLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PVRLoader": (()=>PVRLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class PVRLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTextureLoader"] {
    constructor(manager){
        super(manager);
    }
    parse(buffer, loadMipmaps) {
        const headerLengthInt = 13;
        const header = new Uint32Array(buffer, 0, headerLengthInt);
        const pvrDatas = {
            buffer,
            header,
            loadMipmaps
        };
        if (header[0] === 55727696) {
            return _parseV3(pvrDatas);
        } else if (header[11] === 559044176) {
            return _parseV2(pvrDatas);
        } else {
            console.error("THREE.PVRLoader: Unknown PVR format.");
        }
    }
}
function _parseV3(pvrDatas) {
    const header = pvrDatas.header;
    let bpp, format;
    const metaLen = header[12], pixelFormat = header[2], height = header[6], width = header[7], numFaces = header[10], numMipmaps = header[11];
    switch(pixelFormat){
        case 0:
            bpp = 2;
            format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_PVRTC_2BPPV1_Format"];
            break;
        case 1:
            bpp = 2;
            format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_PVRTC_2BPPV1_Format"];
            break;
        case 2:
            bpp = 4;
            format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_PVRTC_4BPPV1_Format"];
            break;
        case 3:
            bpp = 4;
            format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_PVRTC_4BPPV1_Format"];
            break;
        default:
            console.error("THREE.PVRLoader: Unsupported PVR format:", pixelFormat);
    }
    pvrDatas.dataPtr = 52 + metaLen;
    pvrDatas.bpp = bpp;
    pvrDatas.format = format;
    pvrDatas.width = width;
    pvrDatas.height = height;
    pvrDatas.numSurfaces = numFaces;
    pvrDatas.numMipmaps = numMipmaps;
    pvrDatas.isCubemap = numFaces === 6;
    return _extract(pvrDatas);
}
function _parseV2(pvrDatas) {
    const header = pvrDatas.header;
    const headerLength = header[0], height = header[1], width = header[2], numMipmaps = header[3], flags = header[4], bitmaskAlpha = header[10], numSurfs = header[12];
    const TYPE_MASK = 255;
    const PVRTC_2 = 24, PVRTC_4 = 25;
    const formatFlags = flags & TYPE_MASK;
    let bpp, format;
    const _hasAlpha = bitmaskAlpha > 0;
    if (formatFlags === PVRTC_4) {
        format = _hasAlpha ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_PVRTC_4BPPV1_Format"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_PVRTC_4BPPV1_Format"];
        bpp = 4;
    } else if (formatFlags === PVRTC_2) {
        format = _hasAlpha ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_PVRTC_2BPPV1_Format"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_PVRTC_2BPPV1_Format"];
        bpp = 2;
    } else {
        console.error("THREE.PVRLoader: Unknown PVR format:", formatFlags);
    }
    pvrDatas.dataPtr = headerLength;
    pvrDatas.bpp = bpp;
    pvrDatas.format = format;
    pvrDatas.width = width;
    pvrDatas.height = height;
    pvrDatas.numSurfaces = numSurfs;
    pvrDatas.numMipmaps = numMipmaps + 1;
    pvrDatas.isCubemap = numSurfs === 6;
    return _extract(pvrDatas);
}
function _extract(pvrDatas) {
    const pvr = {
        mipmaps: [],
        width: pvrDatas.width,
        height: pvrDatas.height,
        format: pvrDatas.format,
        mipmapCount: pvrDatas.numMipmaps,
        isCubemap: pvrDatas.isCubemap
    };
    const buffer = pvrDatas.buffer;
    let dataOffset = pvrDatas.dataPtr, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0;
    const bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces;
    if (bpp === 2) {
        blockWidth = 8;
        blockHeight = 4;
    } else {
        blockWidth = 4;
        blockHeight = 4;
    }
    blockSize = blockWidth * blockHeight * bpp / 8;
    pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;
    let mipLevel = 0;
    while(mipLevel < pvrDatas.numMipmaps){
        const sWidth = pvrDatas.width >> mipLevel, sHeight = pvrDatas.height >> mipLevel;
        widthBlocks = sWidth / blockWidth;
        heightBlocks = sHeight / blockHeight;
        if (widthBlocks < 2) widthBlocks = 2;
        if (heightBlocks < 2) heightBlocks = 2;
        dataSize = widthBlocks * heightBlocks * blockSize;
        for(let surfIndex = 0; surfIndex < numSurfs; surfIndex++){
            const byteArray = new Uint8Array(buffer, dataOffset, dataSize);
            const mipmap = {
                data: byteArray,
                width: sWidth,
                height: sHeight
            };
            pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;
            dataOffset += dataSize;
        }
        mipLevel++;
    }
    return pvr;
}
;
 //# sourceMappingURL=PVRLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/GCodeLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GCodeLoader": (()=>GCodeLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class GCodeLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.splitLayer = false;
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(data) {
        let state = {
            x: 0,
            y: 0,
            z: 0,
            e: 0,
            f: 0,
            extruding: false,
            relative: false
        };
        let layers = [];
        let currentLayer = void 0;
        const pathMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
            color: 16711680
        });
        pathMaterial.name = "path";
        const extrudingMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
            color: 65280
        });
        extrudingMaterial.name = "extruded";
        function newLayer(line) {
            currentLayer = {
                vertex: [],
                pathVertex: [],
                z: line.z
            };
            layers.push(currentLayer);
        }
        function addSegment(p1, p2) {
            if (currentLayer === void 0) {
                newLayer(p1);
            }
            if (state.extruding) {
                currentLayer.vertex.push(p1.x, p1.y, p1.z);
                currentLayer.vertex.push(p2.x, p2.y, p2.z);
            } else {
                currentLayer.pathVertex.push(p1.x, p1.y, p1.z);
                currentLayer.pathVertex.push(p2.x, p2.y, p2.z);
            }
        }
        function delta(v1, v2) {
            return state.relative ? v2 : v2 - v1;
        }
        function absolute(v1, v2) {
            return state.relative ? v1 + v2 : v2;
        }
        let lines = data.replace(/;.+/g, "").split("\n");
        for(let i = 0; i < lines.length; i++){
            let tokens = lines[i].split(" ");
            let cmd = tokens[0].toUpperCase();
            let args = {};
            tokens.splice(1).forEach(function(token) {
                if (token[0] !== void 0) {
                    let key = token[0].toLowerCase();
                    let value = parseFloat(token.substring(1));
                    args[key] = value;
                }
            });
            if (cmd === "G0" || cmd === "G1") {
                let line = {
                    x: args.x !== void 0 ? absolute(state.x, args.x) : state.x,
                    y: args.y !== void 0 ? absolute(state.y, args.y) : state.y,
                    z: args.z !== void 0 ? absolute(state.z, args.z) : state.z,
                    e: args.e !== void 0 ? absolute(state.e, args.e) : state.e,
                    f: args.f !== void 0 ? absolute(state.f, args.f) : state.f
                };
                if (delta(state.e, line.e) > 0) {
                    line.extruding = delta(state.e, line.e) > 0;
                    if (currentLayer == void 0 || line.z != currentLayer.z) {
                        newLayer(line);
                    }
                }
                addSegment(state, line);
                state = line;
            } else if (cmd === "G2" || cmd === "G3") ;
            else if (cmd === "G90") {
                state.relative = false;
            } else if (cmd === "G91") {
                state.relative = true;
            } else if (cmd === "G92") {
                let line = state;
                line.x = args.x !== void 0 ? args.x : line.x;
                line.y = args.y !== void 0 ? args.y : line.y;
                line.z = args.z !== void 0 ? args.z : line.z;
                line.e = args.e !== void 0 ? args.e : line.e;
                state = line;
            } else ;
        }
        function addObject(vertex, extruding, i) {
            let geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](vertex, 3));
            let segments = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](geometry, extruding ? extrudingMaterial : pathMaterial);
            segments.name = "layer" + i;
            object.add(segments);
        }
        const object = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        object.name = "gcode";
        if (this.splitLayer) {
            for(let i = 0; i < layers.length; i++){
                let layer = layers[i];
                addObject(layer.vertex, true, i);
                addObject(layer.pathVertex, false, i);
            }
        } else {
            const vertex = [], pathVertex = [];
            for(let i = 0; i < layers.length; i++){
                let layer = layers[i];
                let layerVertex = layer.vertex;
                let layerPathVertex = layer.pathVertex;
                for(let j = 0; j < layerVertex.length; j++){
                    vertex.push(layerVertex[j]);
                }
                for(let j = 0; j < layerPathVertex.length; j++){
                    pathVertex.push(layerPathVertex[j]);
                }
            }
            addObject(vertex, true, layers.length);
            addObject(pathVertex, false, layers.length);
        }
        object.quaternion.setFromEuler(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"](-Math.PI / 2, 0, 0));
        return object;
    }
}
;
 //# sourceMappingURL=GCodeLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/BasisTextureLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BasisTextureLoader": (()=>BasisTextureLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
const _taskCache = /* @__PURE__ */ new WeakMap();
const BasisTextureLoader = /* @__PURE__ */ (()=>{
    const _BasisTextureLoader = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
        constructor(manager){
            super(manager);
            this.transcoderPath = "";
            this.transcoderBinary = null;
            this.transcoderPending = null;
            this.workerLimit = 4;
            this.workerPool = [];
            this.workerNextTaskID = 1;
            this.workerSourceURL = "";
            this.workerConfig = null;
        }
        setTranscoderPath(path) {
            this.transcoderPath = path;
            return this;
        }
        setWorkerLimit(workerLimit) {
            this.workerLimit = workerLimit;
            return this;
        }
        detectSupport(renderer) {
            this.workerConfig = {
                astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
                etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
                etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
                dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
                bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
                pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
            };
            return this;
        }
        load(url, onLoad, onProgress, onError) {
            const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
            loader.setResponseType("arraybuffer");
            loader.setWithCredentials(this.withCredentials);
            const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTexture"]();
            loader.load(url, (buffer)=>{
                if (_taskCache.has(buffer)) {
                    const cachedTask = _taskCache.get(buffer);
                    return cachedTask.promise.then(onLoad).catch(onError);
                }
                this._createTexture([
                    buffer
                ]).then(function(_texture) {
                    texture.copy(_texture);
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }).catch(onError);
            }, onProgress, onError);
            return texture;
        }
        /** Low-level transcoding API, exposed for use by KTX2Loader. */ parseInternalAsync(options) {
            const { levels } = options;
            const buffers = /* @__PURE__ */ new Set();
            for(let i = 0; i < levels.length; i++){
                buffers.add(levels[i].data.buffer);
            }
            return this._createTexture(Array.from(buffers), {
                ...options,
                lowLevel: true
            });
        }
        /**
     * @param {ArrayBuffer[]} buffers
     * @param {object?} config
     * @return {Promise<CompressedTexture>}
     */ _createTexture(buffers, config = {}) {
            let worker;
            let taskID;
            const taskConfig = config;
            let taskCost = 0;
            for(let i = 0; i < buffers.length; i++){
                taskCost += buffers[i].byteLength;
            }
            const texturePending = this._allocateWorker(taskCost).then((_worker)=>{
                worker = _worker;
                taskID = this.workerNextTaskID++;
                return new Promise((resolve, reject)=>{
                    worker._callbacks[taskID] = {
                        resolve,
                        reject
                    };
                    worker.postMessage({
                        type: "transcode",
                        id: taskID,
                        buffers,
                        taskConfig
                    }, buffers);
                });
            }).then((message)=>{
                const { mipmaps, width, height, format } = message;
                const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTexture"](mipmaps, width, height, format, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"]);
                texture.minFilter = mipmaps.length === 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"];
                texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                texture.generateMipmaps = false;
                texture.needsUpdate = true;
                return texture;
            });
            texturePending.catch(()=>true).then(()=>{
                if (worker && taskID) {
                    worker._taskLoad -= taskCost;
                    delete worker._callbacks[taskID];
                }
            });
            _taskCache.set(buffers[0], {
                promise: texturePending
            });
            return texturePending;
        }
        _initTranscoder() {
            if (!this.transcoderPending) {
                const jsLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
                jsLoader.setPath(this.transcoderPath);
                jsLoader.setWithCredentials(this.withCredentials);
                const jsContent = new Promise((resolve, reject)=>{
                    jsLoader.load("basis_transcoder.js", resolve, void 0, reject);
                });
                const binaryLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
                binaryLoader.setPath(this.transcoderPath);
                binaryLoader.setResponseType("arraybuffer");
                binaryLoader.setWithCredentials(this.withCredentials);
                const binaryContent = new Promise((resolve, reject)=>{
                    binaryLoader.load("basis_transcoder.wasm", resolve, void 0, reject);
                });
                this.transcoderPending = Promise.all([
                    jsContent,
                    binaryContent
                ]).then(([jsContent2, binaryContent2])=>{
                    const fn = _BasisTextureLoader.BasisWorker.toString();
                    const body = [
                        "/* constants */",
                        "let _EngineFormat = " + JSON.stringify(_BasisTextureLoader.EngineFormat),
                        "let _TranscoderFormat = " + JSON.stringify(_BasisTextureLoader.TranscoderFormat),
                        "let _BasisFormat = " + JSON.stringify(_BasisTextureLoader.BasisFormat),
                        "/* basis_transcoder.js */",
                        jsContent2,
                        "/* worker */",
                        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
                    ].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([
                        body
                    ]));
                    this.transcoderBinary = binaryContent2;
                });
            }
            return this.transcoderPending;
        }
        _allocateWorker(taskCost) {
            return this._initTranscoder().then(()=>{
                if (this.workerPool.length < this.workerLimit) {
                    const worker2 = new Worker(this.workerSourceURL);
                    worker2._callbacks = {};
                    worker2._taskLoad = 0;
                    worker2.postMessage({
                        type: "init",
                        config: this.workerConfig,
                        transcoderBinary: this.transcoderBinary
                    });
                    worker2.onmessage = function(e) {
                        const message = e.data;
                        switch(message.type){
                            case "transcode":
                                worker2._callbacks[message.id].resolve(message);
                                break;
                            case "error":
                                worker2._callbacks[message.id].reject(message);
                                break;
                            default:
                                console.error('THREE.BasisTextureLoader: Unexpected message, "' + message.type + '"');
                        }
                    };
                    this.workerPool.push(worker2);
                } else {
                    this.workerPool.sort(function(a, b) {
                        return a._taskLoad > b._taskLoad ? -1 : 1;
                    });
                }
                const worker = this.workerPool[this.workerPool.length - 1];
                worker._taskLoad += taskCost;
                return worker;
            });
        }
        dispose() {
            for(let i = 0; i < this.workerPool.length; i++){
                this.workerPool[i].terminate();
            }
            this.workerPool.length = 0;
            return this;
        }
    };
    let BasisTextureLoader2 = _BasisTextureLoader;
    /* CONSTANTS */ __publicField(BasisTextureLoader2, "BasisFormat", {
        ETC1S: 0,
        UASTC_4x4: 1
    });
    __publicField(BasisTextureLoader2, "TranscoderFormat", {
        ETC1: 0,
        ETC2: 1,
        BC1: 2,
        BC3: 3,
        BC4: 4,
        BC5: 5,
        BC7_M6_OPAQUE_ONLY: 6,
        BC7_M5: 7,
        PVRTC1_4_RGB: 8,
        PVRTC1_4_RGBA: 9,
        ASTC_4x4: 10,
        ATC_RGB: 11,
        ATC_RGBA_INTERPOLATED_ALPHA: 12,
        RGBA32: 13,
        RGB565: 14,
        BGR565: 15,
        RGBA4444: 16
    });
    __publicField(BasisTextureLoader2, "EngineFormat", {
        RGBAFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
        RGBA_ASTC_4x4_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_ASTC_4x4_Format"],
        RGBA_BPTC_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_BPTC_Format"],
        RGBA_ETC2_EAC_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_ETC2_EAC_Format"],
        RGBA_PVRTC_4BPPV1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_PVRTC_4BPPV1_Format"],
        RGBA_S3TC_DXT5_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBA_S3TC_DXT5_Format"],
        RGB_ETC1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_ETC1_Format"],
        RGB_ETC2_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_ETC2_Format"],
        RGB_PVRTC_4BPPV1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_PVRTC_4BPPV1_Format"],
        RGB_S3TC_DXT1_Format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGB_S3TC_DXT1_Format"]
    });
    /* WEB WORKER */ __publicField(BasisTextureLoader2, "BasisWorker", function() {
        let config;
        let transcoderPending;
        let BasisModule;
        const EngineFormat = _EngineFormat;
        const TranscoderFormat = _TranscoderFormat;
        const BasisFormat = _BasisFormat;
        onmessage = function(e) {
            const message = e.data;
            switch(message.type){
                case "init":
                    config = message.config;
                    init(message.transcoderBinary);
                    break;
                case "transcode":
                    transcoderPending.then(()=>{
                        try {
                            const { width, height, hasAlpha, mipmaps, format } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);
                            const buffers = [];
                            for(let i = 0; i < mipmaps.length; ++i){
                                buffers.push(mipmaps[i].data.buffer);
                            }
                            self.postMessage({
                                type: "transcode",
                                id: message.id,
                                width,
                                height,
                                hasAlpha,
                                mipmaps,
                                format
                            }, buffers);
                        } catch (error) {
                            console.error(error);
                            self.postMessage({
                                type: "error",
                                id: message.id,
                                error: error.message
                            });
                        }
                    });
                    break;
            }
        };
        function init(wasmBinary) {
            transcoderPending = new Promise((resolve)=>{
                BasisModule = {
                    wasmBinary,
                    onRuntimeInitialized: resolve
                };
                BASIS(BasisModule);
            }).then(()=>{
                BasisModule.initializeBasis();
            });
        }
        function transcodeLowLevel(taskConfig) {
            const { basisFormat, width, height, hasAlpha } = taskConfig;
            const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
            const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
            assert(BasisModule.isFormatSupported(transcoderFormat), "THREE.BasisTextureLoader: Unsupported format.");
            const mipmaps = [];
            if (basisFormat === BasisFormat.ETC1S) {
                const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();
                const { endpointCount, endpointsData, selectorCount, selectorsData, tablesData } = taskConfig.globalData;
                try {
                    let ok;
                    ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);
                    assert(ok, "THREE.BasisTextureLoader: decodePalettes() failed.");
                    ok = transcoder.decodeTables(tablesData);
                    assert(ok, "THREE.BasisTextureLoader: decodeTables() failed.");
                    for(let i = 0; i < taskConfig.levels.length; i++){
                        const level = taskConfig.levels[i];
                        const imageDesc = taskConfig.globalData.imageDescs[i];
                        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
                        const dst = new Uint8Array(dstByteLength);
                        ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);
                        assert(ok, "THREE.BasisTextureLoader: transcodeImage() failed for level " + level.index + ".");
                        mipmaps.push({
                            data: dst,
                            width: level.width,
                            height: level.height
                        });
                    }
                } finally{
                    transcoder.delete();
                }
            } else {
                for(let i = 0; i < taskConfig.levels.length; i++){
                    const level = taskConfig.levels[i];
                    const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
                    const dst = new Uint8Array(dstByteLength);
                    const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);
                    assert(ok, "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + level.index + ".");
                    mipmaps.push({
                        data: dst,
                        width: level.width,
                        height: level.height
                    });
                }
            }
            return {
                width,
                height,
                hasAlpha,
                mipmaps,
                format: engineFormat
            };
        }
        function transcode(buffer) {
            const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));
            const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
            const width = basisFile.getImageWidth(0, 0);
            const height = basisFile.getImageHeight(0, 0);
            const levels = basisFile.getNumLevels(0);
            const hasAlpha = basisFile.getHasAlpha();
            function cleanup() {
                basisFile.close();
                basisFile.delete();
            }
            const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
            if (!width || !height || !levels) {
                cleanup();
                throw new Error("THREE.BasisTextureLoader:	Invalid texture");
            }
            if (!basisFile.startTranscoding()) {
                cleanup();
                throw new Error("THREE.BasisTextureLoader: .startTranscoding failed");
            }
            const mipmaps = [];
            for(let mip = 0; mip < levels; mip++){
                const mipWidth = basisFile.getImageWidth(0, mip);
                const mipHeight = basisFile.getImageHeight(0, mip);
                const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));
                const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);
                if (!status) {
                    cleanup();
                    throw new Error("THREE.BasisTextureLoader: .transcodeImage failed.");
                }
                mipmaps.push({
                    data: dst,
                    width: mipWidth,
                    height: mipHeight
                });
            }
            cleanup();
            return {
                width,
                height,
                hasAlpha,
                mipmaps,
                format: engineFormat
            };
        }
        const FORMAT_OPTIONS = [
            {
                if: "astcSupported",
                basisFormat: [
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.ASTC_4x4,
                    TranscoderFormat.ASTC_4x4
                ],
                engineFormat: [
                    EngineFormat.RGBA_ASTC_4x4_Format,
                    EngineFormat.RGBA_ASTC_4x4_Format
                ],
                priorityETC1S: Infinity,
                priorityUASTC: 1,
                needsPowerOfTwo: false
            },
            {
                if: "bptcSupported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.BC7_M5,
                    TranscoderFormat.BC7_M5
                ],
                engineFormat: [
                    EngineFormat.RGBA_BPTC_Format,
                    EngineFormat.RGBA_BPTC_Format
                ],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: false
            },
            {
                if: "dxtSupported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.BC1,
                    TranscoderFormat.BC3
                ],
                engineFormat: [
                    EngineFormat.RGB_S3TC_DXT1_Format,
                    EngineFormat.RGBA_S3TC_DXT5_Format
                ],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: false
            },
            {
                if: "etc2Supported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.ETC1,
                    TranscoderFormat.ETC2
                ],
                engineFormat: [
                    EngineFormat.RGB_ETC2_Format,
                    EngineFormat.RGBA_ETC2_EAC_Format
                ],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: false
            },
            {
                if: "etc1Supported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.ETC1,
                    TranscoderFormat.ETC1
                ],
                engineFormat: [
                    EngineFormat.RGB_ETC1_Format,
                    EngineFormat.RGB_ETC1_Format
                ],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: false
            },
            {
                if: "pvrtcSupported",
                basisFormat: [
                    BasisFormat.ETC1S,
                    BasisFormat.UASTC_4x4
                ],
                transcoderFormat: [
                    TranscoderFormat.PVRTC1_4_RGB,
                    TranscoderFormat.PVRTC1_4_RGBA
                ],
                engineFormat: [
                    EngineFormat.RGB_PVRTC_4BPPV1_Format,
                    EngineFormat.RGBA_PVRTC_4BPPV1_Format
                ],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: true
            }
        ];
        const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
            return a.priorityETC1S - b.priorityETC1S;
        });
        const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
            return a.priorityUASTC - b.priorityUASTC;
        });
        function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
            let transcoderFormat;
            let engineFormat;
            const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
            for(let i = 0; i < options.length; i++){
                const opt = options[i];
                if (!config[opt.if]) continue;
                if (!opt.basisFormat.includes(basisFormat)) continue;
                if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;
                transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
                engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
                return {
                    transcoderFormat,
                    engineFormat
                };
            }
            console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.");
            transcoderFormat = TranscoderFormat.RGBA32;
            engineFormat = EngineFormat.RGBAFormat;
            return {
                transcoderFormat,
                engineFormat
            };
        }
        function assert(ok, message) {
            if (!ok) throw new Error(message);
        }
        function getWidthInBlocks(transcoderFormat, width) {
            return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));
        }
        function getHeightInBlocks(transcoderFormat, height) {
            return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));
        }
        function getTranscodedImageByteLength(transcoderFormat, width, height) {
            const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
            if (BasisModule.formatIsUncompressed(transcoderFormat)) {
                return width * height * blockByteLength;
            }
            if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {
                const paddedWidth = width + 3 & ~3;
                const paddedHeight = height + 3 & ~3;
                return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;
            }
            return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;
        }
        function isPowerOfTwo(value) {
            if (value <= 2) return true;
            return (value & value - 1) === 0 && value !== 0;
        }
    });
    return BasisTextureLoader2;
})();
;
 //# sourceMappingURL=BasisTextureLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/LDrawLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LDrawLoader": (()=>LDrawLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
;
const FINISH_TYPE_DEFAULT = 0;
const FINISH_TYPE_CHROME = 1;
const FINISH_TYPE_PEARLESCENT = 2;
const FINISH_TYPE_RUBBER = 3;
const FINISH_TYPE_MATTE_METALLIC = 4;
const FINISH_TYPE_METAL = 5;
const FILE_LOCATION_AS_IS = 0;
const FILE_LOCATION_TRY_PARTS = 1;
const FILE_LOCATION_TRY_P = 2;
const FILE_LOCATION_TRY_MODELS = 3;
const FILE_LOCATION_TRY_RELATIVE = 4;
const FILE_LOCATION_TRY_ABSOLUTE = 5;
const FILE_LOCATION_NOT_FOUND = 6;
const MAIN_COLOUR_CODE = "16";
const MAIN_EDGE_COLOUR_CODE = "24";
const _tempVec0 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _tempVec1 = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
class LDrawConditionalLineMaterial extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"] {
    constructor(parameters){
        super({
            uniforms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].merge([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UniformsLib"].fog,
                {
                    diffuse: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]()
                    },
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: /* glsl */ `
        attribute vec3 control0;
        attribute vec3 control1;
        attribute vec3 direction;
        varying float discardFlag;

        #include <common>
        #include <color_pars_vertex>
        #include <fog_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>

        void main() {
          #include <color_vertex>

          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          // Transform the line segment ends and control points into camera clip space
          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);
          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);
          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);

          c0.xy /= c0.w;
          c1.xy /= c1.w;
          p0.xy /= p0.w;
          p1.xy /= p1.w;

          // Get the direction of the segment and an orthogonal vector
          vec2 dir = p1.xy - p0.xy;
          vec2 norm = vec2(-dir.y, dir.x);

          // Get control point directions from the line
          vec2 c0dir = c0.xy - p1.xy;
          vec2 c1dir = c1.xy - p1.xy;

          // If the vectors to the controls points are pointed in different directions away
          // from the line segment then the line should not be drawn.
          float d0 = dot(normalize(norm), normalize(c0dir));
          float d1 = dot(normalize(norm), normalize(c1dir));
          discardFlag = float(sign(d0) != sign(d1));

          #include <logdepthbuf_vertex>
          #include <clipping_planes_vertex>
          #include <fog_vertex>
        }
      `,
            fragmentShader: /* glsl */ `
        uniform vec3 diffuse;
        uniform float opacity;
        varying float discardFlag;

        #include <common>
        #include <color_pars_fragment>
        #include <fog_pars_fragment>
        #include <logdepthbuf_pars_fragment>
        #include <clipping_planes_pars_fragment>

        void main() {
          if (discardFlag > 0.5) discard;

          #include <clipping_planes_fragment>
          vec3 outgoingLight = vec3(0.0);
          vec4 diffuseColor = vec4(diffuse, opacity);
          #include <logdepthbuf_fragment>
          #include <color_fragment>
          outgoingLight = diffuseColor.rgb; // simple shader
          gl_FragColor = vec4(outgoingLight, diffuseColor.a);
          #include <tonemapping_fragment>
          #include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
          #include <fog_fragment>
          #include <premultiplied_alpha_fragment>
        }
      `
        });
        Object.defineProperties(this, {
            opacity: {
                get: function() {
                    return this.uniforms.opacity.value;
                },
                set: function(value) {
                    this.uniforms.opacity.value = value;
                }
            },
            color: {
                get: function() {
                    return this.uniforms.diffuse.value;
                }
            }
        });
        this.setValues(parameters);
        this.isLDrawConditionalLineMaterial = true;
    }
}
class ConditionalLineSegments extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"] {
    constructor(geometry, material){
        super(geometry, material);
        this.isConditionalLine = true;
    }
}
function generateFaceNormals(faces) {
    for(let i = 0, l = faces.length; i < l; i++){
        const face = faces[i];
        const vertices = face.vertices;
        const v0 = vertices[0];
        const v1 = vertices[1];
        const v2 = vertices[2];
        _tempVec0.subVectors(v1, v0);
        _tempVec1.subVectors(v2, v1);
        face.faceNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().crossVectors(_tempVec0, _tempVec1).normalize();
    }
}
const _ray = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ray"]();
function smoothNormals(faces, lineSegments, checkSubSegments = false) {
    const hashMultiplier = (1 + 1e-10) * 100;
    function hashVertex(v) {
        const x = ~~(v.x * hashMultiplier);
        const y = ~~(v.y * hashMultiplier);
        const z = ~~(v.z * hashMultiplier);
        return `${x},${y},${z}`;
    }
    function hashEdge(v0, v1) {
        return `${hashVertex(v0)}_${hashVertex(v1)}`;
    }
    function toNormalizedRay(v0, v1, targetRay) {
        targetRay.direction.subVectors(v1, v0).normalize();
        const scalar = v0.dot(targetRay.direction);
        targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);
        return targetRay;
    }
    function hashRay(ray) {
        return hashEdge(ray.origin, ray.direction);
    }
    const hardEdges = /* @__PURE__ */ new Set();
    const hardEdgeRays = /* @__PURE__ */ new Map();
    const halfEdgeList = {};
    const normals = [];
    for(let i = 0, l = lineSegments.length; i < l; i++){
        const ls = lineSegments[i];
        const vertices = ls.vertices;
        const v0 = vertices[0];
        const v1 = vertices[1];
        hardEdges.add(hashEdge(v0, v1));
        hardEdges.add(hashEdge(v1, v0));
        if (checkSubSegments) {
            const ray = toNormalizedRay(v0, v1, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Ray"]());
            const rh1 = hashRay(ray);
            if (!hardEdgeRays.has(rh1)) {
                toNormalizedRay(v1, v0, ray);
                const rh2 = hashRay(ray);
                const info2 = {
                    ray,
                    distances: []
                };
                hardEdgeRays.set(rh1, info2);
                hardEdgeRays.set(rh2, info2);
            }
            const info = hardEdgeRays.get(rh1);
            let d0 = info.ray.direction.dot(v0);
            let d1 = info.ray.direction.dot(v1);
            if (d0 > d1) {
                [d0, d1] = [
                    d1,
                    d0
                ];
            }
            info.distances.push(d0, d1);
        }
    }
    for(let i = 0, l = faces.length; i < l; i++){
        const tri = faces[i];
        const vertices = tri.vertices;
        const vertCount = vertices.length;
        for(let i2 = 0; i2 < vertCount; i2++){
            const index = i2;
            const next = (i2 + 1) % vertCount;
            const v0 = vertices[index];
            const v1 = vertices[next];
            const hash = hashEdge(v0, v1);
            if (hardEdges.has(hash)) {
                continue;
            }
            if (checkSubSegments) {
                toNormalizedRay(v0, v1, _ray);
                const rayHash = hashRay(_ray);
                if (hardEdgeRays.has(rayHash)) {
                    const info2 = hardEdgeRays.get(rayHash);
                    const { ray, distances } = info2;
                    let d0 = ray.direction.dot(v0);
                    let d1 = ray.direction.dot(v1);
                    if (d0 > d1) {
                        [d0, d1] = [
                            d1,
                            d0
                        ];
                    }
                    let found = false;
                    for(let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2){
                        if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        continue;
                    }
                }
            }
            const info = {
                index,
                tri
            };
            halfEdgeList[hash] = info;
        }
    }
    while(true){
        let halfEdge = null;
        for(const key in halfEdgeList){
            halfEdge = halfEdgeList[key];
            break;
        }
        if (halfEdge === null) {
            break;
        }
        const queue = [
            halfEdge
        ];
        while(queue.length > 0){
            const tri = queue.pop().tri;
            const vertices = tri.vertices;
            const vertNormals = tri.normals;
            const faceNormal = tri.faceNormal;
            const vertCount = vertices.length;
            for(let i2 = 0; i2 < vertCount; i2++){
                const index = i2;
                const next = (i2 + 1) % vertCount;
                const v0 = vertices[index];
                const v1 = vertices[next];
                const hash = hashEdge(v0, v1);
                delete halfEdgeList[hash];
                const reverseHash = hashEdge(v1, v0);
                const otherInfo = halfEdgeList[reverseHash];
                if (otherInfo) {
                    const otherTri = otherInfo.tri;
                    const otherIndex = otherInfo.index;
                    const otherNormals = otherTri.normals;
                    const otherVertCount = otherNormals.length;
                    const otherFaceNormal = otherTri.faceNormal;
                    if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {
                        continue;
                    }
                    if (reverseHash in halfEdgeList) {
                        queue.push(otherInfo);
                        delete halfEdgeList[reverseHash];
                    }
                    const otherNext = (otherIndex + 1) % otherVertCount;
                    if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {
                        otherNormals[otherNext].norm.add(vertNormals[index].norm);
                        vertNormals[index].norm = otherNormals[otherNext].norm;
                    }
                    let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];
                    if (sharedNormal1 === null) {
                        sharedNormal1 = {
                            norm: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
                        };
                        normals.push(sharedNormal1.norm);
                    }
                    if (vertNormals[index] === null) {
                        vertNormals[index] = sharedNormal1;
                        sharedNormal1.norm.add(faceNormal);
                    }
                    if (otherNormals[otherNext] === null) {
                        otherNormals[otherNext] = sharedNormal1;
                        sharedNormal1.norm.add(otherFaceNormal);
                    }
                    if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {
                        otherNormals[otherIndex].norm.add(vertNormals[next].norm);
                        vertNormals[next].norm = otherNormals[otherIndex].norm;
                    }
                    let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];
                    if (sharedNormal2 === null) {
                        sharedNormal2 = {
                            norm: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
                        };
                        normals.push(sharedNormal2.norm);
                    }
                    if (vertNormals[next] === null) {
                        vertNormals[next] = sharedNormal2;
                        sharedNormal2.norm.add(faceNormal);
                    }
                    if (otherNormals[otherIndex] === null) {
                        otherNormals[otherIndex] = sharedNormal2;
                        sharedNormal2.norm.add(otherFaceNormal);
                    }
                }
            }
        }
    }
    for(let i = 0, l = normals.length; i < l; i++){
        normals[i].normalize();
    }
}
function isPartType(type) {
    return type === "Part" || type === "Unofficial_Part";
}
function isPrimitiveType(type) {
    return /primitive/i.test(type) || type === "Subpart";
}
class LineParser {
    constructor(line, lineNumber){
        this.line = line;
        this.lineLength = line.length;
        this.currentCharIndex = 0;
        this.currentChar = " ";
        this.lineNumber = lineNumber;
    }
    seekNonSpace() {
        while(this.currentCharIndex < this.lineLength){
            this.currentChar = this.line.charAt(this.currentCharIndex);
            if (this.currentChar !== " " && this.currentChar !== "	") {
                return;
            }
            this.currentCharIndex++;
        }
    }
    getToken() {
        const pos0 = this.currentCharIndex++;
        while(this.currentCharIndex < this.lineLength){
            this.currentChar = this.line.charAt(this.currentCharIndex);
            if (this.currentChar === " " || this.currentChar === "	") {
                break;
            }
            this.currentCharIndex++;
        }
        const pos1 = this.currentCharIndex;
        this.seekNonSpace();
        return this.line.substring(pos0, pos1);
    }
    getVector() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));
    }
    getRemainingString() {
        return this.line.substring(this.currentCharIndex, this.lineLength);
    }
    isAtTheEnd() {
        return this.currentCharIndex >= this.lineLength;
    }
    setToEnd() {
        this.currentCharIndex = this.lineLength;
    }
    getLineNumberString() {
        return this.lineNumber >= 0 ? " at line " + this.lineNumber : "";
    }
}
class LDrawParsedCache {
    constructor(loader){
        this.loader = loader;
        this._cache = {};
    }
    cloneResult(original) {
        const result = {};
        result.faces = original.faces.map((face)=>{
            return {
                colorCode: face.colorCode,
                material: face.material,
                vertices: face.vertices.map((v)=>v.clone()),
                normals: face.normals.map(()=>null),
                faceNormal: null
            };
        });
        result.conditionalSegments = original.conditionalSegments.map((face)=>{
            return {
                colorCode: face.colorCode,
                material: face.material,
                vertices: face.vertices.map((v)=>v.clone()),
                controlPoints: face.controlPoints.map((v)=>v.clone())
            };
        });
        result.lineSegments = original.lineSegments.map((face)=>{
            return {
                colorCode: face.colorCode,
                material: face.material,
                vertices: face.vertices.map((v)=>v.clone())
            };
        });
        result.type = original.type;
        result.category = original.category;
        result.keywords = original.keywords;
        result.subobjects = original.subobjects;
        result.totalFaces = original.totalFaces;
        result.startingConstructionStep = original.startingConstructionStep;
        result.materials = original.materials;
        result.group = null;
        return result;
    }
    async fetchData(fileName) {
        let triedLowerCase = false;
        let locationState = FILE_LOCATION_AS_IS;
        while(locationState !== FILE_LOCATION_NOT_FOUND){
            let subobjectURL = fileName;
            switch(locationState){
                case FILE_LOCATION_AS_IS:
                    locationState = locationState + 1;
                    break;
                case FILE_LOCATION_TRY_PARTS:
                    subobjectURL = "parts/" + subobjectURL;
                    locationState = locationState + 1;
                    break;
                case FILE_LOCATION_TRY_P:
                    subobjectURL = "p/" + subobjectURL;
                    locationState = locationState + 1;
                    break;
                case FILE_LOCATION_TRY_MODELS:
                    subobjectURL = "models/" + subobjectURL;
                    locationState = locationState + 1;
                    break;
                case FILE_LOCATION_TRY_RELATIVE:
                    subobjectURL = fileName.substring(0, fileName.lastIndexOf("/") + 1) + subobjectURL;
                    locationState = locationState + 1;
                    break;
                case FILE_LOCATION_TRY_ABSOLUTE:
                    if (triedLowerCase) {
                        locationState = FILE_LOCATION_NOT_FOUND;
                    } else {
                        fileName = fileName.toLowerCase();
                        subobjectURL = fileName;
                        triedLowerCase = true;
                        locationState = FILE_LOCATION_AS_IS;
                    }
                    break;
            }
            const loader = this.loader;
            const fileLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](loader.manager);
            fileLoader.setPath(loader.partsLibraryPath);
            fileLoader.setRequestHeader(loader.requestHeader);
            fileLoader.setWithCredentials(loader.withCredentials);
            try {
                const text = await fileLoader.loadAsync(subobjectURL);
                return text;
            } catch (e) {
                continue;
            }
        }
        throw new Error('LDrawLoader: Subobject "' + fileName + '" could not be loaded.');
    }
    parse(text, fileName = null) {
        const loader = this.loader;
        const faces = [];
        const lineSegments = [];
        const conditionalSegments = [];
        const subobjects = [];
        const materials = {};
        const getLocalMaterial = (colorCode)=>{
            return materials[colorCode] || null;
        };
        let type = "Model";
        let category = null;
        let keywords = null;
        let totalFaces = 0;
        if (text.indexOf("\r\n") !== -1) {
            text = text.replace(/\r\n/g, "\n");
        }
        const lines = text.split("\n");
        const numLines = lines.length;
        let parsingEmbeddedFiles = false;
        let currentEmbeddedFileName = null;
        let currentEmbeddedText = null;
        let bfcCertified = false;
        let bfcCCW = true;
        let bfcInverted = false;
        let bfcCull = true;
        let startingConstructionStep = false;
        for(let lineIndex = 0; lineIndex < numLines; lineIndex++){
            const line = lines[lineIndex];
            if (line.length === 0) continue;
            if (parsingEmbeddedFiles) {
                if (line.startsWith("0 FILE ")) {
                    this.setData(currentEmbeddedFileName, currentEmbeddedText);
                    currentEmbeddedFileName = line.substring(7);
                    currentEmbeddedText = "";
                } else {
                    currentEmbeddedText += line + "\n";
                }
                continue;
            }
            const lp = new LineParser(line, lineIndex + 1);
            lp.seekNonSpace();
            if (lp.isAtTheEnd()) {
                continue;
            }
            const lineType = lp.getToken();
            let material;
            let colorCode;
            let segment;
            let ccw;
            let doubleSided;
            let v0, v1, v2, v3, c0, c1;
            switch(lineType){
                case "0":
                    const meta = lp.getToken();
                    if (meta) {
                        switch(meta){
                            case "!LDRAW_ORG":
                                type = lp.getToken();
                                break;
                            case "!COLOUR":
                                material = loader.parseColorMetaDirective(lp);
                                if (material) {
                                    materials[material.userData.code] = material;
                                } else {
                                    console.warn("LDrawLoader: Error parsing material" + lp.getLineNumberString());
                                }
                                break;
                            case "!CATEGORY":
                                category = lp.getToken();
                                break;
                            case "!KEYWORDS":
                                const newKeywords = lp.getRemainingString().split(",");
                                if (newKeywords.length > 0) {
                                    if (!keywords) {
                                        keywords = [];
                                    }
                                    newKeywords.forEach(function(keyword) {
                                        keywords.push(keyword.trim());
                                    });
                                }
                                break;
                            case "FILE":
                                if (lineIndex > 0) {
                                    parsingEmbeddedFiles = true;
                                    currentEmbeddedFileName = lp.getRemainingString();
                                    currentEmbeddedText = "";
                                    bfcCertified = false;
                                    bfcCCW = true;
                                }
                                break;
                            case "BFC":
                                while(!lp.isAtTheEnd()){
                                    const token = lp.getToken();
                                    switch(token){
                                        case "CERTIFY":
                                        case "NOCERTIFY":
                                            bfcCertified = token === "CERTIFY";
                                            bfcCCW = true;
                                            break;
                                        case "CW":
                                        case "CCW":
                                            bfcCCW = token === "CCW";
                                            break;
                                        case "INVERTNEXT":
                                            bfcInverted = true;
                                            break;
                                        case "CLIP":
                                        case "NOCLIP":
                                            bfcCull = token === "CLIP";
                                            break;
                                        default:
                                            console.warn('THREE.LDrawLoader: BFC directive "' + token + '" is unknown.');
                                            break;
                                    }
                                }
                                break;
                            case "STEP":
                                startingConstructionStep = true;
                                break;
                        }
                    }
                    break;
                case "1":
                    colorCode = lp.getToken();
                    material = getLocalMaterial(colorCode);
                    const posX = parseFloat(lp.getToken());
                    const posY = parseFloat(lp.getToken());
                    const posZ = parseFloat(lp.getToken());
                    const m0 = parseFloat(lp.getToken());
                    const m1 = parseFloat(lp.getToken());
                    const m2 = parseFloat(lp.getToken());
                    const m3 = parseFloat(lp.getToken());
                    const m4 = parseFloat(lp.getToken());
                    const m5 = parseFloat(lp.getToken());
                    const m6 = parseFloat(lp.getToken());
                    const m7 = parseFloat(lp.getToken());
                    const m8 = parseFloat(lp.getToken());
                    const matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);
                    let fileName2 = lp.getRemainingString().trim().replace(/\\/g, "/");
                    if (loader.fileMap[fileName2]) {
                        fileName2 = loader.fileMap[fileName2];
                    } else {
                        if (fileName2.startsWith("s/")) {
                            fileName2 = "parts/" + fileName2;
                        } else if (fileName2.startsWith("48/")) {
                            fileName2 = "p/" + fileName2;
                        }
                    }
                    subobjects.push({
                        material,
                        colorCode,
                        matrix,
                        fileName: fileName2,
                        inverted: bfcInverted,
                        startingConstructionStep
                    });
                    bfcInverted = false;
                    break;
                case "2":
                    colorCode = lp.getToken();
                    material = getLocalMaterial(colorCode);
                    v0 = lp.getVector();
                    v1 = lp.getVector();
                    segment = {
                        material,
                        colorCode,
                        vertices: [
                            v0,
                            v1
                        ]
                    };
                    lineSegments.push(segment);
                    break;
                case "5":
                    colorCode = lp.getToken();
                    material = getLocalMaterial(colorCode);
                    v0 = lp.getVector();
                    v1 = lp.getVector();
                    c0 = lp.getVector();
                    c1 = lp.getVector();
                    segment = {
                        material,
                        colorCode,
                        vertices: [
                            v0,
                            v1
                        ],
                        controlPoints: [
                            c0,
                            c1
                        ]
                    };
                    conditionalSegments.push(segment);
                    break;
                case "3":
                    colorCode = lp.getToken();
                    material = getLocalMaterial(colorCode);
                    ccw = bfcCCW;
                    doubleSided = !bfcCertified || !bfcCull;
                    if (ccw === true) {
                        v0 = lp.getVector();
                        v1 = lp.getVector();
                        v2 = lp.getVector();
                    } else {
                        v2 = lp.getVector();
                        v1 = lp.getVector();
                        v0 = lp.getVector();
                    }
                    faces.push({
                        material,
                        colorCode,
                        faceNormal: null,
                        vertices: [
                            v0,
                            v1,
                            v2
                        ],
                        normals: [
                            null,
                            null,
                            null
                        ]
                    });
                    totalFaces++;
                    if (doubleSided === true) {
                        faces.push({
                            material,
                            colorCode,
                            faceNormal: null,
                            vertices: [
                                v2,
                                v1,
                                v0
                            ],
                            normals: [
                                null,
                                null,
                                null
                            ]
                        });
                        totalFaces++;
                    }
                    break;
                case "4":
                    colorCode = lp.getToken();
                    material = getLocalMaterial(colorCode);
                    ccw = bfcCCW;
                    doubleSided = !bfcCertified || !bfcCull;
                    if (ccw === true) {
                        v0 = lp.getVector();
                        v1 = lp.getVector();
                        v2 = lp.getVector();
                        v3 = lp.getVector();
                    } else {
                        v3 = lp.getVector();
                        v2 = lp.getVector();
                        v1 = lp.getVector();
                        v0 = lp.getVector();
                    }
                    faces.push({
                        material,
                        colorCode,
                        faceNormal: null,
                        vertices: [
                            v0,
                            v1,
                            v2,
                            v3
                        ],
                        normals: [
                            null,
                            null,
                            null,
                            null
                        ]
                    });
                    totalFaces += 2;
                    if (doubleSided === true) {
                        faces.push({
                            material,
                            colorCode,
                            faceNormal: null,
                            vertices: [
                                v3,
                                v2,
                                v1,
                                v0
                            ],
                            normals: [
                                null,
                                null,
                                null,
                                null
                            ]
                        });
                        totalFaces += 2;
                    }
                    break;
                default:
                    throw new Error('LDrawLoader: Unknown line type "' + lineType + '"' + lp.getLineNumberString() + ".");
            }
        }
        if (parsingEmbeddedFiles) {
            this.setData(currentEmbeddedFileName, currentEmbeddedText);
        }
        return {
            faces,
            conditionalSegments,
            lineSegments,
            type,
            category,
            keywords,
            subobjects,
            totalFaces,
            startingConstructionStep,
            materials,
            fileName,
            group: null
        };
    }
    // returns an (optionally cloned) instance of the data
    getData(fileName, clone = true) {
        const key = fileName.toLowerCase();
        const result = this._cache[key];
        if (result === null || result instanceof Promise) {
            return null;
        }
        if (clone) {
            return this.cloneResult(result);
        } else {
            return result;
        }
    }
    // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when
    // the data is ready to use and can be retrieved synchronously with "getData".
    async ensureDataLoaded(fileName) {
        const key = fileName.toLowerCase();
        if (!(key in this._cache)) {
            this._cache[key] = this.fetchData(fileName).then((text)=>{
                const info = this.parse(text, fileName);
                this._cache[key] = info;
                return info;
            });
        }
        await this._cache[key];
    }
    // sets the data in the cache from parsed data
    setData(fileName, text) {
        const key = fileName.toLowerCase();
        this._cache[key] = this.parse(text, fileName);
    }
}
function getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {
    const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;
    if (isPassthrough) {
        colorCode = parentColorCode;
    }
    return materialHierarchy[colorCode] || null;
}
class LDrawPartsGeometryCache {
    constructor(loader){
        this.loader = loader;
        this.parseCache = new LDrawParsedCache(loader);
        this._cache = {};
    }
    // Convert the given file information into a mesh by processing subobjects.
    async processIntoMesh(info) {
        const loader = this.loader;
        const parseCache = this.parseCache;
        const faceMaterials = /* @__PURE__ */ new Set();
        const processInfoSubobjects = async (info2, subobject = null)=>{
            const subobjects = info2.subobjects;
            const promises = [];
            for(let i = 0, l = subobjects.length; i < l; i++){
                const subobject2 = subobjects[i];
                const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(()=>{
                    const subobjectInfo = parseCache.getData(subobject2.fileName, false);
                    if (!isPrimitiveType(subobjectInfo.type)) {
                        return this.loadModel(subobject2.fileName).catch((error)=>{
                            console.warn(error);
                            return null;
                        });
                    }
                    return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);
                });
                promises.push(promise);
            }
            const group2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            group2.userData.category = info2.category;
            group2.userData.keywords = info2.keywords;
            info2.group = group2;
            const subobjectInfos = await Promise.all(promises);
            for(let i = 0, l = subobjectInfos.length; i < l; i++){
                const subobject2 = info2.subobjects[i];
                const subobjectInfo = subobjectInfos[i];
                if (subobjectInfo === null) {
                    continue;
                }
                if (subobjectInfo.isGroup) {
                    const subobjectGroup = subobjectInfo;
                    subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);
                    subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;
                    subobjectGroup.name = subobject2.fileName;
                    loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);
                    group2.add(subobjectGroup);
                    continue;
                }
                if (subobjectInfo.group.children.length) {
                    group2.add(subobjectInfo.group);
                }
                const parentLineSegments = info2.lineSegments;
                const parentConditionalSegments = info2.conditionalSegments;
                const parentFaces = info2.faces;
                const lineSegments = subobjectInfo.lineSegments;
                const conditionalSegments = subobjectInfo.conditionalSegments;
                const faces = subobjectInfo.faces;
                const matrix = subobject2.matrix;
                const inverted = subobject2.inverted;
                const matrixScaleInverted = matrix.determinant() < 0;
                const colorCode = subobject2.colorCode;
                const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;
                for(let i2 = 0, l2 = lineSegments.length; i2 < l2; i2++){
                    const ls = lineSegments[i2];
                    const vertices = ls.vertices;
                    vertices[0].applyMatrix4(matrix);
                    vertices[1].applyMatrix4(matrix);
                    ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;
                    ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);
                    parentLineSegments.push(ls);
                }
                for(let i2 = 0, l2 = conditionalSegments.length; i2 < l2; i2++){
                    const os = conditionalSegments[i2];
                    const vertices = os.vertices;
                    const controlPoints = os.controlPoints;
                    vertices[0].applyMatrix4(matrix);
                    vertices[1].applyMatrix4(matrix);
                    controlPoints[0].applyMatrix4(matrix);
                    controlPoints[1].applyMatrix4(matrix);
                    os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;
                    os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);
                    parentConditionalSegments.push(os);
                }
                for(let i2 = 0, l2 = faces.length; i2 < l2; i2++){
                    const tri = faces[i2];
                    const vertices = tri.vertices;
                    for(let i3 = 0, l3 = vertices.length; i3 < l3; i3++){
                        vertices[i3].applyMatrix4(matrix);
                    }
                    tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;
                    tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);
                    faceMaterials.add(tri.colorCode);
                    if (matrixScaleInverted !== inverted) {
                        vertices.reverse();
                    }
                    parentFaces.push(tri);
                }
                info2.totalFaces += subobjectInfo.totalFaces;
            }
            if (subobject) {
                loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);
            }
            return info2;
        };
        for(let i = 0, l = info.faces; i < l; i++){
            faceMaterials.add(info.faces[i].colorCode);
        }
        await processInfoSubobjects(info);
        if (loader.smoothNormals) {
            const checkSubSegments = faceMaterials.size > 1;
            generateFaceNormals(info.faces);
            smoothNormals(info.faces, info.lineSegments, checkSubSegments);
        }
        const group = info.group;
        if (info.faces.length > 0) {
            group.add(createObject(info.faces, 3, false, info.totalFaces));
        }
        if (info.lineSegments.length > 0) {
            group.add(createObject(info.lineSegments, 2));
        }
        if (info.conditionalSegments.length > 0) {
            group.add(createObject(info.conditionalSegments, 2, true));
        }
        return group;
    }
    hasCachedModel(fileName) {
        return fileName !== null && fileName.toLowerCase() in this._cache;
    }
    async getCachedModel(fileName) {
        if (fileName !== null && this.hasCachedModel(fileName)) {
            const key = fileName.toLowerCase();
            const group = await this._cache[key];
            return group.clone();
        } else {
            return null;
        }
    }
    // Loads and parses the model with the given file name. Returns a cached copy if available.
    async loadModel(fileName) {
        const parseCache = this.parseCache;
        const key = fileName.toLowerCase();
        if (this.hasCachedModel(fileName)) {
            return this.getCachedModel(fileName);
        } else {
            await parseCache.ensureDataLoaded(fileName);
            const info = parseCache.getData(fileName);
            const promise = this.processIntoMesh(info);
            if (this.hasCachedModel(fileName)) {
                return this.getCachedModel(fileName);
            }
            if (isPartType(info.type)) {
                this._cache[key] = promise;
            }
            const group = await promise;
            return group.clone();
        }
    }
    // parses the given model text into a renderable object. Returns cached copy if available.
    async parseModel(text) {
        const parseCache = this.parseCache;
        const info = parseCache.parse(text);
        if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {
            return this.getCachedModel(info.fileName);
        }
        return this.processIntoMesh(info);
    }
}
function sortByMaterial(a, b) {
    if (a.colorCode === b.colorCode) {
        return 0;
    }
    if (a.colorCode < b.colorCode) {
        return -1;
    }
    return 1;
}
function createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {
    elements.sort(sortByMaterial);
    if (totalElements === null) {
        totalElements = elements.length;
    }
    const positions = new Float32Array(elementSize * totalElements * 3);
    const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;
    const materials = [];
    const quadArray = new Array(6);
    const bufferGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
    let prevMaterial = null;
    let index0 = 0;
    let numGroupVerts = 0;
    let offset = 0;
    for(let iElem = 0, nElem = elements.length; iElem < nElem; iElem++){
        const elem = elements[iElem];
        let vertices = elem.vertices;
        if (vertices.length === 4) {
            quadArray[0] = vertices[0];
            quadArray[1] = vertices[1];
            quadArray[2] = vertices[2];
            quadArray[3] = vertices[0];
            quadArray[4] = vertices[2];
            quadArray[5] = vertices[3];
            vertices = quadArray;
        }
        for(let j = 0, l = vertices.length; j < l; j++){
            const v = vertices[j];
            const index = offset + j * 3;
            positions[index + 0] = v.x;
            positions[index + 1] = v.y;
            positions[index + 2] = v.z;
        }
        if (elementSize === 3) {
            if (!elem.faceNormal) {
                const v0 = vertices[0];
                const v1 = vertices[1];
                const v2 = vertices[2];
                _tempVec0.subVectors(v1, v0);
                _tempVec1.subVectors(v2, v1);
                elem.faceNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().crossVectors(_tempVec0, _tempVec1).normalize();
            }
            let elemNormals = elem.normals;
            if (elemNormals.length === 4) {
                quadArray[0] = elemNormals[0];
                quadArray[1] = elemNormals[1];
                quadArray[2] = elemNormals[2];
                quadArray[3] = elemNormals[0];
                quadArray[4] = elemNormals[2];
                quadArray[5] = elemNormals[3];
                elemNormals = quadArray;
            }
            for(let j = 0, l = elemNormals.length; j < l; j++){
                let n = elem.faceNormal;
                if (elemNormals[j]) {
                    n = elemNormals[j].norm;
                }
                const index = offset + j * 3;
                normals[index + 0] = n.x;
                normals[index + 1] = n.y;
                normals[index + 2] = n.z;
            }
        }
        if (prevMaterial !== elem.colorCode) {
            if (prevMaterial !== null) {
                bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);
            }
            const material = elem.material;
            if (material !== null) {
                if (elementSize === 3) {
                    materials.push(material);
                } else if (elementSize === 2) {
                    if (material !== null) {
                        if (isConditionalSegments) {
                            materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);
                        } else {
                            materials.push(material.userData.edgeMaterial);
                        }
                    } else {
                        materials.push(null);
                    }
                }
            } else {
                materials.push(elem.colorCode);
            }
            prevMaterial = elem.colorCode;
            index0 = offset / 3;
            numGroupVerts = vertices.length;
        } else {
            numGroupVerts += vertices.length;
        }
        offset += 3 * vertices.length;
    }
    if (numGroupVerts > 0) {
        bufferGeometry.addGroup(index0, Infinity, materials.length - 1);
    }
    bufferGeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](positions, 3));
    if (normals !== null) {
        bufferGeometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](normals, 3));
    }
    let object3d = null;
    if (elementSize === 2) {
        if (isConditionalSegments) {
            object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);
        } else {
            object3d = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](bufferGeometry, materials.length === 1 ? materials[0] : materials);
        }
    } else if (elementSize === 3) {
        object3d = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](bufferGeometry, materials.length === 1 ? materials[0] : materials);
    }
    if (isConditionalSegments) {
        object3d.isConditionalLine = true;
        const controlArray0 = new Float32Array(elements.length * 3 * 2);
        const controlArray1 = new Float32Array(elements.length * 3 * 2);
        const directionArray = new Float32Array(elements.length * 3 * 2);
        for(let i = 0, l = elements.length; i < l; i++){
            const os = elements[i];
            const vertices = os.vertices;
            const controlPoints = os.controlPoints;
            const c0 = controlPoints[0];
            const c1 = controlPoints[1];
            const v0 = vertices[0];
            const v1 = vertices[1];
            const index = i * 3 * 2;
            controlArray0[index + 0] = c0.x;
            controlArray0[index + 1] = c0.y;
            controlArray0[index + 2] = c0.z;
            controlArray0[index + 3] = c0.x;
            controlArray0[index + 4] = c0.y;
            controlArray0[index + 5] = c0.z;
            controlArray1[index + 0] = c1.x;
            controlArray1[index + 1] = c1.y;
            controlArray1[index + 2] = c1.z;
            controlArray1[index + 3] = c1.x;
            controlArray1[index + 4] = c1.y;
            controlArray1[index + 5] = c1.z;
            directionArray[index + 0] = v1.x - v0.x;
            directionArray[index + 1] = v1.y - v0.y;
            directionArray[index + 2] = v1.z - v0.z;
            directionArray[index + 3] = v1.x - v0.x;
            directionArray[index + 4] = v1.y - v0.y;
            directionArray[index + 5] = v1.z - v0.z;
        }
        bufferGeometry.setAttribute("control0", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](controlArray0, 3, false));
        bufferGeometry.setAttribute("control1", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](controlArray1, 3, false));
        bufferGeometry.setAttribute("direction", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](directionArray, 3, false));
    }
    return object3d;
}
class LDrawLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.materials = [];
        this.materialLibrary = {};
        this.partsCache = new LDrawPartsGeometryCache(this);
        this.fileMap = {};
        this.setMaterials([]);
        this.smoothNormals = true;
        this.partsLibraryPath = "";
    }
    setPartsLibraryPath(path) {
        this.partsLibraryPath = path;
        return this;
    }
    async preloadMaterials(url) {
        const fileLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        fileLoader.setPath(this.path);
        fileLoader.setRequestHeader(this.requestHeader);
        fileLoader.setWithCredentials(this.withCredentials);
        const text = await fileLoader.loadAsync(url);
        const colorLineRegex = /^0 !COLOUR/;
        const lines = text.split(/[\n\r]/g);
        const materials = [];
        for(let i = 0, l = lines.length; i < l; i++){
            const line = lines[i];
            if (colorLineRegex.test(line)) {
                const directive = line.replace(colorLineRegex, "");
                const material = this.parseColorMetaDirective(new LineParser(directive));
                materials.push(material);
            }
        }
        this.setMaterials(materials);
    }
    load(url, onLoad, onProgress, onError) {
        const fileLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        fileLoader.setPath(this.path);
        fileLoader.setRequestHeader(this.requestHeader);
        fileLoader.setWithCredentials(this.withCredentials);
        fileLoader.load(url, (text)=>{
            this.partsCache.parseModel(text, this.materialLibrary).then((group)=>{
                this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);
                this.computeConstructionSteps(group);
                onLoad(group);
            }).catch(onError);
        }, onProgress, onError);
    }
    parse(text, onLoad) {
        this.partsCache.parseModel(text, this.materialLibrary).then((group)=>{
            this.computeConstructionSteps(group);
            onLoad(group);
        });
    }
    setMaterials(materials) {
        this.materialLibrary = {};
        this.materials = [];
        for(let i = 0, l = materials.length; i < l; i++){
            this.addMaterial(materials[i]);
        }
        this.addMaterial(this.parseColorMetaDirective(new LineParser("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333")));
        this.addMaterial(this.parseColorMetaDirective(new LineParser("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333")));
        return this;
    }
    setFileMap(fileMap) {
        this.fileMap = fileMap;
        return this;
    }
    addMaterial(material) {
        const matLib = this.materialLibrary;
        if (!matLib[material.userData.code]) {
            this.materials.push(material);
            matLib[material.userData.code] = material;
        }
        return this;
    }
    getMaterial(colorCode) {
        if (colorCode.startsWith("0x2")) {
            const color = colorCode.substring(3);
            return this.parseColorMetaDirective(new LineParser("Direct_Color_" + color + " CODE -1 VALUE #" + color + " EDGE #" + color));
        }
        return this.materialLibrary[colorCode] || null;
    }
    // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present
    // in the material array if they need to be filled in.
    applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {
        const loader = this;
        const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;
        group.traverse((c)=>{
            if (c.isMesh || c.isLineSegments) {
                if (Array.isArray(c.material)) {
                    for(let i = 0, l = c.material.length; i < l; i++){
                        if (!c.material[i].isMaterial) {
                            c.material[i] = getMaterial(c, c.material[i]);
                        }
                    }
                } else if (!c.material.isMaterial) {
                    c.material = getMaterial(c, c.material);
                }
            }
        });
        function getMaterial(c, colorCode) {
            if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {
                return colorCode;
            }
            const forEdge = c.isLineSegments || c.isConditionalLine;
            const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;
            if (isPassthrough) {
                colorCode = parentColorCode;
            }
            let material = null;
            if (colorCode in materialHierarchy) {
                material = materialHierarchy[colorCode];
            } else if (finalMaterialPass) {
                material = loader.getMaterial(colorCode);
                if (material === null) {
                    throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);
                }
            } else {
                return colorCode;
            }
            if (c.isLineSegments) {
                material = material.userData.edgeMaterial;
                if (c.isConditionalLine) {
                    material = material.userData.conditionalEdgeMaterial;
                }
            }
            return material;
        }
    }
    getMainMaterial() {
        return this.getMaterial(MAIN_COLOUR_CODE);
    }
    getMainEdgeMaterial() {
        return this.getMaterial(MAIN_EDGE_COLOUR_CODE);
    }
    parseColorMetaDirective(lineParser) {
        let code = null;
        let color = 16711935;
        let edgeColor = 16711935;
        let alpha = 1;
        let isTransparent = false;
        let luminance = 0;
        let finishType = FINISH_TYPE_DEFAULT;
        let edgeMaterial = null;
        const name = lineParser.getToken();
        if (!name) {
            throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag' + lineParser.getLineNumberString() + ".");
        }
        let token = null;
        while(true){
            token = lineParser.getToken();
            if (!token) {
                break;
            }
            switch(token.toUpperCase()){
                case "CODE":
                    code = lineParser.getToken();
                    break;
                case "VALUE":
                    color = lineParser.getToken();
                    if (color.startsWith("0x")) {
                        color = "#" + color.substring(2);
                    } else if (!color.startsWith("#")) {
                        throw new Error("LDrawLoader: Invalid color while parsing material" + lineParser.getLineNumberString() + ".");
                    }
                    break;
                case "EDGE":
                    edgeColor = lineParser.getToken();
                    if (edgeColor.startsWith("0x")) {
                        edgeColor = "#" + edgeColor.substring(2);
                    } else if (!edgeColor.startsWith("#")) {
                        edgeMaterial = this.getMaterial(edgeColor);
                        if (!edgeMaterial) {
                            throw new Error("LDrawLoader: Invalid edge color while parsing material" + lineParser.getLineNumberString() + ".");
                        }
                        edgeMaterial = edgeMaterial.userData.edgeMaterial;
                    }
                    break;
                case "ALPHA":
                    alpha = parseInt(lineParser.getToken());
                    if (isNaN(alpha)) {
                        throw new Error("LDrawLoader: Invalid alpha value in material definition" + lineParser.getLineNumberString() + ".");
                    }
                    alpha = Math.max(0, Math.min(1, alpha / 255));
                    if (alpha < 1) {
                        isTransparent = true;
                    }
                    break;
                case "LUMINANCE":
                    luminance = parseInt(lineParser.getToken());
                    if (isNaN(luminance)) {
                        throw new Error("LDrawLoader: Invalid luminance value in material definition" + LineParser.getLineNumberString() + ".");
                    }
                    luminance = Math.max(0, Math.min(1, luminance / 255));
                    break;
                case "CHROME":
                    finishType = FINISH_TYPE_CHROME;
                    break;
                case "PEARLESCENT":
                    finishType = FINISH_TYPE_PEARLESCENT;
                    break;
                case "RUBBER":
                    finishType = FINISH_TYPE_RUBBER;
                    break;
                case "MATTE_METALLIC":
                    finishType = FINISH_TYPE_MATTE_METALLIC;
                    break;
                case "METAL":
                    finishType = FINISH_TYPE_METAL;
                    break;
                case "MATERIAL":
                    lineParser.setToEnd();
                    break;
                default:
                    throw new Error('LDrawLoader: Unknown token "' + token + '" while parsing material' + lineParser.getLineNumberString() + ".");
            }
        }
        let material = null;
        switch(finishType){
            case FINISH_TYPE_DEFAULT:
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                    color,
                    roughness: 0.3,
                    metalness: 0
                });
                break;
            case FINISH_TYPE_PEARLESCENT:
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                    color,
                    roughness: 0.3,
                    metalness: 0.25
                });
                break;
            case FINISH_TYPE_CHROME:
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                    color,
                    roughness: 0,
                    metalness: 1
                });
                break;
            case FINISH_TYPE_RUBBER:
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                    color,
                    roughness: 0.9,
                    metalness: 0
                });
                break;
            case FINISH_TYPE_MATTE_METALLIC:
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                    color,
                    roughness: 0.8,
                    metalness: 0.4
                });
                break;
            case FINISH_TYPE_METAL:
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                    color,
                    roughness: 0.2,
                    metalness: 0.85
                });
                break;
        }
        material.transparent = isTransparent;
        material.premultipliedAlpha = true;
        material.opacity = alpha;
        material.depthWrite = !isTransparent;
        material.polygonOffset = true;
        material.polygonOffsetFactor = 1;
        if (luminance !== 0) {
            material.emissive.set(material.color).multiplyScalar(luminance);
        }
        if (!edgeMaterial) {
            edgeMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
                color: edgeColor,
                transparent: isTransparent,
                opacity: alpha,
                depthWrite: !isTransparent
            });
            edgeMaterial.userData.code = code;
            edgeMaterial.name = name + " - Edge";
            edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({
                fog: true,
                transparent: isTransparent,
                depthWrite: !isTransparent,
                color: edgeColor,
                opacity: alpha
            });
        }
        material.userData.code = code;
        material.name = name;
        material.userData.edgeMaterial = edgeMaterial;
        this.addMaterial(material);
        return material;
    }
    computeConstructionSteps(model) {
        let stepNumber = 0;
        model.traverse((c)=>{
            if (c.isGroup) {
                if (c.userData.startingConstructionStep) {
                    stepNumber++;
                }
                c.userData.constructionStep = stepNumber;
            }
        });
        model.userData.numConstructionSteps = stepNumber + 1;
    }
}
;
 //# sourceMappingURL=LDrawLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/GLTFLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GLTFLoader": (()=>GLTFLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/utils/BufferGeometryUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
;
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const sRGBEncoding = 3001;
const LinearEncoding = 3e3;
class GLTFLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.dracoLoader = null;
        this.ktx2Loader = null;
        this.meshoptDecoder = null;
        this.pluginCallbacks = [];
        this.register(function(parser) {
            return new GLTFMaterialsClearcoatExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsDispersionExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFTextureBasisUExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFTextureWebPExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFTextureAVIFExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsSheenExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsTransmissionExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsVolumeExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsIorExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsEmissiveStrengthExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsSpecularExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsIridescenceExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsAnisotropyExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMaterialsBumpExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFLightsExtension(parser);
        });
        this.register(function(parser) {
            return new GLTFMeshoptCompression(parser);
        });
        this.register(function(parser) {
            return new GLTFMeshGpuInstancing(parser);
        });
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        let resourcePath;
        if (this.resourcePath !== "") {
            resourcePath = this.resourcePath;
        } else if (this.path !== "") {
            const relativeUrl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url);
            resourcePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].resolveURL(relativeUrl, this.path);
        } else {
            resourcePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url);
        }
        this.manager.itemStart(url);
        const _onError = function(e) {
            if (onError) {
                onError(e);
            } else {
                console.error(e);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        };
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(data) {
            try {
                scope.parse(data, resourcePath, function(gltf) {
                    onLoad(gltf);
                    scope.manager.itemEnd(url);
                }, _onError);
            } catch (e) {
                _onError(e);
            }
        }, onProgress, _onError);
    }
    setDRACOLoader(dracoLoader) {
        this.dracoLoader = dracoLoader;
        return this;
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(ktx2Loader) {
        this.ktx2Loader = ktx2Loader;
        return this;
    }
    setMeshoptDecoder(meshoptDecoder) {
        this.meshoptDecoder = meshoptDecoder;
        return this;
    }
    register(callback) {
        if (this.pluginCallbacks.indexOf(callback) === -1) {
            this.pluginCallbacks.push(callback);
        }
        return this;
    }
    unregister(callback) {
        if (this.pluginCallbacks.indexOf(callback) !== -1) {
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
        }
        return this;
    }
    parse(data, path, onLoad, onError) {
        let json;
        const extensions = {};
        const plugins = {};
        if (typeof data === "string") {
            json = JSON.parse(data);
        } else if (data instanceof ArrayBuffer) {
            const magic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data.slice(0, 4)));
            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
                try {
                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
                } catch (error) {
                    if (onError) onError(error);
                    return;
                }
                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
            } else {
                json = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data)));
            }
        } else {
            json = data;
        }
        if (json.asset === void 0 || json.asset.version[0] < 2) {
            if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
        }
        const parser = new GLTFParser(json, {
            path: path || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        parser.fileLoader.setRequestHeader(this.requestHeader);
        for(let i = 0; i < this.pluginCallbacks.length; i++){
            const plugin = this.pluginCallbacks[i](parser);
            if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
            plugins[plugin.name] = plugin;
            extensions[plugin.name] = true;
        }
        if (json.extensionsUsed) {
            for(let i = 0; i < json.extensionsUsed.length; ++i){
                const extensionName = json.extensionsUsed[i];
                const extensionsRequired = json.extensionsRequired || [];
                switch(extensionName){
                    case EXTENSIONS.KHR_MATERIALS_UNLIT:
                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                        break;
                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                        break;
                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                        extensions[extensionName] = new GLTFTextureTransformExtension();
                        break;
                    case EXTENSIONS.KHR_MESH_QUANTIZATION:
                        extensions[extensionName] = new GLTFMeshQuantizationExtension();
                        break;
                    default:
                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                            console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                        }
                }
            }
        }
        parser.setExtensions(extensions);
        parser.setPlugins(plugins);
        parser.parse(onLoad, onError);
    }
    parseAsync(data, path) {
        const scope = this;
        return new Promise(function(resolve, reject) {
            scope.parse(data, path, resolve, reject);
        });
    }
}
function GLTFRegistry() {
    let objects = {};
    return {
        get: function(key) {
            return objects[key];
        },
        add: function(key, object) {
            objects[key] = object;
        },
        remove: function(key) {
            delete objects[key];
        },
        removeAll: function() {
            objects = {};
        }
    };
}
const EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
        this.cache = {
            refs: {},
            uses: {}
        };
    }
    _markDefs() {
        const parser = this.parser;
        const nodeDefs = this.parser.json.nodes || [];
        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
            }
        }
    }
    _loadLight(lightIndex) {
        const parser = this.parser;
        const cacheKey = "light:" + lightIndex;
        let dependency = parser.cache.get(cacheKey);
        if (dependency) return dependency;
        const json = parser.json;
        const extensions = json.extensions && json.extensions[this.name] || {};
        const lightDefs = extensions.lights || [];
        const lightDef = lightDefs[lightIndex];
        let lightNode;
        const color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](16777215);
        if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
        const range = lightDef.range !== void 0 ? lightDef.range : 0;
        switch(lightDef.type){
            case "directional":
                lightNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DirectionalLight"](color);
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;
            case "point":
                lightNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"](color);
                lightNode.distance = range;
                break;
            case "spot":
                lightNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpotLight"](color);
                lightNode.distance = range;
                lightDef.spot = lightDef.spot || {};
                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
                lightNode.angle = lightDef.spot.outerConeAngle;
                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
        }
        lightNode.position.set(0, 0, 0);
        lightNode.decay = 2;
        assignExtrasToUserData(lightNode, lightDef);
        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
        lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
        dependency = Promise.resolve(lightNode);
        parser.cache.add(cacheKey, dependency);
        return dependency;
    }
    getDependency(type, index) {
        if (type !== "light") return;
        return this._loadLight(index);
    }
    createNodeAttachment(nodeIndex) {
        const self2 = this;
        const parser = this.parser;
        const json = parser.json;
        const nodeDef = json.nodes[nodeIndex];
        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
        const lightIndex = lightDef.light;
        if (lightIndex === void 0) return null;
        return this._loadLight(lightIndex).then(function(light) {
            return parser._getNodeRef(self2.cache, lightIndex, light);
        });
    }
}
class GLTFMaterialsUnlitExtension {
    constructor(){
        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"];
    }
    extendParams(materialParams, materialDef, parser) {
        const pending = [];
        materialParams.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](1, 1, 1);
        materialParams.opacity = 1;
        const metallicRoughness = materialDef.pbrMetallicRoughness;
        if (metallicRoughness) {
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
                const array = metallicRoughness.baseColorFactor;
                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
                materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
                pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
            }
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsEmissiveStrengthExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
        if (emissiveStrength !== void 0) {
            materialParams.emissiveIntensity = emissiveStrength;
        }
        return Promise.resolve();
    }
}
class GLTFMaterialsClearcoatExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        if (extension.clearcoatFactor !== void 0) {
            materialParams.clearcoat = extension.clearcoatFactor;
        }
        if (extension.clearcoatTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
        }
        if (extension.clearcoatRoughnessFactor !== void 0) {
            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
        }
        if (extension.clearcoatRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
        }
        if (extension.clearcoatNormalTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
            if (extension.clearcoatNormalTexture.scale !== void 0) {
                const scale = extension.clearcoatNormalTexture.scale;
                materialParams.clearcoatNormalScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](scale, scale);
            }
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsDispersionExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const extension = materialDef.extensions[this.name];
        materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
        return Promise.resolve();
    }
}
class GLTFMaterialsIridescenceExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        if (extension.iridescenceFactor !== void 0) {
            materialParams.iridescence = extension.iridescenceFactor;
        }
        if (extension.iridescenceTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
        }
        if (extension.iridescenceIor !== void 0) {
            materialParams.iridescenceIOR = extension.iridescenceIor;
        }
        if (materialParams.iridescenceThicknessRange === void 0) {
            materialParams.iridescenceThicknessRange = [
                100,
                400
            ];
        }
        if (extension.iridescenceThicknessMinimum !== void 0) {
            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
        }
        if (extension.iridescenceThicknessMaximum !== void 0) {
            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
        }
        if (extension.iridescenceThicknessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsSheenExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        materialParams.sheenColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](0, 0, 0);
        materialParams.sheenRoughness = 0;
        materialParams.sheen = 1;
        const extension = materialDef.extensions[this.name];
        if (extension.sheenColorFactor !== void 0) {
            const colorFactor = extension.sheenColorFactor;
            materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
        }
        if (extension.sheenRoughnessFactor !== void 0) {
            materialParams.sheenRoughness = extension.sheenRoughnessFactor;
        }
        if (extension.sheenColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
        }
        if (extension.sheenRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsTransmissionExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        if (extension.transmissionFactor !== void 0) {
            materialParams.transmission = extension.transmissionFactor;
        }
        if (extension.transmissionTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsVolumeExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
        if (extension.thicknessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
        }
        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
        const colorArray = extension.attenuationColor || [
            1,
            1,
            1
        ];
        materialParams.attenuationColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
        return Promise.all(pending);
    }
}
class GLTFMaterialsIorExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_IOR;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const extension = materialDef.extensions[this.name];
        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
        return Promise.resolve();
    }
}
class GLTFMaterialsSpecularExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
        if (extension.specularTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
        }
        const colorArray = extension.specularColorFactor || [
            1,
            1,
            1
        ];
        materialParams.specularColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
        if (extension.specularColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsBumpExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
        if (extension.bumpTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFMaterialsAnisotropyExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
    }
    getMaterialType(materialIndex) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
    }
    extendMaterialParams(materialIndex, materialParams) {
        const parser = this.parser;
        const materialDef = parser.json.materials[materialIndex];
        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
        }
        const pending = [];
        const extension = materialDef.extensions[this.name];
        if (extension.anisotropyStrength !== void 0) {
            materialParams.anisotropy = extension.anisotropyStrength;
        }
        if (extension.anisotropyRotation !== void 0) {
            materialParams.anisotropyRotation = extension.anisotropyRotation;
        }
        if (extension.anisotropyTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
        }
        return Promise.all(pending);
    }
}
class GLTFTextureBasisUExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }
    loadTexture(textureIndex) {
        const parser = this.parser;
        const json = parser.json;
        const textureDef = json.textures[textureIndex];
        if (!textureDef.extensions || !textureDef.extensions[this.name]) {
            return null;
        }
        const extension = textureDef.extensions[this.name];
        const loader = parser.options.ktx2Loader;
        if (!loader) {
            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            } else {
                return null;
            }
        }
        return parser.loadTextureImage(textureIndex, extension.source, loader);
    }
}
class GLTFTextureWebPExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
        this.isSupported = null;
    }
    loadTexture(textureIndex) {
        const name = this.name;
        const parser = this.parser;
        const json = parser.json;
        const textureDef = json.textures[textureIndex];
        if (!textureDef.extensions || !textureDef.extensions[name]) {
            return null;
        }
        const extension = textureDef.extensions[name];
        const source = json.images[extension.source];
        let loader = parser.textureLoader;
        if (source.uri) {
            const handler = parser.options.manager.getHandler(source.uri);
            if (handler !== null) loader = handler;
        }
        return this.detectSupport().then(function(isSupported) {
            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            }
            return parser.loadTexture(textureIndex);
        });
    }
    detectSupport() {
        if (!this.isSupported) {
            this.isSupported = new Promise(function(resolve) {
                const image = new Image();
                image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
                image.onload = image.onerror = function() {
                    resolve(image.height === 1);
                };
            });
        }
        return this.isSupported;
    }
}
class GLTFTextureAVIFExtension {
    constructor(parser){
        this.parser = parser;
        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
        this.isSupported = null;
    }
    loadTexture(textureIndex) {
        const name = this.name;
        const parser = this.parser;
        const json = parser.json;
        const textureDef = json.textures[textureIndex];
        if (!textureDef.extensions || !textureDef.extensions[name]) {
            return null;
        }
        const extension = textureDef.extensions[name];
        const source = json.images[extension.source];
        let loader = parser.textureLoader;
        if (source.uri) {
            const handler = parser.options.manager.getHandler(source.uri);
            if (handler !== null) loader = handler;
        }
        return this.detectSupport().then(function(isSupported) {
            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            }
            return parser.loadTexture(textureIndex);
        });
    }
    detectSupport() {
        if (!this.isSupported) {
            this.isSupported = new Promise(function(resolve) {
                const image = new Image();
                image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
                image.onload = image.onerror = function() {
                    resolve(image.height === 1);
                };
            });
        }
        return this.isSupported;
    }
}
class GLTFMeshoptCompression {
    constructor(parser){
        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
        this.parser = parser;
    }
    loadBufferView(index) {
        const json = this.parser.json;
        const bufferView = json.bufferViews[index];
        if (bufferView.extensions && bufferView.extensions[this.name]) {
            const extensionDef = bufferView.extensions[this.name];
            const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
            const decoder = this.parser.options.meshoptDecoder;
            if (!decoder || !decoder.supported) {
                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                } else {
                    return null;
                }
            }
            return buffer.then(function(res) {
                const byteOffset = extensionDef.byteOffset || 0;
                const byteLength = extensionDef.byteLength || 0;
                const count = extensionDef.count;
                const stride = extensionDef.byteStride;
                const source = new Uint8Array(res, byteOffset, byteLength);
                if (decoder.decodeGltfBufferAsync) {
                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
                        return res2.buffer;
                    });
                } else {
                    return decoder.ready.then(function() {
                        const result = new ArrayBuffer(count * stride);
                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
                        return result;
                    });
                }
            });
        } else {
            return null;
        }
    }
}
class GLTFMeshGpuInstancing {
    constructor(parser){
        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
        this.parser = parser;
    }
    createNodeMesh(nodeIndex) {
        const json = this.parser.json;
        const nodeDef = json.nodes[nodeIndex];
        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
            return null;
        }
        const meshDef = json.meshes[nodeDef.mesh];
        for (const primitive of meshDef.primitives){
            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
                return null;
            }
        }
        const extensionDef = nodeDef.extensions[this.name];
        const attributesDef = extensionDef.attributes;
        const pending = [];
        const attributes = {};
        for(const key in attributesDef){
            pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor)=>{
                attributes[key] = accessor;
                return attributes[key];
            }));
        }
        if (pending.length < 1) {
            return null;
        }
        pending.push(this.parser.createNodeMesh(nodeIndex));
        return Promise.all(pending).then((results)=>{
            const nodeObject = results.pop();
            const meshes = nodeObject.isGroup ? nodeObject.children : [
                nodeObject
            ];
            const count = results[0].count;
            const instancedMeshes = [];
            for (const mesh of meshes){
                const m = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                const p = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                const q = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
                const s = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1);
                const instancedMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedMesh"](mesh.geometry, mesh.material, count);
                for(let i = 0; i < count; i++){
                    if (attributes.TRANSLATION) {
                        p.fromBufferAttribute(attributes.TRANSLATION, i);
                    }
                    if (attributes.ROTATION) {
                        q.fromBufferAttribute(attributes.ROTATION, i);
                    }
                    if (attributes.SCALE) {
                        s.fromBufferAttribute(attributes.SCALE, i);
                    }
                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));
                }
                for(const attributeName in attributes){
                    if (attributeName === "_COLOR_0") {
                        const attr = attributes[attributeName];
                        instancedMesh.instanceColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedBufferAttribute"](attr.array, attr.itemSize, attr.normalized);
                    } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
                    }
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"].prototype.copy.call(instancedMesh, mesh);
                this.parser.assignFinalMaterial(instancedMesh);
                instancedMeshes.push(instancedMesh);
            }
            if (nodeObject.isGroup) {
                nodeObject.clear();
                nodeObject.add(...instancedMeshes);
                return nodeObject;
            }
            return instancedMeshes[0];
        });
    }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 1313821514,
    BIN: 5130562
};
class GLTFBinaryExtension {
    constructor(data){
        this.name = EXTENSIONS.KHR_BINARY_GLTF;
        this.content = null;
        this.body = null;
        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
        this.header = {
            magic: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data.slice(0, 4))),
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
        };
        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        } else if (this.header.version < 2) {
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        }
        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
        let chunkIndex = 0;
        while(chunkIndex < chunkContentsLength){
            const chunkLength = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            const chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
                this.content = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(contentArray);
            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                this.body = data.slice(byteOffset, byteOffset + chunkLength);
            }
            chunkIndex += chunkLength;
        }
        if (this.content === null) {
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
    }
}
class GLTFDracoMeshCompressionExtension {
    constructor(json, dracoLoader){
        if (!dracoLoader) {
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        }
        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
        this.json = json;
        this.dracoLoader = dracoLoader;
        this.dracoLoader.preload();
    }
    decodePrimitive(primitive, parser) {
        const json = this.json;
        const dracoLoader = this.dracoLoader;
        const bufferViewIndex = primitive.extensions[this.name].bufferView;
        const gltfAttributeMap = primitive.extensions[this.name].attributes;
        const threeAttributeMap = {};
        const attributeNormalizedMap = {};
        const attributeTypeMap = {};
        for(const attributeName in gltfAttributeMap){
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
        }
        for(const attributeName in primitive.attributes){
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            if (gltfAttributeMap[attributeName] !== void 0) {
                const accessorDef = json.accessors[primitive.attributes[attributeName]];
                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                attributeTypeMap[threeAttributeName] = componentType.name;
                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
            }
        }
        return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
            return new Promise(function(resolve, reject) {
                dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                    for(const attributeName in geometry.attributes){
                        const attribute = geometry.attributes[attributeName];
                        const normalized = attributeNormalizedMap[attributeName];
                        if (normalized !== void 0) attribute.normalized = normalized;
                    }
                    resolve(geometry);
                }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
            });
        });
    }
}
class GLTFTextureTransformExtension {
    constructor(){
        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(texture, transform) {
        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
            return texture;
        }
        texture = texture.clone();
        if (transform.texCoord !== void 0) {
            texture.channel = transform.texCoord;
        }
        if (transform.offset !== void 0) {
            texture.offset.fromArray(transform.offset);
        }
        if (transform.rotation !== void 0) {
            texture.rotation = transform.rotation;
        }
        if (transform.scale !== void 0) {
            texture.repeat.fromArray(transform.scale);
        }
        texture.needsUpdate = true;
        return texture;
    }
}
class GLTFMeshQuantizationExtension {
    constructor(){
        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    }
}
class GLTFCubicSplineInterpolant extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Interpolant"] {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    copySampleValue_(index) {
        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
        for(let i = 0; i !== valueSize; i++){
            result[i] = values[offset + i];
        }
        return result;
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer;
        const values = this.sampleValues;
        const stride = this.valueSize;
        const stride2 = stride * 2;
        const stride3 = stride * 3;
        const td = t1 - t0;
        const p = (t - t0) / td;
        const pp = p * p;
        const ppp = pp * p;
        const offset1 = i1 * stride3;
        const offset0 = offset1 - stride3;
        const s2 = -2 * ppp + 3 * pp;
        const s3 = ppp - pp;
        const s0 = 1 - s2;
        const s1 = s3 - pp + p;
        for(let i = 0; i !== stride; i++){
            const p0 = values[offset0 + i + stride];
            const m0 = values[offset0 + i + stride2] * td;
            const p1 = values[offset1 + i + stride];
            const m1 = values[offset1 + i] * td;
            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
        }
        return result;
    }
}
const _q = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
    interpolate_(i1, t0, t, t1) {
        const result = super.interpolate_(i1, t0, t, t1);
        _q.fromArray(result).normalize().toArray(result);
        return result;
    }
}
const WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
};
const WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
};
const WEBGL_FILTERS = {
    9728: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"],
    9729: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"],
    9984: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestMipmapNearestFilter"],
    9985: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapNearestFilter"],
    9986: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestMipmapLinearFilter"],
    9987: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"]
};
const WEBGL_WRAPPINGS = {
    33071: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"],
    33648: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MirroredRepeatWrapping"],
    10497: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"]
};
const WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
};
const ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    // uv => uv1, 4 uv channels
    // https://github.com/mrdoob/three.js/pull/25943
    // https://github.com/mrdoob/three.js/pull/25788
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 152 ? {
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3"
    } : {
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2"
    },
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
};
const PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
};
const INTERPOLATION = {
    CUBICSPLINE: void 0,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterpolateLinear"],
    STEP: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterpolateDiscrete"]
};
const ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
        cache["DefaultMaterial"] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: false,
            depthTest: true,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"]
        });
    }
    return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for(const name in objectDef.extensions){
        if (knownExtensions[name] === void 0) {
            object.userData.gltfExtensions = object.userData.gltfExtensions || {};
            object.userData.gltfExtensions[name] = objectDef.extensions[name];
        }
    }
}
function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
        if (typeof gltfDef.extras === "object") {
            Object.assign(object.userData, gltfDef.extras);
        } else {
            console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
        }
    }
}
function addMorphTargets(geometry, targets, parser) {
    let hasMorphPosition = false;
    let hasMorphNormal = false;
    let hasMorphColor = false;
    for(let i = 0, il = targets.length; i < il; i++){
        const target = targets[i];
        if (target.POSITION !== void 0) hasMorphPosition = true;
        if (target.NORMAL !== void 0) hasMorphNormal = true;
        if (target.COLOR_0 !== void 0) hasMorphColor = true;
        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
    }
    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
    const pendingPositionAccessors = [];
    const pendingNormalAccessors = [];
    const pendingColorAccessors = [];
    for(let i = 0, il = targets.length; i < il; i++){
        const target = targets[i];
        if (hasMorphPosition) {
            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
            pendingPositionAccessors.push(pendingAccessor);
        }
        if (hasMorphNormal) {
            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
            pendingNormalAccessors.push(pendingAccessor);
        }
        if (hasMorphColor) {
            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
            pendingColorAccessors.push(pendingAccessor);
        }
    }
    return Promise.all([
        Promise.all(pendingPositionAccessors),
        Promise.all(pendingNormalAccessors),
        Promise.all(pendingColorAccessors)
    ]).then(function(accessors) {
        const morphPositions = accessors[0];
        const morphNormals = accessors[1];
        const morphColors = accessors[2];
        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
        if (hasMorphColor) geometry.morphAttributes.color = morphColors;
        geometry.morphTargetsRelative = true;
        return geometry;
    });
}
function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
        for(let i = 0, il = meshDef.weights.length; i < il; i++){
            mesh.morphTargetInfluences[i] = meshDef.weights[i];
        }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
        const targetNames = meshDef.extras.targetNames;
        if (mesh.morphTargetInfluences.length === targetNames.length) {
            mesh.morphTargetDictionary = {};
            for(let i = 0, il = targetNames.length; i < il; i++){
                mesh.morphTargetDictionary[targetNames[i]] = i;
            }
        } else {
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
    }
}
function createPrimitiveKey(primitiveDef) {
    let geometryKey;
    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    if (dracoExtension) {
        geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
        geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    if (primitiveDef.targets !== void 0) {
        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){
            geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
        }
    }
    return geometryKey;
}
function createAttributesKey(attributes) {
    let attributesKey = "";
    const keys = Object.keys(attributes).sort();
    for(let i = 0, il = keys.length; i < il; i++){
        attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
    }
    return attributesKey;
}
function getNormalizedComponentScale(constructor) {
    switch(constructor){
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
}
function getImageURIMimeType(uri) {
    if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
    if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
    return "image/png";
}
const _identityMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
class GLTFParser {
    constructor(json = {}, options = {}){
        this.json = json;
        this.extensions = {};
        this.plugins = {};
        this.options = options;
        this.cache = new GLTFRegistry();
        this.associations = /* @__PURE__ */ new Map();
        this.primitiveCache = {};
        this.nodeCache = {};
        this.meshCache = {
            refs: {},
            uses: {}
        };
        this.cameraCache = {
            refs: {},
            uses: {}
        };
        this.lightCache = {
            refs: {},
            uses: {}
        };
        this.sourceCache = {};
        this.textureCache = {};
        this.nodeNamesUsed = {};
        let isSafari = false;
        let isFirefox = false;
        let firefoxVersion = -1;
        if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
            isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
        }
        if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
            this.textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.options.manager);
        } else {
            this.textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ImageBitmapLoader"](this.options.manager);
        }
        this.textureLoader.setCrossOrigin(this.options.crossOrigin);
        this.textureLoader.setRequestHeader(this.options.requestHeader);
        this.fileLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.options.manager);
        this.fileLoader.setResponseType("arraybuffer");
        if (this.options.crossOrigin === "use-credentials") {
            this.fileLoader.setWithCredentials(true);
        }
    }
    setExtensions(extensions) {
        this.extensions = extensions;
    }
    setPlugins(plugins) {
        this.plugins = plugins;
    }
    parse(onLoad, onError) {
        const parser = this;
        const json = this.json;
        const extensions = this.extensions;
        this.cache.removeAll();
        this.nodeCache = {};
        this._invokeAll(function(ext) {
            return ext._markDefs && ext._markDefs();
        });
        Promise.all(this._invokeAll(function(ext) {
            return ext.beforeRoot && ext.beforeRoot();
        })).then(function() {
            return Promise.all([
                parser.getDependencies("scene"),
                parser.getDependencies("animation"),
                parser.getDependencies("camera")
            ]);
        }).then(function(dependencies) {
            const result = {
                scene: dependencies[0][json.scene || 0],
                scenes: dependencies[0],
                animations: dependencies[1],
                cameras: dependencies[2],
                asset: json.asset,
                parser,
                userData: {}
            };
            addUnknownExtensionsToUserData(extensions, result, json);
            assignExtrasToUserData(result, json);
            return Promise.all(parser._invokeAll(function(ext) {
                return ext.afterRoot && ext.afterRoot(result);
            })).then(function() {
                for (const scene of result.scenes){
                    scene.updateMatrixWorld();
                }
                onLoad(result);
            });
        }).catch(onError);
    }
    /**
   * Marks the special nodes/meshes in json for efficient parse.
   */ _markDefs() {
        const nodeDefs = this.json.nodes || [];
        const skinDefs = this.json.skins || [];
        const meshDefs = this.json.meshes || [];
        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){
            const joints = skinDefs[skinIndex].joints;
            for(let i = 0, il = joints.length; i < il; i++){
                nodeDefs[joints[i]].isBone = true;
            }
        }
        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.mesh !== void 0) {
                this._addNodeRef(this.meshCache, nodeDef.mesh);
                if (nodeDef.skin !== void 0) {
                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;
                }
            }
            if (nodeDef.camera !== void 0) {
                this._addNodeRef(this.cameraCache, nodeDef.camera);
            }
        }
    }
    /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */ _addNodeRef(cache, index) {
        if (index === void 0) return;
        if (cache.refs[index] === void 0) {
            cache.refs[index] = cache.uses[index] = 0;
        }
        cache.refs[index]++;
    }
    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {
        if (cache.refs[index] <= 1) return object;
        const ref = object.clone();
        const updateMappings = (original, clone)=>{
            const mappings = this.associations.get(original);
            if (mappings != null) {
                this.associations.set(clone, mappings);
            }
            for (const [i, child] of original.children.entries()){
                updateMappings(child, clone.children[i]);
            }
        };
        updateMappings(object, ref);
        ref.name += "_instance_" + cache.uses[index]++;
        return ref;
    }
    _invokeOne(func) {
        const extensions = Object.values(this.plugins);
        extensions.push(this);
        for(let i = 0; i < extensions.length; i++){
            const result = func(extensions[i]);
            if (result) return result;
        }
        return null;
    }
    _invokeAll(func) {
        const extensions = Object.values(this.plugins);
        extensions.unshift(this);
        const pending = [];
        for(let i = 0; i < extensions.length; i++){
            const result = func(extensions[i]);
            if (result) pending.push(result);
        }
        return pending;
    }
    /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */ getDependency(type, index) {
        const cacheKey = type + ":" + index;
        let dependency = this.cache.get(cacheKey);
        if (!dependency) {
            switch(type){
                case "scene":
                    dependency = this.loadScene(index);
                    break;
                case "node":
                    dependency = this._invokeOne(function(ext) {
                        return ext.loadNode && ext.loadNode(index);
                    });
                    break;
                case "mesh":
                    dependency = this._invokeOne(function(ext) {
                        return ext.loadMesh && ext.loadMesh(index);
                    });
                    break;
                case "accessor":
                    dependency = this.loadAccessor(index);
                    break;
                case "bufferView":
                    dependency = this._invokeOne(function(ext) {
                        return ext.loadBufferView && ext.loadBufferView(index);
                    });
                    break;
                case "buffer":
                    dependency = this.loadBuffer(index);
                    break;
                case "material":
                    dependency = this._invokeOne(function(ext) {
                        return ext.loadMaterial && ext.loadMaterial(index);
                    });
                    break;
                case "texture":
                    dependency = this._invokeOne(function(ext) {
                        return ext.loadTexture && ext.loadTexture(index);
                    });
                    break;
                case "skin":
                    dependency = this.loadSkin(index);
                    break;
                case "animation":
                    dependency = this._invokeOne(function(ext) {
                        return ext.loadAnimation && ext.loadAnimation(index);
                    });
                    break;
                case "camera":
                    dependency = this.loadCamera(index);
                    break;
                default:
                    dependency = this._invokeOne(function(ext) {
                        return ext != this && ext.getDependency && ext.getDependency(type, index);
                    });
                    if (!dependency) {
                        throw new Error("Unknown type: " + type);
                    }
                    break;
            }
            this.cache.add(cacheKey, dependency);
        }
        return dependency;
    }
    /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */ getDependencies(type) {
        let dependencies = this.cache.get(type);
        if (!dependencies) {
            const parser = this;
            const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
            dependencies = Promise.all(defs.map(function(def, index) {
                return parser.getDependency(type, index);
            }));
            this.cache.add(type, dependencies);
        }
        return dependencies;
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */ loadBuffer(bufferIndex) {
        const bufferDef = this.json.buffers[bufferIndex];
        const loader = this.fileLoader;
        if (bufferDef.type && bufferDef.type !== "arraybuffer") {
            throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
        }
        if (bufferDef.uri === void 0 && bufferIndex === 0) {
            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        }
        const options = this.options;
        return new Promise(function(resolve, reject) {
            loader.load(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
                reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
            });
        });
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */ loadBufferView(bufferViewIndex) {
        const bufferViewDef = this.json.bufferViews[bufferViewIndex];
        return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
            const byteLength = bufferViewDef.byteLength || 0;
            const byteOffset = bufferViewDef.byteOffset || 0;
            return buffer.slice(byteOffset, byteOffset + byteLength);
        });
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */ loadAccessor(accessorIndex) {
        const parser = this;
        const json = this.json;
        const accessorDef = this.json.accessors[accessorIndex];
        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            const normalized = accessorDef.normalized === true;
            const array = new TypedArray(accessorDef.count * itemSize);
            return Promise.resolve(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize, normalized));
        }
        const pendingBufferViews = [];
        if (accessorDef.bufferView !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
        } else {
            pendingBufferViews.push(null);
        }
        if (accessorDef.sparse !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
        }
        return Promise.all(pendingBufferViews).then(function(bufferViews) {
            const bufferView = bufferViews[0];
            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            const elementBytes = TypedArray.BYTES_PER_ELEMENT;
            const itemBytes = elementBytes * itemSize;
            const byteOffset = accessorDef.byteOffset || 0;
            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
            const normalized = accessorDef.normalized === true;
            let array, bufferAttribute;
            if (byteStride && byteStride !== itemBytes) {
                const ibSlice = Math.floor(byteOffset / byteStride);
                const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
                let ib = parser.cache.get(ibCacheKey);
                if (!ib) {
                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
                    ib = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBuffer"](array, byteStride / elementBytes);
                    parser.cache.add(ibCacheKey, ib);
                }
                bufferAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
            } else {
                if (bufferView === null) {
                    array = new TypedArray(accessorDef.count * itemSize);
                } else {
                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
                }
                bufferAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize, normalized);
            }
            if (accessorDef.sparse !== void 0) {
                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
                if (bufferView !== null) {
                    bufferAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
                }
                for(let i = 0, il = sparseIndices.length; i < il; i++){
                    const index = sparseIndices[i];
                    bufferAttribute.setX(index, sparseValues[i * itemSize]);
                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                    if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                }
            }
            return bufferAttribute;
        });
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */ loadTexture(textureIndex) {
        const json = this.json;
        const options = this.options;
        const textureDef = json.textures[textureIndex];
        const sourceIndex = textureDef.source;
        const sourceDef = json.images[sourceIndex];
        let loader = this.textureLoader;
        if (sourceDef.uri) {
            const handler = options.manager.getHandler(sourceDef.uri);
            if (handler !== null) loader = handler;
        }
        return this.loadTextureImage(textureIndex, sourceIndex, loader);
    }
    loadTextureImage(textureIndex, sourceIndex, loader) {
        const parser = this;
        const json = this.json;
        const textureDef = json.textures[textureIndex];
        const sourceDef = json.images[sourceIndex];
        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
        if (this.textureCache[cacheKey]) {
            return this.textureCache[cacheKey];
        }
        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
            texture.flipY = false;
            texture.name = textureDef.name || sourceDef.name || "";
            if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
                texture.name = sourceDef.uri;
            }
            const samplers = json.samplers || {};
            const sampler = samplers[textureDef.sampler] || {};
            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"];
            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
            parser.associations.set(texture, {
                textures: textureIndex
            });
            return texture;
        }).catch(function() {
            return null;
        });
        this.textureCache[cacheKey] = promise;
        return promise;
    }
    loadImageSource(sourceIndex, loader) {
        const parser = this;
        const json = this.json;
        const options = this.options;
        if (this.sourceCache[sourceIndex] !== void 0) {
            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());
        }
        const sourceDef = json.images[sourceIndex];
        const URL = self.URL || self.webkitURL;
        let sourceURI = sourceDef.uri || "";
        let isObjectURL = false;
        if (sourceDef.bufferView !== void 0) {
            sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
                isObjectURL = true;
                const blob = new Blob([
                    bufferView
                ], {
                    type: sourceDef.mimeType
                });
                sourceURI = URL.createObjectURL(blob);
                return sourceURI;
            });
        } else if (sourceDef.uri === void 0) {
            throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
        }
        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
            return new Promise(function(resolve, reject) {
                let onLoad = resolve;
                if (loader.isImageBitmapLoader === true) {
                    onLoad = function(imageBitmap) {
                        const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](imageBitmap);
                        texture.needsUpdate = true;
                        resolve(texture);
                    };
                }
                loader.load(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
            });
        }).then(function(texture) {
            if (isObjectURL === true) {
                URL.revokeObjectURL(sourceURI);
            }
            assignExtrasToUserData(texture, sourceDef);
            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
            return texture;
        }).catch(function(error) {
            console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
            throw error;
        });
        this.sourceCache[sourceIndex] = promise;
        return promise;
    }
    /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */ assignTexture(materialParams, mapName, mapDef, colorSpace) {
        const parser = this;
        return this.getDependency("texture", mapDef.index).then(function(texture) {
            if (!texture) return null;
            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
                texture = texture.clone();
                texture.channel = mapDef.texCoord;
            }
            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
                if (transform) {
                    const gltfReference = parser.associations.get(texture);
                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                    parser.associations.set(texture, gltfReference);
                }
            }
            if (colorSpace !== void 0) {
                if (typeof colorSpace === "number") colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
                if ("colorSpace" in texture) texture.colorSpace = colorSpace;
                else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
            }
            materialParams[mapName] = texture;
            return texture;
        });
    }
    /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */ assignFinalMaterial(mesh) {
        const geometry = mesh.geometry;
        let material = mesh.material;
        const useDerivativeTangents = geometry.attributes.tangent === void 0;
        const useVertexColors = geometry.attributes.color !== void 0;
        const useFlatShading = geometry.attributes.normal === void 0;
        if (mesh.isPoints) {
            const cacheKey = "PointsMaterial:" + material.uuid;
            let pointsMaterial = this.cache.get(cacheKey);
            if (!pointsMaterial) {
                pointsMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].prototype.copy.call(pointsMaterial, material);
                pointsMaterial.color.copy(material.color);
                pointsMaterial.map = material.map;
                pointsMaterial.sizeAttenuation = false;
                this.cache.add(cacheKey, pointsMaterial);
            }
            material = pointsMaterial;
        } else if (mesh.isLine) {
            const cacheKey = "LineBasicMaterial:" + material.uuid;
            let lineMaterial = this.cache.get(cacheKey);
            if (!lineMaterial) {
                lineMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].prototype.copy.call(lineMaterial, material);
                lineMaterial.color.copy(material.color);
                lineMaterial.map = material.map;
                this.cache.add(cacheKey, lineMaterial);
            }
            material = lineMaterial;
        }
        if (useDerivativeTangents || useVertexColors || useFlatShading) {
            let cacheKey = "ClonedMaterial:" + material.uuid + ":";
            if (useDerivativeTangents) cacheKey += "derivative-tangents:";
            if (useVertexColors) cacheKey += "vertex-colors:";
            if (useFlatShading) cacheKey += "flat-shading:";
            let cachedMaterial = this.cache.get(cacheKey);
            if (!cachedMaterial) {
                cachedMaterial = material.clone();
                if (useVertexColors) cachedMaterial.vertexColors = true;
                if (useFlatShading) cachedMaterial.flatShading = true;
                if (useDerivativeTangents) {
                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
                }
                this.cache.add(cacheKey, cachedMaterial);
                this.associations.set(cachedMaterial, this.associations.get(material));
            }
            material = cachedMaterial;
        }
        mesh.material = material;
    }
    getMaterialType() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"];
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */ loadMaterial(materialIndex) {
        const parser = this;
        const json = this.json;
        const extensions = this.extensions;
        const materialDef = json.materials[materialIndex];
        let materialType;
        const materialParams = {};
        const materialExtensions = materialDef.extensions || {};
        const pending = [];
        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
            materialType = kmuExtension.getMaterialType();
            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
        } else {
            const metallicRoughness = materialDef.pbrMetallicRoughness || {};
            materialParams.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](1, 1, 1);
            materialParams.opacity = 1;
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
                const array = metallicRoughness.baseColorFactor;
                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
                materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
                pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
            }
            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
            if (metallicRoughness.metallicRoughnessTexture !== void 0) {
                pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
                pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
            }
            materialType = this._invokeOne(function(ext) {
                return ext.getMaterialType && ext.getMaterialType(materialIndex);
            });
            pending.push(Promise.all(this._invokeAll(function(ext) {
                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
            })));
        }
        if (materialDef.doubleSided === true) {
            materialParams.side = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"];
        }
        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
        if (alphaMode === ALPHA_MODES.BLEND) {
            materialParams.transparent = true;
            materialParams.depthWrite = false;
        } else {
            materialParams.transparent = false;
            if (alphaMode === ALPHA_MODES.MASK) {
                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
            }
        }
        if (materialDef.normalTexture !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
            pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
            materialParams.normalScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](1, 1);
            if (materialDef.normalTexture.scale !== void 0) {
                const scale = materialDef.normalTexture.scale;
                materialParams.normalScale.set(scale, scale);
            }
        }
        if (materialDef.occlusionTexture !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
            pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
            if (materialDef.occlusionTexture.strength !== void 0) {
                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
            }
        }
        if (materialDef.emissiveFactor !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
            const emissiveFactor = materialDef.emissiveFactor;
            materialParams.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
        }
        if (materialDef.emissiveTexture !== void 0 && materialType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
            pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
        }
        return Promise.all(pending).then(function() {
            const material = new materialType(materialParams);
            if (materialDef.name) material.name = materialDef.name;
            assignExtrasToUserData(material, materialDef);
            parser.associations.set(material, {
                materials: materialIndex
            });
            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
            return material;
        });
    }
    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {
        const sanitizedName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PropertyBinding"].sanitizeNodeName(originalName || "");
        if (sanitizedName in this.nodeNamesUsed) {
            return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
        } else {
            this.nodeNamesUsed[sanitizedName] = 0;
            return sanitizedName;
        }
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */ loadGeometries(primitives) {
        const parser = this;
        const extensions = this.extensions;
        const cache = this.primitiveCache;
        function createDracoPrimitive(primitive) {
            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
                return addPrimitiveAttributes(geometry, primitive, parser);
            });
        }
        const pending = [];
        for(let i = 0, il = primitives.length; i < il; i++){
            const primitive = primitives[i];
            const cacheKey = createPrimitiveKey(primitive);
            const cached = cache[cacheKey];
            if (cached) {
                pending.push(cached.promise);
            } else {
                let geometryPromise;
                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
                    geometryPromise = createDracoPrimitive(primitive);
                } else {
                    geometryPromise = addPrimitiveAttributes(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"](), primitive, parser);
                }
                cache[cacheKey] = {
                    primitive,
                    promise: geometryPromise
                };
                pending.push(geometryPromise);
            }
        }
        return Promise.all(pending);
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */ loadMesh(meshIndex) {
        const parser = this;
        const json = this.json;
        const extensions = this.extensions;
        const meshDef = json.meshes[meshIndex];
        const primitives = meshDef.primitives;
        const pending = [];
        for(let i = 0, il = primitives.length; i < il; i++){
            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
            pending.push(material);
        }
        pending.push(parser.loadGeometries(primitives));
        return Promise.all(pending).then(function(results) {
            const materials = results.slice(0, results.length - 1);
            const geometries = results[results.length - 1];
            const meshes = [];
            for(let i = 0, il = geometries.length; i < il; i++){
                const geometry = geometries[i];
                const primitive = primitives[i];
                let mesh;
                const material = materials[i];
                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
                    mesh = meshDef.isSkinnedMesh === true ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkinnedMesh"](geometry, material) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material);
                    if (mesh.isSkinnedMesh === true) {
                        mesh.normalizeSkinWeights();
                    }
                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                        mesh.geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toTrianglesDrawMode"])(mesh.geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleStripDrawMode"]);
                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                        mesh.geometry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$utils$2f$BufferGeometryUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toTrianglesDrawMode"])(mesh.geometry, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TriangleFanDrawMode"]);
                    }
                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
                    mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](geometry, material);
                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
                    mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](geometry, material);
                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
                    mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineLoop"](geometry, material);
                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
                    mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](geometry, material);
                } else {
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
                }
                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
                    updateMorphTargets(mesh, meshDef);
                }
                mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
                assignExtrasToUserData(mesh, meshDef);
                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
                parser.assignFinalMaterial(mesh);
                meshes.push(mesh);
            }
            for(let i = 0, il = meshes.length; i < il; i++){
                parser.associations.set(meshes[i], {
                    meshes: meshIndex,
                    primitives: i
                });
            }
            if (meshes.length === 1) {
                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
                return meshes[0];
            }
            const group = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
            parser.associations.set(group, {
                meshes: meshIndex
            });
            for(let i = 0, il = meshes.length; i < il; i++){
                group.add(meshes[i]);
            }
            return group;
        });
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */ loadCamera(cameraIndex) {
        let camera;
        const cameraDef = this.json.cameras[cameraIndex];
        const params = cameraDef[cameraDef.type];
        if (!params) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
        }
        if (cameraDef.type === "perspective") {
            camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
        } else if (cameraDef.type === "orthographic") {
            camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
        }
        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
        assignExtrasToUserData(camera, cameraDef);
        return Promise.resolve(camera);
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */ loadSkin(skinIndex) {
        const skinDef = this.json.skins[skinIndex];
        const pending = [];
        for(let i = 0, il = skinDef.joints.length; i < il; i++){
            pending.push(this._loadNodeShallow(skinDef.joints[i]));
        }
        if (skinDef.inverseBindMatrices !== void 0) {
            pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
        } else {
            pending.push(null);
        }
        return Promise.all(pending).then(function(results) {
            const inverseBindMatrices = results.pop();
            const jointNodes = results;
            const bones = [];
            const boneInverses = [];
            for(let i = 0, il = jointNodes.length; i < il; i++){
                const jointNode = jointNodes[i];
                if (jointNode) {
                    bones.push(jointNode);
                    const mat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                    if (inverseBindMatrices !== null) {
                        mat.fromArray(inverseBindMatrices.array, i * 16);
                    }
                    boneInverses.push(mat);
                } else {
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
                }
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Skeleton"](bones, boneInverses);
        });
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */ loadAnimation(animationIndex) {
        const json = this.json;
        const parser = this;
        const animationDef = json.animations[animationIndex];
        const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
        const pendingNodes = [];
        const pendingInputAccessors = [];
        const pendingOutputAccessors = [];
        const pendingSamplers = [];
        const pendingTargets = [];
        for(let i = 0, il = animationDef.channels.length; i < il; i++){
            const channel = animationDef.channels[i];
            const sampler = animationDef.samplers[channel.sampler];
            const target = channel.target;
            const name = target.node;
            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
            if (target.node === void 0) continue;
            pendingNodes.push(this.getDependency("node", name));
            pendingInputAccessors.push(this.getDependency("accessor", input));
            pendingOutputAccessors.push(this.getDependency("accessor", output));
            pendingSamplers.push(sampler);
            pendingTargets.push(target);
        }
        return Promise.all([
            Promise.all(pendingNodes),
            Promise.all(pendingInputAccessors),
            Promise.all(pendingOutputAccessors),
            Promise.all(pendingSamplers),
            Promise.all(pendingTargets)
        ]).then(function(dependencies) {
            const nodes = dependencies[0];
            const inputAccessors = dependencies[1];
            const outputAccessors = dependencies[2];
            const samplers = dependencies[3];
            const targets = dependencies[4];
            const tracks = [];
            for(let i = 0, il = nodes.length; i < il; i++){
                const node = nodes[i];
                const inputAccessor = inputAccessors[i];
                const outputAccessor = outputAccessors[i];
                const sampler = samplers[i];
                const target = targets[i];
                if (node === void 0) continue;
                if (node.updateMatrix) {
                    node.updateMatrix();
                }
                const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
                if (createdTracks) {
                    for(let k = 0; k < createdTracks.length; k++){
                        tracks.push(createdTracks[k]);
                    }
                }
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"](animationName, void 0, tracks);
        });
    }
    createNodeMesh(nodeIndex) {
        const json = this.json;
        const parser = this;
        const nodeDef = json.nodes[nodeIndex];
        if (nodeDef.mesh === void 0) return null;
        return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
            if (nodeDef.weights !== void 0) {
                node.traverse(function(o) {
                    if (!o.isMesh) return;
                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){
                        o.morphTargetInfluences[i] = nodeDef.weights[i];
                    }
                });
            }
            return node;
        });
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */ loadNode(nodeIndex) {
        const json = this.json;
        const parser = this;
        const nodeDef = json.nodes[nodeIndex];
        const nodePending = parser._loadNodeShallow(nodeIndex);
        const childPending = [];
        const childrenDef = nodeDef.children || [];
        for(let i = 0, il = childrenDef.length; i < il; i++){
            childPending.push(parser.getDependency("node", childrenDef[i]));
        }
        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
        return Promise.all([
            nodePending,
            Promise.all(childPending),
            skeletonPending
        ]).then(function(results) {
            const node = results[0];
            const children = results[1];
            const skeleton = results[2];
            if (skeleton !== null) {
                node.traverse(function(mesh) {
                    if (!mesh.isSkinnedMesh) return;
                    mesh.bind(skeleton, _identityMatrix);
                });
            }
            for(let i = 0, il = children.length; i < il; i++){
                node.add(children[i]);
            }
            return node;
        });
    }
    // ._loadNodeShallow() parses a single node.
    // skin and child nodes are created and added in .loadNode() (no '_' prefix).
    _loadNodeShallow(nodeIndex) {
        const json = this.json;
        const extensions = this.extensions;
        const parser = this;
        if (this.nodeCache[nodeIndex] !== void 0) {
            return this.nodeCache[nodeIndex];
        }
        const nodeDef = json.nodes[nodeIndex];
        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
        const pending = [];
        const meshPromise = parser._invokeOne(function(ext) {
            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
        });
        if (meshPromise) {
            pending.push(meshPromise);
        }
        if (nodeDef.camera !== void 0) {
            pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
            }));
        }
        parser._invokeAll(function(ext) {
            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
        }).forEach(function(promise) {
            pending.push(promise);
        });
        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
            let node;
            if (nodeDef.isBone === true) {
                node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]();
            } else if (objects.length > 1) {
                node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            } else if (objects.length === 1) {
                node = objects[0];
            } else {
                node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
            }
            if (node !== objects[0]) {
                for(let i = 0, il = objects.length; i < il; i++){
                    node.add(objects[i]);
                }
            }
            if (nodeDef.name) {
                node.userData.name = nodeDef.name;
                node.name = nodeName;
            }
            assignExtrasToUserData(node, nodeDef);
            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
            if (nodeDef.matrix !== void 0) {
                const matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                matrix.fromArray(nodeDef.matrix);
                node.applyMatrix4(matrix);
            } else {
                if (nodeDef.translation !== void 0) {
                    node.position.fromArray(nodeDef.translation);
                }
                if (nodeDef.rotation !== void 0) {
                    node.quaternion.fromArray(nodeDef.rotation);
                }
                if (nodeDef.scale !== void 0) {
                    node.scale.fromArray(nodeDef.scale);
                }
            }
            if (!parser.associations.has(node)) {
                parser.associations.set(node, {});
            }
            parser.associations.get(node).nodes = nodeIndex;
            return node;
        });
        return this.nodeCache[nodeIndex];
    }
    /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */ loadScene(sceneIndex) {
        const extensions = this.extensions;
        const sceneDef = this.json.scenes[sceneIndex];
        const parser = this;
        const scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
        assignExtrasToUserData(scene, sceneDef);
        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
        const nodeIds = sceneDef.nodes || [];
        const pending = [];
        for(let i = 0, il = nodeIds.length; i < il; i++){
            pending.push(parser.getDependency("node", nodeIds[i]));
        }
        return Promise.all(pending).then(function(nodes) {
            for(let i = 0, il = nodes.length; i < il; i++){
                scene.add(nodes[i]);
            }
            const reduceAssociations = (node)=>{
                const reducedAssociations = /* @__PURE__ */ new Map();
                for (const [key, value] of parser.associations){
                    if (key instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"] || key instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
                        reducedAssociations.set(key, value);
                    }
                }
                node.traverse((node2)=>{
                    const mappings = parser.associations.get(node2);
                    if (mappings != null) {
                        reducedAssociations.set(node2, mappings);
                    }
                });
                return reducedAssociations;
            };
            parser.associations = reduceAssociations(scene);
            return scene;
        });
    }
    _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
        const tracks = [];
        const targetName = node.name ? node.name : node.uuid;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
            node.traverse(function(object) {
                if (object.morphTargetInfluences) {
                    targetNames.push(object.name ? object.name : object.uuid);
                }
            });
        } else {
            targetNames.push(targetName);
        }
        let TypedKeyframeTrack;
        switch(PATH_PROPERTIES[target.path]){
            case PATH_PROPERTIES.weights:
                TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"];
                break;
            case PATH_PROPERTIES.rotation:
                TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"];
                break;
            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
                TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"];
                break;
            default:
                switch(outputAccessor.itemSize){
                    case 1:
                        TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"];
                        break;
                    case 2:
                    case 3:
                    default:
                        TypedKeyframeTrack = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"];
                        break;
                }
                break;
        }
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterpolateLinear"];
        const outputArray = this._getArrayFromAccessor(outputAccessor);
        for(let j = 0, jl = targetNames.length; j < jl; j++){
            const track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
            if (sampler.interpolation === "CUBICSPLINE") {
                this._createCubicSplineTrackInterpolant(track);
            }
            tracks.push(track);
        }
        return tracks;
    }
    _getArrayFromAccessor(accessor) {
        let outputArray = accessor.array;
        if (accessor.normalized) {
            const scale = getNormalizedComponentScale(outputArray.constructor);
            const scaled = new Float32Array(outputArray.length);
            for(let j = 0, jl = outputArray.length; j < jl; j++){
                scaled[j] = outputArray[j] * scale;
            }
            outputArray = scaled;
        }
        return outputArray;
    }
    _createCubicSplineTrackInterpolant(track) {
        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
            const interpolantType = this instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"] ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
        };
        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
    }
}
function computeBounds(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const box = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
    if (attributes.POSITION !== void 0) {
        const accessor = parser.json.accessors[attributes.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
            box.set(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](min[0], min[1], min[2]), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](max[0], max[1], max[2]));
            if (accessor.normalized) {
                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                box.min.multiplyScalar(boxScale);
                box.max.multiplyScalar(boxScale);
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
        }
    } else {
        return;
    }
    const targets = primitiveDef.targets;
    if (targets !== void 0) {
        const maxDisplacement = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const vector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0, il = targets.length; i < il; i++){
            const target = targets[i];
            if (target.POSITION !== void 0) {
                const accessor = parser.json.accessors[target.POSITION];
                const min = accessor.min;
                const max = accessor.max;
                if (min !== void 0 && max !== void 0) {
                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
                    if (accessor.normalized) {
                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                        vector.multiplyScalar(boxScale);
                    }
                    maxDisplacement.max(vector);
                } else {
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
            }
        }
        box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    const sphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"]();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
        return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
            geometry.setAttribute(attributeName, accessor);
        });
    }
    for(const gltfAttributeName in attributes){
        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
        if (threeAttributeName in geometry.attributes) continue;
        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
        const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
            geometry.setIndex(accessor2);
        });
        pending.push(accessor);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
}
;
 //# sourceMappingURL=GLTFLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/3DMLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Rhino3dmLoader": (()=>Rhino3dmLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _taskCache = /* @__PURE__ */ new WeakMap();
class Rhino3dmLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.libraryPath = "";
        this.libraryPending = null;
        this.libraryBinary = null;
        this.libraryConfig = {};
        this.url = "";
        this.workerLimit = 4;
        this.workerPool = [];
        this.workerNextTaskID = 1;
        this.workerSourceURL = "";
        this.workerConfig = {};
        this.materials = [];
    }
    setLibraryPath(path) {
        this.libraryPath = path;
        return this;
    }
    setWorkerLimit(workerLimit) {
        this.workerLimit = workerLimit;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        this.url = url;
        loader.load(url, (buffer)=>{
            if (_taskCache.has(buffer)) {
                const cachedTask = _taskCache.get(buffer);
                return cachedTask.promise.then(onLoad).catch(onError);
            }
            this.decodeObjects(buffer, url).then(onLoad).catch(onError);
        }, onProgress, onError);
    }
    debug() {
        console.log("Task load: ", this.workerPool.map((worker)=>worker._taskLoad));
    }
    decodeObjects(buffer, url) {
        let worker;
        let taskID;
        const taskCost = buffer.byteLength;
        const objectPending = this._getWorker(taskCost).then((_worker)=>{
            worker = _worker;
            taskID = this.workerNextTaskID++;
            return new Promise((resolve, reject)=>{
                worker._callbacks[taskID] = {
                    resolve,
                    reject
                };
                worker.postMessage({
                    type: "decode",
                    id: taskID,
                    buffer
                }, [
                    buffer
                ]);
            });
        }).then((message)=>this._createGeometry(message.data));
        objectPending.catch(()=>true).then(()=>{
            if (worker && taskID) {
                this._releaseTask(worker, taskID);
            }
        });
        _taskCache.set(buffer, {
            url,
            promise: objectPending
        });
        return objectPending;
    }
    parse(data, onLoad, onError) {
        this.decodeObjects(data, "").then(onLoad).catch(onError);
    }
    _compareMaterials(material) {
        const mat = {};
        mat.name = material.name;
        mat.color = {};
        mat.color.r = material.color.r;
        mat.color.g = material.color.g;
        mat.color.b = material.color.b;
        mat.type = material.type;
        for(let i = 0; i < this.materials.length; i++){
            const m = this.materials[i];
            const _mat = {};
            _mat.name = m.name;
            _mat.color = {};
            _mat.color.r = m.color.r;
            _mat.color.g = m.color.g;
            _mat.color.b = m.color.b;
            _mat.type = m.type;
            if (JSON.stringify(mat) === JSON.stringify(_mat)) {
                return m;
            }
        }
        this.materials.push(material);
        return material;
    }
    _createMaterial(material) {
        if (material === void 0) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
                color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](1, 1, 1),
                metalness: 0.8,
                name: "default",
                side: 2
            });
        }
        const _diffuseColor = material.diffuseColor;
        const diffusecolor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](_diffuseColor.r / 255, _diffuseColor.g / 255, _diffuseColor.b / 255);
        if (_diffuseColor.r === 0 && _diffuseColor.g === 0 && _diffuseColor.b === 0) {
            diffusecolor.r = 1;
            diffusecolor.g = 1;
            diffusecolor.b = 1;
        }
        const mat = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
            color: diffusecolor,
            name: material.name,
            side: 2,
            transparent: material.transparency > 0 ? true : false,
            opacity: 1 - material.transparency
        });
        const textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"]();
        for(let i = 0; i < material.textures.length; i++){
            const texture = material.textures[i];
            if (texture.image !== null) {
                const map = textureLoader.load(texture.image);
                switch(texture.type){
                    case "Diffuse":
                        mat.map = map;
                        break;
                    case "Bump":
                        mat.bumpMap = map;
                        break;
                    case "Transparency":
                        mat.alphaMap = map;
                        mat.transparent = true;
                        break;
                    case "Emap":
                        mat.envMap = map;
                        break;
                }
            }
        }
        return mat;
    }
    _createGeometry(data) {
        const object = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
        const instanceDefinitionObjects = [];
        const instanceDefinitions = [];
        const instanceReferences = [];
        object.userData["layers"] = data.layers;
        object.userData["groups"] = data.groups;
        object.userData["settings"] = data.settings;
        object.userData["objectType"] = "File3dm";
        object.userData["materials"] = null;
        object.name = this.url;
        let objects = data.objects;
        const materials = data.materials;
        for(let i = 0; i < objects.length; i++){
            const obj = objects[i];
            const attributes = obj.attributes;
            switch(obj.objectType){
                case "InstanceDefinition":
                    instanceDefinitions.push(obj);
                    break;
                case "InstanceReference":
                    instanceReferences.push(obj);
                    break;
                default:
                    let _object;
                    if (attributes.materialIndex >= 0) {
                        const rMaterial = materials[attributes.materialIndex];
                        let material = this._createMaterial(rMaterial);
                        material = this._compareMaterials(material);
                        _object = this._createObject(obj, material);
                    } else {
                        const material = this._createMaterial();
                        _object = this._createObject(obj, material);
                    }
                    if (_object === void 0) {
                        continue;
                    }
                    const layer = data.layers[attributes.layerIndex];
                    _object.visible = layer ? data.layers[attributes.layerIndex].visible : true;
                    if (attributes.isInstanceDefinitionObject) {
                        instanceDefinitionObjects.push(_object);
                    } else {
                        object.add(_object);
                    }
                    break;
            }
        }
        for(let i = 0; i < instanceDefinitions.length; i++){
            const iDef = instanceDefinitions[i];
            objects = [];
            for(let j = 0; j < iDef.attributes.objectIds.length; j++){
                const objId = iDef.attributes.objectIds[j];
                for(let p = 0; p < instanceDefinitionObjects.length; p++){
                    const idoId = instanceDefinitionObjects[p].userData.attributes.id;
                    if (objId === idoId) {
                        objects.push(instanceDefinitionObjects[p]);
                    }
                }
            }
            for(let j = 0; j < instanceReferences.length; j++){
                const iRef = instanceReferences[j];
                if (iRef.geometry.parentIdefId === iDef.attributes.id) {
                    const iRefObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
                    const xf = iRef.geometry.xform.array;
                    const matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                    matrix.set(xf[0], xf[1], xf[2], xf[3], xf[4], xf[5], xf[6], xf[7], xf[8], xf[9], xf[10], xf[11], xf[12], xf[13], xf[14], xf[15]);
                    iRefObject.applyMatrix4(matrix);
                    for(let p = 0; p < objects.length; p++){
                        iRefObject.add(objects[p].clone(true));
                    }
                    object.add(iRefObject);
                }
            }
        }
        object.userData["materials"] = this.materials;
        return object;
    }
    _createObject(obj, mat) {
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometryLoader"]();
        const attributes = obj.attributes;
        let geometry, material, _color, color;
        switch(obj.objectType){
            case "Point":
            case "PointSet":
                geometry = loader.parse(obj.geometry);
                if (geometry.attributes.hasOwnProperty("color")) {
                    material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]({
                        vertexColors: true,
                        sizeAttenuation: false,
                        size: 2
                    });
                } else {
                    _color = attributes.drawColor;
                    color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](_color.r / 255, _color.g / 255, _color.b / 255);
                    material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]({
                        color,
                        sizeAttenuation: false,
                        size: 2
                    });
                }
                material = this._compareMaterials(material);
                const points = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](geometry, material);
                points.userData["attributes"] = attributes;
                points.userData["objectType"] = obj.objectType;
                if (attributes.name) {
                    points.name = attributes.name;
                }
                return points;
            case "Mesh":
            case "Extrusion":
            case "SubD":
            case "Brep":
                if (obj.geometry === null) return;
                geometry = loader.parse(obj.geometry);
                if (geometry.attributes.hasOwnProperty("color")) {
                    mat.vertexColors = true;
                }
                if (mat === null) {
                    mat = this._createMaterial();
                    mat = this._compareMaterials(mat);
                }
                const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, mat);
                mesh.castShadow = attributes.castsShadows;
                mesh.receiveShadow = attributes.receivesShadows;
                mesh.userData["attributes"] = attributes;
                mesh.userData["objectType"] = obj.objectType;
                if (attributes.name) {
                    mesh.name = attributes.name;
                }
                return mesh;
            case "Curve":
                geometry = loader.parse(obj.geometry);
                _color = attributes.drawColor;
                color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](_color.r / 255, _color.g / 255, _color.b / 255);
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]({
                    color
                });
                material = this._compareMaterials(material);
                const lines = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Line"](geometry, material);
                lines.userData["attributes"] = attributes;
                lines.userData["objectType"] = obj.objectType;
                if (attributes.name) {
                    lines.name = attributes.name;
                }
                return lines;
            case "TextDot":
                geometry = obj.geometry;
                const ctx = document.createElement("canvas").getContext("2d");
                const font = `${geometry.fontHeight}px ${geometry.fontFace}`;
                ctx.font = font;
                const width = ctx.measureText(geometry.text).width + 10;
                const height = geometry.fontHeight + 10;
                const r = window.devicePixelRatio;
                ctx.canvas.width = width * r;
                ctx.canvas.height = height * r;
                ctx.canvas.style.width = width + "px";
                ctx.canvas.style.height = height + "px";
                ctx.setTransform(r, 0, 0, r, 0, 0);
                ctx.font = font;
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";
                color = attributes.drawColor;
                ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`;
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = "white";
                ctx.fillText(geometry.text, width / 2, height / 2);
                const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CanvasTexture"](ctx.canvas);
                texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
                texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
                material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpriteMaterial"]({
                    map: texture,
                    depthTest: false
                });
                const sprite = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sprite"](material);
                sprite.position.set(geometry.point[0], geometry.point[1], geometry.point[2]);
                sprite.scale.set(width / 10, height / 10, 1);
                sprite.userData["attributes"] = attributes;
                sprite.userData["objectType"] = obj.objectType;
                if (attributes.name) {
                    sprite.name = attributes.name;
                }
                return sprite;
            case "Light":
                geometry = obj.geometry;
                let light;
                if (geometry.isDirectionalLight) {
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DirectionalLight"]();
                    light.castShadow = attributes.castsShadows;
                    light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);
                    light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);
                    light.shadow.normalBias = 0.1;
                } else if (geometry.isPointLight) {
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"]();
                    light.castShadow = attributes.castsShadows;
                    light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);
                    light.shadow.normalBias = 0.1;
                } else if (geometry.isRectangularLight) {
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RectAreaLight"]();
                    const width2 = Math.abs(geometry.width[2]);
                    const height2 = Math.abs(geometry.length[0]);
                    light.position.set(geometry.location[0] - height2 / 2, geometry.location[1], geometry.location[2] - width2 / 2);
                    light.height = height2;
                    light.width = width2;
                    light.lookAt(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](geometry.direction[0], geometry.direction[1], geometry.direction[2]));
                } else if (geometry.isSpotLight) {
                    light = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpotLight"]();
                    light.castShadow = attributes.castsShadows;
                    light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);
                    light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);
                    light.angle = geometry.spotAngleRadians;
                    light.shadow.normalBias = 0.1;
                } else if (geometry.isLinearLight) {
                    console.warn("THREE.3DMLoader:  No conversion exists for linear lights.");
                    return;
                }
                if (light) {
                    light.intensity = geometry.intensity;
                    _color = geometry.diffuse;
                    color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](_color.r / 255, _color.g / 255, _color.b / 255);
                    light.color = color;
                    light.userData["attributes"] = attributes;
                    light.userData["objectType"] = obj.objectType;
                }
                return light;
        }
    }
    _initLibrary() {
        if (!this.libraryPending) {
            const jsLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
            jsLoader.setPath(this.libraryPath);
            const jsContent = new Promise((resolve, reject)=>{
                jsLoader.load("rhino3dm.js", resolve, void 0, reject);
            });
            const binaryLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
            binaryLoader.setPath(this.libraryPath);
            binaryLoader.setResponseType("arraybuffer");
            const binaryContent = new Promise((resolve, reject)=>{
                binaryLoader.load("rhino3dm.wasm", resolve, void 0, reject);
            });
            this.libraryPending = Promise.all([
                jsContent,
                binaryContent
            ]).then(([jsContent2, binaryContent2])=>{
                this.libraryConfig.wasmBinary = binaryContent2;
                const fn = Rhino3dmWorker.toString();
                const body = [
                    "/* rhino3dm.js */",
                    jsContent2,
                    "/* worker */",
                    fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
                ].join("\n");
                this.workerSourceURL = URL.createObjectURL(new Blob([
                    body
                ]));
            });
        }
        return this.libraryPending;
    }
    _getWorker(taskCost) {
        return this._initLibrary().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                const worker2 = new Worker(this.workerSourceURL);
                worker2._callbacks = {};
                worker2._taskCosts = {};
                worker2._taskLoad = 0;
                worker2.postMessage({
                    type: "init",
                    libraryConfig: this.libraryConfig
                });
                worker2.onmessage = function(e) {
                    const message = e.data;
                    switch(message.type){
                        case "decode":
                            worker2._callbacks[message.id].resolve(message);
                            break;
                        case "error":
                            worker2._callbacks[message.id].reject(message);
                            break;
                        default:
                            console.error('THREE.Rhino3dmLoader: Unexpected message, "' + message.type + '"');
                    }
                };
                this.workerPool.push(worker2);
            } else {
                this.workerPool.sort(function(a, b) {
                    return a._taskLoad > b._taskLoad ? -1 : 1;
                });
            }
            const worker = this.workerPool[this.workerPool.length - 1];
            worker._taskLoad += taskCost;
            return worker;
        });
    }
    _releaseTask(worker, taskID) {
        worker._taskLoad -= worker._taskCosts[taskID];
        delete worker._callbacks[taskID];
        delete worker._taskCosts[taskID];
    }
    dispose() {
        for(let i = 0; i < this.workerPool.length; ++i){
            this.workerPool[i].terminate();
        }
        this.workerPool.length = 0;
        return this;
    }
}
function Rhino3dmWorker() {
    let libraryPending;
    let libraryConfig;
    let rhino;
    onmessage = function(e) {
        const message = e.data;
        switch(message.type){
            case "init":
                libraryConfig = message.libraryConfig;
                const wasmBinary = libraryConfig.wasmBinary;
                let RhinoModule;
                libraryPending = new Promise(function(resolve) {
                    RhinoModule = {
                        wasmBinary,
                        onRuntimeInitialized: resolve
                    };
                    rhino3dm(RhinoModule);
                }).then(()=>{
                    rhino = RhinoModule;
                });
                break;
            case "decode":
                const buffer = message.buffer;
                libraryPending.then(()=>{
                    const data = decodeObjects(rhino, buffer);
                    self.postMessage({
                        type: "decode",
                        id: message.id,
                        data
                    });
                });
                break;
        }
    };
    function decodeObjects(rhino2, buffer) {
        const arr = new Uint8Array(buffer);
        const doc = rhino2.File3dm.fromByteArray(arr);
        const objects = [];
        const materials = [];
        const layers = [];
        const views = [];
        const namedViews = [];
        const groups = [];
        const objs = doc.objects();
        const cnt = objs.count;
        for(let i = 0; i < cnt; i++){
            const _object = objs.get(i);
            const object = extractObjectData(_object, doc);
            _object.delete();
            if (object) {
                objects.push(object);
            }
        }
        for(let i = 0; i < doc.instanceDefinitions().count(); i++){
            const idef = doc.instanceDefinitions().get(i);
            const idefAttributes = extractProperties(idef);
            idefAttributes.objectIds = idef.getObjectIds();
            objects.push({
                geometry: null,
                attributes: idefAttributes,
                objectType: "InstanceDefinition"
            });
        }
        const textureTypes = [
            // rhino.TextureType.Bitmap,
            rhino2.TextureType.Diffuse,
            rhino2.TextureType.Bump,
            rhino2.TextureType.Transparency,
            rhino2.TextureType.Opacity,
            rhino2.TextureType.Emap
        ];
        const pbrTextureTypes = [
            rhino2.TextureType.PBR_BaseColor,
            rhino2.TextureType.PBR_Subsurface,
            rhino2.TextureType.PBR_SubsurfaceScattering,
            rhino2.TextureType.PBR_SubsurfaceScatteringRadius,
            rhino2.TextureType.PBR_Metallic,
            rhino2.TextureType.PBR_Specular,
            rhino2.TextureType.PBR_SpecularTint,
            rhino2.TextureType.PBR_Roughness,
            rhino2.TextureType.PBR_Anisotropic,
            rhino2.TextureType.PBR_Anisotropic_Rotation,
            rhino2.TextureType.PBR_Sheen,
            rhino2.TextureType.PBR_SheenTint,
            rhino2.TextureType.PBR_Clearcoat,
            rhino2.TextureType.PBR_ClearcoatBump,
            rhino2.TextureType.PBR_ClearcoatRoughness,
            rhino2.TextureType.PBR_OpacityIor,
            rhino2.TextureType.PBR_OpacityRoughness,
            rhino2.TextureType.PBR_Emission,
            rhino2.TextureType.PBR_AmbientOcclusion,
            rhino2.TextureType.PBR_Displacement
        ];
        for(let i = 0; i < doc.materials().count(); i++){
            const _material = doc.materials().get(i);
            const _pbrMaterial = _material.physicallyBased();
            let material = extractProperties(_material);
            const textures = [];
            for(let j = 0; j < textureTypes.length; j++){
                const _texture = _material.getTexture(textureTypes[j]);
                if (_texture) {
                    let textureType = textureTypes[j].constructor.name;
                    textureType = textureType.substring(12, textureType.length);
                    const texture = {
                        type: textureType
                    };
                    const image = doc.getEmbeddedFileAsBase64(_texture.fileName);
                    if (image) {
                        texture.image = "data:image/png;base64," + image;
                    } else {
                        console.warn(`THREE.3DMLoader: Image for ${textureType} texture not embedded in file.`);
                        texture.image = null;
                    }
                    textures.push(texture);
                    _texture.delete();
                }
            }
            material.textures = textures;
            if (_pbrMaterial.supported) {
                console.log("pbr true");
                for(let j = 0; j < pbrTextureTypes.length; j++){
                    const _texture = _material.getTexture(textureTypes[j]);
                    if (_texture) {
                        const image = doc.getEmbeddedFileAsBase64(_texture.fileName);
                        let textureType = textureTypes[j].constructor.name;
                        textureType = textureType.substring(12, textureType.length);
                        const texture = {
                            type: textureType,
                            image: "data:image/png;base64," + image
                        };
                        textures.push(texture);
                        _texture.delete();
                    }
                }
                const pbMaterialProperties = extractProperties(_material.physicallyBased());
                material = Object.assign(pbMaterialProperties, material);
            }
            materials.push(material);
            _material.delete();
            _pbrMaterial.delete();
        }
        for(let i = 0; i < doc.layers().count(); i++){
            const _layer = doc.layers().get(i);
            const layer = extractProperties(_layer);
            layers.push(layer);
            _layer.delete();
        }
        for(let i = 0; i < doc.views().count(); i++){
            const _view = doc.views().get(i);
            const view = extractProperties(_view);
            views.push(view);
            _view.delete();
        }
        for(let i = 0; i < doc.namedViews().count(); i++){
            const _namedView = doc.namedViews().get(i);
            const namedView = extractProperties(_namedView);
            namedViews.push(namedView);
            _namedView.delete();
        }
        for(let i = 0; i < doc.groups().count(); i++){
            const _group = doc.groups().get(i);
            const group = extractProperties(_group);
            groups.push(group);
            _group.delete();
        }
        const settings = extractProperties(doc.settings());
        doc.delete();
        return {
            objects,
            materials,
            layers,
            views,
            namedViews,
            groups,
            settings
        };
    }
    function extractObjectData(object, doc) {
        const _geometry = object.geometry();
        const _attributes = object.attributes();
        let objectType = _geometry.objectType;
        let geometry, attributes, position, data, mesh;
        switch(objectType){
            case rhino.ObjectType.Curve:
                const pts = curveToPoints(_geometry, 100);
                position = {};
                attributes = {};
                data = {};
                position.itemSize = 3;
                position.type = "Float32Array";
                position.array = [];
                for(let j = 0; j < pts.length; j++){
                    position.array.push(pts[j][0]);
                    position.array.push(pts[j][1]);
                    position.array.push(pts[j][2]);
                }
                attributes.position = position;
                data.attributes = attributes;
                geometry = {
                    data
                };
                break;
            case rhino.ObjectType.Point:
                const pt = _geometry.location;
                position = {};
                const color = {};
                attributes = {};
                data = {};
                position.itemSize = 3;
                position.type = "Float32Array";
                position.array = [
                    pt[0],
                    pt[1],
                    pt[2]
                ];
                const _color = _attributes.drawColor(doc);
                color.itemSize = 3;
                color.type = "Float32Array";
                color.array = [
                    _color.r / 255,
                    _color.g / 255,
                    _color.b / 255
                ];
                attributes.position = position;
                attributes.color = color;
                data.attributes = attributes;
                geometry = {
                    data
                };
                break;
            case rhino.ObjectType.PointSet:
            case rhino.ObjectType.Mesh:
                geometry = _geometry.toThreejsJSON();
                break;
            case rhino.ObjectType.Brep:
                const faces = _geometry.faces();
                mesh = new rhino.Mesh();
                for(let faceIndex = 0; faceIndex < faces.count; faceIndex++){
                    const face = faces.get(faceIndex);
                    const _mesh = face.getMesh(rhino.MeshType.Any);
                    if (_mesh) {
                        mesh.append(_mesh);
                        _mesh.delete();
                    }
                    face.delete();
                }
                if (mesh.faces().count > 0) {
                    mesh.compact();
                    geometry = mesh.toThreejsJSON();
                    faces.delete();
                }
                mesh.delete();
                break;
            case rhino.ObjectType.Extrusion:
                mesh = _geometry.getMesh(rhino.MeshType.Any);
                if (mesh) {
                    geometry = mesh.toThreejsJSON();
                    mesh.delete();
                }
                break;
            case rhino.ObjectType.TextDot:
                geometry = extractProperties(_geometry);
                break;
            case rhino.ObjectType.Light:
                geometry = extractProperties(_geometry);
                break;
            case rhino.ObjectType.InstanceReference:
                geometry = extractProperties(_geometry);
                geometry.xform = extractProperties(_geometry.xform);
                geometry.xform.array = _geometry.xform.toFloatArray(true);
                break;
            case rhino.ObjectType.SubD:
                _geometry.subdivide(3);
                mesh = rhino.Mesh.createFromSubDControlNet(_geometry);
                if (mesh) {
                    geometry = mesh.toThreejsJSON();
                    mesh.delete();
                }
                break;
            default:
                console.warn(`THREE.3DMLoader: TODO: Implement ${objectType.constructor.name}`);
                break;
        }
        if (geometry) {
            attributes = extractProperties(_attributes);
            attributes.geometry = extractProperties(_geometry);
            if (_attributes.groupCount > 0) {
                attributes.groupIds = _attributes.getGroupList();
            }
            if (_attributes.userStringCount > 0) {
                attributes.userStrings = _attributes.getUserStrings();
            }
            if (_geometry.userStringCount > 0) {
                attributes.geometry.userStrings = _geometry.getUserStrings();
            }
            attributes.drawColor = _attributes.drawColor(doc);
            objectType = objectType.constructor.name;
            objectType = objectType.substring(11, objectType.length);
            return {
                geometry,
                attributes,
                objectType
            };
        } else {
            console.warn(`THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`);
        }
    }
    function extractProperties(object) {
        const result = {};
        for(const property in object){
            const value = object[property];
            if (typeof value !== "function") {
                if (typeof value === "object" && value !== null && value.hasOwnProperty("constructor")) {
                    result[property] = {
                        name: value.constructor.name,
                        value: value.value
                    };
                } else {
                    result[property] = value;
                }
            }
        }
        return result;
    }
    function curveToPoints(curve, pointLimit) {
        let pointCount = pointLimit;
        let rc = [];
        const ts = [];
        if (curve instanceof rhino.LineCurve) {
            return [
                curve.pointAtStart,
                curve.pointAtEnd
            ];
        }
        if (curve instanceof rhino.PolylineCurve) {
            pointCount = curve.pointCount;
            for(let i = 0; i < pointCount; i++){
                rc.push(curve.point(i));
            }
            return rc;
        }
        if (curve instanceof rhino.PolyCurve) {
            const segmentCount = curve.segmentCount;
            for(let i = 0; i < segmentCount; i++){
                const segment = curve.segmentCurve(i);
                const segmentArray = curveToPoints(segment, pointCount);
                rc = rc.concat(segmentArray);
                segment.delete();
            }
            return rc;
        }
        if (curve instanceof rhino.ArcCurve) {
            pointCount = Math.floor(curve.angleDegrees / 5);
            pointCount = pointCount < 2 ? 2 : pointCount;
        }
        if (curve instanceof rhino.NurbsCurve && curve.degree === 1) {
            const pLine = curve.tryGetPolyline();
            for(let i = 0; i < pLine.count; i++){
                rc.push(pLine.get(i));
            }
            pLine.delete();
            return rc;
        }
        const domain = curve.domain;
        const divisions = pointCount - 1;
        for(let j = 0; j < pointCount; j++){
            const t = domain[0] + j / divisions * (domain[1] - domain[0]);
            if (t === domain[0] || t === domain[1]) {
                ts.push(t);
                continue;
            }
            const tan = curve.tangentAt(t);
            const prevTan = curve.tangentAt(ts.slice(-1)[0]);
            const tS = tan[0] * tan[0] + tan[1] * tan[1] + tan[2] * tan[2];
            const ptS = prevTan[0] * prevTan[0] + prevTan[1] * prevTan[1] + prevTan[2] * prevTan[2];
            const denominator = Math.sqrt(tS * ptS);
            let angle;
            if (denominator === 0) {
                angle = Math.PI / 2;
            } else {
                const theta = (tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z) / denominator;
                angle = Math.acos(Math.max(-1, Math.min(1, theta)));
            }
            if (angle < 0.1) continue;
            ts.push(t);
        }
        rc = ts.map((t)=>curve.pointAt(t));
        return rc;
    }
}
;
 //# sourceMappingURL=3DMLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/OBJLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "OBJLoader": (()=>OBJLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _object_pattern = /^[og]\s*(.+)?/;
const _material_library_pattern = /^mtllib /;
const _material_use_pattern = /^usemtl /;
const _map_use_pattern = /^usemap /;
const _vA = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _vB = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _vC = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _ab = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const _cb = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
function ParserState() {
    const state = {
        objects: [],
        object: {},
        vertices: [],
        normals: [],
        colors: [],
        uvs: [],
        materials: {},
        materialLibraries: [],
        startObject: function(name, fromDeclaration) {
            if (this.object && this.object.fromDeclaration === false) {
                this.object.name = name;
                this.object.fromDeclaration = fromDeclaration !== false;
                return;
            }
            const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
            if (this.object && typeof this.object._finalize === "function") {
                this.object._finalize(true);
            }
            this.object = {
                name: name || "",
                fromDeclaration: fromDeclaration !== false,
                geometry: {
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
                    hasUVIndices: false
                },
                materials: [],
                smooth: true,
                startMaterial: function(name2, libraries) {
                    const previous = this._finalize(false);
                    if (previous && (previous.inherited || previous.groupCount <= 0)) {
                        this.materials.splice(previous.index, 1);
                    }
                    const material = {
                        index: this.materials.length,
                        name: name2 || "",
                        mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
                        smooth: previous !== void 0 ? previous.smooth : this.smooth,
                        groupStart: previous !== void 0 ? previous.groupEnd : 0,
                        groupEnd: -1,
                        groupCount: -1,
                        inherited: false,
                        clone: function(index) {
                            const cloned = {
                                index: typeof index === "number" ? index : this.index,
                                name: this.name,
                                mtllib: this.mtllib,
                                smooth: this.smooth,
                                groupStart: 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: false
                            };
                            cloned.clone = this.clone.bind(cloned);
                            return cloned;
                        }
                    };
                    this.materials.push(material);
                    return material;
                },
                currentMaterial: function() {
                    if (this.materials.length > 0) {
                        return this.materials[this.materials.length - 1];
                    }
                    return void 0;
                },
                _finalize: function(end) {
                    const lastMultiMaterial = this.currentMaterial();
                    if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                        lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                        lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                        lastMultiMaterial.inherited = false;
                    }
                    if (end && this.materials.length > 1) {
                        for(let mi = this.materials.length - 1; mi >= 0; mi--){
                            if (this.materials[mi].groupCount <= 0) {
                                this.materials.splice(mi, 1);
                            }
                        }
                    }
                    if (end && this.materials.length === 0) {
                        this.materials.push({
                            name: "",
                            smooth: this.smooth
                        });
                    }
                    return lastMultiMaterial;
                }
            };
            if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
                const declared = previousMaterial.clone(0);
                declared.inherited = true;
                this.object.materials.push(declared);
            }
            this.objects.push(this.object);
        },
        finalize: function() {
            if (this.object && typeof this.object._finalize === "function") {
                this.object._finalize(true);
            }
        },
        parseVertexIndex: function(value, len) {
            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 3) * 3;
        },
        parseNormalIndex: function(value, len) {
            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 3) * 3;
        },
        parseUVIndex: function(value, len) {
            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 2) * 2;
        },
        addVertex: function(a, b, c) {
            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
            dst.push(src[b + 0], src[b + 1], src[b + 2]);
            dst.push(src[c + 0], src[c + 1], src[c + 2]);
        },
        addVertexPoint: function(a) {
            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
        },
        addVertexLine: function(a) {
            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
        },
        addNormal: function(a, b, c) {
            const src = this.normals;
            const dst = this.object.geometry.normals;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
            dst.push(src[b + 0], src[b + 1], src[b + 2]);
            dst.push(src[c + 0], src[c + 1], src[c + 2]);
        },
        addFaceNormal: function(a, b, c) {
            const src = this.vertices;
            const dst = this.object.geometry.normals;
            _vA.fromArray(src, a);
            _vB.fromArray(src, b);
            _vC.fromArray(src, c);
            _cb.subVectors(_vC, _vB);
            _ab.subVectors(_vA, _vB);
            _cb.cross(_ab);
            _cb.normalize();
            dst.push(_cb.x, _cb.y, _cb.z);
            dst.push(_cb.x, _cb.y, _cb.z);
            dst.push(_cb.x, _cb.y, _cb.z);
        },
        addColor: function(a, b, c) {
            const src = this.colors;
            const dst = this.object.geometry.colors;
            if (src[a] !== void 0) dst.push(src[a + 0], src[a + 1], src[a + 2]);
            if (src[b] !== void 0) dst.push(src[b + 0], src[b + 1], src[b + 2]);
            if (src[c] !== void 0) dst.push(src[c + 0], src[c + 1], src[c + 2]);
        },
        addUV: function(a, b, c) {
            const src = this.uvs;
            const dst = this.object.geometry.uvs;
            dst.push(src[a + 0], src[a + 1]);
            dst.push(src[b + 0], src[b + 1]);
            dst.push(src[c + 0], src[c + 1]);
        },
        addDefaultUV: function() {
            const dst = this.object.geometry.uvs;
            dst.push(0, 0);
            dst.push(0, 0);
            dst.push(0, 0);
        },
        addUVLine: function(a) {
            const src = this.uvs;
            const dst = this.object.geometry.uvs;
            dst.push(src[a + 0], src[a + 1]);
        },
        addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
            const vLen = this.vertices.length;
            let ia = this.parseVertexIndex(a, vLen);
            let ib = this.parseVertexIndex(b, vLen);
            let ic = this.parseVertexIndex(c, vLen);
            this.addVertex(ia, ib, ic);
            this.addColor(ia, ib, ic);
            if (na !== void 0 && na !== "") {
                const nLen = this.normals.length;
                ia = this.parseNormalIndex(na, nLen);
                ib = this.parseNormalIndex(nb, nLen);
                ic = this.parseNormalIndex(nc, nLen);
                this.addNormal(ia, ib, ic);
            } else {
                this.addFaceNormal(ia, ib, ic);
            }
            if (ua !== void 0 && ua !== "") {
                const uvLen = this.uvs.length;
                ia = this.parseUVIndex(ua, uvLen);
                ib = this.parseUVIndex(ub, uvLen);
                ic = this.parseUVIndex(uc, uvLen);
                this.addUV(ia, ib, ic);
                this.object.geometry.hasUVIndices = true;
            } else {
                this.addDefaultUV();
            }
        },
        addPointGeometry: function(vertices) {
            this.object.geometry.type = "Points";
            const vLen = this.vertices.length;
            for(let vi = 0, l = vertices.length; vi < l; vi++){
                const index = this.parseVertexIndex(vertices[vi], vLen);
                this.addVertexPoint(index);
                this.addColor(index);
            }
        },
        addLineGeometry: function(vertices, uvs) {
            this.object.geometry.type = "Line";
            const vLen = this.vertices.length;
            const uvLen = this.uvs.length;
            for(let vi = 0, l = vertices.length; vi < l; vi++){
                this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
            }
            for(let uvi = 0, l = uvs.length; uvi < l; uvi++){
                this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
            }
        }
    };
    state.startObject("", false);
    return state;
}
class OBJLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.materials = null;
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    setMaterials(materials) {
        this.materials = materials;
        return this;
    }
    parse(text) {
        const state = new ParserState();
        if (text.indexOf("\r\n") !== -1) {
            text = text.replace(/\r\n/g, "\n");
        }
        if (text.indexOf("\\\n") !== -1) {
            text = text.replace(/\\\n/g, "");
        }
        const lines = text.split("\n");
        let line = "", lineFirstChar = "";
        let lineLength = 0;
        let result = [];
        const trimLeft = typeof "".trimLeft === "function";
        for(let i = 0, l = lines.length; i < l; i++){
            line = lines[i];
            line = trimLeft ? line.trimLeft() : line.trim();
            lineLength = line.length;
            if (lineLength === 0) continue;
            lineFirstChar = line.charAt(0);
            if (lineFirstChar === "#") continue;
            if (lineFirstChar === "v") {
                const data = line.split(/\s+/);
                switch(data[0]){
                    case "v":
                        state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                        if (data.length >= 7) {
                            state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
                        } else {
                            state.colors.push(void 0, void 0, void 0);
                        }
                        break;
                    case "vn":
                        state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                        break;
                    case "vt":
                        state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                        break;
                }
            } else if (lineFirstChar === "f") {
                const lineData = line.substr(1).trim();
                const vertexData = lineData.split(/\s+/);
                const faceVertices = [];
                for(let j = 0, jl = vertexData.length; j < jl; j++){
                    const vertex = vertexData[j];
                    if (vertex.length > 0) {
                        const vertexParts = vertex.split("/");
                        faceVertices.push(vertexParts);
                    }
                }
                const v1 = faceVertices[0];
                for(let j = 1, jl = faceVertices.length - 1; j < jl; j++){
                    const v2 = faceVertices[j];
                    const v3 = faceVertices[j + 1];
                    state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                }
            } else if (lineFirstChar === "l") {
                const lineParts = line.substring(1).trim().split(" ");
                let lineVertices = [];
                const lineUVs = [];
                if (line.indexOf("/") === -1) {
                    lineVertices = lineParts;
                } else {
                    for(let li = 0, llen = lineParts.length; li < llen; li++){
                        const parts = lineParts[li].split("/");
                        if (parts[0] !== "") lineVertices.push(parts[0]);
                        if (parts[1] !== "") lineUVs.push(parts[1]);
                    }
                }
                state.addLineGeometry(lineVertices, lineUVs);
            } else if (lineFirstChar === "p") {
                const lineData = line.substr(1).trim();
                const pointData = lineData.split(" ");
                state.addPointGeometry(pointData);
            } else if ((result = _object_pattern.exec(line)) !== null) {
                const name = (" " + result[0].substr(1).trim()).substr(1);
                state.startObject(name);
            } else if (_material_use_pattern.test(line)) {
                state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
            } else if (_material_library_pattern.test(line)) {
                state.materialLibraries.push(line.substring(7).trim());
            } else if (_map_use_pattern.test(line)) {
                console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
            } else if (lineFirstChar === "s") {
                result = line.split(" ");
                if (result.length > 1) {
                    const value = result[1].trim().toLowerCase();
                    state.object.smooth = value !== "0" && value !== "off";
                } else {
                    state.object.smooth = true;
                }
                const material = state.object.currentMaterial();
                if (material) material.smooth = state.object.smooth;
            } else {
                if (line === "\0") continue;
                console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
            }
        }
        state.finalize();
        const container = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        container.materialLibraries = [].concat(state.materialLibraries);
        const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
        if (hasPrimitives === true) {
            for(let i = 0, l = state.objects.length; i < l; i++){
                const object = state.objects[i];
                const geometry = object.geometry;
                const materials = object.materials;
                const isLine = geometry.type === "Line";
                const isPoints = geometry.type === "Points";
                let hasVertexColors = false;
                if (geometry.vertices.length === 0) continue;
                const buffergeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
                buffergeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.vertices, 3));
                if (geometry.normals.length > 0) {
                    buffergeometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.normals, 3));
                }
                if (geometry.colors.length > 0) {
                    hasVertexColors = true;
                    buffergeometry.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.colors, 3));
                }
                if (geometry.hasUVIndices === true) {
                    buffergeometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geometry.uvs, 2));
                }
                const createdMaterials = [];
                for(let mi = 0, miLen = materials.length; mi < miLen; mi++){
                    const sourceMaterial = materials[mi];
                    const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
                    let material = state.materials[materialHash];
                    if (this.materials !== null) {
                        material = this.materials.create(sourceMaterial.name);
                        if (isLine && material && !(material instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"])) {
                            const materialLine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]();
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].prototype.copy.call(materialLine, material);
                            materialLine.color.copy(material.color);
                            material = materialLine;
                        } else if (isPoints && material && !(material instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"])) {
                            const materialPoints = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]({
                                size: 10,
                                sizeAttenuation: false
                            });
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].prototype.copy.call(materialPoints, material);
                            materialPoints.color.copy(material.color);
                            materialPoints.map = material.map;
                            material = materialPoints;
                        }
                    }
                    if (material === void 0) {
                        if (isLine) {
                            material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"]();
                        } else if (isPoints) {
                            material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]({
                                size: 1,
                                sizeAttenuation: false
                            });
                        } else {
                            material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]();
                        }
                        material.name = sourceMaterial.name;
                        material.flatShading = sourceMaterial.smooth ? false : true;
                        material.vertexColors = hasVertexColors;
                        state.materials[materialHash] = material;
                    }
                    createdMaterials.push(material);
                }
                let mesh;
                if (createdMaterials.length > 1) {
                    for(let mi = 0, miLen = materials.length; mi < miLen; mi++){
                        const sourceMaterial = materials[mi];
                        buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                    }
                    if (isLine) {
                        mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](buffergeometry, createdMaterials);
                    } else if (isPoints) {
                        mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](buffergeometry, createdMaterials);
                    } else {
                        mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](buffergeometry, createdMaterials);
                    }
                } else {
                    if (isLine) {
                        mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](buffergeometry, createdMaterials[0]);
                    } else if (isPoints) {
                        mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](buffergeometry, createdMaterials[0]);
                    } else {
                        mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](buffergeometry, createdMaterials[0]);
                    }
                }
                mesh.name = object.name;
                container.add(mesh);
            }
        } else {
            if (state.vertices.length > 0) {
                const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]({
                    size: 1,
                    sizeAttenuation: false
                });
                const buffergeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
                buffergeometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](state.vertices, 3));
                if (state.colors.length > 0 && state.colors[0] !== void 0) {
                    buffergeometry.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](state.colors, 3));
                    material.vertexColors = true;
                }
                const points = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](buffergeometry, material);
                container.add(points);
            }
        }
        return container;
    }
}
;
 //# sourceMappingURL=OBJLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/AMFLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AMFLoader": (()=>AMFLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)");
;
;
;
class AMFLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(data) {
        function loadDocument(data2) {
            let view = new DataView(data2);
            const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));
            if (magic === "PK") {
                let zip = null;
                let file = null;
                console.log("THREE.AMFLoader: Loading Zip");
                try {
                    zip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzipSync"])(new Uint8Array(data2));
                } catch (e) {
                    if (e instanceof ReferenceError) {
                        console.log("THREE.AMFLoader: fflate missing and file is compressed.");
                        return null;
                    }
                }
                for(file in zip){
                    if (file.toLowerCase().substr(-4) === ".amf") {
                        break;
                    }
                }
                console.log("THREE.AMFLoader: Trying to load file asset: " + file);
                view = new DataView(zip[file].buffer);
            }
            const fileText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(view);
            const xmlData2 = new DOMParser().parseFromString(fileText, "application/xml");
            if (xmlData2.documentElement.nodeName.toLowerCase() !== "amf") {
                console.log("THREE.AMFLoader: Error loading AMF - no AMF document found.");
                return null;
            }
            return xmlData2;
        }
        function loadDocumentScale(node) {
            let scale = 1;
            let unit = "millimeter";
            if (node.documentElement.attributes.unit !== void 0) {
                unit = node.documentElement.attributes.unit.value.toLowerCase();
            }
            const scaleUnits = {
                millimeter: 1,
                inch: 25.4,
                feet: 304.8,
                meter: 1e3,
                micron: 1e-3
            };
            if (scaleUnits[unit] !== void 0) {
                scale = scaleUnits[unit];
            }
            console.log("THREE.AMFLoader: Unit scale: " + scale);
            return scale;
        }
        function loadMaterials(node) {
            let matName = "AMF Material";
            const matId = node.attributes.id.textContent;
            let color = {
                r: 1,
                g: 1,
                b: 1,
                a: 1
            };
            let loadedMaterial = null;
            for(let i2 = 0; i2 < node.childNodes.length; i2++){
                const matChildEl = node.childNodes[i2];
                if (matChildEl.nodeName === "metadata" && matChildEl.attributes.type !== void 0) {
                    if (matChildEl.attributes.type.value === "name") {
                        matName = matChildEl.textContent;
                    }
                } else if (matChildEl.nodeName === "color") {
                    color = loadColor(matChildEl);
                }
            }
            loadedMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]({
                flatShading: true,
                color: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](color.r, color.g, color.b),
                name: matName
            });
            if (color.a !== 1) {
                loadedMaterial.transparent = true;
                loadedMaterial.opacity = color.a;
            }
            return {
                id: matId,
                material: loadedMaterial
            };
        }
        function loadColor(node) {
            const color = {
                r: 1,
                g: 1,
                b: 1,
                a: 1
            };
            for(let i2 = 0; i2 < node.childNodes.length; i2++){
                const matColor = node.childNodes[i2];
                if (matColor.nodeName === "r") {
                    color.r = matColor.textContent;
                } else if (matColor.nodeName === "g") {
                    color.g = matColor.textContent;
                } else if (matColor.nodeName === "b") {
                    color.b = matColor.textContent;
                } else if (matColor.nodeName === "a") {
                    color.a = matColor.textContent;
                }
            }
            return color;
        }
        function loadMeshVolume(node) {
            const volume = {
                name: "",
                triangles: [],
                materialid: null
            };
            let currVolumeNode = node.firstElementChild;
            if (node.attributes.materialid !== void 0) {
                volume.materialId = node.attributes.materialid.nodeValue;
            }
            while(currVolumeNode){
                if (currVolumeNode.nodeName === "metadata") {
                    if (currVolumeNode.attributes.type !== void 0) {
                        if (currVolumeNode.attributes.type.value === "name") {
                            volume.name = currVolumeNode.textContent;
                        }
                    }
                } else if (currVolumeNode.nodeName === "triangle") {
                    const v1 = currVolumeNode.getElementsByTagName("v1")[0].textContent;
                    const v2 = currVolumeNode.getElementsByTagName("v2")[0].textContent;
                    const v3 = currVolumeNode.getElementsByTagName("v3")[0].textContent;
                    volume.triangles.push(v1, v2, v3);
                }
                currVolumeNode = currVolumeNode.nextElementSibling;
            }
            return volume;
        }
        function loadMeshVertices(node) {
            const vertArray = [];
            const normalArray = [];
            let currVerticesNode = node.firstElementChild;
            while(currVerticesNode){
                if (currVerticesNode.nodeName === "vertex") {
                    let vNode = currVerticesNode.firstElementChild;
                    while(vNode){
                        if (vNode.nodeName === "coordinates") {
                            const x = vNode.getElementsByTagName("x")[0].textContent;
                            const y = vNode.getElementsByTagName("y")[0].textContent;
                            const z = vNode.getElementsByTagName("z")[0].textContent;
                            vertArray.push(x, y, z);
                        } else if (vNode.nodeName === "normal") {
                            const nx = vNode.getElementsByTagName("nx")[0].textContent;
                            const ny = vNode.getElementsByTagName("ny")[0].textContent;
                            const nz = vNode.getElementsByTagName("nz")[0].textContent;
                            normalArray.push(nx, ny, nz);
                        }
                        vNode = vNode.nextElementSibling;
                    }
                }
                currVerticesNode = currVerticesNode.nextElementSibling;
            }
            return {
                vertices: vertArray,
                normals: normalArray
            };
        }
        function loadObject(node) {
            const objId = node.attributes.id.textContent;
            const loadedObject = {
                name: "amfobject",
                meshes: []
            };
            let currColor = null;
            let currObjNode = node.firstElementChild;
            while(currObjNode){
                if (currObjNode.nodeName === "metadata") {
                    if (currObjNode.attributes.type !== void 0) {
                        if (currObjNode.attributes.type.value === "name") {
                            loadedObject.name = currObjNode.textContent;
                        }
                    }
                } else if (currObjNode.nodeName === "color") {
                    currColor = loadColor(currObjNode);
                } else if (currObjNode.nodeName === "mesh") {
                    let currMeshNode = currObjNode.firstElementChild;
                    const mesh = {
                        vertices: [],
                        normals: [],
                        volumes: [],
                        color: currColor
                    };
                    while(currMeshNode){
                        if (currMeshNode.nodeName === "vertices") {
                            const loadedVertices = loadMeshVertices(currMeshNode);
                            mesh.normals = mesh.normals.concat(loadedVertices.normals);
                            mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);
                        } else if (currMeshNode.nodeName === "volume") {
                            mesh.volumes.push(loadMeshVolume(currMeshNode));
                        }
                        currMeshNode = currMeshNode.nextElementSibling;
                    }
                    loadedObject.meshes.push(mesh);
                }
                currObjNode = currObjNode.nextElementSibling;
            }
            return {
                id: objId,
                obj: loadedObject
            };
        }
        const xmlData = loadDocument(data);
        let amfName = "";
        let amfAuthor = "";
        const amfScale = loadDocumentScale(xmlData);
        const amfMaterials = {};
        const amfObjects = {};
        const childNodes = xmlData.documentElement.childNodes;
        let i, j;
        for(i = 0; i < childNodes.length; i++){
            const child = childNodes[i];
            if (child.nodeName === "metadata") {
                if (child.attributes.type !== void 0) {
                    if (child.attributes.type.value === "name") {
                        amfName = child.textContent;
                    } else if (child.attributes.type.value === "author") {
                        amfAuthor = child.textContent;
                    }
                }
            } else if (child.nodeName === "material") {
                const loadedMaterial = loadMaterials(child);
                amfMaterials[loadedMaterial.id] = loadedMaterial.material;
            } else if (child.nodeName === "object") {
                const loadedObject = loadObject(child);
                amfObjects[loadedObject.id] = loadedObject.obj;
            }
        }
        const sceneObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
        const defaultMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]({
            color: 11184895,
            flatShading: true
        });
        sceneObject.name = amfName;
        sceneObject.userData.author = amfAuthor;
        sceneObject.userData.loader = "AMF";
        for(const id in amfObjects){
            const part = amfObjects[id];
            const meshes = part.meshes;
            const newObject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Group"]();
            newObject.name = part.name || "";
            for(i = 0; i < meshes.length; i++){
                let objDefaultMaterial = defaultMaterial;
                const mesh = meshes[i];
                const vertices = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](mesh.vertices, 3);
                let normals = null;
                if (mesh.normals.length) {
                    normals = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](mesh.normals, 3);
                }
                if (mesh.color) {
                    const color = mesh.color;
                    objDefaultMaterial = defaultMaterial.clone();
                    objDefaultMaterial.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](color.r, color.g, color.b);
                    if (color.a !== 1) {
                        objDefaultMaterial.transparent = true;
                        objDefaultMaterial.opacity = color.a;
                    }
                }
                const volumes = mesh.volumes;
                for(j = 0; j < volumes.length; j++){
                    const volume = volumes[j];
                    const newGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
                    let material = objDefaultMaterial;
                    newGeometry.setIndex(volume.triangles);
                    newGeometry.setAttribute("position", vertices.clone());
                    if (normals) {
                        newGeometry.setAttribute("normal", normals.clone());
                    }
                    if (amfMaterials[volume.materialId] !== void 0) {
                        material = amfMaterials[volume.materialId];
                    }
                    newGeometry.scale(amfScale, amfScale, amfScale);
                    newObject.add(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](newGeometry, material.clone()));
                }
            }
            sceneObject.add(newObject);
        }
        return sceneObject;
    }
}
;
 //# sourceMappingURL=AMFLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/MMDLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MMDLoader": (()=>MMDLoader)
});
(()=>{
    const e = new Error("Cannot find module './TGALoader.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$mmdparser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/libs/mmdparser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
class MMDLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        this.parser = null;
        this.meshBuilder = new MeshBuilder(this.manager);
        this.animationBuilder = new AnimationBuilder();
    }
    /**
   * @param {string} animationPath
   * @return {MMDLoader}
   */ setAnimationPath(animationPath) {
        this.animationPath = animationPath;
        return this;
    }
    // Load MMD assets as Three.js Object
    /**
   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.
   *
   * @param {string} url - url to Model(.pmd or .pmx) file
   * @param {function} onLoad
   * @param {function} onProgress
   * @param {function} onError
   */ load(url, onLoad, onProgress, onError) {
        const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);
        let resourcePath;
        if (this.resourcePath !== "") {
            resourcePath = this.resourcePath;
        } else if (this.path !== "") {
            resourcePath = this.path;
        } else {
            resourcePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoaderUtils"].extractUrlBase(url);
        }
        const modelExtension = this._extractExtension(url).toLowerCase();
        if (modelExtension !== "pmd" && modelExtension !== "pmx") {
            if (onError) onError(new Error("THREE.MMDLoader: Unknown model file extension ." + modelExtension + "."));
            return;
        }
        this[modelExtension === "pmd" ? "loadPMD" : "loadPMX"](url, function(data) {
            onLoad(builder.build(data, resourcePath, onProgress, onError));
        }, onProgress, onError);
    }
    /**
   * Loads Motion file(s) (.vmd) as a AnimationClip.
   * If two or more files are specified, they'll be merged.
   *
   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)
   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object
   * @param {function} onLoad
   * @param {function} onProgress
   * @param {function} onError
   */ loadAnimation(url, object, onLoad, onProgress, onError) {
        const builder = this.animationBuilder;
        this.loadVMD(url, function(vmd) {
            onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));
        }, onProgress, onError);
    }
    /**
   * Loads mode file and motion file(s) as an object containing
   * a SkinnedMesh and a AnimationClip.
   * Tracks of AnimationClip are fitting to the model.
   *
   * @param {string} modelUrl - url to Model(.pmd or .pmx) file
   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file
   * @param {function} onLoad
   * @param {function} onProgress
   * @param {function} onError
   */ loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {
        const scope = this;
        this.load(modelUrl, function(mesh) {
            scope.loadAnimation(vmdUrl, mesh, function(animation) {
                onLoad({
                    mesh,
                    animation
                });
            }, onProgress, onError);
        }, onProgress, onError);
    }
    // Load MMD assets as Object data parsed by MMDParser
    /**
   * Loads .pmd file as an Object.
   *
   * @param {string} url - url to .pmd file
   * @param {function} onLoad
   * @param {function} onProgress
   * @param {function} onError
   */ loadPMD(url, onLoad, onProgress, onError) {
        const parser = this._getParser();
        this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function(buffer) {
            onLoad(parser.parsePmd(buffer, true));
        }, onProgress, onError);
    }
    /**
   * Loads .pmx file as an Object.
   *
   * @param {string} url - url to .pmx file
   * @param {function} onLoad
   * @param {function} onProgress
   * @param {function} onError
   */ loadPMX(url, onLoad, onProgress, onError) {
        const parser = this._getParser();
        this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function(buffer) {
            onLoad(parser.parsePmx(buffer, true));
        }, onProgress, onError);
    }
    /**
   * Loads .vmd file as an Object. If two or more files are specified
   * they'll be merged.
   *
   * @param {string|Array<string>} url - url(s) to .vmd file(s)
   * @param {function} onLoad
   * @param {function} onProgress
   * @param {function} onError
   */ loadVMD(url, onLoad, onProgress, onError) {
        const urls = Array.isArray(url) ? url : [
            url
        ];
        const vmds = [];
        const vmdNum = urls.length;
        const parser = this._getParser();
        this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);
        for(let i = 0, il = urls.length; i < il; i++){
            this.loader.load(urls[i], function(buffer) {
                vmds.push(parser.parseVmd(buffer, true));
                if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));
            }, onProgress, onError);
        }
    }
    /**
   * Loads .vpd file as an Object.
   *
   * @param {string} url - url to .vpd file
   * @param {boolean} isUnicode
   * @param {function} onLoad
   * @param {function} onProgress
   * @param {function} onError
   */ loadVPD(url, isUnicode, onLoad, onProgress, onError) {
        const parser = this._getParser();
        this.loader.setMimeType(isUnicode ? void 0 : "text/plain; charset=shift_jis").setPath(this.animationPath).setResponseType("text").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function(text) {
            onLoad(parser.parseVpd(text, true));
        }, onProgress, onError);
    }
    // private methods
    _extractExtension(url) {
        const index = url.lastIndexOf(".");
        return index < 0 ? "" : url.slice(index + 1);
    }
    _getParser() {
        if (this.parser === null) {
            this.parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$mmdparser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Parser"]();
        }
        return this.parser;
    }
}
const DEFAULT_TOON_TEXTURES = [
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII="
];
class MeshBuilder {
    constructor(manager){
        this.crossOrigin = "anonymous";
        this.geometryBuilder = new GeometryBuilder();
        this.materialBuilder = new MaterialBuilder(manager);
    }
    /**
   * @param {string} crossOrigin
   * @return {MeshBuilder}
   */ setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    }
    /**
   * @param {Object} data - parsed PMD/PMX data
   * @param {string} resourcePath
   * @param {function} onProgress
   * @param {function} onError
   * @return {SkinnedMesh}
   */ build(data, resourcePath, onProgress, onError) {
        const geometry = this.geometryBuilder.build(data);
        const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SkinnedMesh"](geometry, material);
        const skeleton = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Skeleton"](initBones(mesh));
        mesh.bind(skeleton);
        return mesh;
    }
}
function initBones(mesh) {
    const geometry = mesh.geometry;
    const bones = [];
    if (geometry && geometry.bones !== void 0) {
        for(let i = 0, il = geometry.bones.length; i < il; i++){
            const gbone = geometry.bones[i];
            const bone = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Bone"]();
            bones.push(bone);
            bone.name = gbone.name;
            bone.position.fromArray(gbone.pos);
            bone.quaternion.fromArray(gbone.rotq);
            if (gbone.scl !== void 0) bone.scale.fromArray(gbone.scl);
        }
        for(let i = 0, il = geometry.bones.length; i < il; i++){
            const gbone = geometry.bones[i];
            if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
                bones[gbone.parent].add(bones[i]);
            } else {
                mesh.add(bones[i]);
            }
        }
    }
    mesh.updateMatrixWorld(true);
    return bones;
}
class GeometryBuilder {
    /**
   * @param {Object} data - parsed PMD/PMX data
   * @return {BufferGeometry}
   */ build(data) {
        const positions = [];
        const uvs = [];
        const normals = [];
        const indices = [];
        const groups = [];
        const bones = [];
        const skinIndices = [];
        const skinWeights = [];
        const morphTargets = [];
        const morphPositions = [];
        const iks = [];
        const grants = [];
        const rigidBodies = [];
        const constraints = [];
        let offset = 0;
        const boneTypeTable = {};
        for(let i = 0; i < data.metadata.vertexCount; i++){
            const v = data.vertices[i];
            for(let j = 0, jl = v.position.length; j < jl; j++){
                positions.push(v.position[j]);
            }
            for(let j = 0, jl = v.normal.length; j < jl; j++){
                normals.push(v.normal[j]);
            }
            for(let j = 0, jl = v.uv.length; j < jl; j++){
                uvs.push(v.uv[j]);
            }
            for(let j = 0; j < 4; j++){
                skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0);
            }
            for(let j = 0; j < 4; j++){
                skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0);
            }
        }
        for(let i = 0; i < data.metadata.faceCount; i++){
            const face = data.faces[i];
            for(let j = 0, jl = face.indices.length; j < jl; j++){
                indices.push(face.indices[j]);
            }
        }
        for(let i = 0; i < data.metadata.materialCount; i++){
            const material = data.materials[i];
            groups.push({
                offset: offset * 3,
                count: material.faceCount * 3
            });
            offset += material.faceCount;
        }
        for(let i = 0; i < data.metadata.rigidBodyCount; i++){
            const body = data.rigidBodies[i];
            let value = boneTypeTable[body.boneIndex];
            value = value === void 0 ? body.type : Math.max(body.type, value);
            boneTypeTable[body.boneIndex] = value;
        }
        for(let i = 0; i < data.metadata.boneCount; i++){
            const boneData = data.bones[i];
            const bone = {
                index: i,
                transformationClass: boneData.transformationClass,
                parent: boneData.parentIndex,
                name: boneData.name,
                pos: boneData.position.slice(0, 3),
                rotq: [
                    0,
                    0,
                    0,
                    1
                ],
                scl: [
                    1,
                    1,
                    1
                ],
                rigidBodyType: boneTypeTable[i] !== void 0 ? boneTypeTable[i] : -1
            };
            if (bone.parent !== -1) {
                bone.pos[0] -= data.bones[bone.parent].position[0];
                bone.pos[1] -= data.bones[bone.parent].position[1];
                bone.pos[2] -= data.bones[bone.parent].position[2];
            }
            bones.push(bone);
        }
        if (data.metadata.format === "pmd") {
            for(let i = 0; i < data.metadata.ikCount; i++){
                const ik = data.iks[i];
                const param = {
                    target: ik.target,
                    effector: ik.effector,
                    iteration: ik.iteration,
                    maxAngle: ik.maxAngle * 4,
                    links: []
                };
                for(let j = 0, jl = ik.links.length; j < jl; j++){
                    const link = {};
                    link.index = ik.links[j].index;
                    link.enabled = true;
                    if (data.bones[link.index].name.indexOf("") >= 0) {
                        link.limitation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0);
                    }
                    param.links.push(link);
                }
                iks.push(param);
            }
        } else {
            for(let i = 0; i < data.metadata.boneCount; i++){
                const ik = data.bones[i].ik;
                if (ik === void 0) continue;
                const param = {
                    target: i,
                    effector: ik.effector,
                    iteration: ik.iteration,
                    maxAngle: ik.maxAngle,
                    links: []
                };
                for(let j = 0, jl = ik.links.length; j < jl; j++){
                    const link = {};
                    link.index = ik.links[j].index;
                    link.enabled = true;
                    if (ik.links[j].angleLimitation === 1) {
                        const rotationMin = ik.links[j].lowerLimitationAngle;
                        const rotationMax = ik.links[j].upperLimitationAngle;
                        const tmp1 = -rotationMax[0];
                        const tmp2 = -rotationMax[1];
                        rotationMax[0] = -rotationMin[0];
                        rotationMax[1] = -rotationMin[1];
                        rotationMin[0] = tmp1;
                        rotationMin[1] = tmp2;
                        link.rotationMin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(rotationMin);
                        link.rotationMax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(rotationMax);
                    }
                    param.links.push(link);
                }
                iks.push(param);
                bones[i].ik = param;
            }
        }
        if (data.metadata.format === "pmx") {
            let traverse = function(entry) {
                if (entry.param) {
                    grants.push(entry.param);
                    bones[entry.param.index].grant = entry.param;
                }
                entry.visited = true;
                for(let i = 0, il = entry.children.length; i < il; i++){
                    const child = entry.children[i];
                    if (!child.visited) traverse(child);
                }
            };
            const grantEntryMap = {};
            for(let i = 0; i < data.metadata.boneCount; i++){
                const boneData = data.bones[i];
                const grant = boneData.grant;
                if (grant === void 0) continue;
                const param = {
                    index: i,
                    parentIndex: grant.parentIndex,
                    ratio: grant.ratio,
                    isLocal: grant.isLocal,
                    affectRotation: grant.affectRotation,
                    affectPosition: grant.affectPosition,
                    transformationClass: boneData.transformationClass
                };
                grantEntryMap[i] = {
                    parent: null,
                    children: [],
                    param,
                    visited: false
                };
            }
            const rootEntry = {
                parent: null,
                children: [],
                param: null,
                visited: false
            };
            for(const boneIndex in grantEntryMap){
                const grantEntry = grantEntryMap[boneIndex];
                const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;
                grantEntry.parent = parentGrantEntry;
                parentGrantEntry.children.push(grantEntry);
            }
            traverse(rootEntry);
        }
        function updateAttributes(attribute, morph, ratio) {
            for(let i = 0; i < morph.elementCount; i++){
                const element = morph.elements[i];
                let index;
                if (data.metadata.format === "pmd") {
                    index = data.morphs[0].elements[element.index].index;
                } else {
                    index = element.index;
                }
                attribute.array[index * 3 + 0] += element.position[0] * ratio;
                attribute.array[index * 3 + 1] += element.position[1] * ratio;
                attribute.array[index * 3 + 2] += element.position[2] * ratio;
            }
        }
        for(let i = 0; i < data.metadata.morphCount; i++){
            const morph = data.morphs[i];
            const params = {
                name: morph.name
            };
            const attribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](data.metadata.vertexCount * 3, 3);
            attribute.name = morph.name;
            for(let j = 0; j < data.metadata.vertexCount * 3; j++){
                attribute.array[j] = positions[j];
            }
            if (data.metadata.format === "pmd") {
                if (i !== 0) {
                    updateAttributes(attribute, morph, 1);
                }
            } else {
                if (morph.type === 0) {
                    for(let j = 0; j < morph.elementCount; j++){
                        const morph2 = data.morphs[morph.elements[j].index];
                        const ratio = morph.elements[j].ratio;
                        if (morph2.type === 1) {
                            updateAttributes(attribute, morph2, ratio);
                        }
                    }
                } else if (morph.type === 1) {
                    updateAttributes(attribute, morph, 1);
                } else if (morph.type === 2) ;
                else if (morph.type === 3) ;
                else if (morph.type === 4) ;
                else if (morph.type === 5) ;
                else if (morph.type === 6) ;
                else if (morph.type === 7) ;
                else if (morph.type === 8) ;
            }
            morphTargets.push(params);
            morphPositions.push(attribute);
        }
        for(let i = 0; i < data.metadata.rigidBodyCount; i++){
            const rigidBody = data.rigidBodies[i];
            const params = {};
            for(const key in rigidBody){
                params[key] = rigidBody[key];
            }
            if (data.metadata.format === "pmx") {
                if (params.boneIndex !== -1) {
                    const bone = data.bones[params.boneIndex];
                    params.position[0] -= bone.position[0];
                    params.position[1] -= bone.position[1];
                    params.position[2] -= bone.position[2];
                }
            }
            rigidBodies.push(params);
        }
        for(let i = 0; i < data.metadata.constraintCount; i++){
            const constraint = data.constraints[i];
            const params = {};
            for(const key in constraint){
                params[key] = constraint[key];
            }
            const bodyA = rigidBodies[params.rigidBodyIndex1];
            const bodyB = rigidBodies[params.rigidBodyIndex2];
            if (bodyA.type !== 0 && bodyB.type === 2) {
                if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {
                    bodyB.type = 1;
                }
            }
            constraints.push(params);
        }
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](positions, 3));
        geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normals, 3));
        geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uvs, 2));
        geometry.setAttribute("skinIndex", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Uint16BufferAttribute"](skinIndices, 4));
        geometry.setAttribute("skinWeight", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](skinWeights, 4));
        geometry.setIndex(indices);
        for(let i = 0, il = groups.length; i < il; i++){
            geometry.addGroup(groups[i].offset, groups[i].count, i);
        }
        geometry.bones = bones;
        geometry.morphTargets = morphTargets;
        geometry.morphAttributes.position = morphPositions;
        geometry.morphTargetsRelative = false;
        geometry.userData.MMD = {
            bones,
            iks,
            grants,
            rigidBodies,
            constraints,
            format: data.metadata.format
        };
        geometry.computeBoundingSphere();
        return geometry;
    }
}
class MaterialBuilder {
    constructor(manager){
        this.manager = manager;
        this.textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.manager);
        this.tgaLoader = null;
        this.crossOrigin = "anonymous";
        this.resourcePath = void 0;
    }
    /**
   * @param {string} crossOrigin
   * @return {MaterialBuilder}
   */ setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    }
    /**
   * @param {string} resourcePath
   * @return {MaterialBuilder}
   */ setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    }
    /**
   * @param {Object} data - parsed PMD/PMX data
   * @param {BufferGeometry} geometry - some properties are dependend on geometry
   * @param {function} onProgress
   * @param {function} onError
   * @return {Array<MeshToonMaterial>}
   */ build(data, geometry) {
        const materials = [];
        const textures = {};
        this.textureLoader.setCrossOrigin(this.crossOrigin);
        for(let i = 0; i < data.metadata.materialCount; i++){
            const material = data.materials[i];
            const params = {
                userData: {}
            };
            if (material.name !== void 0) params.name = material.name;
            params.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(material.diffuse);
            params.opacity = material.diffuse[3];
            params.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(material.ambient);
            params.transparent = params.opacity !== 1;
            params.skinning = geometry.bones.length > 0 ? true : false;
            params.morphTargets = geometry.morphTargets.length > 0 ? true : false;
            params.fog = true;
            params.blending = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CustomBlending"];
            params.blendSrc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SrcAlphaFactor"];
            params.blendDst = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OneMinusSrcAlphaFactor"];
            params.blendSrcAlpha = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SrcAlphaFactor"];
            params.blendDstAlpha = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DstAlphaFactor"];
            if (data.metadata.format === "pmx" && (material.flag & 1) === 1) {
                params.side = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"];
            } else {
                params.side = params.opacity === 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"];
            }
            if (data.metadata.format === "pmd") {
                if (material.fileName) {
                    const fileName = material.fileName;
                    const fileNames = fileName.split("*");
                    params.map = this._loadTexture(fileNames[0], textures);
                    if (fileNames.length > 1) {
                        const extension = fileNames[1].slice(-4).toLowerCase();
                        params.envMap = this._loadTexture(fileNames[1], textures);
                        params.combine = extension === ".sph" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MultiplyOperation"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AddOperation"];
                    }
                }
                const toonFileName = material.toonIndex === -1 ? "toon00.bmp" : data.toonTextures[material.toonIndex].fileName;
                params.gradientMap = this._loadTexture(toonFileName, textures, {
                    isToonTexture: true,
                    isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)
                });
                params.userData.outlineParameters = {
                    thickness: material.edgeFlag === 1 ? 3e-3 : 0,
                    color: [
                        0,
                        0,
                        0
                    ],
                    alpha: 1,
                    visible: material.edgeFlag === 1
                };
            } else {
                if (material.textureIndex !== -1) {
                    params.map = this._loadTexture(data.textures[material.textureIndex], textures);
                }
                if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {
                    params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);
                    params.combine = material.envFlag === 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MultiplyOperation"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AddOperation"];
                }
                let toonFileName, isDefaultToon;
                if (material.toonIndex === -1 || material.toonFlag !== 0) {
                    toonFileName = "toon" + ("0" + (material.toonIndex + 1)).slice(-2) + ".bmp";
                    isDefaultToon = true;
                } else {
                    toonFileName = data.textures[material.toonIndex];
                    isDefaultToon = false;
                }
                params.gradientMap = this._loadTexture(toonFileName, textures, {
                    isToonTexture: true,
                    isDefaultToonTexture: isDefaultToon
                });
                params.userData.outlineParameters = {
                    thickness: material.edgeSize / 300,
                    // TODO: better calculation?
                    color: material.edgeColor.slice(0, 3),
                    alpha: material.edgeColor[3],
                    visible: (material.flag & 16) !== 0 && material.edgeSize > 0
                };
            }
            if (params.map !== void 0) {
                if (!params.transparent) {
                    this._checkImageTransparency(params.map, geometry, i);
                }
                params.emissive.multiplyScalar(0.2);
            }
            materials.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshToonMaterial"](params));
        }
        if (data.metadata.format === "pmx") {
            let checkAlphaMorph = function(elements, materials2) {
                for(let i = 0, il = elements.length; i < il; i++){
                    const element = elements[i];
                    if (element.index === -1) continue;
                    const material = materials2[element.index];
                    if (material.opacity !== element.diffuse[3]) {
                        material.transparent = true;
                    }
                }
            };
            for(let i = 0, il = data.morphs.length; i < il; i++){
                const morph = data.morphs[i];
                const elements = morph.elements;
                if (morph.type === 0) {
                    for(let j = 0, jl = elements.length; j < jl; j++){
                        const morph2 = data.morphs[elements[j].index];
                        if (morph2.type !== 8) continue;
                        checkAlphaMorph(morph2.elements, materials);
                    }
                } else if (morph.type === 8) {
                    checkAlphaMorph(elements, materials);
                }
            }
        }
        return materials;
    }
    // private methods
    _getTGALoader() {
        if (this.tgaLoader === null) {
            if (TGALoader === void 0) {
                throw new Error("THREE.MMDLoader: Import TGALoader");
            }
            this.tgaLoader = new TGALoader(this.manager);
        }
        return this.tgaLoader;
    }
    _isDefaultToonTexture(name) {
        if (name.length !== 10) return false;
        return /toon(10|0[0-9])\.bmp/.test(name);
    }
    _loadTexture(filePath, textures, params, onProgress, onError) {
        params = params || {};
        const scope = this;
        let fullPath;
        if (params.isDefaultToonTexture === true) {
            let index;
            try {
                index = parseInt(filePath.match(/toon([0-9]{2})\.bmp$/)[1]);
            } catch (e) {
                console.warn("THREE.MMDLoader: " + filePath + " seems like a not right default texture path. Using toon00.bmp instead.");
                index = 0;
            }
            fullPath = DEFAULT_TOON_TEXTURES[index];
        } else {
            fullPath = this.resourcePath + filePath;
        }
        if (textures[fullPath] !== void 0) return textures[fullPath];
        let loader = this.manager.getHandler(fullPath);
        if (loader === null) {
            loader = filePath.slice(-4).toLowerCase() === ".tga" ? this._getTGALoader() : this.textureLoader;
        }
        const texture = loader.load(fullPath, function(t) {
            if (params.isToonTexture === true) {
                t.image = scope._getRotatedImage(t.image);
                t.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
                t.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            }
            t.flipY = false;
            t.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
            t.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
            for(let i = 0; i < texture.readyCallbacks.length; i++){
                texture.readyCallbacks[i](texture);
            }
            delete texture.readyCallbacks;
        }, onProgress, onError);
        texture.readyCallbacks = [];
        textures[fullPath] = texture;
        return texture;
    }
    _getRotatedImage(image) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const width = image.width;
        const height = image.height;
        canvas.width = width;
        canvas.height = height;
        context.clearRect(0, 0, width, height);
        context.translate(width / 2, height / 2);
        context.rotate(0.5 * Math.PI);
        context.translate(-width / 2, -height / 2);
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, width, height);
    }
    // Check if the partial image area used by the texture is transparent.
    _checkImageTransparency(map, geometry, groupIndex) {
        map.readyCallbacks.push(function(texture) {
            function createImageData(image) {
                const canvas = document.createElement("canvas");
                canvas.width = image.width;
                canvas.height = image.height;
                const context = canvas.getContext("2d");
                context.drawImage(image, 0, 0);
                return context.getImageData(0, 0, canvas.width, canvas.height);
            }
            function detectImageTransparency(image, uvs, indices) {
                const width = image.width;
                const height = image.height;
                const data = image.data;
                const threshold = 253;
                if (data.length / (width * height) !== 4) return false;
                for(let i = 0; i < indices.length; i += 3){
                    const centerUV = {
                        x: 0,
                        y: 0
                    };
                    for(let j = 0; j < 3; j++){
                        const index = indices[i * 3 + j];
                        const uv = {
                            x: uvs[index * 2 + 0],
                            y: uvs[index * 2 + 1]
                        };
                        if (getAlphaByUv(image, uv) < threshold) return true;
                        centerUV.x += uv.x;
                        centerUV.y += uv.y;
                    }
                    centerUV.x /= 3;
                    centerUV.y /= 3;
                    if (getAlphaByUv(image, centerUV) < threshold) return true;
                }
                return false;
            }
            function getAlphaByUv(image, uv) {
                const width = image.width;
                const height = image.height;
                let x = Math.round(uv.x * width) % width;
                let y = Math.round(uv.y * height) % height;
                if (x < 0) x += width;
                if (y < 0) y += height;
                const index = y * width + x;
                return image.data[index * 4 + 3];
            }
            const imageData = texture.image.data !== void 0 ? texture.image : createImageData(texture.image);
            const group = geometry.groups[groupIndex];
            if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {
                map.transparent = true;
            }
        });
    }
}
class AnimationBuilder {
    /**
   * @param {Object} vmd - parsed VMD data
   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh
   * @return {AnimationClip}
   */ build(vmd, mesh) {
        const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;
        const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;
        for(let i = 0, il = tracks2.length; i < il; i++){
            tracks.push(tracks2[i]);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"]("", -1, tracks);
    }
    /**
   * @param {Object} vmd - parsed VMD data
   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh
   * @return {AnimationClip}
   */ buildSkeletalAnimation(vmd, mesh) {
        function pushInterpolation(array, interpolation, index) {
            array.push(interpolation[index + 0] / 127);
            array.push(interpolation[index + 8] / 127);
            array.push(interpolation[index + 4] / 127);
            array.push(interpolation[index + 12] / 127);
        }
        const tracks = [];
        const motions = {};
        const bones = mesh.skeleton.bones;
        const boneNameDictionary = {};
        for(let i = 0, il = bones.length; i < il; i++){
            boneNameDictionary[bones[i].name] = true;
        }
        for(let i = 0; i < vmd.metadata.motionCount; i++){
            const motion = vmd.motions[i];
            const boneName = motion.boneName;
            if (boneNameDictionary[boneName] === void 0) continue;
            motions[boneName] = motions[boneName] || [];
            motions[boneName].push(motion);
        }
        for(const key in motions){
            const array = motions[key];
            array.sort(function(a, b) {
                return a.frameNum - b.frameNum;
            });
            const times = [];
            const positions = [];
            const rotations = [];
            const pInterpolations = [];
            const rInterpolations = [];
            const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();
            for(let i = 0, il = array.length; i < il; i++){
                const time = array[i].frameNum / 30;
                const position = array[i].position;
                const rotation = array[i].rotation;
                const interpolation = array[i].interpolation;
                times.push(time);
                for(let j = 0; j < 3; j++)positions.push(basePosition[j] + position[j]);
                for(let j = 0; j < 4; j++)rotations.push(rotation[j]);
                for(let j = 0; j < 3; j++)pushInterpolation(pInterpolations, interpolation, j);
                pushInterpolation(rInterpolations, interpolation, 3);
            }
            const targetName = ".bones[" + key + "]";
            tracks.push(this._createTrack(targetName + ".position", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"], times, positions, pInterpolations));
            tracks.push(this._createTrack(targetName + ".quaternion", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"], times, rotations, rInterpolations));
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"]("", -1, tracks);
    }
    /**
   * @param {Object} vmd - parsed VMD data
   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh
   * @return {AnimationClip}
   */ buildMorphAnimation(vmd, mesh) {
        const tracks = [];
        const morphs = {};
        const morphTargetDictionary = mesh.morphTargetDictionary;
        for(let i = 0; i < vmd.metadata.morphCount; i++){
            const morph = vmd.morphs[i];
            const morphName = morph.morphName;
            if (morphTargetDictionary[morphName] === void 0) continue;
            morphs[morphName] = morphs[morphName] || [];
            morphs[morphName].push(morph);
        }
        for(const key in morphs){
            const array = morphs[key];
            array.sort(function(a, b) {
                return a.frameNum - b.frameNum;
            });
            const times = [];
            const values = [];
            for(let i = 0, il = array.length; i < il; i++){
                times.push(array[i].frameNum / 30);
                values.push(array[i].weight);
            }
            tracks.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"](".morphTargetInfluences[" + morphTargetDictionary[key] + "]", times, values));
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"]("", -1, tracks);
    }
    /**
   * @param {Object} vmd - parsed VMD data
   * @return {AnimationClip}
   */ buildCameraAnimation(vmd) {
        function pushVector3(array, vec) {
            array.push(vec.x);
            array.push(vec.y);
            array.push(vec.z);
        }
        function pushQuaternion(array, q) {
            array.push(q.x);
            array.push(q.y);
            array.push(q.z);
            array.push(q.w);
        }
        function pushInterpolation(array, interpolation, index) {
            array.push(interpolation[index * 4 + 0] / 127);
            array.push(interpolation[index * 4 + 1] / 127);
            array.push(interpolation[index * 4 + 2] / 127);
            array.push(interpolation[index * 4 + 3] / 127);
        }
        const cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();
        cameras.sort(function(a, b) {
            return a.frameNum - b.frameNum;
        });
        const times = [];
        const centers = [];
        const quaternions = [];
        const positions = [];
        const fovs = [];
        const cInterpolations = [];
        const qInterpolations = [];
        const pInterpolations = [];
        const fInterpolations = [];
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
        const euler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"]();
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0, il = cameras.length; i < il; i++){
            const motion = cameras[i];
            const time = motion.frameNum / 30;
            const pos = motion.position;
            const rot = motion.rotation;
            const distance = motion.distance;
            const fov = motion.fov;
            const interpolation = motion.interpolation;
            times.push(time);
            position.set(0, 0, -distance);
            center.set(pos[0], pos[1], pos[2]);
            euler.set(-rot[0], -rot[1], -rot[2]);
            quaternion.setFromEuler(euler);
            position.add(center);
            position.applyQuaternion(quaternion);
            pushVector3(centers, center);
            pushQuaternion(quaternions, quaternion);
            pushVector3(positions, position);
            fovs.push(fov);
            for(let j = 0; j < 3; j++){
                pushInterpolation(cInterpolations, interpolation, j);
            }
            pushInterpolation(qInterpolations, interpolation, 3);
            for(let j = 0; j < 3; j++){
                pushInterpolation(pInterpolations, interpolation, 4);
            }
            pushInterpolation(fInterpolations, interpolation, 5);
        }
        const tracks = [];
        tracks.push(this._createTrack("target.position", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"], times, centers, cInterpolations));
        tracks.push(this._createTrack(".quaternion", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuaternionKeyframeTrack"], times, quaternions, qInterpolations));
        tracks.push(this._createTrack(".position", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorKeyframeTrack"], times, positions, pInterpolations));
        tracks.push(this._createTrack(".fov", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NumberKeyframeTrack"], times, fovs, fInterpolations));
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationClip"]("", -1, tracks);
    }
    // private method
    _createTrack(node, typedKeyframeTrack, times, values, interpolations) {
        if (times.length > 2) {
            times = times.slice();
            values = values.slice();
            interpolations = interpolations.slice();
            const stride = values.length / times.length;
            const interpolateStride = interpolations.length / times.length;
            let index = 1;
            for(let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++){
                for(let i = 0; i < stride; i++){
                    if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {
                        index++;
                        break;
                    }
                }
                if (aheadIndex > index) {
                    times[index] = times[aheadIndex];
                    for(let i = 0; i < stride; i++){
                        values[index * stride + i] = values[aheadIndex * stride + i];
                    }
                    for(let i = 0; i < interpolateStride; i++){
                        interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];
                    }
                }
            }
            times.length = index + 1;
            values.length = (index + 1) * stride;
            interpolations.length = (index + 1) * interpolateStride;
        }
        const track = new typedKeyframeTrack(node, times, values);
        track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {
            return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));
        };
        return track;
    }
}
class CubicBezierInterpolation extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Interpolant"] {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        this.interpolationParams = params;
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer;
        const values = this.sampleValues;
        const stride = this.valueSize;
        const params = this.interpolationParams;
        const offset1 = i1 * stride;
        const offset0 = offset1 - stride;
        const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t - t0) / (t1 - t0);
        if (stride === 4) {
            const x1 = params[i1 * 4 + 0];
            const x2 = params[i1 * 4 + 1];
            const y1 = params[i1 * 4 + 2];
            const y2 = params[i1 * 4 + 3];
            const ratio = this._calculate(x1, x2, y1, y2, weight1);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].slerpFlat(result, 0, values, offset0, values, offset1, ratio);
        } else if (stride === 3) {
            for(let i = 0; i !== stride; ++i){
                const x1 = params[i1 * 12 + i * 4 + 0];
                const x2 = params[i1 * 12 + i * 4 + 1];
                const y1 = params[i1 * 12 + i * 4 + 2];
                const y2 = params[i1 * 12 + i * 4 + 3];
                const ratio = this._calculate(x1, x2, y1, y2, weight1);
                result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;
            }
        } else {
            const x1 = params[i1 * 4 + 0];
            const x2 = params[i1 * 4 + 1];
            const y1 = params[i1 * 4 + 2];
            const y2 = params[i1 * 4 + 3];
            const ratio = this._calculate(x1, x2, y1, y2, weight1);
            result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;
        }
        return result;
    }
    _calculate(x1, x2, y1, y2, x) {
        let c = 0.5;
        let t = c;
        let s = 1 - t;
        const loop = 15;
        const eps = 1e-5;
        const math = Math;
        let sst3, stt3, ttt;
        for(let i = 0; i < loop; i++){
            sst3 = 3 * s * s * t;
            stt3 = 3 * s * t * t;
            ttt = t * t * t;
            const ft = sst3 * x1 + stt3 * x2 + ttt - x;
            if (math.abs(ft) < eps) break;
            c /= 2;
            t += ft < 0 ? c : -c;
            s = 1 - t;
        }
        return sst3 * y1 + stt3 * y2 + ttt;
    }
}
;
 //# sourceMappingURL=MMDLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/KTXLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "KTXLoader": (()=>KTXLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class KTXLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompressedTextureLoader"] {
    constructor(manager){
        super(manager);
    }
    parse(buffer, loadMipmaps) {
        const ktx = new KhronosTextureContainer(buffer, 1);
        return {
            mipmaps: ktx.mipmaps(loadMipmaps),
            width: ktx.pixelWidth,
            height: ktx.pixelHeight,
            format: ktx.glInternalFormat,
            isCubemap: ktx.numberOfFaces === 6,
            mipmapCount: ktx.numberOfMipmapLevels
        };
    }
}
const HEADER_LEN = 12 + 13 * 4;
const COMPRESSED_2D = 0;
class KhronosTextureContainer {
    /**
   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file
   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or
   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented
   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented
   */ constructor(arrayBuffer, facesExpected){
        this.arrayBuffer = arrayBuffer;
        const identifier = new Uint8Array(this.arrayBuffer, 0, 12);
        if (identifier[0] !== 171 || identifier[1] !== 75 || identifier[2] !== 84 || identifier[3] !== 88 || identifier[4] !== 32 || identifier[5] !== 49 || identifier[6] !== 49 || identifier[7] !== 187 || identifier[8] !== 13 || identifier[9] !== 10 || identifier[10] !== 26 || identifier[11] !== 10) {
            console.error("texture missing KTX identifier");
            return;
        }
        const dataSize = Uint32Array.BYTES_PER_ELEMENT;
        const headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize);
        const endianness = headerDataView.getUint32(0, true);
        const littleEndian = endianness === 67305985;
        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian);
        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian);
        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian);
        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
        if (this.glType !== 0) {
            console.warn("only compressed formats currently supported");
            return;
        } else {
            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
        }
        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
            console.warn("only 2D textures currently supported");
            return;
        }
        if (this.numberOfArrayElements !== 0) {
            console.warn("texture arrays not currently supported");
            return;
        }
        if (this.numberOfFaces !== facesExpected) {
            console.warn("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
            return;
        }
        this.loadType = COMPRESSED_2D;
    }
    mipmaps(loadMipmaps) {
        const mipmaps = [];
        let dataOffset = HEADER_LEN + this.bytesOfKeyValueData;
        let width = this.pixelWidth;
        let height = this.pixelHeight;
        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
        for(let level = 0; level < mipmapCount; level++){
            const imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0];
            dataOffset += 4;
            for(let face = 0; face < this.numberOfFaces; face++){
                const byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize);
                mipmaps.push({
                    data: byteArray,
                    width,
                    height
                });
                dataOffset += imageSize;
                dataOffset += 3 - (imageSize + 3) % 4;
            }
            width = Math.max(1, width * 0.5);
            height = Math.max(1, height * 0.5);
        }
        return mipmaps;
    }
}
;
 //# sourceMappingURL=KTXLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/DRACOLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DRACOLoader": (()=>DRACOLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _taskCache = /* @__PURE__ */ new WeakMap();
class DRACOLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.decoderPath = "";
        this.decoderConfig = {};
        this.decoderBinary = null;
        this.decoderPending = null;
        this.workerLimit = 4;
        this.workerPool = [];
        this.workerNextTaskID = 1;
        this.workerSourceURL = "";
        this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        };
        this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        };
    }
    setDecoderPath(path) {
        this.decoderPath = path;
        return this;
    }
    setDecoderConfig(config) {
        this.decoderConfig = config;
        return this;
    }
    setWorkerLimit(workerLimit) {
        this.workerLimit = workerLimit;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, (buffer)=>{
            const taskConfig = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: false
            };
            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);
        }, onProgress, onError);
    }
    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
        const taskConfig = {
            attributeIDs: attributeIDs || this.defaultAttributeIDs,
            attributeTypes: attributeTypes || this.defaultAttributeTypes,
            useUniqueIDs: !!attributeIDs
        };
        this.decodeGeometry(buffer, taskConfig).then(callback);
    }
    decodeGeometry(buffer, taskConfig) {
        for(const attribute in taskConfig.attributeTypes){
            const type = taskConfig.attributeTypes[attribute];
            if (type.BYTES_PER_ELEMENT !== void 0) {
                taskConfig.attributeTypes[attribute] = type.name;
            }
        }
        const taskKey = JSON.stringify(taskConfig);
        if (_taskCache.has(buffer)) {
            const cachedTask = _taskCache.get(buffer);
            if (cachedTask.key === taskKey) {
                return cachedTask.promise;
            } else if (buffer.byteLength === 0) {
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
            }
        }
        let worker;
        const taskID = this.workerNextTaskID++;
        const taskCost = buffer.byteLength;
        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{
            worker = _worker;
            return new Promise((resolve, reject)=>{
                worker._callbacks[taskID] = {
                    resolve,
                    reject
                };
                worker.postMessage({
                    type: "decode",
                    id: taskID,
                    taskConfig,
                    buffer
                }, [
                    buffer
                ]);
            });
        }).then((message)=>this._createGeometry(message.geometry));
        geometryPending.catch(()=>true).then(()=>{
            if (worker && taskID) {
                this._releaseTask(worker, taskID);
            }
        });
        _taskCache.set(buffer, {
            key: taskKey,
            promise: geometryPending
        });
        return geometryPending;
    }
    _createGeometry(geometryData) {
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        if (geometryData.index) {
            geometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](geometryData.index.array, 1));
        }
        for(let i = 0; i < geometryData.attributes.length; i++){
            const attribute = geometryData.attributes[i];
            const name = attribute.name;
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            geometry.setAttribute(name, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](array, itemSize));
        }
        return geometry;
    }
    _loadLibrary(url, responseType) {
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.decoderPath);
        loader.setResponseType(responseType);
        loader.setWithCredentials(this.withCredentials);
        return new Promise((resolve, reject)=>{
            loader.load(url, resolve, void 0, reject);
        });
    }
    preload() {
        this._initDecoder();
        return this;
    }
    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
        const librariesPending = [];
        if (useJS) {
            librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
        } else {
            librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
            librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
        }
        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{
            const jsContent = libraries[0];
            if (!useJS) {
                this.decoderConfig.wasmBinary = libraries[1];
            }
            const fn = DRACOWorker.toString();
            const body = [
                "/* draco decoder */",
                jsContent,
                "",
                "/* worker */",
                fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
            ].join("\n");
            this.workerSourceURL = URL.createObjectURL(new Blob([
                body
            ]));
        });
        return this.decoderPending;
    }
    _getWorker(taskID, taskCost) {
        return this._initDecoder().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                const worker2 = new Worker(this.workerSourceURL);
                worker2._callbacks = {};
                worker2._taskCosts = {};
                worker2._taskLoad = 0;
                worker2.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                });
                worker2.onmessage = function(e) {
                    const message = e.data;
                    switch(message.type){
                        case "decode":
                            worker2._callbacks[message.id].resolve(message);
                            break;
                        case "error":
                            worker2._callbacks[message.id].reject(message);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
                    }
                };
                this.workerPool.push(worker2);
            } else {
                this.workerPool.sort(function(a, b) {
                    return a._taskLoad > b._taskLoad ? -1 : 1;
                });
            }
            const worker = this.workerPool[this.workerPool.length - 1];
            worker._taskCosts[taskID] = taskCost;
            worker._taskLoad += taskCost;
            return worker;
        });
    }
    _releaseTask(worker, taskID) {
        worker._taskLoad -= worker._taskCosts[taskID];
        delete worker._callbacks[taskID];
        delete worker._taskCosts[taskID];
    }
    debug() {
        console.log("Task load: ", this.workerPool.map((worker)=>worker._taskLoad));
    }
    dispose() {
        for(let i = 0; i < this.workerPool.length; ++i){
            this.workerPool[i].terminate();
        }
        this.workerPool.length = 0;
        return this;
    }
}
function DRACOWorker() {
    let decoderConfig;
    let decoderPending;
    onmessage = function(e) {
        const message = e.data;
        switch(message.type){
            case "init":
                decoderConfig = message.decoderConfig;
                decoderPending = new Promise(function(resolve) {
                    decoderConfig.onModuleLoaded = function(draco) {
                        resolve({
                            draco
                        });
                    };
                    DracoDecoderModule(decoderConfig);
                });
                break;
            case "decode":
                const buffer = message.buffer;
                const taskConfig = message.taskConfig;
                decoderPending.then((module)=>{
                    const draco = module.draco;
                    const decoder = new draco.Decoder();
                    const decoderBuffer = new draco.DecoderBuffer();
                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
                    try {
                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);
                        if (geometry.index) buffers.push(geometry.index.array.buffer);
                        self.postMessage({
                            type: "decode",
                            id: message.id,
                            geometry
                        }, buffers);
                    } catch (error) {
                        console.error(error);
                        self.postMessage({
                            type: "error",
                            id: message.id,
                            error: error.message
                        });
                    } finally{
                        draco.destroy(decoderBuffer);
                        draco.destroy(decoder);
                    }
                });
                break;
        }
    };
    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
        const attributeIDs = taskConfig.attributeIDs;
        const attributeTypes = taskConfig.attributeTypes;
        let dracoGeometry;
        let decodingStatus;
        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
        if (geometryType === draco.TRIANGULAR_MESH) {
            dracoGeometry = new draco.Mesh();
            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
        } else if (geometryType === draco.POINT_CLOUD) {
            dracoGeometry = new draco.PointCloud();
            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
        } else {
            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        }
        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
            throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
        }
        const geometry = {
            index: null,
            attributes: []
        };
        for(const attributeName in attributeIDs){
            const attributeType = self[attributeTypes[attributeName]];
            let attribute;
            let attributeID;
            if (taskConfig.useUniqueIDs) {
                attributeID = attributeIDs[attributeName];
                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
            } else {
                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
                if (attributeID === -1) continue;
                attribute = decoder.GetAttribute(dracoGeometry, attributeID);
            }
            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
        }
        if (geometryType === draco.TRIANGULAR_MESH) {
            geometry.index = decodeIndex(draco, decoder, dracoGeometry);
        }
        draco.destroy(dracoGeometry);
        return geometry;
    }
    function decodeIndex(draco, decoder, dracoGeometry) {
        const numFaces = dracoGeometry.num_faces();
        const numIndices = numFaces * 3;
        const byteLength = numIndices * 4;
        const ptr = draco._malloc(byteLength);
        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
        draco._free(ptr);
        return {
            array: index,
            itemSize: 1
        };
    }
    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
        const numComponents = attribute.num_components();
        const numPoints = dracoGeometry.num_points();
        const numValues = numPoints * numComponents;
        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
        const dataType = getDracoDataType(draco, attributeType);
        const ptr = draco._malloc(byteLength);
        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
        draco._free(ptr);
        return {
            name: attributeName,
            array,
            itemSize: numComponents
        };
    }
    function getDracoDataType(draco, attributeType) {
        switch(attributeType){
            case Float32Array:
                return draco.DT_FLOAT32;
            case Int8Array:
                return draco.DT_INT8;
            case Int16Array:
                return draco.DT_INT16;
            case Int32Array:
                return draco.DT_INT32;
            case Uint8Array:
                return draco.DT_UINT8;
            case Uint16Array:
                return draco.DT_UINT16;
            case Uint32Array:
                return draco.DT_UINT32;
        }
    }
}
;
 //# sourceMappingURL=DRACOLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/HDRCubeTextureLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "HDRCubeTextureLoader": (()=>HDRCubeTextureLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$RGBELoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/RGBELoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class HDRCubeTextureLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.hdrLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$RGBELoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBELoader"]();
        this.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
    }
    load(urls, onLoad, onProgress, onError) {
        if (typeof urls === "string") {
            urls = [
                urls
            ];
        } else if (!Array.isArray(urls)) {
            console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead.");
            this.setDataType(urls);
            urls = onLoad;
            onLoad = onProgress;
            onProgress = onError;
            onError = arguments[4];
        }
        const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeTexture"]();
        texture.type = this.type;
        switch(texture.type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                if ("colorSpace" in texture) texture.colorSpace = "srgb-linear";
                else texture.encoding = 3e3;
                texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                texture.generateMipmaps = false;
                break;
        }
        const scope = this;
        let loaded = 0;
        function loadHDRData(i, onLoad2, onProgress2, onError2) {
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager).setPath(scope.path).setResponseType("arraybuffer").setWithCredentials(scope.withCredentials).load(urls[i], function(buffer) {
                loaded++;
                const texData = scope.hdrLoader.parse(buffer);
                if (!texData) return;
                if (texData.data !== void 0) {
                    const dataTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"](texData.data, texData.width, texData.height);
                    dataTexture.type = texture.type;
                    if ("colorSpace" in dataTexture) dataTexture.colorSpace = texture.SRGBColorSpace;
                    else dataTexture.encoding = texture.encoding;
                    dataTexture.format = texture.format;
                    dataTexture.minFilter = texture.minFilter;
                    dataTexture.magFilter = texture.magFilter;
                    dataTexture.generateMipmaps = texture.generateMipmaps;
                    texture.images[i] = dataTexture;
                }
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad2) onLoad2(texture);
                }
            }, onProgress2, onError2);
        }
        for(let i = 0; i < urls.length; i++){
            loadHDRData(i, onLoad, onProgress, onError);
        }
        return texture;
    }
    setDataType(value) {
        this.type = value;
        this.hdrLoader.setDataType(value);
        return this;
    }
}
;
 //# sourceMappingURL=HDRCubeTextureLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/PDBLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PDBLoader": (()=>PDBLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class PDBLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    // Based on CanvasMol PDB parser
    parse(text) {
        function trim(text2) {
            return text2.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function capitalize(text2) {
            return text2.charAt(0).toUpperCase() + text2.substr(1).toLowerCase();
        }
        function hash(s, e) {
            return "s" + Math.min(s, e) + "e" + Math.max(s, e);
        }
        function parseBond(start, length, satom, i) {
            const eatom = parseInt(lines[i].substr(start, length));
            if (eatom) {
                const h = hash(satom, eatom);
                if (_bhash[h] === void 0) {
                    _bonds.push([
                        satom - 1,
                        eatom - 1,
                        1
                    ]);
                    _bhash[h] = _bonds.length - 1;
                }
            }
        }
        function buildGeometry() {
            const build = {
                geometryAtoms: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"](),
                geometryBonds: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"](),
                json: {
                    atoms
                }
            };
            const geometryAtoms = build.geometryAtoms;
            const geometryBonds = build.geometryBonds;
            const verticesAtoms = [];
            const colorsAtoms = [];
            const verticesBonds = [];
            for(let i = 0, l = atoms.length; i < l; i++){
                const atom = atoms[i];
                const x = atom[0];
                const y = atom[1];
                const z = atom[2];
                verticesAtoms.push(x, y, z);
                const r = atom[3][0] / 255;
                const g = atom[3][1] / 255;
                const b = atom[3][2] / 255;
                colorsAtoms.push(r, g, b);
            }
            for(let i = 0, l = _bonds.length; i < l; i++){
                const bond = _bonds[i];
                const start = bond[0];
                const end = bond[1];
                const startAtom = _atomMap[start];
                const endAtom = _atomMap[end];
                let x = startAtom[0];
                let y = startAtom[1];
                let z = startAtom[2];
                verticesBonds.push(x, y, z);
                x = endAtom[0];
                y = endAtom[1];
                z = endAtom[2];
                verticesBonds.push(x, y, z);
            }
            geometryAtoms.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](verticesAtoms, 3));
            geometryAtoms.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](colorsAtoms, 3));
            geometryBonds.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](verticesBonds, 3));
            return build;
        }
        const CPK = {
            h: [
                255,
                255,
                255
            ],
            he: [
                217,
                255,
                255
            ],
            li: [
                204,
                128,
                255
            ],
            be: [
                194,
                255,
                0
            ],
            b: [
                255,
                181,
                181
            ],
            c: [
                144,
                144,
                144
            ],
            n: [
                48,
                80,
                248
            ],
            o: [
                255,
                13,
                13
            ],
            f: [
                144,
                224,
                80
            ],
            ne: [
                179,
                227,
                245
            ],
            na: [
                171,
                92,
                242
            ],
            mg: [
                138,
                255,
                0
            ],
            al: [
                191,
                166,
                166
            ],
            si: [
                240,
                200,
                160
            ],
            p: [
                255,
                128,
                0
            ],
            s: [
                255,
                255,
                48
            ],
            cl: [
                31,
                240,
                31
            ],
            ar: [
                128,
                209,
                227
            ],
            k: [
                143,
                64,
                212
            ],
            ca: [
                61,
                255,
                0
            ],
            sc: [
                230,
                230,
                230
            ],
            ti: [
                191,
                194,
                199
            ],
            v: [
                166,
                166,
                171
            ],
            cr: [
                138,
                153,
                199
            ],
            mn: [
                156,
                122,
                199
            ],
            fe: [
                224,
                102,
                51
            ],
            co: [
                240,
                144,
                160
            ],
            ni: [
                80,
                208,
                80
            ],
            cu: [
                200,
                128,
                51
            ],
            zn: [
                125,
                128,
                176
            ],
            ga: [
                194,
                143,
                143
            ],
            ge: [
                102,
                143,
                143
            ],
            as: [
                189,
                128,
                227
            ],
            se: [
                255,
                161,
                0
            ],
            br: [
                166,
                41,
                41
            ],
            kr: [
                92,
                184,
                209
            ],
            rb: [
                112,
                46,
                176
            ],
            sr: [
                0,
                255,
                0
            ],
            y: [
                148,
                255,
                255
            ],
            zr: [
                148,
                224,
                224
            ],
            nb: [
                115,
                194,
                201
            ],
            mo: [
                84,
                181,
                181
            ],
            tc: [
                59,
                158,
                158
            ],
            ru: [
                36,
                143,
                143
            ],
            rh: [
                10,
                125,
                140
            ],
            pd: [
                0,
                105,
                133
            ],
            ag: [
                192,
                192,
                192
            ],
            cd: [
                255,
                217,
                143
            ],
            in: [
                166,
                117,
                115
            ],
            sn: [
                102,
                128,
                128
            ],
            sb: [
                158,
                99,
                181
            ],
            te: [
                212,
                122,
                0
            ],
            i: [
                148,
                0,
                148
            ],
            xe: [
                66,
                158,
                176
            ],
            cs: [
                87,
                23,
                143
            ],
            ba: [
                0,
                201,
                0
            ],
            la: [
                112,
                212,
                255
            ],
            ce: [
                255,
                255,
                199
            ],
            pr: [
                217,
                255,
                199
            ],
            nd: [
                199,
                255,
                199
            ],
            pm: [
                163,
                255,
                199
            ],
            sm: [
                143,
                255,
                199
            ],
            eu: [
                97,
                255,
                199
            ],
            gd: [
                69,
                255,
                199
            ],
            tb: [
                48,
                255,
                199
            ],
            dy: [
                31,
                255,
                199
            ],
            ho: [
                0,
                255,
                156
            ],
            er: [
                0,
                230,
                117
            ],
            tm: [
                0,
                212,
                82
            ],
            yb: [
                0,
                191,
                56
            ],
            lu: [
                0,
                171,
                36
            ],
            hf: [
                77,
                194,
                255
            ],
            ta: [
                77,
                166,
                255
            ],
            w: [
                33,
                148,
                214
            ],
            re: [
                38,
                125,
                171
            ],
            os: [
                38,
                102,
                150
            ],
            ir: [
                23,
                84,
                135
            ],
            pt: [
                208,
                208,
                224
            ],
            au: [
                255,
                209,
                35
            ],
            hg: [
                184,
                184,
                208
            ],
            tl: [
                166,
                84,
                77
            ],
            pb: [
                87,
                89,
                97
            ],
            bi: [
                158,
                79,
                181
            ],
            po: [
                171,
                92,
                0
            ],
            at: [
                117,
                79,
                69
            ],
            rn: [
                66,
                130,
                150
            ],
            fr: [
                66,
                0,
                102
            ],
            ra: [
                0,
                125,
                0
            ],
            ac: [
                112,
                171,
                250
            ],
            th: [
                0,
                186,
                255
            ],
            pa: [
                0,
                161,
                255
            ],
            u: [
                0,
                143,
                255
            ],
            np: [
                0,
                128,
                255
            ],
            pu: [
                0,
                107,
                255
            ],
            am: [
                84,
                92,
                242
            ],
            cm: [
                120,
                92,
                227
            ],
            bk: [
                138,
                79,
                227
            ],
            cf: [
                161,
                54,
                212
            ],
            es: [
                179,
                31,
                212
            ],
            fm: [
                179,
                31,
                186
            ],
            md: [
                179,
                13,
                166
            ],
            no: [
                189,
                13,
                135
            ],
            lr: [
                199,
                0,
                102
            ],
            rf: [
                204,
                0,
                89
            ],
            db: [
                209,
                0,
                79
            ],
            sg: [
                217,
                0,
                69
            ],
            bh: [
                224,
                0,
                56
            ],
            hs: [
                230,
                0,
                46
            ],
            mt: [
                235,
                0,
                38
            ],
            ds: [
                235,
                0,
                38
            ],
            rg: [
                235,
                0,
                38
            ],
            cn: [
                235,
                0,
                38
            ],
            uut: [
                235,
                0,
                38
            ],
            uuq: [
                235,
                0,
                38
            ],
            uup: [
                235,
                0,
                38
            ],
            uuh: [
                235,
                0,
                38
            ],
            uus: [
                235,
                0,
                38
            ],
            uuo: [
                235,
                0,
                38
            ]
        };
        const atoms = [];
        const _bonds = [];
        const _bhash = {};
        const _atomMap = {};
        const lines = text.split("\n");
        for(let i = 0, l = lines.length; i < l; i++){
            if (lines[i].substr(0, 4) === "ATOM" || lines[i].substr(0, 6) === "HETATM") {
                const x = parseFloat(lines[i].substr(30, 7));
                const y = parseFloat(lines[i].substr(38, 7));
                const z = parseFloat(lines[i].substr(46, 7));
                const index = parseInt(lines[i].substr(6, 5)) - 1;
                let e = trim(lines[i].substr(76, 2)).toLowerCase();
                if (e === "") {
                    e = trim(lines[i].substr(12, 2)).toLowerCase();
                }
                const atomData = [
                    x,
                    y,
                    z,
                    CPK[e],
                    capitalize(e)
                ];
                atoms.push(atomData);
                _atomMap[index] = atomData;
            } else if (lines[i].substr(0, 6) === "CONECT") {
                const satom = parseInt(lines[i].substr(6, 5));
                parseBond(11, 5, satom, i);
                parseBond(16, 5, satom, i);
                parseBond(21, 5, satom, i);
                parseBond(26, 5, satom, i);
            }
        }
        return buildGeometry();
    }
}
;
 //# sourceMappingURL=PDBLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/PRWMLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PRWMLoader": (()=>PRWMLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
let bigEndianPlatform = null;
function isBigEndianPlatform() {
    if (bigEndianPlatform === null) {
        const buffer = new ArrayBuffer(2), uint8Array = new Uint8Array(buffer), uint16Array = new Uint16Array(buffer);
        uint8Array[0] = 170;
        uint8Array[1] = 187;
        bigEndianPlatform = uint16Array[0] === 43707;
    }
    return bigEndianPlatform;
}
const InvertedEncodingTypes = [
    null,
    Float32Array,
    null,
    Int8Array,
    Int16Array,
    null,
    Int32Array,
    Uint8Array,
    Uint16Array,
    null,
    Uint32Array
];
const getMethods = {
    Uint16Array: "getUint16",
    Uint32Array: "getUint32",
    Int16Array: "getInt16",
    Int32Array: "getInt32",
    Float32Array: "getFloat32",
    Float64Array: "getFloat64"
};
function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {
    const bytesPerElement = viewType.BYTES_PER_ELEMENT;
    let result;
    if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {
        result = new viewType(sourceArrayBuffer, position, length);
    } else {
        const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement), getMethod = getMethods[viewType.name], littleEndian = !fromBigEndian;
        result = new viewType(length);
        for(let i = 0; i < length; i++){
            result[i] = readView[getMethod](i * bytesPerElement, littleEndian);
        }
    }
    return result;
}
function decodePrwm(buffer) {
    const array = new Uint8Array(buffer), version = array[0];
    let flags = array[1];
    const indexedGeometry = !!(flags >> 7 & 1), indicesType = flags >> 6 & 1, bigEndian = (flags >> 5 & 1) === 1, attributesNumber = flags & 31;
    let valuesNumber = 0, indicesNumber = 0;
    if (bigEndian) {
        valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];
        indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];
    } else {
        valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);
        indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);
    }
    if (version === 0) {
        throw new Error("PRWM decoder: Invalid format version: 0");
    } else if (version !== 1) {
        throw new Error("PRWM decoder: Unsupported format version: " + version);
    }
    if (!indexedGeometry) {
        if (indicesType !== 0) {
            throw new Error("PRWM decoder: Indices type must be set to 0 for non-indexed geometries");
        } else if (indicesNumber !== 0) {
            throw new Error("PRWM decoder: Number of indices must be set to 0 for non-indexed geometries");
        }
    }
    let pos = 8;
    const attributes = {};
    for(let i = 0; i < attributesNumber; i++){
        let attributeName = "";
        while(pos < array.length){
            const char = array[pos];
            pos++;
            if (char === 0) {
                break;
            } else {
                attributeName += String.fromCharCode(char);
            }
        }
        flags = array[pos];
        const attributeType = flags >> 7 & 1;
        const cardinality = (flags >> 4 & 3) + 1;
        const encodingType = flags & 15;
        const arrayType = InvertedEncodingTypes[encodingType];
        pos++;
        pos = Math.ceil(pos / 4) * 4;
        const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);
        pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;
        attributes[attributeName] = {
            type: attributeType,
            cardinality,
            values
        };
    }
    pos = Math.ceil(pos / 4) * 4;
    let indices = null;
    if (indexedGeometry) {
        indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);
    }
    return {
        version,
        attributes,
        indices
    };
}
const PRWMLoader = /* @__PURE__ */ (()=>{
    class PRWMLoader2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
        constructor(manager){
            super(manager);
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
            loader.setPath(scope.path);
            loader.setResponseType("arraybuffer");
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            url = url.replace(/\*/g, isBigEndianPlatform() ? "be" : "le");
            loader.load(url, function(arrayBuffer) {
                try {
                    onLoad(scope.parse(arrayBuffer));
                } catch (e) {
                    if (onError) {
                        onError(e);
                    } else {
                        console.error(e);
                    }
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        }
        parse(arrayBuffer) {
            const data = decodePrwm(arrayBuffer), attributesKey = Object.keys(data.attributes), bufferGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            for(let i = 0; i < attributesKey.length; i++){
                const attribute = data.attributes[attributesKey[i]];
                bufferGeometry.setAttribute(attributesKey[i], new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](attribute.values, attribute.cardinality, attribute.normalized));
            }
            if (data.indices !== null) {
                bufferGeometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](data.indices, 1));
            }
            return bufferGeometry;
        }
        static isBigEndianPlatform() {
            return isBigEndianPlatform();
        }
    }
    return PRWMLoader2;
})();
;
 //# sourceMappingURL=PRWMLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/RGBMLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RGBMLoader": (()=>RGBMLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
let UPNG;
function init() {
    if (UPNG) return UPNG;
    UPNG = {};
    UPNG.toRGBA8 = function(out) {
        var w = out.width, h = out.height;
        if (out.tabs.acTL == null) return [
            UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer
        ];
        var frms = [];
        if (out.frames[0].data == null) out.frames[0].data = out.data;
        var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
        for(var i = 0; i < out.frames.length; i++){
            var frm = out.frames[i];
            var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
            var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
            if (i != 0) for(var j = 0; j < len; j++)prev[j] = img[j];
            if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
            else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
            frms.push(img.buffer.slice(0));
            if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
            else if (frm.dispose == 2) for(var j = 0; j < len; j++)img[j] = prev[j];
        }
        return frms;
    };
    UPNG.toRGBA8.decodeImage = function(data, w, h, out) {
        var area = w * h, bpp = UPNG.decode._getBPP(out);
        var bpl = Math.ceil(w * bpp / 8);
        var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
        var ctype = out.ctype, depth = out.depth;
        var rs = UPNG._bin.readUshort;
        if (ctype == 6) {
            var qarea = area << 2;
            if (depth == 8) {
                for(var i = 0; i < qarea; i += 4){
                    bf[i] = data[i];
                    bf[i + 1] = data[i + 1];
                    bf[i + 2] = data[i + 2];
                    bf[i + 3] = data[i + 3];
                }
            }
            if (depth == 16) {
                for(var i = 0; i < qarea; i++){
                    bf[i] = data[i << 1];
                }
            }
        } else if (ctype == 2) {
            var ts = out.tabs["tRNS"];
            if (ts == null) {
                if (depth == 8) {
                    for(var i = 0; i < area; i++){
                        var ti = i * 3;
                        bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
                    }
                }
                if (depth == 16) {
                    for(var i = 0; i < area; i++){
                        var ti = i * 6;
                        bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
                    }
                }
            } else {
                var tr = ts[0], tg = ts[1], tb = ts[2];
                if (depth == 8) {
                    for(var i = 0; i < area; i++){
                        var qi = i << 2, ti = i * 3;
                        bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
                        if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;
                    }
                }
                if (depth == 16) {
                    for(var i = 0; i < area; i++){
                        var qi = i << 2, ti = i * 6;
                        bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
                        if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;
                    }
                }
            }
        } else if (ctype == 3) {
            var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
            if (depth == 1) {
                for(var y = 0; y < h; y++){
                    var s0 = y * bpl, t0 = y * w;
                    for(var i = 0; i < w; i++){
                        var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;
                        bf[qi] = p[cj];
                        bf[qi + 1] = p[cj + 1];
                        bf[qi + 2] = p[cj + 2];
                        bf[qi + 3] = j < tl ? ap[j] : 255;
                    }
                }
            }
            if (depth == 2) {
                for(var y = 0; y < h; y++){
                    var s0 = y * bpl, t0 = y * w;
                    for(var i = 0; i < w; i++){
                        var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;
                        bf[qi] = p[cj];
                        bf[qi + 1] = p[cj + 1];
                        bf[qi + 2] = p[cj + 2];
                        bf[qi + 3] = j < tl ? ap[j] : 255;
                    }
                }
            }
            if (depth == 4) {
                for(var y = 0; y < h; y++){
                    var s0 = y * bpl, t0 = y * w;
                    for(var i = 0; i < w; i++){
                        var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;
                        bf[qi] = p[cj];
                        bf[qi + 1] = p[cj + 1];
                        bf[qi + 2] = p[cj + 2];
                        bf[qi + 3] = j < tl ? ap[j] : 255;
                    }
                }
            }
            if (depth == 8) {
                for(var i = 0; i < area; i++){
                    var qi = i << 2, j = data[i], cj = 3 * j;
                    bf[qi] = p[cj];
                    bf[qi + 1] = p[cj + 1];
                    bf[qi + 2] = p[cj + 2];
                    bf[qi + 3] = j < tl ? ap[j] : 255;
                }
            }
        } else if (ctype == 4) {
            if (depth == 8) {
                for(var i = 0; i < area; i++){
                    var qi = i << 2, di = i << 1, gr = data[di];
                    bf[qi] = gr;
                    bf[qi + 1] = gr;
                    bf[qi + 2] = gr;
                    bf[qi + 3] = data[di + 1];
                }
            }
            if (depth == 16) {
                for(var i = 0; i < area; i++){
                    var qi = i << 2, di = i << 2, gr = data[di];
                    bf[qi] = gr;
                    bf[qi + 1] = gr;
                    bf[qi + 2] = gr;
                    bf[qi + 3] = data[di + 2];
                }
            }
        } else if (ctype == 0) {
            var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
            for(var y = 0; y < h; y++){
                var off = y * bpl, to = y * w;
                if (depth == 1) {
                    for(var x = 0; x < w; x++){
                        var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
                        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
                    }
                } else if (depth == 2) {
                    for(var x = 0; x < w; x++){
                        var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
                        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
                    }
                } else if (depth == 4) {
                    for(var x = 0; x < w; x++){
                        var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
                        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
                    }
                } else if (depth == 8) {
                    for(var x = 0; x < w; x++){
                        var gr = data[off + x], al = gr == tr ? 0 : 255;
                        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
                    }
                } else if (depth == 16) {
                    for(var x = 0; x < w; x++){
                        var gr = data[off + (x << 1)], al = rs(data, off + (x << 1)) == tr ? 0 : 255;
                        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
                    }
                }
            }
        }
        return bf;
    };
    UPNG.decode = function(buff) {
        var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
        var out = {
            tabs: {},
            frames: []
        };
        var dd = new Uint8Array(data.length), doff = 0;
        var fd, foff = 0;
        var text, keyw, bfr;
        var mgck = [
            137,
            80,
            78,
            71,
            13,
            10,
            26,
            10
        ];
        for(var i = 0; i < 8; i++)if (data[i] != mgck[i]) throw new Error("The input is not a PNG file!");
        while(offset < data.length){
            var len = bin.readUint(data, offset);
            offset += 4;
            var type = bin.readASCII(data, offset, 4);
            offset += 4;
            if (type == "IHDR") {
                UPNG.decode._IHDR(data, offset, out);
            } else if (type == "CgBI") {
                out.tabs[type] = data.slice(offset, offset + 4);
            } else if (type == "IDAT") {
                for(var i = 0; i < len; i++)dd[doff + i] = data[offset + i];
                doff += len;
            } else if (type == "acTL") {
                out.tabs[type] = {
                    num_frames: rUi(data, offset),
                    num_plays: rUi(data, offset + 4)
                };
                fd = new Uint8Array(data.length);
            } else if (type == "fcTL") {
                if (foff != 0) {
                    var fr = out.frames[out.frames.length - 1];
                    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
                    foff = 0;
                }
                var rct = {
                    x: rUi(data, offset + 12),
                    y: rUi(data, offset + 16),
                    width: rUi(data, offset + 4),
                    height: rUi(data, offset + 8)
                };
                var del = rUs(data, offset + 22);
                del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
                var frm = {
                    rect: rct,
                    delay: Math.round(del * 1e3),
                    dispose: data[offset + 24],
                    blend: data[offset + 25]
                };
                out.frames.push(frm);
            } else if (type == "fdAT") {
                for(var i = 0; i < len - 4; i++)fd[foff + i] = data[offset + i + 4];
                foff += len - 4;
            } else if (type == "pHYs") {
                out.tabs[type] = [
                    bin.readUint(data, offset),
                    bin.readUint(data, offset + 4),
                    data[offset + 8]
                ];
            } else if (type == "cHRM") {
                out.tabs[type] = [];
                for(var i = 0; i < 8; i++)out.tabs[type].push(bin.readUint(data, offset + i * 4));
            } else if (type == "tEXt" || type == "zTXt") {
                if (out.tabs[type] == null) out.tabs[type] = {};
                var nz = bin.nextZero(data, offset);
                keyw = bin.readASCII(data, offset, nz - offset);
                var tl = offset + len - nz - 1;
                if (type == "tEXt") {
                    text = bin.readASCII(data, nz + 1, tl);
                } else {
                    bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));
                    text = bin.readUTF8(bfr, 0, bfr.length);
                }
                out.tabs[type][keyw] = text;
            } else if (type == "iTXt") {
                if (out.tabs[type] == null) out.tabs[type] = {};
                var nz = 0, off = offset;
                nz = bin.nextZero(data, off);
                keyw = bin.readASCII(data, off, nz - off);
                off = nz + 1;
                var cflag = data[off];
                off += 2;
                nz = bin.nextZero(data, off);
                bin.readASCII(data, off, nz - off);
                off = nz + 1;
                nz = bin.nextZero(data, off);
                bin.readUTF8(data, off, nz - off);
                off = nz + 1;
                var tl = len - (off - offset);
                if (cflag == 0) {
                    text = bin.readUTF8(data, off, tl);
                } else {
                    bfr = UPNG.decode._inflate(data.slice(off, off + tl));
                    text = bin.readUTF8(bfr, 0, bfr.length);
                }
                out.tabs[type][keyw] = text;
            } else if (type == "PLTE") {
                out.tabs[type] = bin.readBytes(data, offset, len);
            } else if (type == "hIST") {
                var pl = out.tabs["PLTE"].length / 3;
                out.tabs[type] = [];
                for(var i = 0; i < pl; i++)out.tabs[type].push(rUs(data, offset + i * 2));
            } else if (type == "tRNS") {
                if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);
                else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);
                else if (out.ctype == 2) out.tabs[type] = [
                    rUs(data, offset),
                    rUs(data, offset + 2),
                    rUs(data, offset + 4)
                ];
            } else if (type == "gAMA") {
                out.tabs[type] = bin.readUint(data, offset) / 1e5;
            } else if (type == "sRGB") {
                out.tabs[type] = data[offset];
            } else if (type == "bKGD") {
                if (out.ctype == 0 || out.ctype == 4) {
                    out.tabs[type] = [
                        rUs(data, offset)
                    ];
                } else if (out.ctype == 2 || out.ctype == 6) {
                    out.tabs[type] = [
                        rUs(data, offset),
                        rUs(data, offset + 2),
                        rUs(data, offset + 4)
                    ];
                } else if (out.ctype == 3) {
                    out.tabs[type] = data[offset];
                }
            } else if (type == "IEND") {
                break;
            }
            offset += len;
            bin.readUint(data, offset);
            offset += 4;
        }
        if (foff != 0) {
            var fr = out.frames[out.frames.length - 1];
            fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        }
        out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
        delete out.compress;
        delete out.interlace;
        delete out.filter;
        return out;
    };
    UPNG.decode._decompress = function(out, dd, w, h) {
        var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
        if (out.tabs["CgBI"]) dd = UPNG.inflateRaw(dd, buff);
        else dd = UPNG.decode._inflate(dd, buff);
        if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);
        else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);
        return dd;
    };
    UPNG.decode._inflate = function(data, buff) {
        var out = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
        return out;
    };
    UPNG.inflateRaw = function() {
        var H = {};
        H.H = {};
        H.H.N = function(N, W) {
            var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;
            if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);
            var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;
            if (Z) W = new R(N.length >>> 2 << 5);
            while(i == 0){
                i = n(N, d, 1);
                m = n(N, d + 1, 2);
                d += 3;
                if (m == 0) {
                    if ((d & 7) != 0) d += 8 - (d & 7);
                    var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
                    if (Z) W = H.H.W(W, w + q);
                    W.set(new R(N.buffer, N.byteOffset + D, q), w);
                    d = D + q << 3;
                    w += q;
                    continue;
                }
                if (Z) W = H.H.W(W, w + (1 << 17));
                if (m == 1) {
                    v = b.J;
                    C = b.h;
                    X = (1 << 9) - 1;
                    u = (1 << 5) - 1;
                }
                if (m == 2) {
                    J = A(N, d, 5) + 257;
                    h = A(N, d + 5, 5) + 1;
                    Q = A(N, d + 10, 4) + 4;
                    d += 14;
                    var j = 1;
                    for(var c = 0; c < 38; c += 2){
                        b.Q[c] = 0;
                        b.Q[c + 1] = 0;
                    }
                    for(var c = 0; c < Q; c++){
                        var K = A(N, d + c * 3, 3);
                        b.Q[(b.X[c] << 1) + 1] = K;
                        if (K > j) j = K;
                    }
                    d += 3 * Q;
                    M(b.Q, j);
                    I(b.Q, j, b.u);
                    v = b.w;
                    C = b.d;
                    d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);
                    var r = V.V(b.v, 0, J, b.C);
                    X = (1 << r) - 1;
                    var S = V.V(b.v, J, h, b.D);
                    u = (1 << S) - 1;
                    M(b.C, r);
                    I(b.C, r, v);
                    M(b.D, S);
                    I(b.D, S, C);
                }
                while(true){
                    var T = v[e(N, d) & X];
                    d += T & 15;
                    var p = T >>> 4;
                    if (p >>> 8 == 0) {
                        W[w++] = p;
                    } else if (p == 256) {
                        break;
                    } else {
                        var z = w + p - 254;
                        if (p > 264) {
                            var _ = b.q[p - 257];
                            z = w + (_ >>> 3) + A(N, d, _ & 7);
                            d += _ & 7;
                        }
                        var $ = C[e(N, d) & u];
                        d += $ & 15;
                        var s = $ >>> 4, Y = b.c[s], a = (Y >>> 4) + n(N, d, Y & 15);
                        d += Y & 15;
                        while(w < z){
                            W[w] = W[w++ - a];
                            W[w] = W[w++ - a];
                            W[w] = W[w++ - a];
                            W[w] = W[w++ - a];
                        }
                        w = z;
                    }
                }
            }
            return W.length == w ? W : W.slice(0, w);
        };
        H.H.W = function(N, W) {
            var R = N.length;
            if (W <= R) return N;
            var V = new Uint8Array(R << 1);
            V.set(N, 0);
            return V;
        };
        H.H.R = function(N, W, R, V, n, A) {
            var l = H.H.e, M = H.H.Z, I = 0;
            while(I < R){
                var e = N[M(V, n) & W];
                n += e & 15;
                var b = e >>> 4;
                if (b <= 15) {
                    A[I] = b;
                    I++;
                } else {
                    var Z = 0, m = 0;
                    if (b == 16) {
                        m = 3 + l(V, n, 2);
                        n += 2;
                        Z = A[I - 1];
                    } else if (b == 17) {
                        m = 3 + l(V, n, 3);
                        n += 3;
                    } else if (b == 18) {
                        m = 11 + l(V, n, 7);
                        n += 7;
                    }
                    var J = I + m;
                    while(I < J){
                        A[I] = Z;
                        I++;
                    }
                }
            }
            return n;
        };
        H.H.V = function(N, W, R, V) {
            var n = 0, A = 0, l = V.length >>> 1;
            while(A < R){
                var M = N[A + W];
                V[A << 1] = 0;
                V[(A << 1) + 1] = M;
                if (M > n) n = M;
                A++;
            }
            while(A < l){
                V[A << 1] = 0;
                V[(A << 1) + 1] = 0;
                A++;
            }
            return n;
        };
        H.H.n = function(N, W) {
            var R = H.H.m, V = N.length, n, A, l, M, I, e = R.j;
            for(var M = 0; M <= W; M++)e[M] = 0;
            for(M = 1; M < V; M += 2)e[N[M]]++;
            var b = R.K;
            n = 0;
            e[0] = 0;
            for(A = 1; A <= W; A++){
                n = n + e[A - 1] << 1;
                b[A] = n;
            }
            for(l = 0; l < V; l += 2){
                I = N[l + 1];
                if (I != 0) {
                    N[l] = b[I];
                    b[I]++;
                }
            }
        };
        H.H.A = function(N, W, R) {
            var V = N.length, n = H.H.m, A = n.r;
            for(var l = 0; l < V; l += 2){
                if (N[l + 1] != 0) {
                    var M = l >> 1, I = N[l + 1], e = M << 4 | I, b = W - I, Z = N[l] << b, m = Z + (1 << b);
                    while(Z != m){
                        var J = A[Z] >>> 15 - W;
                        R[J] = e;
                        Z++;
                    }
                }
            }
        };
        H.H.l = function(N, W) {
            var R = H.H.m.r, V = 15 - W;
            for(var n = 0; n < N.length; n += 2){
                var A = N[n] << W - N[n + 1];
                N[n] = R[A] >>> V;
            }
        };
        H.H.M = function(N, W, R) {
            R = R << (W & 7);
            var V = W >>> 3;
            N[V] |= R;
            N[V + 1] |= R >>> 8;
        };
        H.H.I = function(N, W, R) {
            R = R << (W & 7);
            var V = W >>> 3;
            N[V] |= R;
            N[V + 1] |= R >>> 8;
            N[V + 2] |= R >>> 16;
        };
        H.H.e = function(N, W, R) {
            return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;
        };
        H.H.b = function(N, W, R) {
            return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;
        };
        H.H.Z = function(N, W) {
            return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
        };
        H.H.i = function(N, W) {
            return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
        };
        H.H.m = function() {
            var N = Uint16Array, W = Uint32Array;
            return {
                K: new N(16),
                j: new N(16),
                X: [
                    16,
                    17,
                    18,
                    0,
                    8,
                    7,
                    9,
                    6,
                    10,
                    5,
                    11,
                    4,
                    12,
                    3,
                    13,
                    2,
                    14,
                    1,
                    15
                ],
                S: [
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    13,
                    15,
                    17,
                    19,
                    23,
                    27,
                    31,
                    35,
                    43,
                    51,
                    59,
                    67,
                    83,
                    99,
                    115,
                    131,
                    163,
                    195,
                    227,
                    258,
                    999,
                    999,
                    999
                ],
                T: [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3,
                    3,
                    4,
                    4,
                    4,
                    4,
                    5,
                    5,
                    5,
                    5,
                    0,
                    0,
                    0,
                    0
                ],
                q: new N(32),
                p: [
                    1,
                    2,
                    3,
                    4,
                    5,
                    7,
                    9,
                    13,
                    17,
                    25,
                    33,
                    49,
                    65,
                    97,
                    129,
                    193,
                    257,
                    385,
                    513,
                    769,
                    1025,
                    1537,
                    2049,
                    3073,
                    4097,
                    6145,
                    8193,
                    12289,
                    16385,
                    24577,
                    65535,
                    65535
                ],
                z: [
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5,
                    6,
                    6,
                    7,
                    7,
                    8,
                    8,
                    9,
                    9,
                    10,
                    10,
                    11,
                    11,
                    12,
                    12,
                    13,
                    13,
                    0,
                    0
                ],
                c: new W(32),
                J: new N(512),
                _: [],
                h: new N(32),
                $: [],
                w: new N(32768),
                C: [],
                v: [],
                d: new N(32768),
                D: [],
                u: new N(512),
                Q: [],
                r: new N(1 << 15),
                s: new W(286),
                Y: new W(30),
                a: new W(19),
                t: new W(15e3),
                k: new N(1 << 16),
                g: new N(1 << 15)
            };
        }();
        (function() {
            var N = H.H.m, W = 1 << 15;
            for(var R = 0; R < W; R++){
                var V = R;
                V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
                V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
                V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
                V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
                N.r[R] = (V >>> 16 | V << 16) >>> 17;
            }
            function n(A, l, M) {
                while(l-- != 0)A.push(0, M);
            }
            for(var R = 0; R < 32; R++){
                N.q[R] = N.S[R] << 3 | N.T[R];
                N.c[R] = N.p[R] << 4 | N.z[R];
            }
            n(N._, 144, 8);
            n(N._, 255 - 143, 9);
            n(N._, 279 - 255, 7);
            n(N._, 287 - 279, 8);
            H.H.n(N._, 9);
            H.H.A(N._, 9, N.J);
            H.H.l(N._, 9);
            n(N.$, 32, 5);
            H.H.n(N.$, 5);
            H.H.A(N.$, 5, N.h);
            H.H.l(N.$, 5);
            n(N.Q, 19, 0);
            n(N.C, 286, 0);
            n(N.D, 30, 0);
            n(N.v, 320, 0);
        })();
        return H.H.N;
    }();
    UPNG.decode._readInterlace = function(data, out) {
        var w = out.width, h = out.height;
        var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
        var img = new Uint8Array(h * bpl);
        var di = 0;
        var starting_row = [
            0,
            0,
            4,
            0,
            2,
            0,
            1
        ];
        var starting_col = [
            0,
            4,
            0,
            2,
            0,
            1,
            0
        ];
        var row_increment = [
            8,
            8,
            8,
            4,
            4,
            2,
            2
        ];
        var col_increment = [
            8,
            8,
            4,
            4,
            2,
            2,
            1
        ];
        var pass = 0;
        while(pass < 7){
            var ri = row_increment[pass], ci = col_increment[pass];
            var sw = 0, sh = 0;
            var cr = starting_row[pass];
            while(cr < h){
                cr += ri;
                sh++;
            }
            var cc = starting_col[pass];
            while(cc < w){
                cc += ci;
                sw++;
            }
            var bpll = Math.ceil(sw * bpp / 8);
            UPNG.decode._filterZero(data, out, di, sw, sh);
            var y = 0, row = starting_row[pass];
            var val;
            while(row < h){
                var col = starting_col[pass];
                var cdi = di + y * bpll << 3;
                while(col < w){
                    if (bpp == 1) {
                        val = data[cdi >> 3];
                        val = val >> 7 - (cdi & 7) & 1;
                        img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
                    }
                    if (bpp == 2) {
                        val = data[cdi >> 3];
                        val = val >> 6 - (cdi & 7) & 3;
                        img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
                    }
                    if (bpp == 4) {
                        val = data[cdi >> 3];
                        val = val >> 4 - (cdi & 7) & 15;
                        img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
                    }
                    if (bpp >= 8) {
                        var ii = row * bpl + col * cbpp;
                        for(var j = 0; j < cbpp; j++)img[ii + j] = data[(cdi >> 3) + j];
                    }
                    cdi += bpp;
                    col += ci;
                }
                y++;
                row += ri;
            }
            if (sw * sh != 0) di += sh * (1 + bpll);
            pass = pass + 1;
        }
        return img;
    };
    UPNG.decode._getBPP = function(out) {
        var noc = [
            1,
            null,
            3,
            1,
            2,
            null,
            4
        ][out.ctype];
        return noc * out.depth;
    };
    UPNG.decode._filterZero = function(data, out, off, w, h) {
        var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
        bpp = Math.ceil(bpp / 8);
        var i, di, type = data[off], x = 0;
        if (type > 1) data[off] = [
            0,
            0,
            1
        ][type - 2];
        if (type == 3) for(x = bpp; x < bpl; x++)data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
        for(var y = 0; y < h; y++){
            i = off + y * bpl;
            di = i + y + 1;
            type = data[di - 1];
            x = 0;
            if (type == 0) {
                for(; x < bpl; x++)data[i + x] = data[di + x];
            } else if (type == 1) {
                for(; x < bpp; x++)data[i + x] = data[di + x];
                for(; x < bpl; x++)data[i + x] = data[di + x] + data[i + x - bpp];
            } else if (type == 2) {
                for(; x < bpl; x++)data[i + x] = data[di + x] + data[i + x - bpl];
            } else if (type == 3) {
                for(; x < bpp; x++)data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);
                for(; x < bpl; x++)data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);
            } else {
                for(; x < bpp; x++)data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);
                for(; x < bpl; x++){
                    data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);
                }
            }
        }
        return data;
    };
    UPNG.decode._paeth = function(a, b, c) {
        var p = a + b - c, pa = p - a, pb = p - b, pc = p - c;
        if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;
        else if (pb * pb <= pc * pc) return b;
        return c;
    };
    UPNG.decode._IHDR = function(data, offset, out) {
        var bin = UPNG._bin;
        out.width = bin.readUint(data, offset);
        offset += 4;
        out.height = bin.readUint(data, offset);
        offset += 4;
        out.depth = data[offset];
        offset++;
        out.ctype = data[offset];
        offset++;
        out.compress = data[offset];
        offset++;
        out.filter = data[offset];
        offset++;
        out.interlace = data[offset];
        offset++;
    };
    UPNG._bin = {
        nextZero: function(data, p) {
            while(data[p] != 0)p++;
            return p;
        },
        readUshort: function(buff, p) {
            return buff[p] << 8 | buff[p + 1];
        },
        writeUshort: function(buff, p, n) {
            buff[p] = n >> 8 & 255;
            buff[p + 1] = n & 255;
        },
        readUint: function(buff, p) {
            return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
        },
        writeUint: function(buff, p, n) {
            buff[p] = n >> 24 & 255;
            buff[p + 1] = n >> 16 & 255;
            buff[p + 2] = n >> 8 & 255;
            buff[p + 3] = n & 255;
        },
        readASCII: function(buff, p, l) {
            var s = "";
            for(var i = 0; i < l; i++)s += String.fromCharCode(buff[p + i]);
            return s;
        },
        writeASCII: function(data, p, s) {
            for(var i = 0; i < s.length; i++)data[p + i] = s.charCodeAt(i);
        },
        readBytes: function(buff, p, l) {
            var arr = [];
            for(var i = 0; i < l; i++)arr.push(buff[p + i]);
            return arr;
        },
        pad: function(n) {
            return n.length < 2 ? "0" + n : n;
        },
        readUTF8: function(buff, p, l) {
            var s = "", ns;
            for(var i = 0; i < l; i++)s += "%" + UPNG._bin.pad(buff[p + i].toString(16));
            try {
                ns = decodeURIComponent(s);
            } catch (e) {
                return UPNG._bin.readASCII(buff, p, l);
            }
            return ns;
        }
    };
    UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
        var w = Math.min(sw, tw), h = Math.min(sh, th);
        var si = 0, ti = 0;
        for(var y = 0; y < h; y++){
            for(var x = 0; x < w; x++){
                if (xoff >= 0 && yoff >= 0) {
                    si = y * sw + x << 2;
                    ti = (yoff + y) * tw + xoff + x << 2;
                } else {
                    si = (-yoff + y) * sw - xoff + x << 2;
                    ti = y * tw + x << 2;
                }
                if (mode == 0) {
                    tb[ti] = sb[si];
                    tb[ti + 1] = sb[si + 1];
                    tb[ti + 2] = sb[si + 2];
                    tb[ti + 3] = sb[si + 3];
                } else if (mode == 1) {
                    var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
                    var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
                    var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
                    tb[ti + 3] = 255 * oa;
                    tb[ti + 0] = (fr + br * ifa) * ioa;
                    tb[ti + 1] = (fg + bg * ifa) * ioa;
                    tb[ti + 2] = (fb + bb * ifa) * ioa;
                } else if (mode == 2) {
                    var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
                    var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
                    if (fa == ba && fr == br && fg == bg && fb == bb) {
                        tb[ti] = 0;
                        tb[ti + 1] = 0;
                        tb[ti + 2] = 0;
                        tb[ti + 3] = 0;
                    } else {
                        tb[ti] = fr;
                        tb[ti + 1] = fg;
                        tb[ti + 2] = fb;
                        tb[ti + 3] = fa;
                    }
                } else if (mode == 3) {
                    var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
                    var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
                    if (fa == ba && fr == br && fg == bg && fb == bb) continue;
                    if (fa < 220 && ba > 20) return false;
                }
            }
        }
        return true;
    };
}
class RGBMLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTextureLoader"] {
    constructor(manager){
        super(manager);
        this.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
        this.maxRange = 7;
    }
    setDataType(value) {
        this.type = value;
        return this;
    }
    setMaxRange(value) {
        this.maxRange = value;
        return this;
    }
    loadCubemap(urls, onLoad, onProgress, onError) {
        const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeTexture"]();
        let loaded = 0;
        const scope = this;
        function loadTexture(i) {
            scope.load(urls[i], function(image) {
                texture.images[i] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, void 0, onError);
        }
        for(let i = 0; i < urls.length; ++i){
            loadTexture(i);
        }
        texture.type = this.type;
        texture.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"];
        texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
        texture.generateMipmaps = false;
        return texture;
    }
    parse(buffer) {
        init();
        const img = UPNG.decode(buffer);
        const rgba = UPNG.toRGBA8(img)[0];
        const data = new Uint8Array(rgba);
        const size = img.width * img.height * 4;
        const output = this.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"] ? new Uint16Array(size) : new Float32Array(size);
        for(let i = 0; i < data.length; i += 4){
            const r = data[i + 0] / 255;
            const g = data[i + 1] / 255;
            const b = data[i + 2] / 255;
            const a = data[i + 3] / 255;
            if (this.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]) {
                output[i + 0] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(r * a * this.maxRange, 65504));
                output[i + 1] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(g * a * this.maxRange, 65504));
                output[i + 2] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(b * a * this.maxRange, 65504));
                output[i + 3] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(1);
            } else {
                output[i + 0] = r * a * this.maxRange;
                output[i + 1] = g * a * this.maxRange;
                output[i + 2] = b * a * this.maxRange;
                output[i + 3] = 1;
            }
        }
        return {
            width: img.width,
            height: img.height,
            data: output,
            format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
            type: this.type,
            flipY: true
        };
    }
}
;
 //# sourceMappingURL=RGBMLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/PCDLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PCDLoader": (()=>PCDLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class PCDLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.littleEndian = true;
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(data) {
            try {
                onLoad(scope.parse(data, url));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(data, url) {
        function decompressLZF(inData, outLength) {
            const inLength = inData.length;
            const outData = new Uint8Array(outLength);
            let inPtr = 0;
            let outPtr = 0;
            let ctrl;
            let len;
            let ref;
            do {
                ctrl = inData[inPtr++];
                if (ctrl < 1 << 5) {
                    ctrl++;
                    if (outPtr + ctrl > outLength) throw new Error("Output buffer is not large enough");
                    if (inPtr + ctrl > inLength) throw new Error("Invalid compressed data");
                    do {
                        outData[outPtr++] = inData[inPtr++];
                    }while (--ctrl)
                } else {
                    len = ctrl >> 5;
                    ref = outPtr - ((ctrl & 31) << 8) - 1;
                    if (inPtr >= inLength) throw new Error("Invalid compressed data");
                    if (len === 7) {
                        len += inData[inPtr++];
                        if (inPtr >= inLength) throw new Error("Invalid compressed data");
                    }
                    ref -= inData[inPtr++];
                    if (outPtr + len + 2 > outLength) throw new Error("Output buffer is not large enough");
                    if (ref < 0) throw new Error("Invalid compressed data");
                    if (ref >= outPtr) throw new Error("Invalid compressed data");
                    do {
                        outData[outPtr++] = outData[ref++];
                    }while (--len + 2)
                }
            }while (inPtr < inLength)
            return outData;
        }
        function parseHeader(data2) {
            const PCDheader2 = {};
            const result1 = data2.search(/[\r\n]DATA\s(\S*)\s/i);
            const result2 = /[\r\n]DATA\s(\S*)\s/i.exec(data2.substr(result1 - 1));
            PCDheader2.data = result2[1];
            PCDheader2.headerLen = result2[0].length + result1;
            PCDheader2.str = data2.substr(0, PCDheader2.headerLen);
            PCDheader2.str = PCDheader2.str.replace(/\#.*/gi, "");
            PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);
            PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);
            PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);
            PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);
            PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);
            PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);
            PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);
            PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);
            PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);
            if (PCDheader2.version !== null) PCDheader2.version = parseFloat(PCDheader2.version[1]);
            if (PCDheader2.fields !== null) PCDheader2.fields = PCDheader2.fields[1].split(" ");
            if (PCDheader2.type !== null) PCDheader2.type = PCDheader2.type[1].split(" ");
            if (PCDheader2.width !== null) PCDheader2.width = parseInt(PCDheader2.width[1]);
            if (PCDheader2.height !== null) PCDheader2.height = parseInt(PCDheader2.height[1]);
            if (PCDheader2.viewpoint !== null) PCDheader2.viewpoint = PCDheader2.viewpoint[1];
            if (PCDheader2.points !== null) PCDheader2.points = parseInt(PCDheader2.points[1], 10);
            if (PCDheader2.points === null) PCDheader2.points = PCDheader2.width * PCDheader2.height;
            if (PCDheader2.size !== null) {
                PCDheader2.size = PCDheader2.size[1].split(" ").map(function(x) {
                    return parseInt(x, 10);
                });
            }
            if (PCDheader2.count !== null) {
                PCDheader2.count = PCDheader2.count[1].split(" ").map(function(x) {
                    return parseInt(x, 10);
                });
            } else {
                PCDheader2.count = [];
                for(let i = 0, l = PCDheader2.fields.length; i < l; i++){
                    PCDheader2.count.push(1);
                }
            }
            PCDheader2.offset = {};
            let sizeSum = 0;
            for(let i = 0, l = PCDheader2.fields.length; i < l; i++){
                if (PCDheader2.data === "ascii") {
                    PCDheader2.offset[PCDheader2.fields[i]] = i;
                } else {
                    PCDheader2.offset[PCDheader2.fields[i]] = sizeSum;
                    sizeSum += PCDheader2.size[i] * PCDheader2.count[i];
                }
            }
            PCDheader2.rowSize = sizeSum;
            return PCDheader2;
        }
        const textData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data));
        const PCDheader = parseHeader(textData);
        const position = [];
        const normal = [];
        const color = [];
        if (PCDheader.data === "ascii") {
            const offset = PCDheader.offset;
            const pcdData = textData.substr(PCDheader.headerLen);
            const lines = pcdData.split("\n");
            for(let i = 0, l = lines.length; i < l; i++){
                if (lines[i] === "") continue;
                const line = lines[i].split(" ");
                if (offset.x !== void 0) {
                    position.push(parseFloat(line[offset.x]));
                    position.push(parseFloat(line[offset.y]));
                    position.push(parseFloat(line[offset.z]));
                }
                if (offset.rgb !== void 0) {
                    const rgb = parseFloat(line[offset.rgb]);
                    const r = rgb >> 16 & 255;
                    const g = rgb >> 8 & 255;
                    const b = rgb >> 0 & 255;
                    color.push(r / 255, g / 255, b / 255);
                }
                if (offset.normal_x !== void 0) {
                    normal.push(parseFloat(line[offset.normal_x]));
                    normal.push(parseFloat(line[offset.normal_y]));
                    normal.push(parseFloat(line[offset.normal_z]));
                }
            }
        }
        if (PCDheader.data === "binary_compressed") {
            const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));
            const compressedSize = sizes[0];
            const decompressedSize = sizes[1];
            const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);
            const dataview = new DataView(decompressed.buffer);
            const offset = PCDheader.offset;
            for(let i = 0; i < PCDheader.points; i++){
                if (offset.x !== void 0) {
                    position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian));
                    position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian));
                    position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian));
                }
                if (offset.rgb !== void 0) {
                    color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255);
                    color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255);
                    color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255);
                }
                if (offset.normal_x !== void 0) {
                    normal.push(dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian));
                    normal.push(dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian));
                    normal.push(dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian));
                }
            }
        }
        if (PCDheader.data === "binary") {
            const dataview = new DataView(data, PCDheader.headerLen);
            const offset = PCDheader.offset;
            for(let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize){
                if (offset.x !== void 0) {
                    position.push(dataview.getFloat32(row + offset.x, this.littleEndian));
                    position.push(dataview.getFloat32(row + offset.y, this.littleEndian));
                    position.push(dataview.getFloat32(row + offset.z, this.littleEndian));
                }
                if (offset.rgb !== void 0) {
                    color.push(dataview.getUint8(row + offset.rgb + 2) / 255);
                    color.push(dataview.getUint8(row + offset.rgb + 1) / 255);
                    color.push(dataview.getUint8(row + offset.rgb + 0) / 255);
                }
                if (offset.normal_x !== void 0) {
                    normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));
                    normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));
                    normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));
                }
            }
        }
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        if (position.length > 0) geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](position, 3));
        if (normal.length > 0) geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normal, 3));
        if (color.length > 0) geometry.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](color, 3));
        geometry.computeBoundingSphere();
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"]({
            size: 5e-3
        });
        if (color.length > 0) {
            material.vertexColors = true;
        } else {
            material.color.setHex(Math.random() * 16777215);
        }
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](geometry, material);
        let name = url.split("").reverse().join("");
        name = /([^\/]*)/.exec(name);
        name = name[1].split("").reverse().join("");
        mesh.name = name;
        return mesh;
    }
}
;
 //# sourceMappingURL=PCDLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/lwo/LWO2Parser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LWO2Parser": (()=>LWO2Parser)
});
class LWO2Parser {
    constructor(IFFParser){
        this.IFF = IFFParser;
    }
    parseBlock() {
        this.IFF.debugger.offset = this.IFF.reader.offset;
        this.IFF.debugger.closeForms();
        const blockID = this.IFF.reader.getIDTag();
        let length = this.IFF.reader.getUint32();
        if (length > this.IFF.reader.dv.byteLength - this.IFF.reader.offset) {
            this.IFF.reader.offset -= 4;
            length = this.IFF.reader.getUint16();
        }
        this.IFF.debugger.dataOffset = this.IFF.reader.offset;
        this.IFF.debugger.length = length;
        switch(blockID){
            case "FORM":
                this.IFF.parseForm(length);
                break;
            case "ICON":
            case "VMPA":
            case "BBOX":
            case "NORM":
            case "PRE ":
            case "POST":
            case "KEY ":
            case "SPAN":
            case "TIME":
            case "CLRS":
            case "CLRA":
            case "FILT":
            case "DITH":
            case "CONT":
            case "BRIT":
            case "SATR":
            case "HUE ":
            case "GAMM":
            case "NEGA":
            case "IFLT":
            case "PFLT":
            case "PROJ":
            case "AXIS":
            case "AAST":
            case "PIXB":
            case "AUVO":
            case "STCK":
            case "PROC":
            case "VALU":
            case "FUNC":
            case "PNAM":
            case "INAM":
            case "GRST":
            case "GREN":
            case "GRPT":
            case "FKEY":
            case "IKEY":
            case "CSYS":
            case "OPAQ":
            case "CMAP":
            case "NLOC":
            case "NZOM":
            case "NVER":
            case "NSRV":
            case "NVSK":
            case "NCRD":
            case "WRPW":
            case "WRPH":
            case "NMOD":
            case "NSEL":
            case "NPRW":
            case "NPLA":
            case "NODS":
            case "VERS":
            case "ENUM":
            case "TAG ":
            case "OPAC":
            case "CGMD":
            case "CGTY":
            case "CGST":
            case "CGEN":
            case "CGTS":
            case "CGTE":
            case "OSMP":
            case "OMDE":
            case "OUTR":
            case "FLAG":
            case "TRNL":
            case "GLOW":
            case "GVAL":
            case "SHRP":
            case "RFOP":
            case "RSAN":
            case "TROP":
            case "RBLR":
            case "TBLR":
            case "CLRH":
            case "CLRF":
            case "ADTR":
            case "LINE":
            case "ALPH":
            case "VCOL":
            case "ENAB":
                this.IFF.debugger.skipped = true;
                this.IFF.reader.skip(length);
                break;
            case "SURF":
                this.IFF.parseSurfaceLwo2(length);
                break;
            case "CLIP":
                this.IFF.parseClipLwo2(length);
                break;
            case "IPIX":
            case "IMIP":
            case "IMOD":
            case "AMOD":
            case "IINV":
            case "INCR":
            case "IAXS":
            case "IFOT":
            case "ITIM":
            case "IWRL":
            case "IUTI":
            case "IINX":
            case "IINY":
            case "IINZ":
            case "IREF":
                if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
                else this.IFF.reader.skip(length);
                break;
            case "OTAG":
                this.IFF.parseObjectTag();
                break;
            case "LAYR":
                this.IFF.parseLayer(length);
                break;
            case "PNTS":
                this.IFF.parsePoints(length);
                break;
            case "VMAP":
                this.IFF.parseVertexMapping(length);
                break;
            case "AUVU":
            case "AUVN":
                this.IFF.reader.skip(length - 1);
                this.IFF.reader.getVariableLengthIndex();
                break;
            case "POLS":
                this.IFF.parsePolygonList(length);
                break;
            case "TAGS":
                this.IFF.parseTagStrings(length);
                break;
            case "PTAG":
                this.IFF.parsePolygonTagMapping(length);
                break;
            case "VMAD":
                this.IFF.parseVertexMapping(length, true);
                break;
            case "DESC":
                this.IFF.currentForm.description = this.IFF.reader.getString();
                break;
            case "TEXT":
            case "CMNT":
            case "NCOM":
                this.IFF.currentForm.comment = this.IFF.reader.getString();
                break;
            case "NAME":
                this.IFF.currentForm.channelName = this.IFF.reader.getString();
                break;
            case "WRAP":
                this.IFF.currentForm.wrap = {
                    w: this.IFF.reader.getUint16(),
                    h: this.IFF.reader.getUint16()
                };
                break;
            case "IMAG":
                const index = this.IFF.reader.getVariableLengthIndex();
                this.IFF.currentForm.imageIndex = index;
                break;
            case "OREF":
                this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
                break;
            case "ROID":
                this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
                break;
            case "SSHN":
                this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
                break;
            case "AOVN":
                this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
                break;
            case "NSTA":
                this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
                break;
            case "NRNM":
                this.IFF.currentForm.realName = this.IFF.reader.getString();
                break;
            case "NNME":
                this.IFF.currentForm.refName = this.IFF.reader.getString();
                this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
                break;
            case "INME":
                if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = [];
                this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
                break;
            case "IINN":
                if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = [];
                this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
                break;
            case "IINM":
                if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = [];
                this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
                break;
            case "IONM":
                if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = [];
                this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
                break;
            case "FNAM":
                this.IFF.currentForm.fileName = this.IFF.reader.getString();
                break;
            case "CHAN":
                if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
                else this.IFF.reader.skip(length);
                break;
            case "SMAN":
                const maxSmoothingAngle = this.IFF.reader.getFloat32();
                this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
                break;
            case "COLR":
                this.IFF.currentSurface.attributes.Color = {
                    value: this.IFF.reader.getFloat32Array(3)
                };
                this.IFF.reader.skip(2);
                break;
            case "LUMI":
                this.IFF.currentSurface.attributes.Luminosity = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "SPEC":
                this.IFF.currentSurface.attributes.Specular = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "DIFF":
                this.IFF.currentSurface.attributes.Diffuse = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "REFL":
                this.IFF.currentSurface.attributes.Reflection = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "GLOS":
                this.IFF.currentSurface.attributes.Glossiness = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "TRAN":
                this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
                this.IFF.reader.skip(2);
                break;
            case "BUMP":
                this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
                this.IFF.reader.skip(2);
                break;
            case "SIDE":
                this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
                break;
            case "RIMG":
                this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
                break;
            case "RIND":
                this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
                this.IFF.reader.skip(2);
                break;
            case "TIMG":
                this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
                break;
            case "IMAP":
                this.IFF.reader.skip(2);
                break;
            case "TMAP":
                this.IFF.debugger.skipped = true;
                this.IFF.reader.skip(length);
                break;
            case "IUVI":
                this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length);
                break;
            case "IUTL":
                this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
                break;
            case "IVTL":
                this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
                break;
            case "BLOK":
                break;
            default:
                this.IFF.parseUnknownCHUNK(blockID, length);
        }
        if (blockID != "FORM") {
            this.IFF.debugger.node = 1;
            this.IFF.debugger.nodeID = blockID;
            this.IFF.debugger.log();
        }
        if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
            this.IFF.currentForm = this.IFF.parentForm;
        }
    }
}
;
 //# sourceMappingURL=LWO2Parser.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/lwo/LWO3Parser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LWO3Parser": (()=>LWO3Parser)
});
class LWO3Parser {
    constructor(IFFParser){
        this.IFF = IFFParser;
    }
    parseBlock() {
        this.IFF.debugger.offset = this.IFF.reader.offset;
        this.IFF.debugger.closeForms();
        const blockID = this.IFF.reader.getIDTag();
        const length = this.IFF.reader.getUint32();
        this.IFF.debugger.dataOffset = this.IFF.reader.offset;
        this.IFF.debugger.length = length;
        switch(blockID){
            case "FORM":
                this.IFF.parseForm(length);
                break;
            case "ICON":
            case "VMPA":
            case "BBOX":
            case "NORM":
            case "PRE ":
            case "POST":
            case "KEY ":
            case "SPAN":
            case "TIME":
            case "CLRS":
            case "CLRA":
            case "FILT":
            case "DITH":
            case "CONT":
            case "BRIT":
            case "SATR":
            case "HUE ":
            case "GAMM":
            case "NEGA":
            case "IFLT":
            case "PFLT":
            case "PROJ":
            case "AXIS":
            case "AAST":
            case "PIXB":
            case "STCK":
            case "VALU":
            case "PNAM":
            case "INAM":
            case "GRST":
            case "GREN":
            case "GRPT":
            case "FKEY":
            case "IKEY":
            case "CSYS":
            case "OPAQ":
            case "CMAP":
            case "NLOC":
            case "NZOM":
            case "NVER":
            case "NSRV":
            case "NCRD":
            case "NMOD":
            case "NSEL":
            case "NPRW":
            case "NPLA":
            case "VERS":
            case "ENUM":
            case "TAG ":
            case "CGMD":
            case "CGTY":
            case "CGST":
            case "CGEN":
            case "CGTS":
            case "CGTE":
            case "OSMP":
            case "OMDE":
            case "OUTR":
            case "FLAG":
            case "TRNL":
            case "SHRP":
            case "RFOP":
            case "RSAN":
            case "TROP":
            case "RBLR":
            case "TBLR":
            case "CLRH":
            case "CLRF":
            case "ADTR":
            case "GLOW":
            case "LINE":
            case "ALPH":
            case "VCOL":
            case "ENAB":
                this.IFF.debugger.skipped = true;
                this.IFF.reader.skip(length);
                break;
            case "IPIX":
            case "IMIP":
            case "IMOD":
            case "AMOD":
            case "IINV":
            case "INCR":
            case "IAXS":
            case "IFOT":
            case "ITIM":
            case "IWRL":
            case "IUTI":
            case "IINX":
            case "IINY":
            case "IINZ":
            case "IREF":
                if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
                else this.IFF.reader.skip(length);
                break;
            case "OTAG":
                this.IFF.parseObjectTag();
                break;
            case "LAYR":
                this.IFF.parseLayer(length);
                break;
            case "PNTS":
                this.IFF.parsePoints(length);
                break;
            case "VMAP":
                this.IFF.parseVertexMapping(length);
                break;
            case "POLS":
                this.IFF.parsePolygonList(length);
                break;
            case "TAGS":
                this.IFF.parseTagStrings(length);
                break;
            case "PTAG":
                this.IFF.parsePolygonTagMapping(length);
                break;
            case "VMAD":
                this.IFF.parseVertexMapping(length, true);
                break;
            case "DESC":
                this.IFF.currentForm.description = this.IFF.reader.getString();
                break;
            case "TEXT":
            case "CMNT":
            case "NCOM":
                this.IFF.currentForm.comment = this.IFF.reader.getString();
                break;
            case "NAME":
                this.IFF.currentForm.channelName = this.IFF.reader.getString();
                break;
            case "WRAP":
                this.IFF.currentForm.wrap = {
                    w: this.IFF.reader.getUint16(),
                    h: this.IFF.reader.getUint16()
                };
                break;
            case "IMAG":
                const index = this.IFF.reader.getVariableLengthIndex();
                this.IFF.currentForm.imageIndex = index;
                break;
            case "OREF":
                this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
                break;
            case "ROID":
                this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
                break;
            case "SSHN":
                this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
                break;
            case "AOVN":
                this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
                break;
            case "NSTA":
                this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
                break;
            case "NRNM":
                this.IFF.currentForm.realName = this.IFF.reader.getString();
                break;
            case "NNME":
                this.IFF.currentForm.refName = this.IFF.reader.getString();
                this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
                break;
            case "INME":
                if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = [];
                this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
                break;
            case "IINN":
                if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = [];
                this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
                break;
            case "IINM":
                if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = [];
                this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
                break;
            case "IONM":
                if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = [];
                this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
                break;
            case "FNAM":
                this.IFF.currentForm.fileName = this.IFF.reader.getString();
                break;
            case "CHAN":
                if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
                else this.IFF.reader.skip(length);
                break;
            case "SMAN":
                const maxSmoothingAngle = this.IFF.reader.getFloat32();
                this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
                break;
            case "COLR":
                this.IFF.currentSurface.attributes.Color = {
                    value: this.IFF.reader.getFloat32Array(3)
                };
                this.IFF.reader.skip(2);
                break;
            case "LUMI":
                this.IFF.currentSurface.attributes.Luminosity = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "SPEC":
                this.IFF.currentSurface.attributes.Specular = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "DIFF":
                this.IFF.currentSurface.attributes.Diffuse = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "REFL":
                this.IFF.currentSurface.attributes.Reflection = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "GLOS":
                this.IFF.currentSurface.attributes.Glossiness = {
                    value: this.IFF.reader.getFloat32()
                };
                this.IFF.reader.skip(2);
                break;
            case "TRAN":
                this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
                this.IFF.reader.skip(2);
                break;
            case "BUMP":
                this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
                this.IFF.reader.skip(2);
                break;
            case "SIDE":
                this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
                break;
            case "RIMG":
                this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
                break;
            case "RIND":
                this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
                this.IFF.reader.skip(2);
                break;
            case "TIMG":
                this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
                break;
            case "IMAP":
                this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();
                break;
            case "IUVI":
                this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length);
                break;
            case "IUTL":
                this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
                break;
            case "IVTL":
                this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
                break;
            default:
                this.IFF.parseUnknownCHUNK(blockID, length);
        }
        if (blockID != "FORM") {
            this.IFF.debugger.node = 1;
            this.IFF.debugger.nodeID = blockID;
            this.IFF.debugger.log();
        }
        if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
            this.IFF.currentForm = this.IFF.parentForm;
        }
    }
}
;
 //# sourceMappingURL=LWO3Parser.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/lwo/IFFParser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "IFFParser": (()=>IFFParser)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$lwo$2f$LWO2Parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/lwo/LWO2Parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$lwo$2f$LWO3Parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/lwo/LWO3Parser.js [app-client] (ecmascript)");
;
;
class IFFParser {
    constructor(){
        this.debugger = new Debugger();
    }
    parse(buffer) {
        this.reader = new DataViewReader(buffer);
        this.tree = {
            materials: {},
            layers: [],
            tags: [],
            textures: []
        };
        this.currentLayer = this.tree;
        this.currentForm = this.tree;
        this.parseTopForm();
        if (this.tree.format === void 0) return;
        if (this.tree.format === "LWO2") {
            this.parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$lwo$2f$LWO2Parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LWO2Parser"](this);
            while(!this.reader.endOfFile())this.parser.parseBlock();
        } else if (this.tree.format === "LWO3") {
            this.parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$lwo$2f$LWO3Parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LWO3Parser"](this);
            while(!this.reader.endOfFile())this.parser.parseBlock();
        }
        this.debugger.offset = this.reader.offset;
        this.debugger.closeForms();
        return this.tree;
    }
    parseTopForm() {
        this.debugger.offset = this.reader.offset;
        var topForm = this.reader.getIDTag();
        if (topForm !== "FORM") {
            console.warn("LWOLoader: Top-level FORM missing.");
            return;
        }
        var length = this.reader.getUint32();
        this.debugger.dataOffset = this.reader.offset;
        this.debugger.length = length;
        var type = this.reader.getIDTag();
        if (type === "LWO2") {
            this.tree.format = type;
        } else if (type === "LWO3") {
            this.tree.format = type;
        }
        this.debugger.node = 0;
        this.debugger.nodeID = type;
        this.debugger.log();
        return;
    }
    ///
    // FORM PARSING METHODS
    ///
    // Forms are organisational and can contain any number of sub chunks and sub forms
    // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }
    parseForm(length) {
        var type = this.reader.getIDTag();
        switch(type){
            case "ISEQ":
            case "ANIM":
            case "STCC":
            case "VPVL":
            case "VPRM":
            case "NROT":
            case "WRPW":
            case "WRPH":
            case "FUNC":
            case "FALL":
            case "OPAC":
            case "GRAD":
            case "ENVS":
            case "VMOP":
            case "VMBG":
            case "OMAX":
            case "STEX":
            case "CKBG":
            case "CKEY":
            case "VMLA":
            case "VMLB":
                this.debugger.skipped = true;
                this.skipForm(length);
                break;
            case "META":
            case "NNDS":
            case "NODS":
            case "NDTA":
            case "ADAT":
            case "AOVS":
            case "BLOK":
            case "IBGC":
            case "IOPC":
            case "IIMG":
            case "TXTR":
                this.debugger.length = 4;
                this.debugger.skipped = true;
                break;
            case "IFAL":
            case "ISCL":
            case "IPOS":
            case "IROT":
            case "IBMP":
            case "IUTD":
            case "IVTD":
                this.parseTextureNodeAttribute(type);
                break;
            case "ENVL":
                this.parseEnvelope(length);
                break;
            case "CLIP":
                if (this.tree.format === "LWO2") {
                    this.parseForm(length);
                } else {
                    this.parseClip(length);
                }
                break;
            case "STIL":
                this.parseImage();
                break;
            case "XREF":
                this.reader.skip(8);
                this.currentForm.referenceTexture = {
                    index: this.reader.getUint32(),
                    refName: this.reader.getString()
                };
                break;
            case "IMST":
                this.parseImageStateForm(length);
                break;
            case "SURF":
                this.parseSurfaceForm(length);
                break;
            case "VALU":
                this.parseValueForm(length);
                break;
            case "NTAG":
                this.parseSubNode(length);
                break;
            case "ATTR":
            case "SATR":
                this.setupForm("attributes", length);
                break;
            case "NCON":
                this.parseConnections(length);
                break;
            case "SSHA":
                this.parentForm = this.currentForm;
                this.currentForm = this.currentSurface;
                this.setupForm("surfaceShader", length);
                break;
            case "SSHD":
                this.setupForm("surfaceShaderData", length);
                break;
            case "ENTR":
                this.parseEntryForm(length);
                break;
            case "IMAP":
                this.parseImageMap(length);
                break;
            case "TAMP":
                this.parseXVAL("amplitude", length);
                break;
            case "TMAP":
                this.setupForm("textureMap", length);
                break;
            case "CNTR":
                this.parseXVAL3("center", length);
                break;
            case "SIZE":
                this.parseXVAL3("scale", length);
                break;
            case "ROTA":
                this.parseXVAL3("rotation", length);
                break;
            default:
                this.parseUnknownForm(type, length);
        }
        this.debugger.node = 0;
        this.debugger.nodeID = type;
        this.debugger.log();
    }
    setupForm(type, length) {
        if (!this.currentForm) this.currentForm = this.currentNode;
        this.currentFormEnd = this.reader.offset + length;
        this.parentForm = this.currentForm;
        if (!this.currentForm[type]) {
            this.currentForm[type] = {};
            this.currentForm = this.currentForm[type];
        } else {
            console.warn("LWOLoader: form already exists on parent: ", type, this.currentForm);
            this.currentForm = this.currentForm[type];
        }
    }
    skipForm(length) {
        this.reader.skip(length - 4);
    }
    parseUnknownForm(type, length) {
        console.warn("LWOLoader: unknown FORM encountered: " + type, length);
        printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);
        this.reader.skip(length - 4);
    }
    parseSurfaceForm(length) {
        this.reader.skip(8);
        var name = this.reader.getString();
        var surface = {
            attributes: {},
            // LWO2 style non-node attributes will go here
            connections: {},
            name,
            inputName: name,
            nodes: {},
            source: this.reader.getString()
        };
        this.tree.materials[name] = surface;
        this.currentSurface = surface;
        this.parentForm = this.tree.materials;
        this.currentForm = surface;
        this.currentFormEnd = this.reader.offset + length;
    }
    parseSurfaceLwo2(length) {
        var name = this.reader.getString();
        var surface = {
            attributes: {},
            // LWO2 style non-node attributes will go here
            connections: {},
            name,
            nodes: {},
            source: this.reader.getString()
        };
        this.tree.materials[name] = surface;
        this.currentSurface = surface;
        this.parentForm = this.tree.materials;
        this.currentForm = surface;
        this.currentFormEnd = this.reader.offset + length;
    }
    parseSubNode(length) {
        this.reader.skip(8);
        var name = this.reader.getString();
        var node = {
            name
        };
        this.currentForm = node;
        this.currentNode = node;
        this.currentFormEnd = this.reader.offset + length;
    }
    // collect attributes from all nodes at the top level of a surface
    parseConnections(length) {
        this.currentFormEnd = this.reader.offset + length;
        this.parentForm = this.currentForm;
        this.currentForm = this.currentSurface.connections;
    }
    // surface node attribute data, e.g. specular, roughness etc
    parseEntryForm(length) {
        this.reader.skip(8);
        var name = this.reader.getString();
        this.currentForm = this.currentNode.attributes;
        this.setupForm(name, length);
    }
    // parse values from material - doesn't match up to other LWO3 data types
    // sub form of entry form
    parseValueForm() {
        this.reader.skip(8);
        var valueType = this.reader.getString();
        if (valueType === "double") {
            this.currentForm.value = this.reader.getUint64();
        } else if (valueType === "int") {
            this.currentForm.value = this.reader.getUint32();
        } else if (valueType === "vparam") {
            this.reader.skip(24);
            this.currentForm.value = this.reader.getFloat64();
        } else if (valueType === "vparam3") {
            this.reader.skip(24);
            this.currentForm.value = this.reader.getFloat64Array(3);
        }
    }
    // holds various data about texture node image state
    // Data other thanmipMapLevel unknown
    parseImageStateForm() {
        this.reader.skip(8);
        this.currentForm.mipMapLevel = this.reader.getFloat32();
    }
    // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)
    parseImageMap(length) {
        this.currentFormEnd = this.reader.offset + length;
        this.parentForm = this.currentForm;
        if (!this.currentForm.maps) this.currentForm.maps = [];
        var map = {};
        this.currentForm.maps.push(map);
        this.currentForm = map;
        this.reader.skip(10);
    }
    parseTextureNodeAttribute(type) {
        this.reader.skip(28);
        this.reader.skip(20);
        switch(type){
            case "ISCL":
                this.currentNode.scale = this.reader.getFloat32Array(3);
                break;
            case "IPOS":
                this.currentNode.position = this.reader.getFloat32Array(3);
                break;
            case "IROT":
                this.currentNode.rotation = this.reader.getFloat32Array(3);
                break;
            case "IFAL":
                this.currentNode.falloff = this.reader.getFloat32Array(3);
                break;
            case "IBMP":
                this.currentNode.amplitude = this.reader.getFloat32();
                break;
            case "IUTD":
                this.currentNode.uTiles = this.reader.getFloat32();
                break;
            case "IVTD":
                this.currentNode.vTiles = this.reader.getFloat32();
                break;
        }
        this.reader.skip(2);
    }
    // ENVL forms are currently ignored
    parseEnvelope(length) {
        this.reader.skip(length - 4);
    }
    ///
    // CHUNK PARSING METHODS
    ///
    // clips can either be defined inside a surface node, or at the top
    // level and they have a different format in each case
    parseClip(length) {
        var tag = this.reader.getIDTag();
        if (tag === "FORM") {
            this.reader.skip(16);
            this.currentNode.fileName = this.reader.getString();
            return;
        }
        this.reader.setOffset(this.reader.offset - 4);
        this.currentFormEnd = this.reader.offset + length;
        this.parentForm = this.currentForm;
        this.reader.skip(8);
        var texture = {
            index: this.reader.getUint32()
        };
        this.tree.textures.push(texture);
        this.currentForm = texture;
    }
    parseClipLwo2(length) {
        var texture = {
            index: this.reader.getUint32(),
            fileName: ""
        };
        while(true){
            var tag = this.reader.getIDTag();
            var n_length = this.reader.getUint16();
            if (tag === "STIL") {
                texture.fileName = this.reader.getString();
                break;
            }
            if (n_length >= length) {
                break;
            }
        }
        this.tree.textures.push(texture);
        this.currentForm = texture;
    }
    parseImage() {
        this.reader.skip(8);
        this.currentForm.fileName = this.reader.getString();
    }
    parseXVAL(type, length) {
        var endOffset = this.reader.offset + length - 4;
        this.reader.skip(8);
        this.currentForm[type] = this.reader.getFloat32();
        this.reader.setOffset(endOffset);
    }
    parseXVAL3(type, length) {
        var endOffset = this.reader.offset + length - 4;
        this.reader.skip(8);
        this.currentForm[type] = {
            x: this.reader.getFloat32(),
            y: this.reader.getFloat32(),
            z: this.reader.getFloat32()
        };
        this.reader.setOffset(endOffset);
    }
    // Tags associated with an object
    // OTAG { type[ID4], tag-string[S0] }
    parseObjectTag() {
        if (!this.tree.objectTags) this.tree.objectTags = {};
        this.tree.objectTags[this.reader.getIDTag()] = {
            tagString: this.reader.getString()
        };
    }
    // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.
    // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]
    parseLayer(length) {
        var layer = {
            number: this.reader.getUint16(),
            flags: this.reader.getUint16(),
            // If the least significant bit of flags is set, the layer is hidden.
            pivot: this.reader.getFloat32Array(3),
            // Note: this seems to be superflous, as the geometry is translated when pivot is present
            name: this.reader.getString()
        };
        this.tree.layers.push(layer);
        this.currentLayer = layer;
        var parsedLength = 16 + stringOffset(this.currentLayer.name);
        this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1;
    }
    // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors
    // Converting from left to right handed coordinate system:
    // x -> -x and switch material FrontSide -> BackSide
    parsePoints(length) {
        this.currentPoints = [];
        for(var i = 0; i < length / 4; i += 3){
            this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
        }
    }
    // parse VMAP or VMAD
    // Associates a set of floating-point vectors with a set of points.
    // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }
    // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.
    // Similar to VMAP UVs, but associates with polygon vertices rather than points
    // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,
    // if they exist. The vector values in the VMAD will then replace those in the
    // corresponding VMAP, but only for calculations involving the specified polygons.
    // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }
    parseVertexMapping(length, discontinuous) {
        var finalOffset = this.reader.offset + length;
        var channelName = this.reader.getString();
        if (this.reader.offset === finalOffset) {
            this.currentForm.UVChannel = channelName;
            return;
        }
        this.reader.setOffset(this.reader.offset - stringOffset(channelName));
        var type = this.reader.getIDTag();
        this.reader.getUint16();
        var name = this.reader.getString();
        var remainingLength = length - 6 - stringOffset(name);
        switch(type){
            case "TXUV":
                this.parseUVMapping(name, finalOffset, discontinuous);
                break;
            case "MORF":
            case "SPOT":
                this.parseMorphTargets(name, finalOffset, type);
                break;
            case "APSL":
            case "NORM":
            case "WGHT":
            case "MNVW":
            case "PICK":
            case "RGB ":
            case "RGBA":
                this.reader.skip(remainingLength);
                break;
            default:
                console.warn("LWOLoader: unknown vertex map type: " + type);
                this.reader.skip(remainingLength);
        }
    }
    parseUVMapping(name, finalOffset, discontinuous) {
        var uvIndices = [];
        var polyIndices = [];
        var uvs = [];
        while(this.reader.offset < finalOffset){
            uvIndices.push(this.reader.getVariableLengthIndex());
            if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());
            uvs.push(this.reader.getFloat32(), this.reader.getFloat32());
        }
        if (discontinuous) {
            if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};
            this.currentLayer.discontinuousUVs[name] = {
                uvIndices,
                polyIndices,
                uvs
            };
        } else {
            if (!this.currentLayer.uvs) this.currentLayer.uvs = {};
            this.currentLayer.uvs[name] = {
                uvIndices,
                uvs
            };
        }
    }
    parseMorphTargets(name, finalOffset, type) {
        var indices = [];
        var points = [];
        type = type === "MORF" ? "relative" : "absolute";
        while(this.reader.offset < finalOffset){
            indices.push(this.reader.getVariableLengthIndex());
            points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
        }
        if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};
        this.currentLayer.morphTargets[name] = {
            indices,
            points,
            type
        };
    }
    // A list of polygons for the current layer.
    // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }
    parsePolygonList(length) {
        var finalOffset = this.reader.offset + length;
        var type = this.reader.getIDTag();
        var indices = [];
        var polygonDimensions = [];
        while(this.reader.offset < finalOffset){
            var numverts = this.reader.getUint16();
            numverts = numverts & 1023;
            polygonDimensions.push(numverts);
            for(var j = 0; j < numverts; j++)indices.push(this.reader.getVariableLengthIndex());
        }
        var geometryData = {
            type,
            vertexIndices: indices,
            polygonDimensions,
            points: this.currentPoints
        };
        if (polygonDimensions[0] === 1) geometryData.type = "points";
        else if (polygonDimensions[0] === 2) geometryData.type = "lines";
        this.currentLayer.geometry = geometryData;
    }
    // Lists the tag strings that can be associated with polygons by the PTAG chunk.
    // TAGS { tag-string[S0] * }
    parseTagStrings(length) {
        this.tree.tags = this.reader.getStringArray(length);
    }
    // Associates tags of a given type with polygons in the most recent POLS chunk.
    // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }
    parsePolygonTagMapping(length) {
        var finalOffset = this.reader.offset + length;
        var type = this.reader.getIDTag();
        if (type === "SURF") this.parseMaterialIndices(finalOffset);
        else {
            this.reader.skip(length - 4);
        }
    }
    parseMaterialIndices(finalOffset) {
        this.currentLayer.geometry.materialIndices = [];
        while(this.reader.offset < finalOffset){
            var polygonIndex = this.reader.getVariableLengthIndex();
            var materialIndex = this.reader.getUint16();
            this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);
        }
    }
    parseUnknownCHUNK(blockID, length) {
        console.warn("LWOLoader: unknown chunk type: " + blockID + " length: " + length);
        var data = this.reader.getString(length);
        this.currentForm[blockID] = data;
    }
}
class DataViewReader {
    constructor(buffer){
        this.dv = new DataView(buffer);
        this.offset = 0;
        this._textDecoder = new TextDecoder();
        this._bytes = new Uint8Array(buffer);
    }
    size() {
        return this.dv.buffer.byteLength;
    }
    setOffset(offset) {
        if (offset > 0 && offset < this.dv.buffer.byteLength) {
            this.offset = offset;
        } else {
            console.error("LWOLoader: invalid buffer offset");
        }
    }
    endOfFile() {
        if (this.offset >= this.size()) return true;
        return false;
    }
    skip(length) {
        this.offset += length;
    }
    getUint8() {
        var value = this.dv.getUint8(this.offset);
        this.offset += 1;
        return value;
    }
    getUint16() {
        var value = this.dv.getUint16(this.offset);
        this.offset += 2;
        return value;
    }
    getInt32() {
        var value = this.dv.getInt32(this.offset, false);
        this.offset += 4;
        return value;
    }
    getUint32() {
        var value = this.dv.getUint32(this.offset, false);
        this.offset += 4;
        return value;
    }
    getUint64() {
        var low, high;
        high = this.getUint32();
        low = this.getUint32();
        return high * 4294967296 + low;
    }
    getFloat32() {
        var value = this.dv.getFloat32(this.offset, false);
        this.offset += 4;
        return value;
    }
    getFloat32Array(size) {
        var a = [];
        for(var i = 0; i < size; i++){
            a.push(this.getFloat32());
        }
        return a;
    }
    getFloat64() {
        var value = this.dv.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    getFloat64Array(size) {
        var a = [];
        for(var i = 0; i < size; i++){
            a.push(this.getFloat64());
        }
        return a;
    }
    // get variable-length index data type
    // VX ::= index[U2] | (index + 0xFF000000)[U4]
    // If the index value is less than 65,280 (0xFF00),then VX === U2
    // otherwise VX === U4 with bits 24-31 set
    // When reading an index, if the first byte encountered is 255 (0xFF), then
    // the four-byte form is being used and the first byte should be discarded or masked out.
    getVariableLengthIndex() {
        var firstByte = this.getUint8();
        if (firstByte === 255) {
            return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();
        }
        return firstByte * 256 + this.getUint8();
    }
    // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values
    getIDTag() {
        return this.getString(4);
    }
    getString(size) {
        if (size === 0) return;
        const start = this.offset;
        let result;
        let length;
        if (size) {
            length = size;
            result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));
        } else {
            length = this._bytes.indexOf(0, start) - start;
            result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));
            length++;
            length += length % 2;
        }
        this.skip(length);
        return result;
    }
    getStringArray(size) {
        var a = this.getString(size);
        a = a.split("\0");
        return a.filter(Boolean);
    }
}
class Debugger {
    constructor(){
        this.active = false;
        this.depth = 0;
        this.formList = [];
    }
    enable() {
        this.active = true;
    }
    log() {
        if (!this.active) return;
        var nodeType;
        switch(this.node){
            case 0:
                nodeType = "FORM";
                break;
            case 1:
                nodeType = "CHK";
                break;
            case 2:
                nodeType = "S-CHK";
                break;
        }
        console.log("| ".repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? " {" : "", this.skipped ? "SKIPPED" : "", this.node == 0 && this.skipped ? "}" : "");
        if (this.node == 0 && !this.skipped) {
            this.depth += 1;
            this.formList.push(this.dataOffset + this.length);
        }
        this.skipped = false;
    }
    closeForms() {
        if (!this.active) return;
        for(var i = this.formList.length - 1; i >= 0; i--){
            if (this.offset >= this.formList[i]) {
                this.depth -= 1;
                console.log("| ".repeat(this.depth) + "}");
                this.formList.splice(-1, 1);
            }
        }
    }
}
function isEven(num) {
    return num % 2;
}
function stringOffset(string) {
    return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);
}
function printBuffer(buffer, from, to) {
    console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));
}
;
 //# sourceMappingURL=IFFParser.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/LWOLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LWOLoader": (()=>LWOLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$lwo$2f$IFFParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/loaders/lwo/IFFParser.js [app-client] (ecmascript)");
(()=>{
    const e = new Error("Cannot find module '../_polyfill/uv1.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
let _lwoTree;
class LWOLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager, parameters = {}){
        super(manager);
        this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : "";
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = scope.path === "" ? extractParentUrl(url, "Objects") : scope.path;
        const modelName = url.split(path).pop().split(".")[0];
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.load(url, function(buffer) {
            try {
                onLoad(scope.parse(buffer, path, modelName));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(iffBuffer, path, modelName) {
        _lwoTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$lwo$2f$IFFParser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IFFParser"]().parse(iffBuffer);
        const textureLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"](this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        return new LWOTreeParser(textureLoader).parse(modelName);
    }
}
class LWOTreeParser {
    constructor(textureLoader){
        this.textureLoader = textureLoader;
    }
    parse(modelName) {
        this.materials = new MaterialParser(this.textureLoader).parse();
        this.defaultLayerName = modelName;
        this.meshes = this.parseLayers();
        return {
            materials: this.materials,
            meshes: this.meshes
        };
    }
    parseLayers() {
        const meshes = [];
        const finalMeshes = [];
        const geometryParser = new GeometryParser();
        const scope = this;
        _lwoTree.layers.forEach(function(layer) {
            const geometry = geometryParser.parse(layer.geometry, layer);
            const mesh = scope.parseMesh(geometry, layer);
            meshes[layer.number] = mesh;
            if (layer.parent === -1) finalMeshes.push(mesh);
            else meshes[layer.parent].add(mesh);
        });
        this.applyPivots(finalMeshes);
        return finalMeshes;
    }
    parseMesh(geometry, layer) {
        let mesh;
        const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);
        if (UV1 === "uv2") this.duplicateUVs(geometry, materials);
        if (layer.geometry.type === "points") mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Points"](geometry, materials);
        else if (layer.geometry.type === "lines") mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineSegments"](geometry, materials);
        else mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, materials);
        if (layer.name) mesh.name = layer.name;
        else mesh.name = this.defaultLayerName + "_layer_" + layer.number;
        mesh.userData.pivot = layer.pivot;
        return mesh;
    }
    // TODO: may need to be reversed in z to convert LWO to three.js coordinates
    applyPivots(meshes) {
        meshes.forEach(function(mesh) {
            mesh.traverse(function(child) {
                const pivot = child.userData.pivot;
                child.position.x += pivot[0];
                child.position.y += pivot[1];
                child.position.z += pivot[2];
                if (child.parent) {
                    const parentPivot = child.parent.userData.pivot;
                    child.position.x -= parentPivot[0];
                    child.position.y -= parentPivot[1];
                    child.position.z -= parentPivot[2];
                }
            });
        });
    }
    getMaterials(namesArray, type) {
        const materials = [];
        const scope = this;
        namesArray.forEach(function(name, i) {
            materials[i] = scope.getMaterialByName(name);
        });
        if (type === "points" || type === "lines") {
            materials.forEach(function(mat, i) {
                const spec = {
                    color: mat.color
                };
                if (type === "points") {
                    spec.size = 0.1;
                    spec.map = mat.map;
                    spec.morphTargets = mat.morphTargets;
                    materials[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointsMaterial"](spec);
                } else if (type === "lines") {
                    materials[i] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LineBasicMaterial"](spec);
                }
            });
        }
        const filtered = materials.filter(Boolean);
        if (filtered.length === 1) return filtered[0];
        return materials;
    }
    getMaterialByName(name) {
        return this.materials.filter(function(m) {
            return m.name === name;
        })[0];
    }
    // If the material has an aoMap, duplicate UVs
    duplicateUVs(geometry, materials) {
        let duplicateUVs = false;
        if (!Array.isArray(materials)) {
            if (materials.aoMap) duplicateUVs = true;
        } else {
            materials.forEach(function(material) {
                if (material.aoMap) duplicateUVs = true;
            });
        }
        if (!duplicateUVs) return;
        geometry.setAttribute("uv2", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](geometry.attributes.uv.array, 2));
    }
}
class MaterialParser {
    constructor(textureLoader){
        this.textureLoader = textureLoader;
    }
    parse() {
        const materials = [];
        this.textures = {};
        for(const name in _lwoTree.materials){
            if (_lwoTree.format === "LWO3") {
                materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));
            } else if (_lwoTree.format === "LWO2") {
                materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));
            }
        }
        return materials;
    }
    parseMaterial(materialData, name, textures) {
        let params = {
            name,
            side: this.getSide(materialData.attributes),
            flatShading: this.getSmooth(materialData.attributes)
        };
        const connections = this.parseConnections(materialData.connections, materialData.nodes);
        const maps = this.parseTextureNodes(connections.maps);
        this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);
        const attributes = this.parseAttributes(connections.attributes, maps);
        this.parseEnvMap(connections, maps, attributes);
        params = Object.assign(maps, params);
        params = Object.assign(params, attributes);
        const materialType = this.getMaterialType(connections.attributes);
        return new materialType(params);
    }
    parseMaterialLwo2(materialData, name) {
        let params = {
            name,
            side: this.getSide(materialData.attributes),
            flatShading: this.getSmooth(materialData.attributes)
        };
        const attributes = this.parseAttributes(materialData.attributes, {});
        params = Object.assign(params, attributes);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"](params);
    }
    // Note: converting from left to right handed coords by switching x -> -x in vertices, and
    // then switching mat FrontSide -> BackSide
    // NB: this means that FrontSide and BackSide have been switched!
    getSide(attributes) {
        if (!attributes.side) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"];
        switch(attributes.side){
            case 0:
            case 1:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"];
            case 2:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"];
            case 3:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"];
        }
    }
    getSmooth(attributes) {
        if (!attributes.smooth) return true;
        return !attributes.smooth;
    }
    parseConnections(connections, nodes) {
        const materialConnections = {
            maps: {}
        };
        const inputName = connections.inputName;
        const inputNodeName = connections.inputNodeName;
        const nodeName = connections.nodeName;
        const scope = this;
        inputName.forEach(function(name, index) {
            if (name === "Material") {
                const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);
                materialConnections.attributes = matNode.attributes;
                materialConnections.envMap = matNode.fileName;
                materialConnections.name = inputNodeName[index];
            }
        });
        nodeName.forEach(function(name, index) {
            if (name === materialConnections.name) {
                materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);
            }
        });
        return materialConnections;
    }
    getNodeByRefName(refName, nodes) {
        for(const name in nodes){
            if (nodes[name].refName === refName) return nodes[name];
        }
    }
    parseTextureNodes(textureNodes) {
        const maps = {};
        for(const name in textureNodes){
            const node = textureNodes[name];
            const path = node.fileName;
            if (!path) return;
            const texture = this.loadTexture(path);
            if (node.widthWrappingMode !== void 0) texture.wrapS = this.getWrappingType(node.widthWrappingMode);
            if (node.heightWrappingMode !== void 0) texture.wrapT = this.getWrappingType(node.heightWrappingMode);
            switch(name){
                case "Color":
                    maps.map = texture;
                    break;
                case "Roughness":
                    maps.roughnessMap = texture;
                    maps.roughness = 0.5;
                    break;
                case "Specular":
                    maps.specularMap = texture;
                    maps.specular = 16777215;
                    break;
                case "Luminous":
                    maps.emissiveMap = texture;
                    maps.emissive = 8421504;
                    break;
                case "Luminous Color":
                    maps.emissive = 8421504;
                    break;
                case "Metallic":
                    maps.metalnessMap = texture;
                    maps.metalness = 0.5;
                    break;
                case "Transparency":
                case "Alpha":
                    maps.alphaMap = texture;
                    maps.transparent = true;
                    break;
                case "Normal":
                    maps.normalMap = texture;
                    if (node.amplitude !== void 0) maps.normalScale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](node.amplitude, node.amplitude);
                    break;
                case "Bump":
                    maps.bumpMap = texture;
                    break;
            }
        }
        if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;
        return maps;
    }
    // maps can also be defined on individual material attributes, parse those here
    // This occurs on Standard (Phong) surfaces
    parseAttributeImageMaps(attributes, textures, maps) {
        for(const name in attributes){
            const attribute = attributes[name];
            if (attribute.maps) {
                const mapData = attribute.maps[0];
                const path = this.getTexturePathByIndex(mapData.imageIndex, textures);
                if (!path) return;
                const texture = this.loadTexture(path);
                if (mapData.wrap !== void 0) texture.wrapS = this.getWrappingType(mapData.wrap.w);
                if (mapData.wrap !== void 0) texture.wrapT = this.getWrappingType(mapData.wrap.h);
                switch(name){
                    case "Color":
                        maps.map = texture;
                        break;
                    case "Diffuse":
                        maps.aoMap = texture;
                        break;
                    case "Roughness":
                        maps.roughnessMap = texture;
                        maps.roughness = 1;
                        break;
                    case "Specular":
                        maps.specularMap = texture;
                        maps.specular = 16777215;
                        break;
                    case "Luminosity":
                        maps.emissiveMap = texture;
                        maps.emissive = 8421504;
                        break;
                    case "Metallic":
                        maps.metalnessMap = texture;
                        maps.metalness = 1;
                        break;
                    case "Transparency":
                    case "Alpha":
                        maps.alphaMap = texture;
                        maps.transparent = true;
                        break;
                    case "Normal":
                        maps.normalMap = texture;
                        break;
                    case "Bump":
                        maps.bumpMap = texture;
                        break;
                }
            }
        }
    }
    parseAttributes(attributes, maps) {
        const params = {};
        if (attributes.Color && !maps.map) {
            params.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(attributes.Color.value);
        } else {
            params.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        }
        if (attributes.Transparency && attributes.Transparency.value !== 0) {
            params.opacity = 1 - attributes.Transparency.value;
            params.transparent = true;
        }
        if (attributes["Bump Height"]) params.bumpScale = attributes["Bump Height"].value * 0.1;
        if (attributes["Refraction Index"]) params.refractionRatio = 1 / attributes["Refraction Index"].value;
        this.parsePhysicalAttributes(params, attributes, maps);
        this.parseStandardAttributes(params, attributes, maps);
        this.parsePhongAttributes(params, attributes, maps);
        return params;
    }
    parsePhysicalAttributes(params, attributes) {
        if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {
            params.clearcoat = attributes.Clearcoat.value;
            if (attributes["Clearcoat Gloss"]) {
                params.clearcoatRoughness = 0.5 * (1 - attributes["Clearcoat Gloss"].value);
            }
        }
    }
    parseStandardAttributes(params, attributes, maps) {
        if (attributes.Luminous) {
            params.emissiveIntensity = attributes.Luminous.value;
            if (attributes["Luminous Color"] && !maps.emissive) {
                params.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().fromArray(attributes["Luminous Color"].value);
            } else {
                params.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8421504);
            }
        }
        if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;
        if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;
    }
    parsePhongAttributes(params, attributes, maps) {
        if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);
        if (attributes.Reflection) {
            params.reflectivity = attributes.Reflection.value;
            params.combine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AddOperation"];
        }
        if (attributes.Luminosity) {
            params.emissiveIntensity = attributes.Luminosity.value;
            if (!maps.emissiveMap && !maps.map) {
                params.emissive = params.color;
            } else {
                params.emissive = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8421504);
            }
        }
        if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {
            if (attributes["Color Highlight"]) {
                params.specular = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes["Color Highlight"].value);
            } else {
                params.specular = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]().setScalar(attributes.Specular.value);
            }
        }
        if (params.specular && attributes.Glossiness) {
            params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);
        }
    }
    parseEnvMap(connections, maps, attributes) {
        if (connections.envMap) {
            const envMap = this.loadTexture(connections.envMap);
            if (attributes.transparent && attributes.opacity < 0.999) {
                envMap.mapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EquirectangularRefractionMapping"];
                if (attributes.reflectivity !== void 0) {
                    delete attributes.reflectivity;
                    delete attributes.combine;
                }
                if (attributes.metalness !== void 0) {
                    delete attributes.metalness;
                }
            } else {
                envMap.mapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EquirectangularReflectionMapping"];
            }
            maps.envMap = envMap;
        }
    }
    // get texture defined at top level by its index
    getTexturePathByIndex(index) {
        let fileName = "";
        if (!_lwoTree.textures) return fileName;
        _lwoTree.textures.forEach(function(texture) {
            if (texture.index === index) fileName = texture.fileName;
        });
        return fileName;
    }
    loadTexture(path) {
        if (!path) return null;
        const texture = this.textureLoader.load(path, void 0, void 0, function() {
            console.warn("LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.");
        });
        return texture;
    }
    // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge
    getWrappingType(num) {
        switch(num){
            case 0:
                console.warn('LWOLoader: "Reset" texture wrapping type is not supported in three.js');
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
            case 1:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
            case 2:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MirroredRepeatWrapping"];
            case 3:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"];
        }
    }
    getMaterialType(nodeData) {
        if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhysicalMaterial"];
        if (nodeData.Roughness) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"];
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshPhongMaterial"];
    }
}
class GeometryParser {
    parse(geoData, layer) {
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](geoData.points, 3));
        const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);
        geometry.setIndex(indices);
        this.parseGroups(geometry, geoData);
        geometry.computeVertexNormals();
        this.parseUVs(geometry, layer, indices);
        this.parseMorphTargets(geometry, layer, indices);
        geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);
        return geometry;
    }
    // split quads into tris
    splitIndices(indices, polygonDimensions) {
        const remappedIndices = [];
        let i = 0;
        polygonDimensions.forEach(function(dim) {
            if (dim < 4) {
                for(let k = 0; k < dim; k++)remappedIndices.push(indices[i + k]);
            } else if (dim === 4) {
                remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);
            } else if (dim > 4) {
                for(let k = 1; k < dim - 1; k++){
                    remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);
                }
                console.warn("LWOLoader: polygons with greater than 4 sides are not supported");
            }
            i += dim;
        });
        return remappedIndices;
    }
    // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered
    parseGroups(geometry, geoData) {
        const tags = _lwoTree.tags;
        const matNames = [];
        let elemSize = 3;
        if (geoData.type === "lines") elemSize = 2;
        if (geoData.type === "points") elemSize = 1;
        const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);
        let indexNum = 0;
        const indexPairs = {};
        let prevMaterialIndex;
        let materialIndex;
        let prevStart = 0;
        let currentCount = 0;
        for(let i = 0; i < remappedIndices.length; i += 2){
            materialIndex = remappedIndices[i + 1];
            if (i === 0) matNames[indexNum] = tags[materialIndex];
            if (prevMaterialIndex === void 0) prevMaterialIndex = materialIndex;
            if (materialIndex !== prevMaterialIndex) {
                let currentIndex;
                if (indexPairs[tags[prevMaterialIndex]]) {
                    currentIndex = indexPairs[tags[prevMaterialIndex]];
                } else {
                    currentIndex = indexNum;
                    indexPairs[tags[prevMaterialIndex]] = indexNum;
                    matNames[indexNum] = tags[prevMaterialIndex];
                    indexNum++;
                }
                geometry.addGroup(prevStart, currentCount, currentIndex);
                prevStart += currentCount;
                prevMaterialIndex = materialIndex;
                currentCount = 0;
            }
            currentCount += elemSize;
        }
        if (geometry.groups.length > 0) {
            let currentIndex;
            if (indexPairs[tags[materialIndex]]) {
                currentIndex = indexPairs[tags[materialIndex]];
            } else {
                currentIndex = indexNum;
                indexPairs[tags[materialIndex]] = indexNum;
                matNames[indexNum] = tags[materialIndex];
            }
            geometry.addGroup(prevStart, currentCount, currentIndex);
        }
        geometry.userData.matNames = matNames;
    }
    splitMaterialIndices(polygonDimensions, indices) {
        const remappedIndices = [];
        polygonDimensions.forEach(function(dim, i) {
            if (dim <= 3) {
                remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);
            } else if (dim === 4) {
                remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);
            } else {
                for(let k = 0; k < dim - 2; k++){
                    remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);
                }
            }
        });
        return remappedIndices;
    }
    // UV maps:
    // 1: are defined via index into an array of points, not into a geometry
    // - the geometry is also defined by an index into this array, but the indexes may not match
    // 2: there can be any number of UV maps for a single geometry. Here these are combined,
    // 	with preference given to the first map encountered
    // 3: UV maps can be partial - that is, defined for only a part of the geometry
    // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most
    // UV maps are defined as partially VMAP and partially VMAD
    // VMADs are currently not supported
    parseUVs(geometry, layer) {
        const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function() {
            return 0;
        });
        for(const name in layer.uvs){
            const uvs = layer.uvs[name].uvs;
            const uvIndices = layer.uvs[name].uvIndices;
            uvIndices.forEach(function(i, j) {
                remappedUVs[i * 2] = uvs[j * 2];
                remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];
            });
        }
        geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](remappedUVs, 2));
    }
    parseMorphTargets(geometry, layer) {
        let num = 0;
        for(const name in layer.morphTargets){
            const remappedPoints = geometry.attributes.position.array.slice();
            if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];
            const morphPoints = layer.morphTargets[name].points;
            const morphIndices = layer.morphTargets[name].indices;
            const type = layer.morphTargets[name].type;
            morphIndices.forEach(function(i, j) {
                if (type === "relative") {
                    remappedPoints[i * 3] += morphPoints[j * 3];
                    remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];
                    remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];
                } else {
                    remappedPoints[i * 3] = morphPoints[j * 3];
                    remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];
                    remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];
                }
            });
            geometry.morphAttributes.position[num] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](remappedPoints, 3);
            geometry.morphAttributes.position[num].name = name;
            num++;
        }
        geometry.morphTargetsRelative = false;
    }
}
function extractParentUrl(url, dir) {
    const index = url.indexOf(dir);
    if (index === -1) return "./";
    return url.substr(0, index);
}
;
 //# sourceMappingURL=LWOLoader.js.map
}}),
"[project]/node_modules/three-stdlib/loaders/PLYLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PLYLoader": (()=>PLYLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/LoaderUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class PLYLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"] {
    constructor(manager){
        super(manager);
        this.propertyNameMapping = {};
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    setPropertyNameMapping(mapping) {
        this.propertyNameMapping = mapping;
    }
    parse(data) {
        function parseHeader(data2) {
            const patternHeader = /ply([\s\S]*)end_header\r?\n/;
            let headerText = "";
            let headerLength = 0;
            const result = patternHeader.exec(data2);
            if (result !== null) {
                headerText = result[1];
                headerLength = new Blob([
                    result[0]
                ]).size;
            }
            const header = {
                comments: [],
                elements: [],
                headerLength,
                objInfo: ""
            };
            const lines = headerText.split("\n");
            let currentElement;
            function make_ply_element_property(propertValues, propertyNameMapping) {
                const property = {
                    type: propertValues[0]
                };
                if (property.type === "list") {
                    property.name = propertValues[3];
                    property.countType = propertValues[1];
                    property.itemType = propertValues[2];
                } else {
                    property.name = propertValues[1];
                }
                if (property.name in propertyNameMapping) {
                    property.name = propertyNameMapping[property.name];
                }
                return property;
            }
            for(let i = 0; i < lines.length; i++){
                let line = lines[i];
                line = line.trim();
                if (line === "") continue;
                const lineValues = line.split(/\s+/);
                const lineType = lineValues.shift();
                line = lineValues.join(" ");
                switch(lineType){
                    case "format":
                        header.format = lineValues[0];
                        header.version = lineValues[1];
                        break;
                    case "comment":
                        header.comments.push(line);
                        break;
                    case "element":
                        if (currentElement !== void 0) {
                            header.elements.push(currentElement);
                        }
                        currentElement = {};
                        currentElement.name = lineValues[0];
                        currentElement.count = parseInt(lineValues[1]);
                        currentElement.properties = [];
                        break;
                    case "property":
                        currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));
                        break;
                    case "obj_info":
                        header.objInfo = line;
                        break;
                    default:
                        console.log("unhandled", lineType, lineValues);
                }
            }
            if (currentElement !== void 0) {
                header.elements.push(currentElement);
            }
            return header;
        }
        function parseASCIINumber(n, type) {
            switch(type){
                case "char":
                case "uchar":
                case "short":
                case "ushort":
                case "int":
                case "uint":
                case "int8":
                case "uint8":
                case "int16":
                case "uint16":
                case "int32":
                case "uint32":
                    return parseInt(n);
                case "float":
                case "double":
                case "float32":
                case "float64":
                    return parseFloat(n);
            }
        }
        function parseASCIIElement(properties, line) {
            const values = line.split(/\s+/);
            const element = {};
            for(let i = 0; i < properties.length; i++){
                if (properties[i].type === "list") {
                    const list = [];
                    const n = parseASCIINumber(values.shift(), properties[i].countType);
                    for(let j = 0; j < n; j++){
                        list.push(parseASCIINumber(values.shift(), properties[i].itemType));
                    }
                    element[properties[i].name] = list;
                } else {
                    element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);
                }
            }
            return element;
        }
        function parseASCII(data2, header) {
            const buffer = {
                indices: [],
                vertices: [],
                normals: [],
                uvs: [],
                faceVertexUvs: [],
                colors: []
            };
            let result;
            const patternBody = /end_header\s([\s\S]*)$/;
            let body = "";
            if ((result = patternBody.exec(data2)) !== null) {
                body = result[1];
            }
            const lines = body.split("\n");
            let currentElement = 0;
            let currentElementCount = 0;
            for(let i = 0; i < lines.length; i++){
                let line = lines[i];
                line = line.trim();
                if (line === "") {
                    continue;
                }
                if (currentElementCount >= header.elements[currentElement].count) {
                    currentElement++;
                    currentElementCount = 0;
                }
                const element = parseASCIIElement(header.elements[currentElement].properties, line);
                handleElement(buffer, header.elements[currentElement].name, element);
                currentElementCount++;
            }
            return postProcess(buffer);
        }
        function postProcess(buffer) {
            let geometry2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            if (buffer.indices.length > 0) {
                geometry2.setIndex(buffer.indices);
            }
            geometry2.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffer.vertices, 3));
            if (buffer.normals.length > 0) {
                geometry2.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffer.normals, 3));
            }
            if (buffer.uvs.length > 0) {
                geometry2.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffer.uvs, 2));
            }
            if (buffer.colors.length > 0) {
                geometry2.setAttribute("color", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffer.colors, 3));
            }
            if (buffer.faceVertexUvs.length > 0) {
                geometry2 = geometry2.toNonIndexed();
                geometry2.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](buffer.faceVertexUvs, 2));
            }
            geometry2.computeBoundingSphere();
            return geometry2;
        }
        function handleElement(buffer, elementName, element) {
            if (elementName === "vertex") {
                buffer.vertices.push(element.x, element.y, element.z);
                if ("nx" in element && "ny" in element && "nz" in element) {
                    buffer.normals.push(element.nx, element.ny, element.nz);
                }
                if ("s" in element && "t" in element) {
                    buffer.uvs.push(element.s, element.t);
                }
                if ("red" in element && "green" in element && "blue" in element) {
                    buffer.colors.push(element.red / 255, element.green / 255, element.blue / 255);
                }
            } else if (elementName === "face") {
                const vertex_indices = element.vertex_indices || element.vertex_index;
                const texcoord = element.texcoord;
                if (vertex_indices.length === 3) {
                    buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);
                    if (texcoord && texcoord.length === 6) {
                        buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);
                        buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);
                        buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);
                    }
                } else if (vertex_indices.length === 4) {
                    buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);
                    buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);
                }
            }
        }
        function binaryRead(dataview, at, type, little_endian) {
            switch(type){
                case "int8":
                case "char":
                    return [
                        dataview.getInt8(at),
                        1
                    ];
                case "uint8":
                case "uchar":
                    return [
                        dataview.getUint8(at),
                        1
                    ];
                case "int16":
                case "short":
                    return [
                        dataview.getInt16(at, little_endian),
                        2
                    ];
                case "uint16":
                case "ushort":
                    return [
                        dataview.getUint16(at, little_endian),
                        2
                    ];
                case "int32":
                case "int":
                    return [
                        dataview.getInt32(at, little_endian),
                        4
                    ];
                case "uint32":
                case "uint":
                    return [
                        dataview.getUint32(at, little_endian),
                        4
                    ];
                case "float32":
                case "float":
                    return [
                        dataview.getFloat32(at, little_endian),
                        4
                    ];
                case "float64":
                case "double":
                    return [
                        dataview.getFloat64(at, little_endian),
                        8
                    ];
            }
        }
        function binaryReadElement(dataview, at, properties, little_endian) {
            const element = {};
            let result, read = 0;
            for(let i = 0; i < properties.length; i++){
                if (properties[i].type === "list") {
                    const list = [];
                    result = binaryRead(dataview, at + read, properties[i].countType, little_endian);
                    const n = result[0];
                    read += result[1];
                    for(let j = 0; j < n; j++){
                        result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);
                        list.push(result[0]);
                        read += result[1];
                    }
                    element[properties[i].name] = list;
                } else {
                    result = binaryRead(dataview, at + read, properties[i].type, little_endian);
                    element[properties[i].name] = result[0];
                    read += result[1];
                }
            }
            return [
                element,
                read
            ];
        }
        function parseBinary(data2, header) {
            const buffer = {
                indices: [],
                vertices: [],
                normals: [],
                uvs: [],
                faceVertexUvs: [],
                colors: []
            };
            const little_endian = header.format === "binary_little_endian";
            const body = new DataView(data2, header.headerLength);
            let result, loc = 0;
            for(let currentElement = 0; currentElement < header.elements.length; currentElement++){
                for(let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++){
                    result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);
                    loc += result[1];
                    const element = result[0];
                    handleElement(buffer, header.elements[currentElement].name, element);
                }
            }
            return postProcess(buffer);
        }
        let geometry;
        const scope = this;
        if (data instanceof ArrayBuffer) {
            const text = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$LoaderUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeText"])(new Uint8Array(data));
            const header = parseHeader(text);
            geometry = header.format === "ascii" ? parseASCII(text, header) : parseBinary(data, header);
        } else {
            geometry = parseASCII(data, parseHeader(data));
        }
        return geometry;
    }
}
;
 //# sourceMappingURL=PLYLoader.js.map
}}),
}]);

//# sourceMappingURL=node_modules_three-stdlib_loaders_236009._.js.map