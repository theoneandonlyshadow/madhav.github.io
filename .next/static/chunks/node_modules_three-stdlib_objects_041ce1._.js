(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_three-stdlib_objects_041ce1._.js", {

"[project]/node_modules/three-stdlib/objects/BatchedMesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BatchedMesh": (()=>BatchedMesh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
const ID_ATTR_NAME = "_batch_id_";
const _identityMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const _zeroScaleMatrix = /* @__PURE__ */ (()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1))();
const batchingParsVertex = /* glsl */ `
#ifdef BATCHING
	attribute float ${ID_ATTR_NAME};
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {

		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );

	}
#endif
`;
const batchingbaseVertex = /* glsl */ `
#ifdef BATCHING
	mat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );
#endif
`;
const batchingnormalVertex = /* glsl */ `
#ifdef BATCHING
	objectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif
`;
const batchingVertex = /* glsl */ `
#ifdef BATCHING
	transformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;
#endif
`;
function copyAttributeData(src, target, targetOffset = 0) {
    const itemSize = target.itemSize;
    if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
        const vertexCount = src.count;
        for(let i = 0; i < vertexCount; i++){
            for(let c = 0; c < itemSize; c++){
                target.setComponent(i + targetOffset, c, src.getComponent(i, c));
            }
        }
    } else {
        target.array.set(src.array, targetOffset * itemSize);
    }
    target.needsUpdate = true;
}
class BatchedMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material){
        super(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"](), material);
        __publicField(this, "_vertexStarts");
        __publicField(this, "_vertexCounts");
        __publicField(this, "_indexStarts");
        __publicField(this, "_indexCounts");
        __publicField(this, "_reservedRanges");
        __publicField(this, "_visible");
        __publicField(this, "_active");
        __publicField(this, "_maxGeometryCount");
        __publicField(this, "_maxVertexCount");
        __publicField(this, "_maxIndexCount");
        __publicField(this, "_geometryInitialized");
        __publicField(this, "_geometryCount");
        __publicField(this, "_matrices");
        __publicField(this, "_matricesTexture");
        __publicField(this, "_customUniforms");
        this._vertexStarts = [];
        this._vertexCounts = [];
        this._indexStarts = [];
        this._indexCounts = [];
        this._reservedRanges = [];
        this._visible = [];
        this._active = [];
        this._maxGeometryCount = maxGeometryCount;
        this._maxVertexCount = maxVertexCount;
        this._maxIndexCount = maxIndexCount;
        this._geometryInitialized = false;
        this._geometryCount = 0;
        this._matrices = [];
        this._matricesTexture = null;
        this.frustumCulled = false;
        this._customUniforms = {
            batchingTexture: {
                value: null
            }
        };
        this._initMatricesTexture();
        this._initShader();
        this.onBeforeRender = function() {
            if (this.material.defines) {
                this.material.defines.BATCHING = true;
            }
        };
        this.onAfterRender = function() {
            if (this.material.defines) {
                this.material.defines.BATCHING = false;
            }
        };
    }
    _initMatricesTexture() {
        let size = Math.sqrt(this._maxGeometryCount * 4);
        size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].ceilPowerOfTwo(size);
        size = Math.max(size, 4);
        const matricesArray = new Float32Array(size * size * 4);
        const matricesTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"](matricesArray, size, size, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]);
        this._matricesTexture = matricesTexture;
        this._customUniforms.batchingTexture.value = this._matricesTexture;
    }
    _initShader() {
        const material = this.material;
        const currentOnBeforeCompile = material.onBeforeCompile;
        const customUniforms = this._customUniforms;
        material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {
            parameters.vertexShader = parameters.vertexShader.replace("#include <skinning_pars_vertex>", "#include <skinning_pars_vertex>\n" + batchingParsVertex).replace("#include <uv_vertex>", "#include <uv_vertex>\n" + batchingbaseVertex).replace("#include <skinnormal_vertex>", "#include <skinnormal_vertex>\n" + batchingnormalVertex).replace("#include <skinning_vertex>", "#include <skinning_vertex>\n" + batchingVertex);
            for(const uniformName in customUniforms){
                parameters.uniforms[uniformName] = customUniforms[uniformName];
            }
            currentOnBeforeCompile.call(this, parameters, renderer);
        };
        material.defines = material.defines || {};
        material.defines.BATCHING = false;
    }
    _initializeGeometry(reference) {
        const geometry = this.geometry;
        const maxVertexCount = this._maxVertexCount;
        const maxGeometryCount = this._maxGeometryCount;
        const maxIndexCount = this._maxIndexCount;
        if (this._geometryInitialized === false) {
            for(const attributeName in reference.attributes){
                const srcAttribute = reference.getAttribute(attributeName);
                const { array, itemSize, normalized } = srcAttribute;
                const dstArray = new array.constructor(maxVertexCount * itemSize);
                const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);
                dstAttribute.setUsage(srcAttribute.usage);
                geometry.setAttribute(attributeName, dstAttribute);
            }
            if (reference.getIndex() !== null) {
                const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
                geometry.setIndex(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](indexArray, 1));
            }
            const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount);
            geometry.setAttribute(ID_ATTR_NAME, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](idArray, 1));
            this._geometryInitialized = true;
        }
    }
    // Make sure the geometry is compatible with the existing combined geometry atributes
    _validateGeometry(geometry) {
        if (geometry.getAttribute(ID_ATTR_NAME)) {
            throw new Error(`BatchedMesh: Geometry cannot use attribute "${ID_ATTR_NAME}"`);
        }
        const batchGeometry = this.geometry;
        if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
            throw new Error('BatchedMesh: All geometries must consistently have "index".');
        }
        for(const attributeName in batchGeometry.attributes){
            if (attributeName === ID_ATTR_NAME) {
                continue;
            }
            if (!geometry.hasAttribute(attributeName)) {
                throw new Error(`BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
            }
            const srcAttribute = geometry.getAttribute(attributeName);
            const dstAttribute = batchGeometry.getAttribute(attributeName);
            if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
                throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
            }
        }
    }
    getGeometryCount() {
        return this._geometryCount;
    }
    getVertexCount() {
        const reservedRanges = this._reservedRanges;
        if (reservedRanges.length === 0) {
            return 0;
        } else {
            const finalRange = reservedRanges[reservedRanges.length - 1];
            return finalRange.vertexStart + finalRange.vertexCount;
        }
    }
    getIndexCount() {
        const reservedRanges = this._reservedRanges;
        const geometry = this.geometry;
        if (geometry.getIndex() === null || reservedRanges.length === 0) {
            return 0;
        } else {
            const finalRange = reservedRanges[reservedRanges.length - 1];
            return finalRange.indexStart + finalRange.indexCount;
        }
    }
    addGeometry(geometry, vertexCount = -1, indexCount = -1) {
        this._initializeGeometry(geometry);
        this._validateGeometry(geometry);
        if (this._geometryCount >= this._maxGeometryCount) {
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        }
        const range = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1
        };
        let lastRange = null;
        const reservedRanges = this._reservedRanges;
        if (this._geometryCount !== 0) {
            lastRange = reservedRanges[reservedRanges.length - 1];
        }
        if (vertexCount === -1) {
            range.vertexCount = geometry.getAttribute("position").count;
        } else {
            range.vertexCount = vertexCount;
        }
        if (lastRange === null) {
            range.vertexStart = 0;
        } else {
            range.vertexStart = lastRange.vertexStart + lastRange.vertexCount;
        }
        if (geometry.getIndex() !== null) {
            if (indexCount === -1) {
                range.indexCount = geometry.getIndex().count;
            } else {
                range.indexCount = indexCount;
            }
            if (lastRange === null) {
                range.indexStart = 0;
            } else {
                range.indexStart = lastRange.indexStart + lastRange.indexCount;
            }
        }
        if (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount || range.vertexStart + range.vertexCount > this._maxVertexCount) {
            throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        }
        const indexCounts = this._indexCounts;
        const indexStarts = this._indexStarts;
        const vertexCounts = this._vertexCounts;
        const vertexStarts = this._vertexStarts;
        const visible = this._visible;
        const active = this._active;
        const matricesTexture = this._matricesTexture;
        const matrices = this._matrices;
        const matricesArray = this._matricesTexture.image.data;
        visible.push(true);
        active.push(true);
        const geometryId = this._geometryCount;
        this._geometryCount++;
        matrices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]());
        _identityMatrix.toArray(matricesArray, geometryId * 16);
        matricesTexture.needsUpdate = true;
        reservedRanges.push(range);
        vertexStarts.push(range.vertexStart);
        vertexCounts.push(range.vertexCount);
        if (geometry.getIndex() !== null) {
            indexStarts.push(range.indexCount);
            indexCounts.push(range.indexCount);
        }
        const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);
        for(let i = 0; i < range.vertexCount; i++){
            idAttribute.setX(range.vertexStart + i, geometryId);
        }
        idAttribute.needsUpdate = true;
        this.setGeometryAt(geometryId, geometry);
        return geometryId;
    }
    /**
   * @deprecated use `addGeometry` instead.
   */ applyGeometry(geometry) {
        return this.addGeometry(geometry);
    }
    setGeometryAt(id, geometry) {
        if (id >= this._geometryCount) {
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        }
        this._validateGeometry(geometry);
        const range = this._reservedRanges[id];
        if (geometry.getIndex() !== null && geometry.getIndex().count > range.indexCount || geometry.attributes.position.count > range.vertexCount) {
            throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        }
        const batchGeometry = this.geometry;
        const srcPositionAttribute = geometry.getAttribute("position");
        const hasIndex = batchGeometry.getIndex() !== null;
        const dstIndex = batchGeometry.getIndex();
        const srcIndex = geometry.getIndex();
        const vertexStart = range.vertexStart;
        const vertexCount = range.vertexCount;
        for(const attributeName in batchGeometry.attributes){
            if (attributeName === ID_ATTR_NAME) {
                continue;
            }
            const srcAttribute = geometry.getAttribute(attributeName);
            const dstAttribute = batchGeometry.getAttribute(attributeName);
            copyAttributeData(srcAttribute, dstAttribute, vertexStart);
            const itemSize = srcAttribute.itemSize;
            for(let i = srcAttribute.count, l = vertexCount; i < l; i++){
                const index = vertexStart + i;
                for(let c = 0; c < itemSize; c++){
                    dstAttribute.setComponent(index, c, 0);
                }
            }
            dstAttribute.needsUpdate = true;
        }
        this._vertexCounts[id] = srcPositionAttribute.count;
        if (hasIndex) {
            const indexStart = range.indexStart;
            for(let i = 0; i < srcIndex.count; i++){
                dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));
            }
            for(let i = srcIndex.count, l = range.indexCount; i < l; i++){
                dstIndex.setX(indexStart + i, vertexStart);
            }
            dstIndex.needsUpdate = true;
            this._indexCounts[id] = srcIndex.count;
        }
        return id;
    }
    deleteGeometry(geometryId) {
        const active = this._active;
        const matricesTexture = this._matricesTexture;
        const matricesArray = matricesTexture.image.data;
        if (geometryId >= active.length || active[geometryId] === false) {
            return this;
        }
        active[geometryId] = false;
        _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);
        matricesTexture.needsUpdate = true;
        return this;
    }
    optimize() {
        throw new Error("BatchedMesh: Optimize function not implemented.");
    }
    setMatrixAt(geometryId, matrix) {
        const visible = this._visible;
        const active = this._active;
        const matricesTexture = this._matricesTexture;
        const matrices = this._matrices;
        const matricesArray = matricesTexture.image.data;
        if (geometryId >= matrices.length || active[geometryId] === false) {
            return this;
        }
        if (visible[geometryId] === true) {
            matrix.toArray(matricesArray, geometryId * 16);
            matricesTexture.needsUpdate = true;
        }
        matrices[geometryId].copy(matrix);
        return this;
    }
    getMatrixAt(geometryId, matrix) {
        const matrices = this._matrices;
        const active = this._active;
        if (geometryId >= matrices.length || active[geometryId] === false) {
            return matrix;
        }
        return matrix.copy(matrices[geometryId]);
    }
    setVisibleAt(geometryId, value) {
        const visible = this._visible;
        const active = this._active;
        const matricesTexture = this._matricesTexture;
        const matrices = this._matrices;
        const matricesArray = matricesTexture.image.data;
        if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {
            return this;
        }
        if (value === true) {
            matrices[geometryId].toArray(matricesArray, geometryId * 16);
        } else {
            _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);
        }
        matricesTexture.needsUpdate = true;
        visible[geometryId] = value;
        return this;
    }
    getVisibleAt(geometryId) {
        const visible = this._visible;
        const active = this._active;
        if (geometryId >= visible.length || active[geometryId] === false) {
            return false;
        }
        return visible[geometryId];
    }
    raycast() {
        console.warn("BatchedMesh: Raycast function not implemented.");
    }
    copy() {
        throw new Error("BatchedMesh: Copy function not implemented.");
    }
    toJSON() {
        throw new Error("BatchedMesh: toJSON function not implemented.");
    }
    dispose() {
        this.geometry.dispose();
        this._matricesTexture.dispose();
        this._matricesTexture = null;
        return this;
    }
}
;
 //# sourceMappingURL=BatchedMesh.js.map
}}),
"[project]/node_modules/three-stdlib/objects/Reflector.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Reflector": (()=>Reflector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
const Reflector = /* @__PURE__ */ (()=>{
    const _Reflector = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
        constructor(geometry, options = {}){
            super(geometry);
            this.isReflector = true;
            this.type = "Reflector";
            this.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
            const scope = this;
            const color = options.color !== void 0 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](options.color) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8355711);
            const textureWidth = options.textureWidth || 512;
            const textureHeight = options.textureHeight || 512;
            const clipBias = options.clipBias || 0;
            const shader = options.shader || _Reflector.ReflectorShader;
            const multisample = options.multisample !== void 0 ? options.multisample : 4;
            const reflectorPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
            const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const reflectorWorldPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const cameraWorldPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const rotationMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            const lookAtPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, -1);
            const clipPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
            const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const q = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
            const textureMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            const virtualCamera = this.camera;
            const renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](textureWidth, textureHeight, {
                samples: multisample,
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]
            });
            const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
                uniforms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(shader.uniforms),
                fragmentShader: shader.fragmentShader,
                vertexShader: shader.vertexShader
            });
            material.uniforms["tDiffuse"].value = renderTarget.texture;
            material.uniforms["color"].value = color;
            material.uniforms["textureMatrix"].value = textureMatrix;
            this.material = material;
            this.onBeforeRender = function(renderer, scene, camera) {
                reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
                cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
                rotationMatrix.extractRotation(scope.matrixWorld);
                normal.set(0, 0, 1);
                normal.applyMatrix4(rotationMatrix);
                view.subVectors(reflectorWorldPosition, cameraWorldPosition);
                if (view.dot(normal) > 0) return;
                view.reflect(normal).negate();
                view.add(reflectorWorldPosition);
                rotationMatrix.extractRotation(camera.matrixWorld);
                lookAtPosition.set(0, 0, -1);
                lookAtPosition.applyMatrix4(rotationMatrix);
                lookAtPosition.add(cameraWorldPosition);
                target.subVectors(reflectorWorldPosition, lookAtPosition);
                target.reflect(normal).negate();
                target.add(reflectorWorldPosition);
                virtualCamera.position.copy(view);
                virtualCamera.up.set(0, 1, 0);
                virtualCamera.up.applyMatrix4(rotationMatrix);
                virtualCamera.up.reflect(normal);
                virtualCamera.lookAt(target);
                virtualCamera.far = camera.far;
                virtualCamera.updateMatrixWorld();
                virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
                textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
                textureMatrix.multiply(virtualCamera.projectionMatrix);
                textureMatrix.multiply(virtualCamera.matrixWorldInverse);
                textureMatrix.multiply(scope.matrixWorld);
                reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
                reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
                clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
                const projectionMatrix = virtualCamera.projectionMatrix;
                q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
                q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
                q.z = -1;
                q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
                clipPlane.multiplyScalar(2 / clipPlane.dot(q));
                projectionMatrix.elements[2] = clipPlane.x;
                projectionMatrix.elements[6] = clipPlane.y;
                projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
                projectionMatrix.elements[14] = clipPlane.w;
                scope.visible = false;
                const currentRenderTarget = renderer.getRenderTarget();
                const currentXrEnabled = renderer.xr.enabled;
                const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
                const currentToneMapping = renderer.toneMapping;
                let isSRGB = false;
                if ("outputColorSpace" in renderer) isSRGB = renderer.outputColorSpace === "srgb";
                else isSRGB = renderer.outputEncoding === 3001;
                renderer.xr.enabled = false;
                renderer.shadowMap.autoUpdate = false;
                if ("outputColorSpace" in renderer) renderer.outputColorSpace = "srgb-linear";
                else renderer.outputEncoding = 3e3;
                renderer.toneMapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoToneMapping"];
                renderer.setRenderTarget(renderTarget);
                renderer.state.buffers.depth.setMask(true);
                if (renderer.autoClear === false) renderer.clear();
                renderer.render(scene, virtualCamera);
                renderer.xr.enabled = currentXrEnabled;
                renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
                renderer.toneMapping = currentToneMapping;
                if ("outputColorSpace" in renderer) renderer.outputColorSpace = isSRGB ? "srgb" : "srgb-linear";
                else renderer.outputEncoding = isSRGB ? 3001 : 3e3;
                renderer.setRenderTarget(currentRenderTarget);
                const viewport = camera.viewport;
                if (viewport !== void 0) {
                    renderer.state.viewport(viewport);
                }
                scope.visible = true;
            };
            this.getRenderTarget = function() {
                return renderTarget;
            };
            this.dispose = function() {
                renderTarget.dispose();
                scope.material.dispose();
            };
        }
    };
    let Reflector2 = _Reflector;
    __publicField(Reflector2, "ReflectorShader", {
        uniforms: {
            color: {
                value: null
            },
            tDiffuse: {
                value: null
            },
            textureMatrix: {
                value: null
            }
        },
        vertexShader: /* glsl */ `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,
        fragmentShader: /* glsl */ `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

		}`
    });
    return Reflector2;
})();
;
 //# sourceMappingURL=Reflector.js.map
}}),
"[project]/node_modules/three-stdlib/objects/Refractor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Refractor": (()=>Refractor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
const Refractor = /* @__PURE__ */ (()=>{
    const _Refractor = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
        constructor(geometry, options = {}){
            super(geometry);
            this.isRefractor = true;
            this.type = "Refractor";
            this.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
            const scope = this;
            const color = options.color !== void 0 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](options.color) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8355711);
            const textureWidth = options.textureWidth || 512;
            const textureHeight = options.textureHeight || 512;
            const clipBias = options.clipBias || 0;
            const shader = options.shader || _Refractor.RefractorShader;
            const multisample = options.multisample !== void 0 ? options.multisample : 4;
            const virtualCamera = this.camera;
            virtualCamera.matrixAutoUpdate = false;
            virtualCamera.userData.refractor = true;
            const refractorPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
            const textureMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            const renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](textureWidth, textureHeight, {
                samples: multisample,
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]
            });
            this.material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
                uniforms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(shader.uniforms),
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader,
                transparent: true
            });
            this.material.uniforms["color"].value = color;
            this.material.uniforms["tDiffuse"].value = renderTarget.texture;
            this.material.uniforms["textureMatrix"].value = textureMatrix;
            const visible = function() {
                const refractorWorldPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                const cameraWorldPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                const rotationMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
                const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                return function visible2(camera) {
                    refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
                    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
                    view.subVectors(refractorWorldPosition, cameraWorldPosition);
                    rotationMatrix.extractRotation(scope.matrixWorld);
                    normal.set(0, 0, 1);
                    normal.applyMatrix4(rotationMatrix);
                    return view.dot(normal) < 0;
                };
            }();
            const updateRefractorPlane = function() {
                const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
                const scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
                return function updateRefractorPlane2() {
                    scope.matrixWorld.decompose(position, quaternion, scale);
                    normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();
                    normal.negate();
                    refractorPlane.setFromNormalAndCoplanarPoint(normal, position);
                };
            }();
            const updateVirtualCamera = function() {
                const clipPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"]();
                const clipVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
                const q = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
                return function updateVirtualCamera2(camera) {
                    virtualCamera.matrixWorld.copy(camera.matrixWorld);
                    virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();
                    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
                    virtualCamera.far = camera.far;
                    clipPlane.copy(refractorPlane);
                    clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
                    clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);
                    const projectionMatrix = virtualCamera.projectionMatrix;
                    q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
                    q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
                    q.z = -1;
                    q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
                    clipVector.multiplyScalar(2 / clipVector.dot(q));
                    projectionMatrix.elements[2] = clipVector.x;
                    projectionMatrix.elements[6] = clipVector.y;
                    projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;
                    projectionMatrix.elements[14] = clipVector.w;
                };
            }();
            function updateTextureMatrix(camera) {
                textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
                textureMatrix.multiply(camera.projectionMatrix);
                textureMatrix.multiply(camera.matrixWorldInverse);
                textureMatrix.multiply(scope.matrixWorld);
            }
            function render(renderer, scene, camera) {
                scope.visible = false;
                const currentRenderTarget = renderer.getRenderTarget();
                const currentXrEnabled = renderer.xr.enabled;
                const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
                const currentToneMapping = renderer.toneMapping;
                let isSRGB = false;
                if ("outputColorSpace" in renderer) isSRGB = renderer.outputColorSpace === "srgb";
                else isSRGB = renderer.outputEncoding === 3001;
                renderer.xr.enabled = false;
                renderer.shadowMap.autoUpdate = false;
                if ("outputColorSpace" in renderer) renderer.outputColorSpace = "srgb-linear";
                else renderer.outputEncoding = 3e3;
                renderer.toneMapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoToneMapping"];
                renderer.setRenderTarget(renderTarget);
                if (renderer.autoClear === false) renderer.clear();
                renderer.render(scene, virtualCamera);
                renderer.xr.enabled = currentXrEnabled;
                renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
                renderer.toneMapping = currentToneMapping;
                renderer.setRenderTarget(currentRenderTarget);
                if ("outputColorSpace" in renderer) renderer.outputColorSpace = isSRGB ? "srgb" : "srgb-linear";
                else renderer.outputEncoding = isSRGB ? 3001 : 3e3;
                const viewport = camera.viewport;
                if (viewport !== void 0) {
                    renderer.state.viewport(viewport);
                }
                scope.visible = true;
            }
            this.onBeforeRender = function(renderer, scene, camera) {
                if (camera.userData.refractor === true) return;
                if (!visible(camera) === true) return;
                updateRefractorPlane();
                updateTextureMatrix(camera);
                updateVirtualCamera(camera);
                render(renderer, scene, camera);
            };
            this.getRenderTarget = function() {
                return renderTarget;
            };
            this.dispose = function() {
                renderTarget.dispose();
                scope.material.dispose();
            };
        }
    };
    let Refractor2 = _Refractor;
    __publicField(Refractor2, "RefractorShader", {
        uniforms: {
            color: {
                value: null
            },
            tDiffuse: {
                value: null
            },
            textureMatrix: {
                value: null
            }
        },
        vertexShader: /* glsl */ `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
        fragmentShader: /* glsl */ `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

		}`
    });
    return Refractor2;
})();
;
 //# sourceMappingURL=Refractor.js.map
}}),
"[project]/node_modules/three-stdlib/objects/ShadowMesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ShadowMesh": (()=>ShadowMesh)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const _shadowMatrix = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
class ShadowMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(mesh){
        const shadowMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: 0,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
            stencilWrite: true,
            stencilFunc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EqualStencilFunc"],
            stencilRef: 0,
            stencilZPass: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IncrementStencilOp"]
        });
        super(mesh.geometry, shadowMaterial);
        this.isShadowMesh = true;
        this.meshMatrix = mesh.matrixWorld;
        this.frustumCulled = false;
        this.matrixAutoUpdate = false;
    }
    update(plane, lightPosition4D) {
        const dot = plane.normal.x * lightPosition4D.x + plane.normal.y * lightPosition4D.y + plane.normal.z * lightPosition4D.z + -plane.constant * lightPosition4D.w;
        const sme = _shadowMatrix.elements;
        sme[0] = dot - lightPosition4D.x * plane.normal.x;
        sme[4] = -lightPosition4D.x * plane.normal.y;
        sme[8] = -lightPosition4D.x * plane.normal.z;
        sme[12] = -lightPosition4D.x * -plane.constant;
        sme[1] = -lightPosition4D.y * plane.normal.x;
        sme[5] = dot - lightPosition4D.y * plane.normal.y;
        sme[9] = -lightPosition4D.y * plane.normal.z;
        sme[13] = -lightPosition4D.y * -plane.constant;
        sme[2] = -lightPosition4D.z * plane.normal.x;
        sme[6] = -lightPosition4D.z * plane.normal.y;
        sme[10] = dot - lightPosition4D.z * plane.normal.z;
        sme[14] = -lightPosition4D.z * -plane.constant;
        sme[3] = -lightPosition4D.w * plane.normal.x;
        sme[7] = -lightPosition4D.w * plane.normal.y;
        sme[11] = -lightPosition4D.w * plane.normal.z;
        sme[15] = dot - lightPosition4D.w * -plane.constant;
        this.matrix.multiplyMatrices(_shadowMatrix, this.meshMatrix);
    }
}
;
 //# sourceMappingURL=ShadowMesh.js.map
}}),
"[project]/node_modules/three-stdlib/objects/Lensflare.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Lensflare": (()=>Lensflare),
    "LensflareElement": (()=>LensflareElement)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
const Lensflare = /* @__PURE__ */ (()=>{
    class Lensflare2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
        constructor(){
            super(Lensflare2.Geometry, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
                opacity: 0,
                transparent: true
            }));
            this.isLensflare = true;
            this.type = "Lensflare";
            this.frustumCulled = false;
            this.renderOrder = Infinity;
            const positionScreen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const positionView = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const tempMap = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]({
                width: 16,
                height: 16
            });
            tempMap.isFramebufferTexture = true;
            tempMap.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            tempMap.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            tempMap.generateMipmaps = false;
            tempMap.needsUpdate = true;
            const occlusionMap = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]({
                width: 16,
                height: 16
            });
            occlusionMap.isFramebufferTexture = true;
            occlusionMap.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            occlusionMap.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            occlusionMap.generateMipmaps = false;
            occlusionMap.needsUpdate = true;
            const geometry = Lensflare2.Geometry;
            const material1a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawShaderMaterial"]({
                uniforms: {
                    scale: {
                        value: null
                    },
                    screenPosition: {
                        value: null
                    }
                },
                vertexShader: /* glsl */ `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
                fragmentShader: /* glsl */ `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`,
                depthTest: true,
                depthWrite: false,
                transparent: false
            });
            const material1b = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawShaderMaterial"]({
                uniforms: {
                    map: {
                        value: tempMap
                    },
                    scale: {
                        value: null
                    },
                    screenPosition: {
                        value: null
                    }
                },
                vertexShader: /* glsl */ `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,
                fragmentShader: /* glsl */ `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`,
                depthTest: false,
                depthWrite: false,
                transparent: false
            });
            const mesh1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material1a);
            const elements = [];
            const shader = LensflareElement.Shader;
            const material2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawShaderMaterial"]({
                uniforms: {
                    map: {
                        value: null
                    },
                    occlusionMap: {
                        value: occlusionMap
                    },
                    color: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](16777215)
                    },
                    scale: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]()
                    },
                    screenPosition: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
                    }
                },
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader,
                blending: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AdditiveBlending"],
                transparent: true,
                depthWrite: false
            });
            const mesh2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, material2);
            this.addElement = function(element) {
                elements.push(element);
            };
            const scale = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
            const screenPositionPixels = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
            const validArea = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box2"]();
            const viewport = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"]();
            this.onBeforeRender = function(renderer, scene, camera) {
                renderer.getCurrentViewport(viewport);
                const invAspect = viewport.w / viewport.z;
                const halfViewportWidth = viewport.z / 2;
                const halfViewportHeight = viewport.w / 2;
                let size = 16 / viewport.w;
                scale.set(size * invAspect, size);
                validArea.min.set(viewport.x, viewport.y);
                validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
                positionView.setFromMatrixPosition(this.matrixWorld);
                positionView.applyMatrix4(camera.matrixWorldInverse);
                if (positionView.z > 0) return;
                positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);
                screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
                screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;
                if (validArea.containsPoint(screenPositionPixels)) {
                    renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);
                    let uniforms = material1a.uniforms;
                    uniforms["scale"].value = scale;
                    uniforms["screenPosition"].value = positionScreen;
                    renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);
                    renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);
                    uniforms = material1b.uniforms;
                    uniforms["scale"].value = scale;
                    uniforms["screenPosition"].value = positionScreen;
                    renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);
                    const vecX = -positionScreen.x * 2;
                    const vecY = -positionScreen.y * 2;
                    for(let i = 0, l = elements.length; i < l; i++){
                        const element = elements[i];
                        const uniforms2 = material2.uniforms;
                        uniforms2["color"].value.copy(element.color);
                        uniforms2["map"].value = element.texture;
                        uniforms2["screenPosition"].value.x = positionScreen.x + vecX * element.distance;
                        uniforms2["screenPosition"].value.y = positionScreen.y + vecY * element.distance;
                        size = element.size / viewport.w;
                        const invAspect2 = viewport.w / viewport.z;
                        uniforms2["scale"].value.set(size * invAspect2, size);
                        material2.uniformsNeedUpdate = true;
                        renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);
                    }
                }
            };
            this.dispose = function() {
                material1a.dispose();
                material1b.dispose();
                material2.dispose();
                tempMap.dispose();
                occlusionMap.dispose();
                for(let i = 0, l = elements.length; i < l; i++){
                    elements[i].texture.dispose();
                }
            };
        }
    }
    const _geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
    const interleavedBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBuffer"](new Float32Array([
        -1,
        -1,
        0,
        0,
        0,
        1,
        -1,
        0,
        1,
        0,
        1,
        1,
        0,
        1,
        1,
        -1,
        1,
        0,
        0,
        1
    ]), 5);
    _geometry.setIndex([
        0,
        1,
        2,
        0,
        2,
        3
    ]);
    _geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](interleavedBuffer, 3, 0, false));
    _geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"](interleavedBuffer, 2, 3, false));
    Lensflare2.Geometry = _geometry;
    return Lensflare2;
})();
const LensflareElement = /* @__PURE__ */ (()=>{
    class LensflareElement2 {
        constructor(texture, size = 1, distance = 0, color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](16777215)){
            this.texture = texture;
            this.size = size;
            this.distance = distance;
            this.color = color;
        }
    }
    LensflareElement2.Shader = {
        uniforms: {
            map: {
                value: null
            },
            occlusionMap: {
                value: null
            },
            color: {
                value: null
            },
            scale: {
                value: null
            },
            screenPosition: {
                value: null
            }
        },
        vertexShader: /* glsl */ `

      precision highp float;

      uniform vec3 screenPosition;
      uniform vec2 scale;

      uniform sampler2D occlusionMap;

      attribute vec3 position;
      attribute vec2 uv;

      varying vec2 vUV;
      varying float vVisibility;

      void main() {

        vUV = uv;

        vec2 pos = position.xy;

        vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
        visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
        visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
        visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
        visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
        visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
        visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
        visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
        visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

        vVisibility =        visibility.r / 9.0;
        vVisibility *= 1.0 - visibility.g / 9.0;
        vVisibility *=       visibility.b / 9.0;

        gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

      }
    `,
        fragmentShader: /* glsl */ `

      precision highp float;

      uniform sampler2D map;
      uniform vec3 color;

      varying vec2 vUV;
      varying float vVisibility;

      void main() {

        vec4 texture = texture2D( map, vUV );
        texture.a *= vVisibility;
        gl_FragColor = texture;
        gl_FragColor.rgb *= color;

      }
    `
    };
    return LensflareElement2;
})();
;
 //# sourceMappingURL=Lensflare.js.map
}}),
"[project]/node_modules/three-stdlib/objects/MarchingCubes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MarchingCubes": (()=>MarchingCubes),
    "edgeTable": (()=>edgeTable),
    "triTable": (()=>triTable)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
class MarchingCubes extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 1e4){
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        super(geometry, material);
        this.isMarchingCubes = true;
        const scope = this;
        const vlist = new Float32Array(12 * 3);
        const nlist = new Float32Array(12 * 3);
        const clist = new Float32Array(12 * 3);
        this.enableUvs = enableUvs;
        this.enableColors = enableColors;
        this.init = function(resolution2) {
            this.resolution = resolution2;
            this.isolation = 80;
            this.size = resolution2;
            this.size2 = this.size * this.size;
            this.size3 = this.size2 * this.size;
            this.halfsize = this.size / 2;
            this.delta = 2 / this.size;
            this.yd = this.size;
            this.zd = this.size2;
            this.field = new Float32Array(this.size3);
            this.normal_cache = new Float32Array(this.size3 * 3);
            this.palette = new Float32Array(this.size3 * 3);
            this.count = 0;
            const maxVertexCount = maxPolyCount * 3;
            this.positionArray = new Float32Array(maxVertexCount * 3);
            const positionAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.positionArray, 3);
            positionAttribute.setUsage(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"]);
            geometry.setAttribute("position", positionAttribute);
            this.normalArray = new Float32Array(maxVertexCount * 3);
            const normalAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.normalArray, 3);
            normalAttribute.setUsage(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"]);
            geometry.setAttribute("normal", normalAttribute);
            if (this.enableUvs) {
                this.uvArray = new Float32Array(maxVertexCount * 2);
                const uvAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.uvArray, 2);
                uvAttribute.setUsage(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"]);
                geometry.setAttribute("uv", uvAttribute);
            }
            if (this.enableColors) {
                this.colorArray = new Float32Array(maxVertexCount * 3);
                const colorAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferAttribute"](this.colorArray, 3);
                colorAttribute.setUsage(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DynamicDrawUsage"]);
                geometry.setAttribute("color", colorAttribute);
            }
            geometry.boundingSphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](), 1);
        };
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
            const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
            vlist[offset + 0] = x + mu * scope.delta;
            vlist[offset + 1] = y;
            vlist[offset + 2] = z;
            nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);
            nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);
            nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);
            clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
            clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
            clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
        }
        function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
            const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
            vlist[offset + 0] = x;
            vlist[offset + 1] = y + mu * scope.delta;
            vlist[offset + 2] = z;
            const q2 = q + scope.yd * 3;
            nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
            nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
            nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
            clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
            clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
            clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
        }
        function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
            const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
            vlist[offset + 0] = x;
            vlist[offset + 1] = y;
            vlist[offset + 2] = z + mu * scope.delta;
            const q2 = q + scope.zd * 3;
            nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
            nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
            nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
            clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
            clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
            clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
        }
        function compNorm(q) {
            const q3 = q * 3;
            if (scope.normal_cache[q3] === 0) {
                scope.normal_cache[q3 + 0] = scope.field[q - 1] - scope.field[q + 1];
                scope.normal_cache[q3 + 1] = scope.field[q - scope.yd] - scope.field[q + scope.yd];
                scope.normal_cache[q3 + 2] = scope.field[q - scope.zd] - scope.field[q + scope.zd];
            }
        }
        function polygonize(fx, fy, fz, q, isol) {
            const q1 = q + 1, qy = q + scope.yd, qz = q + scope.zd, q1y = q1 + scope.yd, q1z = q1 + scope.zd, qyz = q + scope.yd + scope.zd, q1yz = q1 + scope.yd + scope.zd;
            let cubeindex = 0;
            const field0 = scope.field[q], field1 = scope.field[q1], field2 = scope.field[qy], field3 = scope.field[q1y], field4 = scope.field[qz], field5 = scope.field[q1z], field6 = scope.field[qyz], field7 = scope.field[q1yz];
            if (field0 < isol) cubeindex |= 1;
            if (field1 < isol) cubeindex |= 2;
            if (field2 < isol) cubeindex |= 8;
            if (field3 < isol) cubeindex |= 4;
            if (field4 < isol) cubeindex |= 16;
            if (field5 < isol) cubeindex |= 32;
            if (field6 < isol) cubeindex |= 128;
            if (field7 < isol) cubeindex |= 64;
            const bits = edgeTable[cubeindex];
            if (bits === 0) return 0;
            const d = scope.delta, fx2 = fx + d, fy2 = fy + d, fz2 = fz + d;
            if (bits & 1) {
                compNorm(q);
                compNorm(q1);
                VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);
            }
            if (bits & 2) {
                compNorm(q1);
                compNorm(q1y);
                VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);
            }
            if (bits & 4) {
                compNorm(qy);
                compNorm(q1y);
                VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);
            }
            if (bits & 8) {
                compNorm(q);
                compNorm(qy);
                VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);
            }
            if (bits & 16) {
                compNorm(qz);
                compNorm(q1z);
                VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);
            }
            if (bits & 32) {
                compNorm(q1z);
                compNorm(q1yz);
                VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);
            }
            if (bits & 64) {
                compNorm(qyz);
                compNorm(q1yz);
                VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);
            }
            if (bits & 128) {
                compNorm(qz);
                compNorm(qyz);
                VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);
            }
            if (bits & 256) {
                compNorm(q);
                compNorm(qz);
                VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);
            }
            if (bits & 512) {
                compNorm(q1);
                compNorm(q1z);
                VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);
            }
            if (bits & 1024) {
                compNorm(q1y);
                compNorm(q1yz);
                VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);
            }
            if (bits & 2048) {
                compNorm(qy);
                compNorm(qyz);
                VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);
            }
            cubeindex <<= 4;
            let o1, o2, o3, numtris = 0, i = 0;
            while(triTable[cubeindex + i] != -1){
                o1 = cubeindex + i;
                o2 = o1 + 1;
                o3 = o1 + 2;
                posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3]);
                i += 3;
                numtris++;
            }
            return numtris;
        }
        function posnormtriv(pos, norm, colors, o1, o2, o3) {
            const c = scope.count * 3;
            scope.positionArray[c + 0] = pos[o1];
            scope.positionArray[c + 1] = pos[o1 + 1];
            scope.positionArray[c + 2] = pos[o1 + 2];
            scope.positionArray[c + 3] = pos[o2];
            scope.positionArray[c + 4] = pos[o2 + 1];
            scope.positionArray[c + 5] = pos[o2 + 2];
            scope.positionArray[c + 6] = pos[o3];
            scope.positionArray[c + 7] = pos[o3 + 1];
            scope.positionArray[c + 8] = pos[o3 + 2];
            if (scope.material.flatShading === true) {
                const nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3;
                const ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3;
                const nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3;
                scope.normalArray[c + 0] = nx;
                scope.normalArray[c + 1] = ny;
                scope.normalArray[c + 2] = nz;
                scope.normalArray[c + 3] = nx;
                scope.normalArray[c + 4] = ny;
                scope.normalArray[c + 5] = nz;
                scope.normalArray[c + 6] = nx;
                scope.normalArray[c + 7] = ny;
                scope.normalArray[c + 8] = nz;
            } else {
                scope.normalArray[c + 0] = norm[o1 + 0];
                scope.normalArray[c + 1] = norm[o1 + 1];
                scope.normalArray[c + 2] = norm[o1 + 2];
                scope.normalArray[c + 3] = norm[o2 + 0];
                scope.normalArray[c + 4] = norm[o2 + 1];
                scope.normalArray[c + 5] = norm[o2 + 2];
                scope.normalArray[c + 6] = norm[o3 + 0];
                scope.normalArray[c + 7] = norm[o3 + 1];
                scope.normalArray[c + 8] = norm[o3 + 2];
            }
            if (scope.enableUvs) {
                const d = scope.count * 2;
                scope.uvArray[d + 0] = pos[o1 + 0];
                scope.uvArray[d + 1] = pos[o1 + 2];
                scope.uvArray[d + 2] = pos[o2 + 0];
                scope.uvArray[d + 3] = pos[o2 + 2];
                scope.uvArray[d + 4] = pos[o3 + 0];
                scope.uvArray[d + 5] = pos[o3 + 2];
            }
            if (scope.enableColors) {
                scope.colorArray[c + 0] = colors[o1 + 0];
                scope.colorArray[c + 1] = colors[o1 + 1];
                scope.colorArray[c + 2] = colors[o1 + 2];
                scope.colorArray[c + 3] = colors[o2 + 0];
                scope.colorArray[c + 4] = colors[o2 + 1];
                scope.colorArray[c + 5] = colors[o2 + 2];
                scope.colorArray[c + 6] = colors[o3 + 0];
                scope.colorArray[c + 7] = colors[o3 + 1];
                scope.colorArray[c + 8] = colors[o3 + 2];
            }
            scope.count += 3;
        }
        this.addBall = function(ballx, bally, ballz, strength, subtract, colors) {
            const sign = Math.sign(strength);
            strength = Math.abs(strength);
            const userDefineColor = !(colors === void 0 || colors === null);
            let ballColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](ballx, bally, ballz);
            if (userDefineColor) {
                try {
                    ballColor = colors instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"] ? colors : Array.isArray(colors) ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](Math.min(Math.abs(colors[0]), 1), Math.min(Math.abs(colors[1]), 1), Math.min(Math.abs(colors[2]), 1)) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](colors);
                } catch (err) {
                    ballColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](ballx, bally, ballz);
                }
            }
            const radius = this.size * Math.sqrt(strength / subtract), zs = ballz * this.size, ys = bally * this.size, xs = ballx * this.size;
            let min_z = Math.floor(zs - radius);
            if (min_z < 1) min_z = 1;
            let max_z = Math.floor(zs + radius);
            if (max_z > this.size - 1) max_z = this.size - 1;
            let min_y = Math.floor(ys - radius);
            if (min_y < 1) min_y = 1;
            let max_y = Math.floor(ys + radius);
            if (max_y > this.size - 1) max_y = this.size - 1;
            let min_x = Math.floor(xs - radius);
            if (min_x < 1) min_x = 1;
            let max_x = Math.floor(xs + radius);
            if (max_x > this.size - 1) max_x = this.size - 1;
            let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;
            for(z = min_z; z < max_z; z++){
                z_offset = this.size2 * z;
                fz = z / this.size - ballz;
                fz2 = fz * fz;
                for(y = min_y; y < max_y; y++){
                    y_offset = z_offset + this.size * y;
                    fy = y / this.size - bally;
                    fy2 = fy * fy;
                    for(x = min_x; x < max_x; x++){
                        fx = x / this.size - ballx;
                        val = strength / (1e-6 + fx * fx + fy2 + fz2) - subtract;
                        if (val > 0) {
                            this.field[y_offset + x] += val * sign;
                            const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;
                            const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);
                            this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;
                            this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;
                            this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;
                        }
                    }
                }
            }
        };
        this.addPlaneX = function(strength, subtract) {
            const size = this.size, yd = this.yd, zd = this.zd, field = this.field;
            let x, y, z, xx, val, xdiv, cxy, dist = size * Math.sqrt(strength / subtract);
            if (dist > size) dist = size;
            for(x = 0; x < dist; x++){
                xdiv = x / size;
                xx = xdiv * xdiv;
                val = strength / (1e-4 + xx) - subtract;
                if (val > 0) {
                    for(y = 0; y < size; y++){
                        cxy = x + y * yd;
                        for(z = 0; z < size; z++){
                            field[zd * z + cxy] += val;
                        }
                    }
                }
            }
        };
        this.addPlaneY = function(strength, subtract) {
            const size = this.size, yd = this.yd, zd = this.zd, field = this.field;
            let x, y, z, yy, val, ydiv, cy, cxy, dist = size * Math.sqrt(strength / subtract);
            if (dist > size) dist = size;
            for(y = 0; y < dist; y++){
                ydiv = y / size;
                yy = ydiv * ydiv;
                val = strength / (1e-4 + yy) - subtract;
                if (val > 0) {
                    cy = y * yd;
                    for(x = 0; x < size; x++){
                        cxy = cy + x;
                        for(z = 0; z < size; z++)field[zd * z + cxy] += val;
                    }
                }
            }
        };
        this.addPlaneZ = function(strength, subtract) {
            const size = this.size, yd = this.yd, zd = this.zd, field = this.field;
            let x, y, z, zz, val, zdiv, cz, cyz, dist = size * Math.sqrt(strength / subtract);
            if (dist > size) dist = size;
            for(z = 0; z < dist; z++){
                zdiv = z / size;
                zz = zdiv * zdiv;
                val = strength / (1e-4 + zz) - subtract;
                if (val > 0) {
                    cz = zd * z;
                    for(y = 0; y < size; y++){
                        cyz = cz + y * yd;
                        for(x = 0; x < size; x++)field[cyz + x] += val;
                    }
                }
            }
        };
        this.setCell = function(x, y, z, value) {
            const index = this.size2 * z + this.size * y + x;
            this.field[index] = value;
        };
        this.getCell = function(x, y, z) {
            const index = this.size2 * z + this.size * y + x;
            return this.field[index];
        };
        this.blur = function(intensity = 1) {
            const field = this.field;
            const fieldCopy = field.slice();
            const size = this.size;
            const size2 = this.size2;
            for(let x = 0; x < size; x++){
                for(let y = 0; y < size; y++){
                    for(let z = 0; z < size; z++){
                        const index = size2 * z + size * y + x;
                        let val = fieldCopy[index];
                        let count = 1;
                        for(let x2 = -1; x2 <= 1; x2 += 2){
                            const x3 = x2 + x;
                            if (x3 < 0 || x3 >= size) continue;
                            for(let y2 = -1; y2 <= 1; y2 += 2){
                                const y3 = y2 + y;
                                if (y3 < 0 || y3 >= size) continue;
                                for(let z2 = -1; z2 <= 1; z2 += 2){
                                    const z3 = z2 + z;
                                    if (z3 < 0 || z3 >= size) continue;
                                    const index2 = size2 * z3 + size * y3 + x3;
                                    const val2 = fieldCopy[index2];
                                    count++;
                                    val += intensity * (val2 - val) / count;
                                }
                            }
                        }
                        field[index] = val;
                    }
                }
            }
        };
        this.reset = function() {
            for(let i = 0; i < this.size3; i++){
                this.normal_cache[i * 3] = 0;
                this.field[i] = 0;
                this.palette[i * 3] = this.palette[i * 3 + 1] = this.palette[i * 3 + 2] = 0;
            }
        };
        this.update = function() {
            this.count = 0;
            const smin2 = this.size - 2;
            for(let z = 1; z < smin2; z++){
                const z_offset = this.size2 * z;
                const fz = (z - this.halfsize) / this.halfsize;
                for(let y = 1; y < smin2; y++){
                    const y_offset = z_offset + this.size * y;
                    const fy = (y - this.halfsize) / this.halfsize;
                    for(let x = 1; x < smin2; x++){
                        const fx = (x - this.halfsize) / this.halfsize;
                        const q = y_offset + x;
                        polygonize(fx, fy, fz, q, this.isolation);
                    }
                }
            }
            this.geometry.setDrawRange(0, this.count);
            geometry.getAttribute("position").needsUpdate = true;
            geometry.getAttribute("normal").needsUpdate = true;
            if (this.enableUvs) geometry.getAttribute("uv").needsUpdate = true;
            if (this.enableColors) geometry.getAttribute("color").needsUpdate = true;
            if (this.count / 3 > maxPolyCount) console.warn("THREE.MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.");
        };
        this.init(resolution);
    }
}
const edgeTable = new Int32Array([
    0,
    265,
    515,
    778,
    1030,
    1295,
    1541,
    1804,
    2060,
    2309,
    2575,
    2822,
    3082,
    3331,
    3593,
    3840,
    400,
    153,
    915,
    666,
    1430,
    1183,
    1941,
    1692,
    2460,
    2197,
    2975,
    2710,
    3482,
    3219,
    3993,
    3728,
    560,
    825,
    51,
    314,
    1590,
    1855,
    1077,
    1340,
    2620,
    2869,
    2111,
    2358,
    3642,
    3891,
    3129,
    3376,
    928,
    681,
    419,
    170,
    1958,
    1711,
    1445,
    1196,
    2988,
    2725,
    2479,
    2214,
    4010,
    3747,
    3497,
    3232,
    1120,
    1385,
    1635,
    1898,
    102,
    367,
    613,
    876,
    3180,
    3429,
    3695,
    3942,
    2154,
    2403,
    2665,
    2912,
    1520,
    1273,
    2035,
    1786,
    502,
    255,
    1013,
    764,
    3580,
    3317,
    4095,
    3830,
    2554,
    2291,
    3065,
    2800,
    1616,
    1881,
    1107,
    1370,
    598,
    863,
    85,
    348,
    3676,
    3925,
    3167,
    3414,
    2650,
    2899,
    2137,
    2384,
    1984,
    1737,
    1475,
    1226,
    966,
    719,
    453,
    204,
    4044,
    3781,
    3535,
    3270,
    3018,
    2755,
    2505,
    2240,
    2240,
    2505,
    2755,
    3018,
    3270,
    3535,
    3781,
    4044,
    204,
    453,
    719,
    966,
    1226,
    1475,
    1737,
    1984,
    2384,
    2137,
    2899,
    2650,
    3414,
    3167,
    3925,
    3676,
    348,
    85,
    863,
    598,
    1370,
    1107,
    1881,
    1616,
    2800,
    3065,
    2291,
    2554,
    3830,
    4095,
    3317,
    3580,
    764,
    1013,
    255,
    502,
    1786,
    2035,
    1273,
    1520,
    2912,
    2665,
    2403,
    2154,
    3942,
    3695,
    3429,
    3180,
    876,
    613,
    367,
    102,
    1898,
    1635,
    1385,
    1120,
    3232,
    3497,
    3747,
    4010,
    2214,
    2479,
    2725,
    2988,
    1196,
    1445,
    1711,
    1958,
    170,
    419,
    681,
    928,
    3376,
    3129,
    3891,
    3642,
    2358,
    2111,
    2869,
    2620,
    1340,
    1077,
    1855,
    1590,
    314,
    51,
    825,
    560,
    3728,
    3993,
    3219,
    3482,
    2710,
    2975,
    2197,
    2460,
    1692,
    1941,
    1183,
    1430,
    666,
    915,
    153,
    400,
    3840,
    3593,
    3331,
    3082,
    2822,
    2575,
    2309,
    2060,
    1804,
    1541,
    1295,
    1030,
    778,
    515,
    265,
    0
]);
const triTable = new Int32Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    9,
    8,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    0,
    2,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    8,
    3,
    2,
    10,
    8,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    8,
    11,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    2,
    1,
    9,
    11,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    11,
    10,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    10,
    1,
    0,
    8,
    10,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    9,
    0,
    3,
    11,
    9,
    11,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    7,
    3,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    1,
    9,
    4,
    7,
    1,
    7,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    7,
    3,
    0,
    4,
    1,
    2,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    10,
    9,
    0,
    2,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    9,
    2,
    9,
    7,
    2,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    4,
    7,
    11,
    2,
    4,
    2,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    8,
    4,
    7,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    9,
    4,
    11,
    9,
    11,
    2,
    9,
    2,
    1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    1,
    3,
    11,
    10,
    7,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    11,
    10,
    1,
    4,
    11,
    1,
    0,
    4,
    7,
    11,
    4,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    8,
    9,
    0,
    11,
    9,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    4,
    7,
    11,
    4,
    11,
    9,
    9,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    1,
    5,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    5,
    4,
    8,
    3,
    5,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    10,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    2,
    10,
    5,
    4,
    2,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    3,
    2,
    5,
    3,
    5,
    4,
    3,
    4,
    8,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    2,
    0,
    8,
    11,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    5,
    4,
    0,
    1,
    5,
    2,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    1,
    5,
    2,
    5,
    8,
    2,
    8,
    11,
    4,
    8,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    3,
    11,
    10,
    1,
    3,
    9,
    5,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    0,
    8,
    1,
    8,
    10,
    1,
    8,
    11,
    10,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    0,
    5,
    0,
    11,
    5,
    11,
    10,
    11,
    0,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    4,
    8,
    5,
    8,
    10,
    10,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    5,
    7,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    3,
    0,
    9,
    5,
    3,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    8,
    0,
    1,
    7,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    8,
    9,
    5,
    7,
    10,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    9,
    5,
    0,
    5,
    3,
    0,
    5,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    0,
    2,
    8,
    2,
    5,
    8,
    5,
    7,
    10,
    5,
    2,
    -1,
    -1,
    -1,
    -1,
    2,
    10,
    5,
    2,
    5,
    3,
    3,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    9,
    5,
    7,
    8,
    9,
    3,
    11,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    7,
    9,
    7,
    2,
    9,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    0,
    1,
    8,
    1,
    7,
    8,
    1,
    5,
    7,
    -1,
    -1,
    -1,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    7,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    8,
    8,
    5,
    7,
    10,
    1,
    3,
    10,
    3,
    11,
    -1,
    -1,
    -1,
    -1,
    5,
    7,
    0,
    5,
    0,
    9,
    7,
    11,
    0,
    1,
    0,
    10,
    11,
    10,
    0,
    -1,
    11,
    10,
    0,
    11,
    0,
    3,
    10,
    5,
    0,
    8,
    0,
    7,
    5,
    7,
    0,
    -1,
    11,
    10,
    5,
    7,
    11,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    8,
    3,
    1,
    9,
    8,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    2,
    6,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    5,
    1,
    2,
    6,
    3,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    6,
    5,
    9,
    0,
    6,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    9,
    8,
    5,
    8,
    2,
    5,
    2,
    6,
    3,
    2,
    8,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    0,
    8,
    11,
    2,
    0,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    1,
    9,
    2,
    9,
    11,
    2,
    9,
    8,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    3,
    11,
    6,
    5,
    3,
    5,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    11,
    0,
    11,
    5,
    0,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    6,
    0,
    3,
    6,
    0,
    6,
    5,
    0,
    5,
    9,
    -1,
    -1,
    -1,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    11,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    3,
    0,
    4,
    7,
    3,
    6,
    5,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    5,
    10,
    6,
    8,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    5,
    1,
    9,
    7,
    1,
    7,
    3,
    7,
    9,
    4,
    -1,
    -1,
    -1,
    -1,
    6,
    1,
    2,
    6,
    5,
    1,
    4,
    7,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    5,
    5,
    2,
    6,
    3,
    0,
    4,
    3,
    4,
    7,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    7,
    9,
    0,
    5,
    0,
    6,
    5,
    0,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    9,
    7,
    9,
    4,
    3,
    2,
    9,
    5,
    9,
    6,
    2,
    6,
    9,
    -1,
    3,
    11,
    2,
    7,
    8,
    4,
    10,
    6,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    6,
    4,
    7,
    2,
    4,
    2,
    0,
    2,
    7,
    11,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    4,
    7,
    8,
    2,
    3,
    11,
    5,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    9,
    2,
    1,
    9,
    11,
    2,
    9,
    4,
    11,
    7,
    11,
    4,
    5,
    10,
    6,
    -1,
    8,
    4,
    7,
    3,
    11,
    5,
    3,
    5,
    1,
    5,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    5,
    1,
    11,
    5,
    11,
    6,
    1,
    0,
    11,
    7,
    11,
    4,
    0,
    4,
    11,
    -1,
    0,
    5,
    9,
    0,
    6,
    5,
    0,
    3,
    6,
    11,
    6,
    3,
    8,
    4,
    7,
    -1,
    6,
    5,
    9,
    6,
    9,
    11,
    4,
    7,
    9,
    7,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    6,
    4,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    10,
    6,
    4,
    9,
    10,
    0,
    8,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    0,
    1,
    10,
    6,
    0,
    6,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    1,
    8,
    1,
    6,
    8,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    1,
    4,
    9,
    1,
    2,
    4,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    1,
    2,
    9,
    2,
    4,
    9,
    2,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    3,
    2,
    8,
    2,
    4,
    4,
    2,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    4,
    9,
    10,
    6,
    4,
    11,
    2,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    2,
    2,
    8,
    11,
    4,
    9,
    10,
    4,
    10,
    6,
    -1,
    -1,
    -1,
    -1,
    3,
    11,
    2,
    0,
    1,
    6,
    0,
    6,
    4,
    6,
    1,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    1,
    6,
    1,
    10,
    4,
    8,
    1,
    2,
    1,
    11,
    8,
    11,
    1,
    -1,
    9,
    6,
    4,
    9,
    3,
    6,
    9,
    1,
    3,
    11,
    6,
    3,
    -1,
    -1,
    -1,
    -1,
    8,
    11,
    1,
    8,
    1,
    0,
    11,
    6,
    1,
    9,
    1,
    4,
    6,
    4,
    1,
    -1,
    3,
    11,
    6,
    3,
    6,
    0,
    0,
    6,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    4,
    8,
    11,
    6,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    10,
    6,
    7,
    8,
    10,
    8,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    7,
    3,
    0,
    10,
    7,
    0,
    9,
    10,
    6,
    7,
    10,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    1,
    10,
    7,
    1,
    7,
    8,
    1,
    8,
    0,
    -1,
    -1,
    -1,
    -1,
    10,
    6,
    7,
    10,
    7,
    1,
    1,
    7,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    6,
    1,
    6,
    8,
    1,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    6,
    9,
    2,
    9,
    1,
    6,
    7,
    9,
    0,
    9,
    3,
    7,
    3,
    9,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    6,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    3,
    2,
    6,
    7,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    11,
    10,
    6,
    8,
    10,
    8,
    9,
    8,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    2,
    0,
    7,
    2,
    7,
    11,
    0,
    9,
    7,
    6,
    7,
    10,
    9,
    10,
    7,
    -1,
    1,
    8,
    0,
    1,
    7,
    8,
    1,
    10,
    7,
    6,
    7,
    10,
    2,
    3,
    11,
    -1,
    11,
    2,
    1,
    11,
    1,
    7,
    10,
    6,
    1,
    6,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    8,
    9,
    6,
    8,
    6,
    7,
    9,
    1,
    6,
    11,
    6,
    3,
    1,
    3,
    6,
    -1,
    0,
    9,
    1,
    11,
    6,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    8,
    0,
    7,
    0,
    6,
    3,
    11,
    0,
    11,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    7,
    11,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    8,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    9,
    8,
    3,
    1,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    2,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    8,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    0,
    2,
    10,
    9,
    6,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    2,
    10,
    3,
    10,
    8,
    3,
    10,
    9,
    8,
    -1,
    -1,
    -1,
    -1,
    7,
    2,
    3,
    6,
    2,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7,
    0,
    8,
    7,
    6,
    0,
    6,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    7,
    6,
    2,
    3,
    7,
    0,
    1,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    2,
    1,
    8,
    6,
    1,
    9,
    8,
    8,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    10,
    1,
    7,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    6,
    1,
    7,
    10,
    1,
    8,
    7,
    1,
    0,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    7,
    0,
    7,
    10,
    0,
    10,
    9,
    6,
    10,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    8,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    11,
    8,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    3,
    0,
    6,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    6,
    11,
    8,
    4,
    6,
    9,
    0,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    6,
    9,
    6,
    3,
    9,
    3,
    1,
    11,
    3,
    6,
    -1,
    -1,
    -1,
    -1,
    6,
    8,
    4,
    6,
    11,
    8,
    2,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    3,
    0,
    11,
    0,
    6,
    11,
    0,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    8,
    4,
    6,
    11,
    0,
    2,
    9,
    2,
    10,
    9,
    -1,
    -1,
    -1,
    -1,
    10,
    9,
    3,
    10,
    3,
    2,
    9,
    4,
    3,
    11,
    3,
    6,
    4,
    6,
    3,
    -1,
    8,
    2,
    3,
    8,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    2,
    4,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    0,
    2,
    3,
    4,
    2,
    4,
    6,
    4,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    9,
    4,
    1,
    4,
    2,
    2,
    4,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    1,
    3,
    8,
    6,
    1,
    8,
    4,
    6,
    6,
    10,
    1,
    -1,
    -1,
    -1,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    6,
    0,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    6,
    3,
    4,
    3,
    8,
    6,
    10,
    3,
    0,
    3,
    9,
    10,
    9,
    3,
    -1,
    10,
    9,
    4,
    6,
    10,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    5,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    5,
    11,
    7,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    1,
    5,
    4,
    0,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    6,
    8,
    3,
    4,
    3,
    5,
    4,
    3,
    1,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    10,
    1,
    2,
    7,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    7,
    1,
    2,
    10,
    0,
    8,
    3,
    4,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    7,
    6,
    11,
    5,
    4,
    10,
    4,
    2,
    10,
    4,
    0,
    2,
    -1,
    -1,
    -1,
    -1,
    3,
    4,
    8,
    3,
    5,
    4,
    3,
    2,
    5,
    10,
    5,
    2,
    11,
    7,
    6,
    -1,
    7,
    2,
    3,
    7,
    6,
    2,
    5,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    4,
    0,
    8,
    6,
    0,
    6,
    2,
    6,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    2,
    3,
    7,
    6,
    1,
    5,
    0,
    5,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    6,
    2,
    8,
    6,
    8,
    7,
    2,
    1,
    8,
    4,
    8,
    5,
    1,
    5,
    8,
    -1,
    9,
    5,
    4,
    10,
    1,
    6,
    1,
    7,
    6,
    1,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    1,
    6,
    10,
    1,
    7,
    6,
    1,
    0,
    7,
    8,
    7,
    0,
    9,
    5,
    4,
    -1,
    4,
    0,
    10,
    4,
    10,
    5,
    0,
    3,
    10,
    6,
    10,
    7,
    3,
    7,
    10,
    -1,
    7,
    6,
    10,
    7,
    10,
    8,
    5,
    4,
    10,
    4,
    8,
    10,
    -1,
    -1,
    -1,
    -1,
    6,
    9,
    5,
    6,
    11,
    9,
    11,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    6,
    11,
    0,
    6,
    3,
    0,
    5,
    6,
    0,
    9,
    5,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    8,
    0,
    5,
    11,
    0,
    1,
    5,
    5,
    6,
    11,
    -1,
    -1,
    -1,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    5,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    10,
    9,
    5,
    11,
    9,
    11,
    8,
    11,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    0,
    11,
    3,
    0,
    6,
    11,
    0,
    9,
    6,
    5,
    6,
    9,
    1,
    2,
    10,
    -1,
    11,
    8,
    5,
    11,
    5,
    6,
    8,
    0,
    5,
    10,
    5,
    2,
    0,
    2,
    5,
    -1,
    6,
    11,
    3,
    6,
    3,
    5,
    2,
    10,
    3,
    10,
    5,
    3,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    9,
    5,
    2,
    8,
    5,
    6,
    2,
    3,
    8,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    5,
    6,
    9,
    6,
    0,
    0,
    6,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    5,
    8,
    1,
    8,
    0,
    5,
    6,
    8,
    3,
    8,
    2,
    6,
    2,
    8,
    -1,
    1,
    5,
    6,
    2,
    1,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    6,
    1,
    6,
    10,
    3,
    8,
    6,
    5,
    6,
    9,
    8,
    9,
    6,
    -1,
    10,
    1,
    0,
    10,
    0,
    6,
    9,
    5,
    0,
    5,
    6,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    5,
    6,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    5,
    6,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    7,
    5,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    5,
    10,
    11,
    7,
    5,
    8,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    11,
    7,
    5,
    10,
    11,
    1,
    9,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    7,
    5,
    10,
    11,
    7,
    9,
    8,
    1,
    8,
    3,
    1,
    -1,
    -1,
    -1,
    -1,
    11,
    1,
    2,
    11,
    7,
    1,
    7,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    1,
    2,
    7,
    1,
    7,
    5,
    7,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    5,
    9,
    2,
    7,
    9,
    0,
    2,
    2,
    11,
    7,
    -1,
    -1,
    -1,
    -1,
    7,
    5,
    2,
    7,
    2,
    11,
    5,
    9,
    2,
    3,
    2,
    8,
    9,
    8,
    2,
    -1,
    2,
    5,
    10,
    2,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    2,
    0,
    8,
    5,
    2,
    8,
    7,
    5,
    10,
    2,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    1,
    5,
    10,
    3,
    5,
    3,
    7,
    3,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    2,
    9,
    2,
    1,
    8,
    7,
    2,
    10,
    2,
    5,
    7,
    5,
    2,
    -1,
    1,
    3,
    5,
    3,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    7,
    0,
    7,
    1,
    1,
    7,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    0,
    3,
    9,
    3,
    5,
    5,
    3,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    8,
    7,
    5,
    9,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    8,
    4,
    5,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5,
    0,
    4,
    5,
    11,
    0,
    5,
    10,
    11,
    11,
    3,
    0,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    9,
    8,
    4,
    10,
    8,
    10,
    11,
    10,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    4,
    10,
    4,
    5,
    11,
    3,
    4,
    9,
    4,
    1,
    3,
    1,
    4,
    -1,
    2,
    5,
    1,
    2,
    8,
    5,
    2,
    11,
    8,
    4,
    5,
    8,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    11,
    0,
    11,
    3,
    4,
    5,
    11,
    2,
    11,
    1,
    5,
    1,
    11,
    -1,
    0,
    2,
    5,
    0,
    5,
    9,
    2,
    11,
    5,
    4,
    5,
    8,
    11,
    8,
    5,
    -1,
    9,
    4,
    5,
    2,
    11,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    5,
    10,
    3,
    5,
    2,
    3,
    4,
    5,
    3,
    8,
    4,
    -1,
    -1,
    -1,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    4,
    2,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    10,
    2,
    3,
    5,
    10,
    3,
    8,
    5,
    4,
    5,
    8,
    0,
    1,
    9,
    -1,
    5,
    10,
    2,
    5,
    2,
    4,
    1,
    9,
    2,
    9,
    4,
    2,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    3,
    5,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    4,
    5,
    1,
    0,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8,
    4,
    5,
    8,
    5,
    3,
    9,
    0,
    5,
    0,
    3,
    5,
    -1,
    -1,
    -1,
    -1,
    9,
    4,
    5,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    11,
    7,
    4,
    9,
    11,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    8,
    3,
    4,
    9,
    7,
    9,
    11,
    7,
    9,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    11,
    1,
    11,
    4,
    1,
    4,
    0,
    7,
    4,
    11,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    4,
    3,
    4,
    8,
    1,
    10,
    4,
    7,
    4,
    11,
    10,
    11,
    4,
    -1,
    4,
    11,
    7,
    9,
    11,
    4,
    9,
    2,
    11,
    9,
    1,
    2,
    -1,
    -1,
    -1,
    -1,
    9,
    7,
    4,
    9,
    11,
    7,
    9,
    1,
    11,
    2,
    11,
    1,
    0,
    8,
    3,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    2,
    4,
    0,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    11,
    7,
    4,
    11,
    4,
    2,
    8,
    3,
    4,
    3,
    2,
    4,
    -1,
    -1,
    -1,
    -1,
    2,
    9,
    10,
    2,
    7,
    9,
    2,
    3,
    7,
    7,
    4,
    9,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    7,
    9,
    7,
    4,
    10,
    2,
    7,
    8,
    7,
    0,
    2,
    0,
    7,
    -1,
    3,
    7,
    10,
    3,
    10,
    2,
    7,
    4,
    10,
    1,
    10,
    0,
    4,
    0,
    10,
    -1,
    1,
    10,
    2,
    8,
    7,
    4,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    7,
    1,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    9,
    1,
    4,
    1,
    7,
    0,
    8,
    1,
    8,
    7,
    1,
    -1,
    -1,
    -1,
    -1,
    4,
    0,
    3,
    7,
    4,
    3,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4,
    8,
    7,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    8,
    10,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    11,
    9,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    10,
    0,
    10,
    8,
    8,
    10,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    1,
    10,
    11,
    3,
    10,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    2,
    11,
    1,
    11,
    9,
    9,
    11,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    0,
    9,
    3,
    9,
    11,
    1,
    2,
    9,
    2,
    11,
    9,
    -1,
    -1,
    -1,
    -1,
    0,
    2,
    11,
    8,
    0,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3,
    2,
    11,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    10,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    9,
    10,
    2,
    0,
    9,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2,
    3,
    8,
    2,
    8,
    10,
    0,
    1,
    8,
    1,
    10,
    8,
    -1,
    -1,
    -1,
    -1,
    1,
    10,
    2,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    3,
    8,
    9,
    1,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    9,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    3,
    8,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
;
 //# sourceMappingURL=MarchingCubes.js.map
}}),
"[project]/node_modules/three-stdlib/objects/LightningStorm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LightningStorm": (()=>LightningStorm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/geometries/LightningStrike.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
class LightningStorm extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(stormParams = {}){
        super();
        this.isLightningStorm = true;
        this.stormParams = stormParams;
        stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;
        stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;
        stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;
        stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;
        stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;
        stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;
        stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;
        stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;
        stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;
        this.lightningParameters = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LightningStrike"].copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);
        this.lightningParameters.isEternal = false;
        this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            color: 11599871
        });
        if (stormParams.onRayPosition !== void 0) {
            this.onRayPosition = stormParams.onRayPosition;
        } else {
            this.onRayPosition = function(source, dest) {
                dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);
                const height = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());
                source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);
            };
        }
        this.onLightningDown = stormParams.onLightningDown;
        this.inited = false;
        this.nextLightningTime = 0;
        this.lightningsMeshes = [];
        this.deadLightningsMeshes = [];
        for(let i = 0; i < this.stormParams.maxLightnings; i++){
            const lightning = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LightningStrike"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LightningStrike"].copyParameters({}, this.lightningParameters));
            const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](lightning, this.lightningMaterial);
            this.deadLightningsMeshes.push(mesh);
        }
    }
    update(time) {
        if (!this.inited) {
            this.nextLightningTime = this.getNextLightningTime(time) * Math.random();
            this.inited = true;
        }
        if (time >= this.nextLightningTime) {
            const lightningMesh = this.deadLightningsMeshes.pop();
            if (lightningMesh) {
                const lightningParams1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LightningStrike"].copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);
                lightningParams1.birthTime = time;
                lightningParams1.deathTime = time + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());
                this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);
                lightningParams1.noiseSeed = Math.random();
                this.add(lightningMesh);
                this.lightningsMeshes.push(lightningMesh);
            }
            this.nextLightningTime = this.getNextLightningTime(time);
        }
        let i = 0, il = this.lightningsMeshes.length;
        while(i < il){
            const mesh = this.lightningsMeshes[i];
            const lightning = mesh.geometry;
            const prevState = lightning.state;
            lightning.update(time);
            if (prevState === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LightningStrike"].RAY_PROPAGATING && lightning.state > prevState) {
                if (this.onLightningDown) {
                    this.onLightningDown(lightning);
                }
            }
            if (lightning.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LightningStrike"].RAY_EXTINGUISHED) {
                this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);
                this.deadLightningsMeshes.push(mesh);
                this.remove(mesh);
                il--;
            } else {
                i++;
            }
        }
    }
    getNextLightningTime(currentTime) {
        return currentTime + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.stormParams.size = source.stormParams.size;
        this.stormParams.minHeight = source.stormParams.minHeight;
        this.stormParams.maxHeight = source.stormParams.maxHeight;
        this.stormParams.maxSlope = source.stormParams.maxSlope;
        this.stormParams.maxLightnings = source.stormParams.maxLightnings;
        this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;
        this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;
        this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;
        this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;
        this.lightningParameters = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$geometries$2f$LightningStrike$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LightningStrike"].copyParameters({}, source.lightningParameters);
        this.lightningMaterial = source.stormParams.lightningMaterial;
        this.onLightningDown = source.onLightningDown;
        return this;
    }
    clone() {
        return new this.constructor(this.stormParams).copy(this);
    }
}
;
 //# sourceMappingURL=LightningStorm.js.map
}}),
"[project]/node_modules/three-stdlib/objects/ReflectorRTT.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ReflectorRTT": (()=>ReflectorRTT)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$Reflector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/objects/Reflector.js [app-client] (ecmascript)");
;
class ReflectorRTT extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$Reflector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Reflector"] {
    constructor(geometry, options){
        super(geometry, options);
        this.geometry.setDrawRange(0, 0);
    }
}
;
 //# sourceMappingURL=ReflectorRTT.js.map
}}),
"[project]/node_modules/three-stdlib/objects/ReflectorForSSRPass.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ReflectorForSSRPass": (()=>ReflectorForSSRPass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
const ReflectorForSSRPass = /* @__PURE__ */ (()=>{
    const _ReflectorForSSRPass = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
        constructor(geometry, options = {}){
            super(geometry);
            this.isReflectorForSSRPass = true;
            this.type = "ReflectorForSSRPass";
            const scope = this;
            const color = options.color !== void 0 ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](options.color) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](8355711);
            const textureWidth = options.textureWidth || 512;
            const textureHeight = options.textureHeight || 512;
            const clipBias = options.clipBias || 0;
            const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;
            const useDepthTexture = options.useDepthTexture === true;
            const yAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
            const vecTemp0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const vecTemp1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            scope.needsUpdate = false;
            scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;
            scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;
            scope.color = color;
            scope.resolution = options.resolution || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](window.innerWidth, window.innerHeight);
            scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;
            Object.defineProperty(scope, "distanceAttenuation", {
                get () {
                    return scope._distanceAttenuation;
                },
                set (val) {
                    if (scope._distanceAttenuation === val) return;
                    scope._distanceAttenuation = val;
                    scope.material.defines.DISTANCE_ATTENUATION = val;
                    scope.material.needsUpdate = true;
                }
            });
            scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;
            Object.defineProperty(scope, "fresnel", {
                get () {
                    return scope._fresnel;
                },
                set (val) {
                    if (scope._fresnel === val) return;
                    scope._fresnel = val;
                    scope.material.defines.FRESNEL = val;
                    scope.material.needsUpdate = true;
                }
            });
            const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const reflectorWorldPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const cameraWorldPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const rotationMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            const lookAtPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, -1);
            const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            const textureMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
            const virtualCamera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
            let depthTexture;
            if (useDepthTexture) {
                depthTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DepthTexture"]();
                depthTexture.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedShortType"];
                depthTexture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
                depthTexture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NearestFilter"];
            }
            const parameters = {
                depthTexture: useDepthTexture ? depthTexture : null,
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]
            };
            const renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](textureWidth, textureHeight, parameters);
            const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
                transparent: useDepthTexture,
                defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {
                    useDepthTexture
                }),
                uniforms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(shader.uniforms),
                fragmentShader: shader.fragmentShader,
                vertexShader: shader.vertexShader
            });
            material.uniforms["tDiffuse"].value = renderTarget.texture;
            material.uniforms["color"].value = scope.color;
            material.uniforms["textureMatrix"].value = textureMatrix;
            if (useDepthTexture) {
                material.uniforms["tDepth"].value = renderTarget.depthTexture;
            }
            this.material = material;
            const globalPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Plane"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0), clipBias);
            const globalPlanes = [
                globalPlane
            ];
            this.doRender = function(renderer, scene, camera) {
                material.uniforms["maxDistance"].value = scope.maxDistance;
                material.uniforms["color"].value = scope.color;
                material.uniforms["opacity"].value = scope.opacity;
                vecTemp0.copy(camera.position).normalize();
                vecTemp1.copy(vecTemp0).reflect(yAxis);
                material.uniforms["fresnelCoe"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;
                reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
                cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
                rotationMatrix.extractRotation(scope.matrixWorld);
                normal.set(0, 0, 1);
                normal.applyMatrix4(rotationMatrix);
                view.subVectors(reflectorWorldPosition, cameraWorldPosition);
                if (view.dot(normal) > 0) return;
                view.reflect(normal).negate();
                view.add(reflectorWorldPosition);
                rotationMatrix.extractRotation(camera.matrixWorld);
                lookAtPosition.set(0, 0, -1);
                lookAtPosition.applyMatrix4(rotationMatrix);
                lookAtPosition.add(cameraWorldPosition);
                target.subVectors(reflectorWorldPosition, lookAtPosition);
                target.reflect(normal).negate();
                target.add(reflectorWorldPosition);
                virtualCamera.position.copy(view);
                virtualCamera.up.set(0, 1, 0);
                virtualCamera.up.applyMatrix4(rotationMatrix);
                virtualCamera.up.reflect(normal);
                virtualCamera.lookAt(target);
                virtualCamera.far = camera.far;
                virtualCamera.updateMatrixWorld();
                virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
                material.uniforms["virtualCameraNear"].value = camera.near;
                material.uniforms["virtualCameraFar"].value = camera.far;
                material.uniforms["virtualCameraMatrixWorld"].value = virtualCamera.matrixWorld;
                material.uniforms["virtualCameraProjectionMatrix"].value = camera.projectionMatrix;
                material.uniforms["virtualCameraProjectionMatrixInverse"].value = camera.projectionMatrixInverse;
                material.uniforms["resolution"].value = scope.resolution;
                textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
                textureMatrix.multiply(virtualCamera.projectionMatrix);
                textureMatrix.multiply(virtualCamera.matrixWorldInverse);
                textureMatrix.multiply(scope.matrixWorld);
                const currentRenderTarget = renderer.getRenderTarget();
                const currentXrEnabled = renderer.xr.enabled;
                const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
                const currentClippingPlanes = renderer.clippingPlanes;
                renderer.xr.enabled = false;
                renderer.shadowMap.autoUpdate = false;
                renderer.clippingPlanes = globalPlanes;
                renderer.setRenderTarget(renderTarget);
                renderer.state.buffers.depth.setMask(true);
                if (renderer.autoClear === false) renderer.clear();
                renderer.render(scene, virtualCamera);
                renderer.xr.enabled = currentXrEnabled;
                renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
                renderer.clippingPlanes = currentClippingPlanes;
                renderer.setRenderTarget(currentRenderTarget);
                const viewport = camera.viewport;
                if (viewport !== void 0) {
                    renderer.state.viewport(viewport);
                }
            };
            this.getRenderTarget = function() {
                return renderTarget;
            };
        }
    };
    let ReflectorForSSRPass2 = _ReflectorForSSRPass;
    __publicField(ReflectorForSSRPass2, "ReflectorShader", {
        defines: {
            DISTANCE_ATTENUATION: true,
            FRESNEL: true
        },
        uniforms: {
            color: {
                value: null
            },
            tDiffuse: {
                value: null
            },
            tDepth: {
                value: null
            },
            textureMatrix: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]()
            },
            maxDistance: {
                value: 180
            },
            opacity: {
                value: 0.5
            },
            fresnelCoe: {
                value: null
            },
            virtualCameraNear: {
                value: null
            },
            virtualCameraFar: {
                value: null
            },
            virtualCameraProjectionMatrix: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]()
            },
            virtualCameraMatrixWorld: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]()
            },
            virtualCameraProjectionMatrixInverse: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]()
            },
            resolution: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]()
            }
        },
        vertexShader: /* glsl */ `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
        fragmentShader: /* glsl */ `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float maxDistance;
		uniform float opacity;
		uniform float fresnelCoe;
		uniform float virtualCameraNear;
		uniform float virtualCameraFar;
		uniform mat4 virtualCameraProjectionMatrix;
		uniform mat4 virtualCameraProjectionMatrixInverse;
		uniform mat4 virtualCameraMatrixWorld;
		uniform vec2 resolution;
		varying vec4 vUv;
		#include <packing>
		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view
		}
		void main() {
			vec4 base = texture2DProj( tDiffuse, vUv );
			#ifdef useDepthTexture
				vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;
				uv.x=1.-uv.x;
				float depth = texture2DProj( tDepth, vUv ).r;
				float viewZ = getViewZ( depth );
				float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];
				vec3 viewPosition=getViewPosition( uv, depth, clipW );
				vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;
				if(worldPosition.y>maxDistance) discard;
				float op=opacity;
				#ifdef DISTANCE_ATTENUATION
					float ratio=1.-(worldPosition.y/maxDistance);
					float attenuation=ratio*ratio;
					op=opacity*attenuation;
				#endif
				#ifdef FRESNEL
					op*=fresnelCoe;
				#endif
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );
			#else
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );
			#endif
		}
	`
    });
    return ReflectorForSSRPass2;
})();
;
 //# sourceMappingURL=ReflectorForSSRPass.js.map
}}),
"[project]/node_modules/three-stdlib/objects/Sky.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Sky": (()=>Sky)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
const Sky = /* @__PURE__ */ (()=>{
    const SkyShader = {
        uniforms: {
            turbidity: {
                value: 2
            },
            rayleigh: {
                value: 1
            },
            mieCoefficient: {
                value: 5e-3
            },
            mieDirectionalG: {
                value: 0.8
            },
            sunPosition: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
            },
            up: {
                value: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0)
            }
        },
        vertexShader: /* glsl */ `
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `,
        fragmentShader: /* glsl */ `
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

      }
    `
    };
    const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
        name: "SkyShader",
        fragmentShader: SkyShader.fragmentShader,
        vertexShader: SkyShader.vertexShader,
        uniforms: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UniformsUtils"].clone(SkyShader.uniforms),
        side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"],
        depthWrite: false
    });
    class Sky2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
        constructor(){
            super(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxGeometry"](1, 1, 1), material);
        }
    }
    __publicField(Sky2, "SkyShader", SkyShader);
    __publicField(Sky2, "material", material);
    return Sky2;
})();
;
 //# sourceMappingURL=Sky.js.map
}}),
"[project]/node_modules/three-stdlib/objects/GroundProjectedEnv.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GroundProjectedEnv": (()=>GroundProjectedEnv)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
const isCubeTexture = (def)=>def && def.isCubeTexture;
class GroundProjectedEnv extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(texture, options){
        var _a, _b;
        const isCubeMap = isCubeTexture(texture);
        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;
        const cubeSize = w / 4;
        const _lodMax = Math.floor(Math.log2(cubeSize));
        const _cubeSize = Math.pow(2, _lodMax);
        const width = 3 * Math.max(_cubeSize, 16 * 7);
        const height = 4 * _cubeSize;
        const defines = [
            isCubeMap ? "#define ENVMAP_TYPE_CUBE" : "",
            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,
            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,
            `#define CUBEUV_MAX_MIP ${_lodMax}.0`
        ];
        const vertexShader = /* glsl */ `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `;
        const fragmentShader = defines.join("\n") + /* glsl */ `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
        `;
        const uniforms = {
            map: {
                value: texture
            },
            height: {
                value: (options == null ? void 0 : options.height) || 15
            },
            radius: {
                value: (options == null ? void 0 : options.radius) || 100
            }
        };
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IcosahedronGeometry"](1, 16);
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            uniforms,
            fragmentShader,
            vertexShader,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"]
        });
        super(geometry, material);
    }
    set radius(radius) {
        this.material.uniforms.radius.value = radius;
    }
    get radius() {
        return this.material.uniforms.radius.value;
    }
    set height(height) {
        this.material.uniforms.height.value = height;
    }
    get height() {
        return this.material.uniforms.height.value;
    }
}
;
 //# sourceMappingURL=GroundProjectedEnv.js.map
}}),
}]);

//# sourceMappingURL=node_modules_three-stdlib_objects_041ce1._.js.map