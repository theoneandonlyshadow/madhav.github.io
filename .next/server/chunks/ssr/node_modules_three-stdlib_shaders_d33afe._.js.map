{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/BokehShader2.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst BokehShader2 = {\n  uniforms: {\n    textureWidth: { value: 1 },\n    textureHeight: { value: 1 },\n    focalDepth: { value: 1 },\n    focalLength: { value: 24 },\n    fstop: { value: 0.9 },\n    tColor: { value: null },\n    tDepth: { value: null },\n    maxblur: { value: 1 },\n    showFocus: { value: 0 },\n    manualdof: { value: 0 },\n    vignetting: { value: 0 },\n    depthblur: { value: 0 },\n    threshold: { value: 0.5 },\n    gain: { value: 2 },\n    bias: { value: 0.5 },\n    fringe: { value: 0.7 },\n    znear: { value: 0.1 },\n    zfar: { value: 100 },\n    noise: { value: 1 },\n    dithering: { value: 1e-4 },\n    pentagon: { value: 0 },\n    shaderFocus: { value: 1 },\n    focusCoords: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #include <common>\n\n    varying vec2 vUv;\n\n    uniform sampler2D tColor;\n    uniform sampler2D tDepth;\n    uniform float textureWidth;\n    uniform float textureHeight;\n\n    uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\n    uniform float focalLength; //focal length in mm\n    uniform float fstop; //f-stop value\n    uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\n\n    /*\n    make sure that these two values are the same for your camera, otherwise distances will be wrong.\n    */\n\n    uniform float znear; // camera clipping start\n    uniform float zfar; // camera clipping end\n\n    //------------------------------------------\n    //user variables\n\n    const int samples = SAMPLES; //samples on the first ring\n    const int rings = RINGS; //ring count\n\n    const int maxringsamples = rings * samples;\n\n    uniform bool manualdof; // manual dof calculation\n    float ndofstart = 1.0; // near dof blur start\n    float ndofdist = 2.0; // near dof blur falloff distance\n    float fdofstart = 1.0; // far dof blur start\n    float fdofdist = 3.0; // far dof blur falloff distance\n\n    float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\n\n    uniform bool vignetting; // use optical lens vignetting\n\n    float vignout = 1.3; // vignetting outer border\n    float vignin = 0.0; // vignetting inner border\n    float vignfade = 22.0; // f-stops till vignete fades\n\n    uniform bool shaderFocus;\n    // disable if you use external focalDepth value\n\n    uniform vec2 focusCoords;\n    // autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n    // if center of screen use vec2(0.5, 0.5);\n\n    uniform float maxblur;\n    //clamp value of max blur (0.0 = no blur, 1.0 default)\n\n    uniform float threshold; // highlight threshold;\n    uniform float gain; // highlight gain;\n\n    uniform float bias; // bokeh edge bias\n    uniform float fringe; // bokeh chromatic aberration / fringing\n\n    uniform bool noise; //use noise instead of pattern for sample dithering\n\n    uniform float dithering;\n\n    uniform bool depthblur; // blur the depth buffer\n    float dbsize = 1.25; // depth blur size\n\n    /*\n    next part is experimental\n    not looking good with small sample and ring count\n    looks okay starting from samples = 4, rings = 4\n    */\n\n    uniform bool pentagon; //use pentagon as bokeh shape?\n    float feather = 0.4; //pentagon shape feather\n\n    //------------------------------------------\n\n    float penta(vec2 coords) {\n    \t//pentagonal shape\n    \tfloat scale = float(rings) - 1.3;\n    \tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\n    \tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\n    \tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\n    \tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\n    \tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\n    \tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\n\n    \tvec4  one = vec4( 1.0 );\n\n    \tvec4 P = vec4((coords),vec2(scale, scale));\n\n    \tvec4 dist = vec4(0.0);\n    \tfloat inorout = -4.0;\n\n    \tdist.x = dot( P, HS0 );\n    \tdist.y = dot( P, HS1 );\n    \tdist.z = dot( P, HS2 );\n    \tdist.w = dot( P, HS3 );\n\n    \tdist = smoothstep( -feather, feather, dist );\n\n    \tinorout += dot( dist, one );\n\n    \tdist.x = dot( P, HS4 );\n    \tdist.y = HS5.w - abs( P.z );\n\n    \tdist = smoothstep( -feather, feather, dist );\n    \tinorout += dist.x;\n\n    \treturn clamp( inorout, 0.0, 1.0 );\n    }\n\n    float bdepth(vec2 coords) {\n    \t// Depth buffer blur\n    \tfloat d = 0.0;\n    \tfloat kernel[9];\n    \tvec2 offset[9];\n\n    \tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\n\n    \toffset[0] = vec2(-wh.x,-wh.y);\n    \toffset[1] = vec2( 0.0, -wh.y);\n    \toffset[2] = vec2( wh.x -wh.y);\n\n    \toffset[3] = vec2(-wh.x,  0.0);\n    \toffset[4] = vec2( 0.0,   0.0);\n    \toffset[5] = vec2( wh.x,  0.0);\n\n    \toffset[6] = vec2(-wh.x, wh.y);\n    \toffset[7] = vec2( 0.0,  wh.y);\n    \toffset[8] = vec2( wh.x, wh.y);\n\n    \tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\n    \tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\n    \tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\n\n    \tfor( int i=0; i<9; i++ ) {\n    \t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\n    \t\td += tmp * kernel[i];\n    \t}\n\n    \treturn d;\n    }\n\n    vec3 color(vec2 coords,float blur) {\n    \t//processing the sample\n\n    \tvec3 col = vec3(0.0);\n    \tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\n\n    \tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\n    \tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\n    \tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\n\n    \tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n    \tfloat lum = dot(col.rgb, lumcoeff);\n    \tfloat thresh = max((lum-threshold)*gain, 0.0);\n    \treturn col+mix(vec3(0.0),col,thresh*blur);\n    }\n\n    vec3 debugFocus(vec3 col, float blur, float depth) {\n    \tfloat edge = 0.002*depth; //distance based edge smoothing\n    \tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\n    \tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\n\n    \tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\n    \tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n\n    \treturn col;\n    }\n\n    float linearize(float depth) {\n    \treturn -zfar * znear / (depth * (zfar - znear) - zfar);\n    }\n\n    float vignette() {\n    \tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\n    \tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\n    \treturn clamp(dist,0.0,1.0);\n    }\n\n    float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n    \tfloat rings2 = float(rings);\n    \tfloat step = PI*2.0 / float(ringsamples);\n    \tfloat pw = cos(j*step)*i;\n    \tfloat ph = sin(j*step)*i;\n    \tfloat p = 1.0;\n    \tif (pentagon) {\n    \t\tp = penta(vec2(pw,ph));\n    \t}\n    \tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\n    \treturn 1.0 * mix(1.0, i /rings2, bias) * p;\n    }\n\n    void main() {\n    \t//scene depth calculation\n\n    \tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\n\n    \t// Blur depth?\n    \tif ( depthblur ) {\n    \t\tdepth = linearize(bdepth(vUv.xy));\n    \t}\n\n    \t//focal plane calculation\n\n    \tfloat fDepth = focalDepth;\n\n    \tif (shaderFocus) {\n\n    \t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\n\n    \t}\n\n    \t// dof blur factor calculation\n\n    \tfloat blur = 0.0;\n\n    \tif (manualdof) {\n    \t\tfloat a = depth-fDepth; // Focal plane\n    \t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\n    \t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\n    \t\tblur = (a>0.0) ? b : c;\n    \t} else {\n    \t\tfloat f = focalLength; // focal length in mm\n    \t\tfloat d = fDepth*1000.0; // focal plane in mm\n    \t\tfloat o = depth*1000.0; // depth in mm\n\n    \t\tfloat a = (o*f)/(o-f);\n    \t\tfloat b = (d*f)/(d-f);\n    \t\tfloat c = (d-f)/(d*fstop*CoC);\n\n    \t\tblur = abs(a-b)*c;\n    \t}\n\n    \tblur = clamp(blur,0.0,1.0);\n\n    \t// calculation of pattern for dithering\n\n    \tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\n\n    \t// getting blur x and y step factor\n\n    \tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\n    \tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\n\n    \t// calculation of final color\n\n    \tvec3 col = vec3(0.0);\n\n    \tif(blur < 0.05) {\n    \t\t//some optimization thingy\n    \t\tcol = texture2D(tColor, vUv.xy).rgb;\n    \t} else {\n    \t\tcol = texture2D(tColor, vUv.xy).rgb;\n    \t\tfloat s = 1.0;\n    \t\tint ringsamples;\n\n    \t\tfor (int i = 1; i <= rings; i++) {\n    \t\t\t/*unboxstart*/\n    \t\t\tringsamples = i * samples;\n\n    \t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\n    \t\t\t\tif (j >= ringsamples) break;\n    \t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\n    \t\t\t}\n    \t\t\t/*unboxend*/\n    \t\t}\n\n    \t\tcol /= s; //divide by sample count\n    \t}\n\n    \tif (showFocus) {\n    \t\tcol = debugFocus(col, blur, depth);\n    \t}\n\n    \tif (vignetting) {\n    \t\tcol *= vignette();\n    \t}\n\n    \tgl_FragColor.rgb = col;\n    \tgl_FragColor.a = 1.0;\n    } \n  `\n  )\n};\nconst BokehDepthShader = {\n  uniforms: {\n    mNear: { value: 1 },\n    mFar: { value: 1e3 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying float vViewZDepth;\n\n    void main() {\n\n    \t#include <begin_vertex>\n    \t#include <project_vertex>\n\n    \tvViewZDepth = - mvPosition.z;\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float mNear;\n    uniform float mFar;\n\n    varying float vViewZDepth;\n\n    void main() {\n\n    \tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\n    \tgl_FragColor = vec4( vec3( color ), 1.0 );\n\n    } \n  `\n  )\n};\nexport {\n  BokehDepthShader,\n  BokehShader2\n};\n//# sourceMappingURL=BokehShader2.js.map\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,eAAe;IACnB,UAAU;QACR,cAAc;YAAE,OAAO;QAAE;QACzB,eAAe;YAAE,OAAO;QAAE;QAC1B,YAAY;YAAE,OAAO;QAAE;QACvB,aAAa;YAAE,OAAO;QAAG;QACzB,OAAO;YAAE,OAAO;QAAI;QACpB,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,SAAS;YAAE,OAAO;QAAE;QACpB,WAAW;YAAE,OAAO;QAAE;QACtB,WAAW;YAAE,OAAO;QAAE;QACtB,YAAY;YAAE,OAAO;QAAE;QACvB,WAAW;YAAE,OAAO;QAAE;QACtB,WAAW;YAAE,OAAO;QAAI;QACxB,MAAM;YAAE,OAAO;QAAE;QACjB,MAAM;YAAE,OAAO;QAAI;QACnB,QAAQ;YAAE,OAAO;QAAI;QACrB,OAAO;YAAE,OAAO;QAAI;QACpB,MAAM;YAAE,OAAO;QAAI;QACnB,OAAO;YAAE,OAAO;QAAE;QAClB,WAAW;YAAE,OAAO;QAAK;QACzB,UAAU;YAAE,OAAO;QAAE;QACrB,aAAa;YAAE,OAAO;QAAE;QACxB,aAAa;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;IACtD;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4RH,CAAC;AAEH;AACA,MAAM,mBAAmB;IACvB,UAAU;QACR,OAAO;YAAE,OAAO;QAAE;QAClB,MAAM;YAAE,OAAO;QAAI;IACrB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;EAWH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;EAYH,CAAC;AAEH;;CAKA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 424, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/DigitalGlitch.js"],"sourcesContent":["const DigitalGlitch = {\n  uniforms: {\n    tDiffuse: { value: null },\n    //diffuse texture\n    tDisp: { value: null },\n    //displacement texture for digital glitch squares\n    byp: { value: 0 },\n    //apply the glitch ?\n    amount: { value: 0.08 },\n    angle: { value: 0.02 },\n    seed: { value: 0.02 },\n    seed_x: { value: 0.02 },\n    //-1,1\n    seed_y: { value: 0.02 },\n    //-1,1\n    distortion_x: { value: 0.5 },\n    distortion_y: { value: 0.6 },\n    col_s: { value: 0.05 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n\t`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform int byp; //should we apply the glitch ?\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDisp;\n\t\tuniform float amount;\n\t\tuniform float angle;\n\t\tuniform float seed;\n\t\tuniform float seed_x;\n\t\tuniform float seed_y;\n\t\tuniform float distortion_x;\n\t\tuniform float distortion_y;\n\t\tuniform float col_s;\n\n\t\tvarying vec2 vUv;\n\n\t\tfloat rand(vec2 co){\n\t\t\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tif(byp<1) {\n\t\t\t\tvec2 p = vUv;\n\t\t\t\tfloat xs = floor(gl_FragCoord.x / 0.5);\n\t\t\t\tfloat ys = floor(gl_FragCoord.y / 0.5);\n\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\t\t\tvec4 normal = texture2D (tDisp, p*seed*seed);\n\t\t\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\n\t\t\t\t\tif(seed_x>0.){\n\t\t\t\t\t\tp.y = 1. - (p.y + distortion_y);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.y = distortion_y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\n\t\t\t\t\tif(seed_y>0.){\n\t\t\t\t\t\tp.x=distortion_x;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.x = 1. - (p.x + distortion_x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.x+=normal.x*seed_x*(seed/5.);\n\t\t\t\tp.y+=normal.y*seed_y*(seed/5.);\n\t\t//base from RGB shift shader\n\t\t\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));\n\t\t\t\tvec4 cr = texture2D(tDiffuse, p + offset);\n\t\t\t\tvec4 cga = texture2D(tDiffuse, p);\n\t\t\t\tvec4 cb = texture2D(tDiffuse, p - offset);\n\t\t\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\t\t//add noise\n\t\t\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\n\t\t\t\tgl_FragColor = gl_FragColor+ snow;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgl_FragColor=texture2D (tDiffuse, vUv);\n\t\t\t}\n\t\t}\n`\n  )\n};\nexport {\n  DigitalGlitch\n};\n//# sourceMappingURL=DigitalGlitch.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,gBAAgB;IACpB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,iBAAiB;QACjB,OAAO;YAAE,OAAO;QAAK;QACrB,iDAAiD;QACjD,KAAK;YAAE,OAAO;QAAE;QAChB,oBAAoB;QACpB,QAAQ;YAAE,OAAO;QAAK;QACtB,OAAO;YAAE,OAAO;QAAK;QACrB,MAAM;YAAE,OAAO;QAAK;QACpB,QAAQ;YAAE,OAAO;QAAK;QACtB,MAAM;QACN,QAAQ;YAAE,OAAO;QAAK;QACtB,MAAM;QACN,cAAc;YAAE,OAAO;QAAI;QAC3B,cAAc;YAAE,OAAO;QAAI;QAC3B,OAAO;YAAE,OAAO;QAAK;IACvB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;CAOJ,CAAC;IAEA,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0DL,CAAC;AAED;;CAIA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 538, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 544, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/HalftoneShader.js"],"sourcesContent":["const HalftoneShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    shape: { value: 1 },\n    radius: { value: 4 },\n    rotateR: { value: Math.PI / 12 * 1 },\n    rotateG: { value: Math.PI / 12 * 2 },\n    rotateB: { value: Math.PI / 12 * 3 },\n    scatter: { value: 0 },\n    width: { value: 1 },\n    height: { value: 1 },\n    blending: { value: 1 },\n    blendingMode: { value: 1 },\n    greyscale: { value: false },\n    disable: { value: false }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUV;\n\n    void main() {\n\n    \tvUV = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #define SQRT2_MINUS_ONE 0.41421356\n    #define SQRT2_HALF_MINUS_ONE 0.20710678\n    #define PI2 6.28318531\n    #define SHAPE_DOT 1\n    #define SHAPE_ELLIPSE 2\n    #define SHAPE_LINE 3\n    #define SHAPE_SQUARE 4\n    #define BLENDING_LINEAR 1\n    #define BLENDING_MULTIPLY 2\n    #define BLENDING_ADD 3\n    #define BLENDING_LIGHTER 4\n    #define BLENDING_DARKER 5\n    uniform sampler2D tDiffuse;\n    uniform float radius;\n    uniform float rotateR;\n    uniform float rotateG;\n    uniform float rotateB;\n    uniform float scatter;\n    uniform float width;\n    uniform float height;\n    uniform int shape;\n    uniform bool disable;\n    uniform float blending;\n    uniform int blendingMode;\n    varying vec2 vUV;\n    uniform bool greyscale;\n    const int samples = 8;\n\n    float blend( float a, float b, float t ) {\n\n    // linear blend\n    \treturn a * ( 1.0 - t ) + b * t;\n\n    }\n\n    float hypot( float x, float y ) {\n\n    // vector magnitude\n    \treturn sqrt( x * x + y * y );\n\n    }\n\n    float rand( vec2 seed ){\n\n    // get pseudo-random number\n    return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\n    }\n\n    float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\n\n    // apply shape-specific transforms\n    \tfloat dist = hypot( coord.x - p.x, coord.y - p.y );\n    \tfloat rad = channel;\n\n    \tif ( shape == SHAPE_DOT ) {\n\n    \t\trad = pow( abs( rad ), 1.125 ) * rad_max;\n\n    \t} else if ( shape == SHAPE_ELLIPSE ) {\n\n    \t\trad = pow( abs( rad ), 1.125 ) * rad_max;\n\n    \t\tif ( dist != 0.0 ) {\n    \t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\n    \t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\n    \t\t}\n\n    \t} else if ( shape == SHAPE_LINE ) {\n\n    \t\trad = pow( abs( rad ), 1.5) * rad_max;\n    \t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\n    \t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );\n\n    \t} else if ( shape == SHAPE_SQUARE ) {\n\n    \t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\n    \t\tfloat sin_t = abs( sin( theta ) );\n    \t\tfloat cos_t = abs( cos( theta ) );\n    \t\trad = pow( abs( rad ), 1.4 );\n    \t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\n\n    \t}\n\n    \treturn rad - dist;\n\n    }\n\n    struct Cell {\n\n    // grid sample positions\n    \tvec2 normal;\n    \tvec2 p1;\n    \tvec2 p2;\n    \tvec2 p3;\n    \tvec2 p4;\n    \tfloat samp2;\n    \tfloat samp1;\n    \tfloat samp3;\n    \tfloat samp4;\n\n    };\n\n    vec4 getSample( vec2 point ) {\n\n    // multi-sampled point\n    \tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\n    \tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\n    \tfloat step = PI2 / float( samples );\n    \tfloat dist = radius * 0.66;\n\n    \tfor ( int i = 0; i < samples; ++i ) {\n\n    \t\tfloat r = base + step * float( i );\n    \t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\n    \t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\n\n    \t}\n\n    \ttex /= float( samples ) + 1.0;\n    \treturn tex;\n\n    }\n\n    float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\n\n    // get colour for given point\n    \tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\n\n    \tif ( channel == 0 ) {\n\n    \t\tc.samp1 = getSample( c.p1 ).r;\n    \t\tc.samp2 = getSample( c.p2 ).r;\n    \t\tc.samp3 = getSample( c.p3 ).r;\n    \t\tc.samp4 = getSample( c.p4 ).r;\n\n    \t} else if (channel == 1) {\n\n    \t\tc.samp1 = getSample( c.p1 ).g;\n    \t\tc.samp2 = getSample( c.p2 ).g;\n    \t\tc.samp3 = getSample( c.p3 ).g;\n    \t\tc.samp4 = getSample( c.p4 ).g;\n\n    \t} else {\n\n    \t\tc.samp1 = getSample( c.p1 ).b;\n    \t\tc.samp3 = getSample( c.p3 ).b;\n    \t\tc.samp2 = getSample( c.p2 ).b;\n    \t\tc.samp4 = getSample( c.p4 ).b;\n\n    \t}\n\n    \tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\n    \tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\n    \tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\n    \tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\n    \tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\n    \tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\n    \tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\n    \tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\n    \tres = clamp( res, 0.0, 1.0 );\n\n    \treturn res;\n\n    }\n\n    Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\n\n    // get containing cell\n    \tCell c;\n\n    // calc grid\n    \tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\n    \tfloat threshold = step * 0.5;\n    \tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\n    \tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\n    \tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\n    \tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );\n    \tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\n    \tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\n    \tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\n    \tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\n    \tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\n\n    // get closest corner\n    \tc.normal = n;\n    \tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\n    \tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\n\n    // scatter\n    \tif ( scatter != 0.0 ) {\n\n    \t\tfloat off_mag = scatter * threshold * 0.5;\n    \t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\n    \t\tc.p1.x += cos( off_angle ) * off_mag;\n    \t\tc.p1.y += sin( off_angle ) * off_mag;\n\n    \t}\n\n    // find corners\n    \tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\n    \tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\n    \tc.p2.x = c.p1.x - n.x * normal_step;\n    \tc.p2.y = c.p1.y - n.y * normal_step;\n    \tc.p3.x = c.p1.x + n.y * line_step;\n    \tc.p3.y = c.p1.y - n.x * line_step;\n    \tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\n    \tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\n\n    \treturn c;\n\n    }\n\n    float blendColour( float a, float b, float t ) {\n\n    // blend colours\n    \tif ( blendingMode == BLENDING_LINEAR ) {\n    \t\treturn blend( a, b, 1.0 - t );\n    \t} else if ( blendingMode == BLENDING_ADD ) {\n    \t\treturn blend( a, min( 1.0, a + b ), t );\n    \t} else if ( blendingMode == BLENDING_MULTIPLY ) {\n    \t\treturn blend( a, max( 0.0, a * b ), t );\n    \t} else if ( blendingMode == BLENDING_LIGHTER ) {\n    \t\treturn blend( a, max( a, b ), t );\n    \t} else if ( blendingMode == BLENDING_DARKER ) {\n    \t\treturn blend( a, min( a, b ), t );\n    \t} else {\n    \t\treturn blend( a, b, 1.0 - t );\n    \t}\n\n    }\n\n    void main() {\n\n    \tif ( ! disable ) {\n\n    // setup\n    \t\tvec2 p = vec2( vUV.x * width, vUV.y * height );\n    \t\tvec2 origin = vec2( 0, 0 );\n    \t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\n\n    // get channel samples\n    \t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );\n    \t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );\n    \t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );\n    \t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );\n    \t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );\n    \t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );\n\n    // blend with original\n    \t\tvec4 colour = texture2D( tDiffuse, vUV );\n    \t\tr = blendColour( r, colour.r, blending );\n    \t\tg = blendColour( g, colour.g, blending );\n    \t\tb = blendColour( b, colour.b, blending );\n\n    \t\tif ( greyscale ) {\n    \t\t\tr = g = b = (r + b + g) / 3.0;\n    \t\t}\n\n    \t\tgl_FragColor = vec4( r, g, b, 1.0 );\n\n    \t} else {\n\n    \t\tgl_FragColor = texture2D( tDiffuse, vUV );\n\n    \t}\n\n    }\n  `\n  )\n};\nexport {\n  HalftoneShader\n};\n//# sourceMappingURL=HalftoneShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,iBAAiB;IACrB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO;QAAE;QAClB,QAAQ;YAAE,OAAO;QAAE;QACnB,SAAS;YAAE,OAAO,KAAK,EAAE,GAAG,KAAK;QAAE;QACnC,SAAS;YAAE,OAAO,KAAK,EAAE,GAAG,KAAK;QAAE;QACnC,SAAS;YAAE,OAAO,KAAK,EAAE,GAAG,KAAK;QAAE;QACnC,SAAS;YAAE,OAAO;QAAE;QACpB,OAAO;YAAE,OAAO;QAAE;QAClB,QAAQ;YAAE,OAAO;QAAE;QACnB,UAAU;YAAE,OAAO;QAAE;QACrB,cAAc;YAAE,OAAO;QAAE;QACzB,WAAW;YAAE,OAAO;QAAM;QAC1B,SAAS;YAAE,OAAO;QAAM;IAC1B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6QH,CAAC;AAEH;;CAIA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 872, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 878, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/SMAAShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst SMAAEdgesShader = {\n  defines: {\n    SMAA_THRESHOLD: \"0.1\"\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 3 ];\n\n    void SMAAEdgeDetectionVS( vec2 texcoord ) {\n    \tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n    \tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n    \tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n    }\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tSMAAEdgeDetectionVS( vUv );\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 3 ];\n\n    vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n    \tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n    // Calculate color deltas:\n    \tvec4 delta;\n    \tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n    \tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n    \tvec3 t = abs( C - Cleft );\n    \tdelta.x = max( max( t.r, t.g ), t.b );\n\n    \tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n    \tt = abs( C - Ctop );\n    \tdelta.y = max( max( t.r, t.g ), t.b );\n\n    // We do the usual threshold:\n    \tvec2 edges = step( threshold, delta.xy );\n\n    // Then discard if there is no edge:\n    \tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n    \t\tdiscard;\n\n    // Calculate right and bottom deltas:\n    \tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n    \tt = abs( C - Cright );\n    \tdelta.z = max( max( t.r, t.g ), t.b );\n\n    \tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n    \tt = abs( C - Cbottom );\n    \tdelta.w = max( max( t.r, t.g ), t.b );\n\n    // Calculate the maximum delta in the direct neighborhood:\n    \tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n    // Calculate left-left and top-top deltas:\n    \tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n    \tt = abs( C - Cleftleft );\n    \tdelta.z = max( max( t.r, t.g ), t.b );\n\n    \tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n    \tt = abs( C - Ctoptop );\n    \tdelta.w = max( max( t.r, t.g ), t.b );\n\n    // Calculate the final maximum delta:\n    \tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n    // Local contrast adaptation in action:\n    \tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n    \treturn vec4( edges, 0.0, 0.0 );\n    }\n\n    void main() {\n\n    \tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n    }\n  `\n  )\n};\nconst SMAAWeightsShader = {\n  defines: {\n    SMAA_MAX_SEARCH_STEPS: \"8\",\n    SMAA_AREATEX_MAX_DISTANCE: \"16\",\n    SMAA_AREATEX_PIXEL_SIZE: \"( 1.0 / vec2( 160.0, 560.0 ) )\",\n    SMAA_AREATEX_SUBTEX_SIZE: \"( 1.0 / 7.0 )\"\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    tArea: { value: null },\n    tSearch: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 3 ];\n    varying vec2 vPixcoord;\n\n    void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n    \tvPixcoord = texcoord / resolution;\n\n    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n    \tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n    \tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n    // And these for the searches, they indicate the ends of the loops:\n    \tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n    }\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tSMAABlendingWeightCalculationVS( vUv );\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tArea;\n    uniform sampler2D tSearch;\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[3];\n    varying vec2 vPixcoord;\n\n    #if __VERSION__ == 100\n    vec2 round( vec2 x ) {\n    \treturn sign( x ) * floor( abs( x ) + 0.5 );\n    }\n    #endif\n\n    float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n    // Not required if searchTex accesses are set to point:\n    // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n    // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n    //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n    \te.r = bias + e.r * scale;\n    \treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n    }\n\n    float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    /**\n     * @PSEUDO_GATHER4\n     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n     * sample between edge, thus fetching four edges in a row.\n     * Sampling with different offsets in each direction allows to disambiguate\n     * which edges are active from the four fetched ones.\n     */\n    \tvec2 e = vec2( 0.0, 1.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n    \t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n    \t}\n\n    // We correct the previous (-0.25, -0.125) offset we applied:\n    \ttexcoord.x += 0.25 * resolution.x;\n\n    // The searches are bias by 1, so adjust the coords accordingly:\n    \ttexcoord.x += resolution.x;\n\n    // Disambiguate the length added by the last step:\n    \ttexcoord.x += 2.0 * resolution.x; // Undo last step\n    \ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n    \treturn texcoord.x;\n    }\n\n    float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    \tvec2 e = vec2( 0.0, 1.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n    \t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n    \t}\n\n    \ttexcoord.x -= 0.25 * resolution.x;\n    \ttexcoord.x -= resolution.x;\n    \ttexcoord.x -= 2.0 * resolution.x;\n    \ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n    \treturn texcoord.x;\n    }\n\n    float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    \tvec2 e = vec2( 1.0, 0.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n    \t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n    \t}\n\n    \ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n    \treturn texcoord.y;\n    }\n\n    float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n    \tvec2 e = vec2( 1.0, 0.0 );\n\n    \tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n    \t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n    \t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n    \t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n    \t}\n\n    \ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n    \ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n    \treturn texcoord.y;\n    }\n\n    vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n    // Rounding prevents precision errors of bilinear filtering:\n    \tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n    // We do a scale and bias for mapping to texel space:\n    \ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n    // Move to proper place, according to the subpixel offset:\n    \ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n    \treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n    }\n\n    vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n    \tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n    \tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n    \tif ( e.g > 0.0 ) { // Edge at north\n    \t\tvec2 d;\n\n    // Find the distance to the left:\n    \t\tvec2 coords;\n    \t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n    \t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n    \t\td.x = coords.x;\n\n    // Now fetch the left crossing edges, two at a time using bilinear\n    // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n    // discern what value each edge has:\n    \t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n    // Find the distance to the right:\n    \t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n    \t\td.y = coords.x;\n\n    // We want the distances to be in pixel units (doing this here allow to\n    // better interleave arithmetic and memory accesses):\n    \t\td = d / resolution.x - pixcoord.x;\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    \t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n    // Fetch the right crossing edges:\n    \t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n    \t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n    // Ok, we know how this pattern looks like, now it is time for getting\n    // the actual area:\n    \t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n    \t}\n\n    \tif ( e.r > 0.0 ) { // Edge at west\n    \t\tvec2 d;\n\n    // Find the distance to the top:\n    \t\tvec2 coords;\n\n    \t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n    \t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n    \t\td.x = coords.y;\n\n    // Fetch the top crossing edges:\n    \t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n    // Find the distance to the bottom:\n    \t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n    \t\td.y = coords.y;\n\n    // We want the distances to be in pixel units:\n    \t\td = d / resolution.y - pixcoord.y;\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    \t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n    // Fetch the bottom crossing edges:\n    \t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n    \t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n    // Get the area for this direction:\n    \t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n    \t}\n\n    \treturn weights;\n    }\n\n    void main() {\n\n    \tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n    }\n  `\n  )\n};\nconst SMAABlendShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    tColor: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 2 ];\n\n    void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n    \tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n    \tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n    }\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tSMAANeighborhoodBlendingVS( vUv );\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tColor;\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n    varying vec4 vOffset[ 2 ];\n\n    vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n    // Fetch the blending weights for current pixel:\n    \tvec4 a;\n    \ta.xz = texture2D( blendTex, texcoord ).xz;\n    \ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n    \ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n    // Is there any blending weight with a value greater than 0.0?\n    \tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n    \t\treturn texture2D( colorTex, texcoord, 0.0 );\n    \t} else {\n    // Up to 4 lines can be crossing a pixel (one through each edge). We\n    // favor blending by choosing the line with the maximum weight for each\n    // direction:\n    \t\tvec2 offset;\n    \t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n    \t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n    // Then we go in the direction that has the maximum weight:\n    \t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n    \t\t\toffset.y = 0.0;\n    \t\t} else {\n    \t\t\toffset.x = 0.0;\n    \t\t}\n\n    // Fetch the opposite color and lerp by hand:\n    \t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n    \t\ttexcoord += sign( offset ) * resolution;\n    \t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n    \t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n    // WebGL port note: Added gamma correction\n    \t\tC.xyz = pow(C.xyz, vec3(2.2));\n    \t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n    \t\tvec4 mixed = mix(C, Cop, s);\n    \t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n    \t\treturn mixed;\n    \t}\n    }\n\n    void main() {\n\n    \tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n    }\n  `\n  )\n};\nexport {\n  SMAABlendShader,\n  SMAAEdgesShader,\n  SMAAWeightsShader\n};\n//# sourceMappingURL=SMAAShader.js.map\n"],"names":[],"mappings":";;;;;AAAA;;AACA,MAAM,kBAAkB;IACtB,SAAS;QACP,gBAAgB;IAClB;IACA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,IAAI,MAAM,IAAI;QAAK;IACtE;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;EAqBH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+DH,CAAC;AAEH;AACA,MAAM,oBAAoB;IACxB,SAAS;QACP,uBAAuB;QACvB,2BAA2B;QAC3B,yBAAyB;QACzB,0BAA0B;IAC5B;IACA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO;QAAK;QACrB,SAAS;YAAE,OAAO;QAAK;QACvB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,IAAI,MAAM,IAAI;QAAK;IACtE;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwMH,CAAC;AAEH;AACA,MAAM,kBAAkB;IACtB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,IAAI,MAAM,IAAI;QAAK;IACtE;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;EAoBH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsDH,CAAC;AAEH;;CAMA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1333, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/FilmShader.js"],"sourcesContent":["const FilmShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    time: { value: 0 },\n    nIntensity: { value: 0.5 },\n    sIntensity: { value: 0.05 },\n    sCount: { value: 4096 },\n    grayscale: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #include <common>\n\n    // control parameter\n    uniform float time;\n\n    uniform bool grayscale;\n\n    // noise effect intensity value (0 = no effect, 1 = full effect)\n    uniform float nIntensity;\n\n    // scanlines effect intensity value (0 = no effect, 1 = full effect)\n    uniform float sIntensity;\n\n    // scanlines effect count value (0 = no effect, 4096 = full effect)\n    uniform float sCount;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    // sample the source\n    \tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\n\n    // make some noise\n    \tfloat dx = rand( vUv + time );\n\n    // add noise\n    \tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\n\n    // get us a sine and cosine\n    \tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\n\n    // add scanlines\n    \tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\n\n    // interpolate between source and result by intensity\n    \tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\n\n    // convert to grayscale if desired\n    \tif( grayscale ) {\n\n    \t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n\n    \t}\n\n    \tgl_FragColor =  vec4( cResult, cTextureScreen.a );\n\n    }\n  `\n  )\n};\nexport {\n  FilmShader\n};\n//# sourceMappingURL=FilmShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,aAAa;IACjB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,MAAM;YAAE,OAAO;QAAE;QACjB,YAAY;YAAE,OAAO;QAAI;QACzB,YAAY;YAAE,OAAO;QAAK;QAC1B,QAAQ;YAAE,OAAO;QAAK;QACtB,WAAW;YAAE,OAAO;QAAE;IACxB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmDH,CAAC;AAEH;;CAIA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1422, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1428, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/CopyShader.js"],"sourcesContent":["const CopyShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float opacity;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n    \tgl_FragColor = opacity * texel;\n\n    }\n  `\n  )\n};\nexport {\n  CopyShader\n};\n//# sourceMappingURL=CopyShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,aAAa;IACjB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAE;IACtB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;EAaH,CAAC;AAEH;;CAIA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1467, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1473, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/SSAOShader.js"],"sourcesContent":["import { Vector2, Matrix4 } from \"three\";\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tDepth: { value: null },\n    tNoise: { value: null },\n    kernel: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    kernelRadius: { value: 8 },\n    minDistance: { value: 5e-3 },\n    maxDistance: { value: 0.05 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tNormal;\n    uniform sampler2D tDepth;\n    uniform sampler2D tNoise;\n\n    uniform vec3 kernel[ KERNEL_SIZE ];\n\n    uniform vec2 resolution;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform mat4 cameraProjectionMatrix;\n    uniform mat4 cameraInverseProjectionMatrix;\n\n    uniform float kernelRadius;\n    uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n    uniform float maxDistance; // avoid the influence of fragments which are too far away\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getDepth( const in vec2 screenPosition ) {\n\n    \treturn texture2D( tDepth, screenPosition ).x;\n\n    }\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    float getViewZ( const in float depth ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n    \t#endif\n\n    }\n\n    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n    \tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n    \tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n    \tclipPosition *= clipW; // unprojection.\n\n    \treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n    }\n\n    vec3 getViewNormal( const in vec2 screenPosition ) {\n\n    \treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n    }\n\n    void main() {\n\n    \tfloat depth = getDepth( vUv );\n    \tfloat viewZ = getViewZ( depth );\n\n    \tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n    \tvec3 viewNormal = getViewNormal( vUv );\n\n     vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n    \tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\n\n    // compute matrix used to reorient a kernel vector\n\n    \tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n    \tvec3 bitangent = cross( viewNormal, tangent );\n    \tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n     float occlusion = 0.0;\n\n     for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n    \t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n    \t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n    \t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n    \t\tsamplePointNDC /= samplePointNDC.w;\n\n    \t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n    \t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n    \t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n    \t\tfloat delta = sampleDepth - realDepth;\n\n    \t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n    \t\t\tocclusion += 1.0;\n\n    \t\t}\n\n    \t}\n\n    \tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n    \tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n    }\n  `\n  )\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n    float getLinearDepth( const in vec2 screenPosition ) {\n\n    \t#if PERSPECTIVE_CAMERA == 1\n\n    \t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n    \t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n    \t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n    \t#else\n\n    \t\treturn texture2D( tDepth, screenPosition ).x;\n\n    \t#endif\n\n    }\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n    \tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n    }\n  `\n  )\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n\n    uniform vec2 resolution;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n    \tfloat result = 0.0;\n\n    \tfor ( int i = - 2; i <= 2; i ++ ) {\n\n    \t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n    \t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n    \t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n    }\n  `\n  )\n};\nexport {\n  SSAOBlurShader,\n  SSAODepthShader,\n  SSAOShader\n};\n//# sourceMappingURL=SSAOShader.js.map\n"],"names":[],"mappings":";;;;;AAAA;;AACA,MAAM,aAAa;IACjB,SAAS;QACP,oBAAoB;QACpB,aAAa;IACf;IACA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAK;QACvB,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAK;QACzB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;QACnD,wBAAwB;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;QAC/D,+BAA+B;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;QACtE,cAAc;YAAE,OAAO;QAAE;QACzB,aAAa;YAAE,OAAO;QAAK;QAC3B,aAAa;YAAE,OAAO;QAAK;IAC7B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2HH,CAAC;AAEH;AACA,MAAM,kBAAkB;IACtB,SAAS;QACP,oBAAoB;IACtB;IACA,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAK;IAC3B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgCH,CAAC;AAEH;AACA,MAAM,iBAAiB;IACrB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;IACrD;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BH,CAAC;AAEH;;CAMA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1770, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1776, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/BokehShader.js"],"sourcesContent":["const BokehShader = {\n  defines: {\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tColor: { value: null },\n    tDepth: { value: null },\n    focus: { value: 1 },\n    aspect: { value: 1 },\n    aperture: { value: 0.025 },\n    maxblur: { value: 0.01 },\n    nearClip: { value: 1 },\n    farClip: { value: 1e3 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #include <common>\n\n    varying vec2 vUv;\n\n    uniform sampler2D tColor;\n    uniform sampler2D tDepth;\n\n    uniform float maxblur; // max blur amount\n    uniform float aperture; // aperture - bigger values for shallower depth of field\n\n    uniform float nearClip;\n    uniform float farClip;\n\n    uniform float focus;\n    uniform float aspect;\n\n    #include <packing>\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n    \t#endif\n    }\n\n    void main() {\n\n    \tvec2 aspectcorrect = vec2( 1.0, aspect );\n\n    \tfloat viewZ = getViewZ( getDepth( vUv ) );\n\n    \tfloat factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation\n\n    \tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\n\n    \tvec2 dofblur9 = dofblur * 0.9;\n    \tvec2 dofblur7 = dofblur * 0.7;\n    \tvec2 dofblur4 = dofblur * 0.4;\n\n    \tvec4 col = vec4( 0.0 );\n\n    \tcol += texture2D( tColor, vUv.xy );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\n\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n    \tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\n\n    \tgl_FragColor = col / 41.0;\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `\n  )\n};\nexport {\n  BokehShader\n};\n//# sourceMappingURL=BokehShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,cAAc;IAClB,SAAS;QACP,eAAe;QACf,oBAAoB;IACtB;IACA,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,OAAO;YAAE,OAAO;QAAE;QAClB,QAAQ;YAAE,OAAO;QAAE;QACnB,UAAU;YAAE,OAAO;QAAM;QACzB,SAAS;YAAE,OAAO;QAAK;QACvB,UAAU;YAAE,OAAO;QAAE;QACrB,SAAS;YAAE,OAAO;QAAI;IACxB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAoGH,CAAC;AAEH;;CAIA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 1924, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1930, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/LuminosityShader.js"],"sourcesContent":["const LuminosityShader = {\n  uniforms: {\n    tDiffuse: { value: null }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #include <common>\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n\n    \tfloat l = linearToRelativeLuminance( texel.rgb );\n\n    \tgl_FragColor = vec4( l, l, l, texel.w );\n\n    }\n  `\n  )\n};\nexport {\n  LuminosityShader\n};\n//# sourceMappingURL=LuminosityShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,mBAAmB;IACvB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;IAC1B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;EAgBH,CAAC;AAEH;;CAIA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 1970, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1976, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/SAOShader.js"],"sourcesContent":["import { Vector2, Matrix4 } from \"three\";\nconst SAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: { value: null },\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    size: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    cameraNear: { value: 1 },\n    cameraFar: { value: 100 },\n    cameraProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    cameraInverseProjectionMatrix: { value: /* @__PURE__ */ new Matrix4() },\n    scale: { value: 1 },\n    intensity: { value: 0.1 },\n    bias: { value: 0.5 },\n    minResolution: { value: 0 },\n    kernelRadius: { value: 100 },\n    randomSeed: { value: 0 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #include <common>\n\n    varying vec2 vUv;\n\n    #if DIFFUSE_TEXTURE == 1\n    uniform sampler2D tDiffuse;\n    #endif\n\n    uniform sampler2D tDepth;\n\n    #if NORMAL_TEXTURE == 1\n    uniform sampler2D tNormal;\n    #endif\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform mat4 cameraProjectionMatrix;\n    uniform mat4 cameraInverseProjectionMatrix;\n\n    uniform float scale;\n    uniform float intensity;\n    uniform float bias;\n    uniform float kernelRadius;\n    uniform float minResolution;\n    uniform vec2 size;\n    uniform float randomSeed;\n\n    // RGBA depth\n\n    #include <packing>\n\n    vec4 getDefaultColor( const in vec2 screenPosition ) {\n    \t#if DIFFUSE_TEXTURE == 1\n    \treturn texture2D( tDiffuse, vUv );\n    \t#else\n    \treturn vec4( 1.0 );\n    \t#endif\n    }\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#endif\n    }\n\n    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n    \tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n    \tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n    \tclipPosition *= clipW; // unprojection.\n\n    \treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n    }\n\n    vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n    \t#if NORMAL_TEXTURE == 1\n    \treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n    \t#else\n    \treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n    \t#endif\n    }\n\n    float scaleDividedByCameraFar;\n    float minResolutionMultipliedByCameraFar;\n\n    float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n    \tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n    \tfloat viewDistance = length( viewDelta );\n    \tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\n    \treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n    }\n\n    // moving costly divides into consts\n    const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n    const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n    float getAmbientOcclusion( const in vec3 centerViewPosition ) {\n    \t// precompute some variables require in getOcclusion.\n    \tscaleDividedByCameraFar = scale / cameraFar;\n    \tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n    \tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\n    \t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n    \tfloat angle = rand( vUv + randomSeed ) * PI2;\n    \tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n    \tvec2 radiusStep = radius;\n\n    \tfloat occlusionSum = 0.0;\n    \tfloat weightSum = 0.0;\n\n    \tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n    \t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n    \t\tradius += radiusStep;\n    \t\tangle += ANGLE_STEP;\n\n    \t\tfloat sampleDepth = getDepth( sampleUv );\n    \t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n    \t\t\tcontinue;\n    \t\t}\n\n    \t\tfloat sampleViewZ = getViewZ( sampleDepth );\n    \t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n    \t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n    \t\tweightSum += 1.0;\n    \t}\n\n    \tif( weightSum == 0.0 ) discard;\n\n    \treturn occlusionSum * ( intensity / weightSum );\n    }\n\n    void main() {\n    \tfloat centerDepth = getDepth( vUv );\n    \tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n    \t\tdiscard;\n    \t}\n\n    \tfloat centerViewZ = getViewZ( centerDepth );\n    \tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\n    \tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\n    \tgl_FragColor = getDefaultColor( vUv );\n    \tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n    }\n  `\n  )\n};\nexport {\n  SAOShader\n};\n//# sourceMappingURL=SAOShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,YAAY;IAChB,SAAS;QACP,aAAa;QACb,WAAW;QACX,gBAAgB;QAChB,iBAAiB;QACjB,eAAe;QACf,oBAAoB;IACtB;IACA,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAK;QACvB,MAAM;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,KAAK;QAAK;QACrD,YAAY;YAAE,OAAO;QAAE;QACvB,WAAW;YAAE,OAAO;QAAI;QACxB,wBAAwB;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;QAC/D,+BAA+B;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;QACtE,OAAO;YAAE,OAAO;QAAE;QAClB,WAAW;YAAE,OAAO;QAAI;QACxB,MAAM;YAAE,OAAO;QAAI;QACnB,eAAe;YAAE,OAAO;QAAE;QAC1B,cAAc;YAAE,OAAO;QAAI;QAC3B,YAAY;YAAE,OAAO;QAAE;IACzB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;EAOH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwIH,CAAC;AAEH;;CAIA,qCAAqC","ignoreList":[0]}},
    {"offset": {"line": 2182, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2188, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    sampleUvOffsets: { value: [/* @__PURE__ */ new Vector2(0, 0)] },\n    sampleWeights: { value: [1] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1e3 },\n    depthCutoff: { value: 10 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    #include <common>\n\n    uniform vec2 size;\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    void main() {\n    \tvUv = uv;\n    \tvInvSize = 1.0 / size;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #include <common>\n    #include <packing>\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform float depthCutoff;\n\n    uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n    uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#endif\n    }\n\n    void main() {\n    \tfloat depth = getDepth( vUv );\n    \tif( depth >= ( 1.0 - EPSILON ) ) {\n    \t\tdiscard;\n    \t}\n\n    \tfloat centerViewZ = -getViewZ( depth );\n    \tbool rBreak = false, lBreak = false;\n\n    \tfloat weightSum = sampleWeights[0];\n    \tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n    \tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n    \t\tfloat sampleWeight = sampleWeights[i];\n    \t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n    \t\tvec2 sampleUv = vUv + sampleUvOffset;\n    \t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n    \t\tif( ! rBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t\tsampleUv = vUv - sampleUvOffset;\n    \t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n    \t\tif( ! lBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = diffuseSum / weightSum;\n    }\n  `\n  )\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport {\n  BlurShaderUtils,\n  DepthLimitedBlurShader\n};\n//# sourceMappingURL=DepthLimitedBlurShader.js.map\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,yBAAyB;IAC7B,SAAS;QACP,eAAe;QACf,eAAe;QACf,oBAAoB;IACtB;IACA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,MAAM;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,KAAK;QAAK;QACrD,iBAAiB;YAAE,OAAO;gBAAC,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,GAAG;aAAG;QAAC;QAC9D,eAAe;YAAE,OAAO;gBAAC;aAAE;QAAC;QAC5B,QAAQ;YAAE,OAAO;QAAK;QACtB,YAAY;YAAE,OAAO;QAAG;QACxB,WAAW;YAAE,OAAO;QAAI;QACxB,aAAa;YAAE,OAAO;QAAG;IAC3B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;EAcH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0EH,CAAC;AAEH;AACA,MAAM,kBAAkB;IACtB,qBAAqB,CAAC,cAAc;QAClC,MAAM,WAAW,CAAC,GAAG;YACnB,OAAO,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,OAAO,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE,IAAI,OAAO;QAC3F;QACA,MAAM,UAAU,EAAE;QAClB,IAAK,IAAI,IAAI,GAAG,KAAK,cAAc,IAAK;YACtC,QAAQ,IAAI,CAAC,SAAS,GAAG;QAC3B;QACA,OAAO;IACT;IACA,qBAAqB,CAAC,cAAc;QAClC,MAAM,UAAU,EAAE;QAClB,IAAK,IAAI,IAAI,GAAG,KAAK,cAAc,IAAK;YACtC,QAAQ,IAAI,CAAC,YAAY,KAAK,GAAG,cAAc,CAAC;QAClD;QACA,OAAO;IACT;IACA,WAAW,CAAC,QAAQ,cAAc,QAAQ;QACxC,OAAO,OAAO,CAAC,gBAAgB,GAAG;QAClC,OAAO,QAAQ,CAAC,kBAAkB,CAAC,KAAK,GAAG,gBAAgB,mBAAmB,CAAC,cAAc;QAC7F,OAAO,QAAQ,CAAC,gBAAgB,CAAC,KAAK,GAAG,gBAAgB,mBAAmB,CAAC,cAAc;QAC3F,OAAO,WAAW,GAAG;IACvB;AACF;;CAKA,kDAAkD","ignoreList":[0]}},
    {"offset": {"line": 2348, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2354, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/AfterimageShader.js"],"sourcesContent":["const AfterimageShader = {\n  uniforms: {\n    damp: { value: 0.96 },\n    tOld: { value: null },\n    tNew: { value: null }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float damp;\n\n    uniform sampler2D tOld;\n    uniform sampler2D tNew;\n\n    varying vec2 vUv;\n\n    vec4 when_gt( vec4 x, float y ) {\n\n    \treturn max( sign( x - y ), 0.0 );\n\n    }\n\n    void main() {\n\n    \tvec4 texelOld = texture2D( tOld, vUv );\n    \tvec4 texelNew = texture2D( tNew, vUv );\n\n    \ttexelOld *= damp * when_gt( texelOld, 0.1 );\n\n    \tgl_FragColor = max(texelNew, texelOld);\n\n    }\n  `\n  )\n};\nexport {\n  AfterimageShader\n};\n//# sourceMappingURL=AfterimageShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,mBAAmB;IACvB,UAAU;QACR,MAAM;YAAE,OAAO;QAAK;QACpB,MAAM;YAAE,OAAO;QAAK;QACpB,MAAM;YAAE,OAAO;QAAK;IACtB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;EAwBH,CAAC;AAEH;;CAIA,4CAA4C","ignoreList":[0]}},
    {"offset": {"line": 2407, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2413, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/DotScreenShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst DotScreenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    tSize: { value: /* @__PURE__ */ new Vector2(256, 256) },\n    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },\n    angle: { value: 1.57 },\n    scale: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform vec2 center;\n    uniform float angle;\n    uniform float scale;\n    uniform vec2 tSize;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    float pattern() {\n\n    \tfloat s = sin( angle ), c = cos( angle );\n\n    \tvec2 tex = vUv * tSize - center;\n    \tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\n\n    \treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n\n    }\n\n    void main() {\n\n    \tvec4 color = texture2D( tDiffuse, vUv );\n\n    \tfloat average = ( color.r + color.g + color.b ) / 3.0;\n\n    \tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n\n    }\n  `\n  )\n};\nexport {\n  DotScreenShader\n};\n//# sourceMappingURL=DotScreenShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,kBAAkB;IACtB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,KAAK;QAAK;QACtD,QAAQ;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,KAAK;QAAK;QACvD,OAAO;YAAE,OAAO;QAAK;QACrB,OAAO;YAAE,OAAO;QAAE;IACpB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8BH,CAAC;AAEH;;CAIA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 2480, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2486, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/ConvolutionShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: \"25.0\",\n    KERNEL_SIZE_INT: \"25\"\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    uImageIncrement: { value: /* @__PURE__ */ new Vector2(1953125e-9, 0) },\n    cKernel: { value: [] }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    uniform vec2 uImageIncrement;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float cKernel[ KERNEL_SIZE_INT ];\n\n    uniform sampler2D tDiffuse;\n    uniform vec2 uImageIncrement;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 imageCoord = vUv;\n    \tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n    \tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n    \t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n    \t\timageCoord += uImageIncrement;\n\n    \t}\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n  ),\n  buildKernel: function(sigma) {\n    function gauss(x, sigma2) {\n      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));\n    }\n    const kMaxKernelSize = 25;\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0;\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    }\n    for (let i = 0; i < kernelSize; ++i)\n      values[i] /= sum;\n    return values;\n  }\n};\nexport {\n  ConvolutionShader\n};\n//# sourceMappingURL=ConvolutionShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,oBAAoB;IACxB,SAAS;QACP,mBAAmB;QACnB,iBAAiB;IACnB;IACA,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,iBAAiB;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,YAAY;QAAG;QACrE,SAAS;YAAE,OAAO,EAAE;QAAC;IACvB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;EAWH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;EAuBH,CAAC;IAED,aAAa,SAAS,KAAK;QACzB,SAAS,MAAM,CAAC,EAAE,MAAM;YACtB,OAAO,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,SAAS,MAAM;QACjD;QACA,MAAM,iBAAiB;QACvB,MAAM,aAAa,KAAK,GAAG,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,KAAK,GAAG;QAC1D,MAAM,YAAY,CAAC,aAAa,CAAC,IAAI;QACrC,MAAM,SAAS,IAAI,MAAM;QACzB,IAAI,MAAM;QACV,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,EAAE,EAAG;YACnC,MAAM,CAAC,EAAE,GAAG,MAAM,IAAI,WAAW;YACjC,OAAO,MAAM,CAAC,EAAE;QAClB;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,EAAE,EAChC,MAAM,CAAC,EAAE,IAAI;QACf,OAAO;IACT;AACF;;CAIA,6CAA6C","ignoreList":[0]}},
    {"offset": {"line": 2562, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2568, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js"],"sourcesContent":["const ACESFilmicToneMappingShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    exposure: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #define saturate(a) clamp( a, 0.0, 1.0 )\n\n    uniform sampler2D tDiffuse;\n\n    uniform float exposure;\n\n    varying vec2 vUv;\n\n    vec3 RRTAndODTFit( vec3 v ) {\n\n    \tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n    \tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n    \treturn a / b;\n\n    }\n\n    vec3 ACESFilmicToneMapping( vec3 color ) {\n\n      // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n    \tconst mat3 ACESInputMat = mat3(\n    \t\tvec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n    \t\tvec3( 0.35458, 0.90834, 0.13383 ),\n    \t\tvec3( 0.04823, 0.01566, 0.83777 )\n    \t);\n\n      // ODT_SAT => XYZ => D60_2_D65 => sRGB\n    \tconst mat3 ACESOutputMat = mat3(\n    \t\tvec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n    \t\tvec3( -0.53108,  1.10813, -0.07276 ),\n    \t\tvec3( -0.07367, -0.00605,  1.07602 )\n    \t);\n\n    \tcolor = ACESInputMat * color;\n\n      // Apply RRT and ODT\n    \tcolor = RRTAndODTFit( color );\n\n    \tcolor = ACESOutputMat * color;\n\n      // Clamp to [0, 1]\n    \treturn saturate( color );\n\n    }\n\n    void main() {\n\n    \tvec4 tex = texture2D( tDiffuse, vUv );\n\n    \ttex.rgb *= exposure / 0.6; // pre-exposed, outside of the tone mapping function\n\n    \tgl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );\n\n    }\n  `\n  )\n};\nexport {\n  ACESFilmicToneMappingShader\n};\n//# sourceMappingURL=ACESFilmicToneMappingShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,8BAA8B;IAClC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,UAAU;YAAE,OAAO;QAAE;IACvB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsDH,CAAC;AAEH;;CAIA,uDAAuD","ignoreList":[0]}},
    {"offset": {"line": 2648, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2654, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/BasicShader.js"],"sourcesContent":["const BasicShader = {\n  uniforms: {},\n  vertexShader: (\n    /* glsl */\n    `\n    void main() {\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    void main() {\n\n      gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\n\n    }\n  `\n  )\n};\nexport {\n  BasicShader\n};\n//# sourceMappingURL=BasicShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,cAAc;IAClB,UAAU,CAAC;IACX,cACE,QAAQ,GACR,CAAC;;;;;;EAMH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;EAMH,CAAC;AAEH;;CAIA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 2676, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2682, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/BleachBypassShader.js"],"sourcesContent":["const BleachBypassShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float opacity;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 base = texture2D( tDiffuse, vUv );\n\n    \tvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\n    \tfloat lum = dot( lumCoeff, base.rgb );\n    \tvec3 blend = vec3( lum );\n\n    \tfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\n\n    \tvec3 result1 = 2.0 * base.rgb * blend;\n    \tvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\n\n    \tvec3 newColor = mix( result1, result2, L );\n\n    \tfloat A2 = opacity * base.a;\n    \tvec3 mixRGB = A2 * newColor.rgb;\n    \tmixRGB += ( ( 1.0 - A2 ) * base.rgb );\n\n    \tgl_FragColor = vec4( mixRGB, base.a );\n\n    }\n  `\n  )\n};\nexport {\n  BleachBypassShader\n};\n//# sourceMappingURL=BleachBypassShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,qBAAqB;IACzB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,SAAS;YAAE,OAAO;QAAE;IACtB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6BH,CAAC;AAEH;;CAIA,8CAA8C","ignoreList":[0]}},
    {"offset": {"line": 2737, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2743, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/BlendShader.js"],"sourcesContent":["const BlendShader = {\n  uniforms: {\n    tDiffuse1: { value: null },\n    tDiffuse2: { value: null },\n    mixRatio: { value: 0.5 },\n    opacity: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float opacity;\n    uniform float mixRatio;\n\n    uniform sampler2D tDiffuse1;\n    uniform sampler2D tDiffuse2;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel1 = texture2D( tDiffuse1, vUv );\n    \tvec4 texel2 = texture2D( tDiffuse2, vUv );\n    \tgl_FragColor = opacity * mix( texel1, texel2, mixRatio );\n\n    }\n  `\n  )\n};\nexport {\n  BlendShader\n};\n//# sourceMappingURL=BlendShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,cAAc;IAClB,UAAU;QACR,WAAW;YAAE,OAAO;QAAK;QACzB,WAAW;YAAE,OAAO;QAAK;QACzB,UAAU;YAAE,OAAO;QAAI;QACvB,SAAS;YAAE,OAAO;QAAE;IACtB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;EAgBH,CAAC;AAEH;;CAIA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 2791, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2797, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/BrightnessContrastShader.js"],"sourcesContent":["const BrightnessContrastShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    brightness: { value: 0 },\n    contrast: { value: 0 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float brightness;\n    uniform float contrast;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tgl_FragColor = texture2D( tDiffuse, vUv );\n\n    \tgl_FragColor.rgb += brightness;\n\n    \tif (contrast > 0.0) {\n    \t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\n    \t} else {\n    \t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\n    \t}\n\n    }\n  `\n  )\n};\nexport {\n  BrightnessContrastShader\n};\n//# sourceMappingURL=BrightnessContrastShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,2BAA2B;IAC/B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO;QAAE;QACvB,UAAU;YAAE,OAAO;QAAE;IACvB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;EAoBH,CAAC;AAEH;;CAIA,oDAAoD","ignoreList":[0]}},
    {"offset": {"line": 2847, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2853, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/ColorCorrectionShader.js"],"sourcesContent":["import { Vector3 } from \"three\";\nconst ColorCorrectionShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    powRGB: { value: /* @__PURE__ */ new Vector3(2, 2, 2) },\n    mulRGB: { value: /* @__PURE__ */ new Vector3(1, 1, 1) },\n    addRGB: { value: /* @__PURE__ */ new Vector3(0, 0, 0) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform vec3 powRGB;\n    uniform vec3 mulRGB;\n    uniform vec3 addRGB;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tgl_FragColor = texture2D( tDiffuse, vUv );\n    \tgl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );\n\n    }\n  `\n  )\n};\nexport {\n  ColorCorrectionShader\n};\n//# sourceMappingURL=ColorCorrectionShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,wBAAwB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,GAAG,GAAG;QAAG;QACtD,QAAQ;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,GAAG,GAAG;QAAG;QACtD,QAAQ;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,GAAG,GAAG;QAAG;IACxD;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;EAcH,CAAC;AAEH;;CAIA,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 2902, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2908, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/ColorifyShader.js"],"sourcesContent":["import { Color } from \"three\";\nconst ColorifyShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    color: { value: /* @__PURE__ */ new Color(16777215) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform vec3 color;\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n\n    \tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n    \tfloat v = dot( texel.xyz, luma );\n\n    \tgl_FragColor = vec4( v * color, texel.w );\n\n    }\n  `\n  )\n};\nexport {\n  ColorifyShader\n};\n//# sourceMappingURL=ColorifyShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,iBAAiB;IACrB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,QAAK,CAAC;QAAU;IACtD;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;EAgBH,CAAC;AAEH;;CAIA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 2952, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2958, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/DOFMipMapShader.js"],"sourcesContent":["const DOFMipMapShader = {\n  uniforms: {\n    tColor: { value: null },\n    tDepth: { value: null },\n    focus: { value: 1 },\n    maxblur: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float focus;\n    uniform float maxblur;\n\n    uniform sampler2D tColor;\n    uniform sampler2D tDepth;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 depth = texture2D( tDepth, vUv );\n\n    \tfloat factor = depth.x - focus;\n\n    \tvec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\n\n    \tgl_FragColor = col;\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `\n  )\n};\nexport {\n  DOFMipMapShader\n};\n//# sourceMappingURL=DOFMipMapShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,kBAAkB;IACtB,UAAU;QACR,QAAQ;YAAE,OAAO;QAAK;QACtB,QAAQ;YAAE,OAAO;QAAK;QACtB,OAAO;YAAE,OAAO;QAAE;QAClB,SAAS;YAAE,OAAO;QAAE;IACtB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;EAqBH,CAAC;AAEH;;CAIA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 3011, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3017, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/FXAAShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst FXAAShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(1 / 1024, 1 / 512) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    precision highp float;\n    \n    uniform sampler2D tDiffuse;\n    \n    uniform vec2 resolution;\n    \n    varying vec2 vUv;\n    \n    // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n    \n    //----------------------------------------------------------------------------------\n    // File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n    // SDK Version: v3.00\n    // Email:       gameworks@nvidia.com\n    // Site:        http://developer.nvidia.com/\n    //\n    // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n    //\n    // Redistribution and use in source and binary forms, with or without\n    // modification, are permitted provided that the following conditions\n    // are met:\n    //  * Redistributions of source code must retain the above copyright\n    //    notice, this list of conditions and the following disclaimer.\n    //  * Redistributions in binary form must reproduce the above copyright\n    //    notice, this list of conditions and the following disclaimer in the\n    //    documentation and/or other materials provided with the distribution.\n    //  * Neither the name of NVIDIA CORPORATION nor the names of its\n    //    contributors may be used to endorse or promote products derived\n    //    from this software without specific prior written permission.\n    //\n    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AS IS AND ANY\n    // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n    // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n    // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n    // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    //\n    //----------------------------------------------------------------------------------\n    \n    #define FXAA_PC 1\n    #define FXAA_GLSL_100 1\n    #define FXAA_QUALITY_PRESET 12\n    \n    #define FXAA_GREEN_AS_LUMA 1\n    \n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_PC_CONSOLE\n        //\n        // The console algorithm for PC is included\n        // for developers targeting really low spec machines.\n        // Likely better to just run FXAA_PC, and use a really low preset.\n        //\n        #define FXAA_PC_CONSOLE 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GLSL_120\n        #define FXAA_GLSL_120 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GLSL_130\n        #define FXAA_GLSL_130 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_3\n        #define FXAA_HLSL_3 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_4\n        #define FXAA_HLSL_4 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_HLSL_5\n        #define FXAA_HLSL_5 0\n    #endif\n    /*==========================================================================*/\n    #ifndef FXAA_GREEN_AS_LUMA\n        //\n        // For those using non-linear color,\n        // and either not able to get luma in alpha, or not wanting to,\n        // this enables FXAA to run using green as a proxy for luma.\n        // So with this enabled, no need to pack luma in alpha.\n        //\n        // This will turn off AA on anything which lacks some amount of green.\n        // Pure red and blue or combination of only R and B, will get no AA.\n        //\n        // Might want to lower the settings for both,\n        //    fxaaConsoleEdgeThresholdMin\n        //    fxaaQualityEdgeThresholdMin\n        // In order to insure AA does not get turned off on colors\n        // which contain a minor amount of green.\n        //\n        // 1 = On.\n        // 0 = Off.\n        //\n        #define FXAA_GREEN_AS_LUMA 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_EARLY_EXIT\n        //\n        // Controls algorithms early exit path.\n        // On PS3 turning this ON adds 2 cycles to the shader.\n        // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n        // Turning this off on console will result in a more blurry image.\n        // So this defaults to on.\n        //\n        // 1 = On.\n        // 0 = Off.\n        //\n        #define FXAA_EARLY_EXIT 1\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_DISCARD\n        //\n        // Only valid for PC OpenGL currently.\n        // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n        //\n        // 1 = Use discard on pixels which dont need AA.\n        //     For APIs which enable concurrent TEX+ROP from same surface.\n        // 0 = Return unchanged color on pixels which dont need AA.\n        //\n        #define FXAA_DISCARD 0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        //\n        // Used for GLSL 120 only.\n        //\n        // 1 = GL API supports fast pixel offsets\n        // 0 = do not use fast pixel offsets\n        //\n        #ifdef GL_EXT_gpu_shader4\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n            #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifndef FXAA_FAST_PIXEL_OFFSET\n            #define FXAA_FAST_PIXEL_OFFSET 0\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #ifndef FXAA_GATHER4_ALPHA\n        //\n        // 1 = API supports gather4 on alpha channel.\n        // 0 = API does not support gather4 on alpha channel.\n        //\n        #if (FXAA_HLSL_5 == 1)\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n            #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifndef FXAA_GATHER4_ALPHA\n            #define FXAA_GATHER4_ALPHA 0\n        #endif\n    #endif\n    \n    \n    /*============================================================================\n                            FXAA QUALITY - TUNING KNOBS\n    ------------------------------------------------------------------------------\n    NOTE the other tuning knobs are now in the shader function inputs!\n    ============================================================================*/\n    #ifndef FXAA_QUALITY_PRESET\n        //\n        // Choose the quality preset.\n        // This needs to be compiled into the shader as it effects code.\n        // Best option to include multiple presets is to\n        // in each shader define the preset, then include this file.\n        //\n        // OPTIONS\n        // -----------------------------------------------------------------------\n        // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n        // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n        // 39       - no dither, very expensive\n        //\n        // NOTES\n        // -----------------------------------------------------------------------\n        // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n        // 13 = about same speed as FXAA 3.9 and better than 12\n        // 23 = closest to FXAA 3.9 visually and performance wise\n        //  _ = the lowest digit is directly related to performance\n        // _  = the highest digit is directly related to style\n        //\n        #define FXAA_QUALITY_PRESET 12\n    #endif\n    \n    \n    /*============================================================================\n    \n                               FXAA QUALITY - PRESETS\n    \n    ============================================================================*/\n    \n    /*============================================================================\n                         FXAA QUALITY - MEDIUM DITHER PRESETS\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 10)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 3.0\n        #define FXAA_QUALITY_P2 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 11)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 3.0\n        #define FXAA_QUALITY_P3 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 12)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 4.0\n        #define FXAA_QUALITY_P4 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 13)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 4.0\n        #define FXAA_QUALITY_P5 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 14)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 4.0\n        #define FXAA_QUALITY_P6 12.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 15)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 12.0\n    #endif\n    \n    /*============================================================================\n                         FXAA QUALITY - LOW DITHER PRESETS\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 20)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 2.0\n        #define FXAA_QUALITY_P2 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 21)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 22)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 23)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 24)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 3.0\n        #define FXAA_QUALITY_P6 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 25)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 26)\n        #define FXAA_QUALITY_PS 9\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 4.0\n        #define FXAA_QUALITY_P8 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 27)\n        #define FXAA_QUALITY_PS 10\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 4.0\n        #define FXAA_QUALITY_P9 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 28)\n        #define FXAA_QUALITY_PS 11\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 4.0\n        #define FXAA_QUALITY_P10 8.0\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PRESET == 29)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n    #endif\n    \n    /*============================================================================\n                         FXAA QUALITY - EXTREME QUALITY\n    ============================================================================*/\n    #if (FXAA_QUALITY_PRESET == 39)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.0\n        #define FXAA_QUALITY_P2 1.0\n        #define FXAA_QUALITY_P3 1.0\n        #define FXAA_QUALITY_P4 1.0\n        #define FXAA_QUALITY_P5 1.5\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n    #endif\n    \n    \n    \n    /*============================================================================\n    \n                                    API PORTING\n    \n    ============================================================================*/\n    #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n        #define FxaaBool bool\n        #define FxaaDiscard discard\n        #define FxaaFloat float\n        #define FxaaFloat2 vec2\n        #define FxaaFloat3 vec3\n        #define FxaaFloat4 vec4\n        #define FxaaHalf float\n        #define FxaaHalf2 vec2\n        #define FxaaHalf3 vec3\n        #define FxaaHalf4 vec4\n        #define FxaaInt2 ivec2\n        #define FxaaSat(x) clamp(x, 0.0, 1.0)\n        #define FxaaTex sampler2D\n    #else\n        #define FxaaBool bool\n        #define FxaaDiscard clip(-1)\n        #define FxaaFloat float\n        #define FxaaFloat2 float2\n        #define FxaaFloat3 float3\n        #define FxaaFloat4 float4\n        #define FxaaHalf half\n        #define FxaaHalf2 half2\n        #define FxaaHalf3 half3\n        #define FxaaHalf4 half4\n        #define FxaaSat(x) saturate(x)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_100 == 1)\n      #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_120 == 1)\n        // Requires,\n        //  #version 120\n        // And at least,\n        //  #extension GL_EXT_gpu_shader4 : enable\n        //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n        #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n        #if (FXAA_FAST_PIXEL_OFFSET == 1)\n            #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n        #else\n            #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n        #endif\n        #if (FXAA_GATHER4_ALPHA == 1)\n            // use #extension GL_ARB_gpu_shader5 : enable\n            #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n            #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n            #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n            #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_GLSL_130 == 1)\n        // Requires \"#version 130\" or better\n        #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n        #if (FXAA_GATHER4_ALPHA == 1)\n            // use #extension GL_ARB_gpu_shader5 : enable\n            #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n            #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n            #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n            #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_3 == 1)\n        #define FxaaInt2 float2\n        #define FxaaTex sampler2D\n        #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n        #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_4 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex { SamplerState smpl; Texture2D tex; };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #endif\n    /*--------------------------------------------------------------------------*/\n    #if (FXAA_HLSL_5 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex { SamplerState smpl; Texture2D tex; };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n        #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n        #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n        #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n        #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n    #endif\n    \n    \n    /*============================================================================\n                       GREEN AS LUMA OPTION SUPPORT FUNCTION\n    ============================================================================*/\n    #if (FXAA_GREEN_AS_LUMA == 0)\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n    #else\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n    #endif\n    \n    \n    \n    \n    /*============================================================================\n    \n                                 FXAA3 QUALITY - PC\n    \n    ============================================================================*/\n    #if (FXAA_PC == 1)\n    /*--------------------------------------------------------------------------*/\n    FxaaFloat4 FxaaPixelShader(\n        //\n        // Use noperspective interpolation here (turn off perspective interpolation).\n        // {xy} = center of pixel\n        FxaaFloat2 pos,\n        //\n        // Used only for FXAA Console, and not used on the 360 version.\n        // Use noperspective interpolation here (turn off perspective interpolation).\n        // {xy_} = upper left of pixel\n        // {_zw} = lower right of pixel\n        FxaaFloat4 fxaaConsolePosPos,\n        //\n        // Input color texture.\n        // {rgb_} = color in linear or perceptual color space\n        // if (FXAA_GREEN_AS_LUMA == 0)\n        //     {__a} = luma in perceptual color space (not linear)\n        FxaaTex tex,\n        //\n        // Only used on the optimized 360 version of FXAA Console.\n        // For everything but 360, just use the same input here as for \"tex\".\n        // For 360, same texture, just alias with a 2nd sampler.\n        // This sampler needs to have an exponent bias of -1.\n        FxaaTex fxaaConsole360TexExpBiasNegOne,\n        //\n        // Only used on the optimized 360 version of FXAA Console.\n        // For everything but 360, just use the same input here as for \"tex\".\n        // For 360, same texture, just alias with a 3nd sampler.\n        // This sampler needs to have an exponent bias of -2.\n        FxaaTex fxaaConsole360TexExpBiasNegTwo,\n        //\n        // Only used on FXAA Quality.\n        // This must be from a constant/uniform.\n        // {x_} = 1.0/screenWidthInPixels\n        // {_y} = 1.0/screenHeightInPixels\n        FxaaFloat2 fxaaQualityRcpFrame,\n        //\n        // Only used on FXAA Console.\n        // This must be from a constant/uniform.\n        // This effects sub-pixel AA quality and inversely sharpness.\n        //   Where N ranges between,\n        //     N = 0.50 (default)\n        //     N = 0.33 (sharper)\n        // {x__} = -N/screenWidthInPixels\n        // {_y_} = -N/screenHeightInPixels\n        // {_z_} =  N/screenWidthInPixels\n        // {__w} =  N/screenHeightInPixels\n        FxaaFloat4 fxaaConsoleRcpFrameOpt,\n        //\n        // Only used on FXAA Console.\n        // Not used on 360, but used on PS3 and PC.\n        // This must be from a constant/uniform.\n        // {x__} = -2.0/screenWidthInPixels\n        // {_y_} = -2.0/screenHeightInPixels\n        // {_z_} =  2.0/screenWidthInPixels\n        // {__w} =  2.0/screenHeightInPixels\n        FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n        //\n        // Only used on FXAA Console.\n        // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n        // This must be from a constant/uniform.\n        // {x__} =  8.0/screenWidthInPixels\n        // {_y_} =  8.0/screenHeightInPixels\n        // {_z_} = -4.0/screenWidthInPixels\n        // {__w} = -4.0/screenHeightInPixels\n        FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_SUBPIX define.\n        // It is here now to allow easier tuning.\n        // Choose the amount of sub-pixel aliasing removal.\n        // This can effect sharpness.\n        //   1.00 - upper limit (softer)\n        //   0.75 - default amount of filtering\n        //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n        //   0.25 - almost off\n        //   0.00 - completely off\n        FxaaFloat fxaaQualitySubpix,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n        // It is here now to allow easier tuning.\n        // The minimum amount of local contrast required to apply algorithm.\n        //   0.333 - too little (faster)\n        //   0.250 - low quality\n        //   0.166 - default\n        //   0.125 - high quality\n        //   0.063 - overkill (slower)\n        FxaaFloat fxaaQualityEdgeThreshold,\n        //\n        // Only used on FXAA Quality.\n        // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n        // It is here now to allow easier tuning.\n        // Trims the algorithm from processing darks.\n        //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n        //   0.0625 - high quality (faster)\n        //   0.0312 - visible limit (slower)\n        // Special notes when using FXAA_GREEN_AS_LUMA,\n        //   Likely want to set this to zero.\n        //   As colors that are mostly not-green\n        //   will appear very dark in the green channel!\n        //   Tune by looking at mostly non-green content,\n        //   then start at zero and increase until aliasing is a problem.\n        FxaaFloat fxaaQualityEdgeThresholdMin,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n        // It is here now to allow easier tuning.\n        // This does not effect PS3, as this needs to be compiled in.\n        //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n        //   Due to the PS3 being ALU bound,\n        //   there are only three safe values here: 2 and 4 and 8.\n        //   These options use the shaders ability to a free *|/ by 2|4|8.\n        // For all other platforms can be a non-power of two.\n        //   8.0 is sharper (default!!!)\n        //   4.0 is softer\n        //   2.0 is really soft (good only for vector graphics inputs)\n        FxaaFloat fxaaConsoleEdgeSharpness,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n        // It is here now to allow easier tuning.\n        // This does not effect PS3, as this needs to be compiled in.\n        //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n        //   Due to the PS3 being ALU bound,\n        //   there are only two safe values here: 1/4 and 1/8.\n        //   These options use the shaders ability to a free *|/ by 2|4|8.\n        // The console setting has a different mapping than the quality setting.\n        // Other platforms can use other values.\n        //   0.125 leaves less aliasing, but is softer (default!!!)\n        //   0.25 leaves more aliasing, and is sharper\n        FxaaFloat fxaaConsoleEdgeThreshold,\n        //\n        // Only used on FXAA Console.\n        // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n        // It is here now to allow easier tuning.\n        // Trims the algorithm from processing darks.\n        // The console setting has a different mapping than the quality setting.\n        // This only applies when FXAA_EARLY_EXIT is 1.\n        // This does not apply to PS3,\n        // PS3 was simplified to avoid more shader instructions.\n        //   0.06 - faster but more aliasing in darks\n        //   0.05 - default\n        //   0.04 - slower and less aliasing in darks\n        // Special notes when using FXAA_GREEN_AS_LUMA,\n        //   Likely want to set this to zero.\n        //   As colors that are mostly not-green\n        //   will appear very dark in the green channel!\n        //   Tune by looking at mostly non-green content,\n        //   then start at zero and increase until aliasing is a problem.\n        FxaaFloat fxaaConsoleEdgeThresholdMin,\n        //\n        // Extra constants for 360 FXAA Console only.\n        // Use zeros or anything else for other platforms.\n        // These must be in physical constant registers and NOT immediates.\n        // Immediates will result in compiler un-optimizing.\n        // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n        FxaaFloat4 fxaaConsole360ConstDir\n    ) {\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posM;\n        posM.x = pos.x;\n        posM.y = pos.y;\n        #if (FXAA_GATHER4_ALPHA == 1)\n            #if (FXAA_DISCARD == 0)\n                FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n                #if (FXAA_GREEN_AS_LUMA == 0)\n                    #define lumaM rgbyM.w\n                #else\n                    #define lumaM rgbyM.y\n                #endif\n            #endif\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n                FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n            #else\n                FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n                FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n            #endif\n            #if (FXAA_DISCARD == 1)\n                #define lumaM luma4A.w\n            #endif\n            #define lumaE luma4A.z\n            #define lumaS luma4A.x\n            #define lumaSE luma4A.y\n            #define lumaNW luma4B.w\n            #define lumaN luma4B.z\n            #define lumaW luma4B.x\n        #else\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n            #if (FXAA_GLSL_100 == 1)\n              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n            #else\n              FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n            #endif\n        #endif\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat maxSM = max(lumaS, lumaM);\n        FxaaFloat minSM = min(lumaS, lumaM);\n        FxaaFloat maxESM = max(lumaE, maxSM);\n        FxaaFloat minESM = min(lumaE, minSM);\n        FxaaFloat maxWN = max(lumaN, lumaW);\n        FxaaFloat minWN = min(lumaN, lumaW);\n        FxaaFloat rangeMax = max(maxWN, maxESM);\n        FxaaFloat rangeMin = min(minWN, minESM);\n        FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n        FxaaFloat range = rangeMax - rangeMin;\n        FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n        FxaaBool earlyExit = range < rangeMaxClamped;\n    /*--------------------------------------------------------------------------*/\n        if(earlyExit)\n            #if (FXAA_DISCARD == 1)\n                FxaaDiscard;\n            #else\n                return rgbyM;\n            #endif\n    /*--------------------------------------------------------------------------*/\n        #if (FXAA_GATHER4_ALPHA == 0)\n            #if (FXAA_GLSL_100 == 1)\n              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n            #else\n              FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n              FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n            #endif\n        #else\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNS = lumaN + lumaS;\n        FxaaFloat lumaWE = lumaW + lumaE;\n        FxaaFloat subpixRcpRange = 1.0/range;\n        FxaaFloat subpixNSWE = lumaNS + lumaWE;\n        FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n        FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNESE = lumaNE + lumaSE;\n        FxaaFloat lumaNWNE = lumaNW + lumaNE;\n        FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n        FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat lumaNWSW = lumaNW + lumaSW;\n        FxaaFloat lumaSWSE = lumaSW + lumaSE;\n        FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n        FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n        FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n        FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n        FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n        FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n        FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n        FxaaBool horzSpan = edgeHorz >= edgeVert;\n        FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    /*--------------------------------------------------------------------------*/\n        if(!horzSpan) lumaN = lumaW;\n        if(!horzSpan) lumaS = lumaE;\n        if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n        FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat gradientN = lumaN - lumaM;\n        FxaaFloat gradientS = lumaS - lumaM;\n        FxaaFloat lumaNN = lumaN + lumaM;\n        FxaaFloat lumaSS = lumaS + lumaM;\n        FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n        FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n        if(pairN) lengthSign = -lengthSign;\n        FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posB;\n        posB.x = posM.x;\n        posB.y = posM.y;\n        FxaaFloat2 offNP;\n        offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n        offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n        if(!horzSpan) posB.x += lengthSign * 0.5;\n        if( horzSpan) posB.y += lengthSign * 0.5;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat2 posN;\n        posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n        posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n        FxaaFloat2 posP;\n        posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n        posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n        FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n        FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n        FxaaFloat subpixE = subpixC * subpixC;\n        FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n    /*--------------------------------------------------------------------------*/\n        if(!pairN) lumaNN = lumaSS;\n        FxaaFloat gradientScaled = gradient * 1.0/4.0;\n        FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n        FxaaFloat subpixF = subpixD * subpixE;\n        FxaaBool lumaMLTZero = lumaMM < 0.0;\n    /*--------------------------------------------------------------------------*/\n        lumaEndN -= lumaNN * 0.5;\n        lumaEndP -= lumaNN * 0.5;\n        FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n        FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n        FxaaBool doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n    /*--------------------------------------------------------------------------*/\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n    /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 3)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n    /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 4)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 5)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n    /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 6)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n    /*--------------------------------------------------------------------------*/\n                            #if (FXAA_QUALITY_PS > 7)\n                            if(doneNP) {\n                                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                                doneN = abs(lumaEndN) >= gradientScaled;\n                                doneP = abs(lumaEndP) >= gradientScaled;\n                                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                                doneNP = (!doneN) || (!doneP);\n                                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n    /*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 8)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n    /*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 9)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n    /*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 10)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n    /*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 11)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n    /*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 12)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n    /*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n    /*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n    /*--------------------------------------------------------------------------*/\n                }\n                #endif\n    /*--------------------------------------------------------------------------*/\n            }\n            #endif\n    /*--------------------------------------------------------------------------*/\n        }\n        #endif\n    /*--------------------------------------------------------------------------*/\n                            }\n                            #endif\n    /*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n    /*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n    /*--------------------------------------------------------------------------*/\n                }\n                #endif\n    /*--------------------------------------------------------------------------*/\n            }\n            #endif\n    /*--------------------------------------------------------------------------*/\n        }\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat dstN = posM.x - posN.x;\n        FxaaFloat dstP = posP.x - posM.x;\n        if(!horzSpan) dstN = posM.y - posN.y;\n        if(!horzSpan) dstP = posP.y - posM.y;\n    /*--------------------------------------------------------------------------*/\n        FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n        FxaaFloat spanLength = (dstP + dstN);\n        FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n        FxaaFloat spanLengthRcp = 1.0/spanLength;\n    /*--------------------------------------------------------------------------*/\n        FxaaBool directionN = dstN < dstP;\n        FxaaFloat dst = min(dstN, dstP);\n        FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n        FxaaFloat subpixG = subpixF * subpixF;\n        FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n        FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n    /*--------------------------------------------------------------------------*/\n        FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n        FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n        if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n        if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n        #if (FXAA_DISCARD == 1)\n            return FxaaTexTop(tex, posM);\n        #else\n            return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n        #endif\n    }\n    /*==========================================================================*/\n    #endif\n    \n    void main() {\n      gl_FragColor = FxaaPixelShader(\n        vUv,\n        vec4(0.0),\n        tDiffuse,\n        tDiffuse,\n        tDiffuse,\n        resolution,\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        0.75,\n        0.166,\n        0.0833,\n        0.0,\n        0.0,\n        0.0,\n        vec4(0.0)\n      );\n    \n      // TODO avoid querying texture twice for same texel\n      gl_FragColor.a = texture2D(tDiffuse, vUv).a;\n    }\n  `\n  )\n};\nexport {\n  FXAAShader\n};\n//# sourceMappingURL=FXAAShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,aAAa;IACjB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,IAAI,MAAM,IAAI;QAAK;IACtE;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwjCH,CAAC;AAEH;;CAIA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 4125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4131, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/FocusShader.js"],"sourcesContent":["const FocusShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    screenWidth: { value: 1024 },\n    screenHeight: { value: 1024 },\n    sampleDistance: { value: 0.94 },\n    waveFactor: { value: 125e-5 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float screenWidth;\n    uniform float screenHeight;\n    uniform float sampleDistance;\n    uniform float waveFactor;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 color, org, tmp, add;\n    \tfloat sample_dist, f;\n    \tvec2 vin;\n    \tvec2 uv = vUv;\n\n    \tadd = color = org = texture2D( tDiffuse, uv );\n\n    \tvin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\n    \tsample_dist = dot( vin, vin ) * 2.0;\n\n    \tf = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\n\n    \tvec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\n    \tif( tmp.b < color.b ) color = tmp;\n\n    \tcolor = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\n    \tcolor = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\n\n    \tgl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\n\n    }\n  `\n  )\n};\nexport {\n  FocusShader\n};\n//# sourceMappingURL=FocusShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,cAAc;IAClB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,aAAa;YAAE,OAAO;QAAK;QAC3B,cAAc;YAAE,OAAO;QAAK;QAC5B,gBAAgB;YAAE,OAAO;QAAK;QAC9B,YAAY;YAAE,OAAO;QAAO;IAC9B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqDH,CAAC;AAEH;;CAIA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 4219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4225, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/FreiChenShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst FreiChenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    aspect: { value: /* @__PURE__ */ new Vector2(512, 512) }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n\n    uniform vec2 aspect;\n\n    vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\n\n    mat3 G[9];\n\n    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n    const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\n    const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\n    const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\n    const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\n    const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\n    const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\n    const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\n    const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\n    const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\n\n    void main(void)\n    {\n\n    \tG[0] = g0,\n    \tG[1] = g1,\n    \tG[2] = g2,\n    \tG[3] = g3,\n    \tG[4] = g4,\n    \tG[5] = g5,\n    \tG[6] = g6,\n    \tG[7] = g7,\n    \tG[8] = g8;\n\n    \tmat3 I;\n    \tfloat cnv[9];\n    \tvec3 sample;\n\n    /* fetch the 3x3 neighbourhood and use the RGB vectors length as intensity value */\n    \tfor (float i=0.0; i<3.0; i++) {\n    \t\tfor (float j=0.0; j<3.0; j++) {\n    \t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\n    \t\t\tI[int(i)][int(j)] = length(sample);\n    \t\t}\n    \t}\n\n    /* calculate the convolution values for all the masks */\n    \tfor (int i=0; i<9; i++) {\n    \t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\n    \t\tcnv[i] = dp3 * dp3;\n    \t}\n\n    \tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\n    \tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\n\n    \tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\n    }\n  `\n  )\n};\nexport {\n  FreiChenShader\n};\n//# sourceMappingURL=FreiChenShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,iBAAiB;IACrB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,KAAK;QAAK;IACzD;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0DH,CAAC;AAEH;;CAIA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 4311, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4317, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/FresnelShader.js"],"sourcesContent":["const FresnelShader = {\n  uniforms: {\n    mRefractionRatio: { value: 1.02 },\n    mFresnelBias: { value: 0.1 },\n    mFresnelPower: { value: 2 },\n    mFresnelScale: { value: 1 },\n    tCube: { value: null }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    uniform float mRefractionRatio;\n    uniform float mFresnelBias;\n    uniform float mFresnelScale;\n    uniform float mFresnelPower;\n\n    varying vec3 vReflect;\n    varying vec3 vRefract[3];\n    varying float vReflectionFactor;\n\n    void main() {\n\n    \tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n    \tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n\n    \tvec3 I = worldPosition.xyz - cameraPosition;\n\n    \tvReflect = reflect( I, worldNormal );\n    \tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\n    \tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\n    \tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\n    \tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\n\n    \tgl_Position = projectionMatrix * mvPosition;\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform samplerCube tCube;\n\n    varying vec3 vReflect;\n    varying vec3 vRefract[3];\n    varying float vReflectionFactor;\n\n    void main() {\n\n    \tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n    \tvec4 refractedColor = vec4( 1.0 );\n\n    \trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\n    \trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\n    \trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\n\n    \tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\n\n    }\n  `\n  )\n};\nexport {\n  FresnelShader\n};\n//# sourceMappingURL=FresnelShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,gBAAgB;IACpB,UAAU;QACR,kBAAkB;YAAE,OAAO;QAAK;QAChC,cAAc;YAAE,OAAO;QAAI;QAC3B,eAAe;YAAE,OAAO;QAAE;QAC1B,eAAe;YAAE,OAAO;QAAE;QAC1B,OAAO;YAAE,OAAO;QAAK;IACvB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;EAmBH,CAAC;AAEH;;CAIA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 4390, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4396, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/GammaCorrectionShader.js"],"sourcesContent":["const GammaCorrectionShader = {\n  uniforms: {\n    tDiffuse: { value: null }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 tex = texture2D( tDiffuse, vUv );\n\n    \t#ifdef LinearTosRGB\n    \t\tgl_FragColor = LinearTosRGB( tex );\n    \t#else\n    \t\tgl_FragColor = sRGBTransferOETF( tex );\n    \t#endif\n\n    }\n  `\n  )\n};\nexport {\n  GammaCorrectionShader\n};\n//# sourceMappingURL=GammaCorrectionShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,wBAAwB;IAC5B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;IAC1B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;EAgBH,CAAC;AAEH;;CAIA,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 4435, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4441, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/GodRaysShader.js"],"sourcesContent":["import { Vector3, Color } from \"three\";\nconst GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n     vUv = uv;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    uniform sampler2D tInput;\n\n    void main() {\n\n    \tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\n\n    }\n  `\n  )\n};\nconst GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1\n    },\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3()\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n     vUv = uv;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #define TAPS_PER_PASS 6.0\n\n    varying vec2 vUv;\n\n    uniform sampler2D tInput;\n\n    uniform vec3 vSunPositionScreenSpace;\n    uniform float fStepSize; // filter step size\n\n    void main() {\n\n    // delta from current pixel to \"sun\" position\n\n    \tvec2 delta = vSunPositionScreenSpace.xy - vUv;\n    \tfloat dist = length( delta );\n\n    // Step vector (uv space)\n\n    \tvec2 stepv = fStepSize * delta / dist;\n\n    // Number of iterations between pixel and sun\n\n    \tfloat iters = dist/fStepSize;\n\n    \tvec2 uv = vUv.xy;\n    \tfloat col = 0.0;\n\n    // This breaks ANGLE in Chrome 22\n    //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n    /*\n\t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t\t// so ive just left the loop\n\n\t\tfor ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t// mode, with a black border color. I dont think this is currently\n\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t// not specifically handled.\n\n\t\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\n\t\tuv += stepv;\n\n\t\t}\n\t\t*/\n\n    // Unrolling loop manually makes it work in ANGLE\n\n    \tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) ); // used to fade out godrays\n\n    \tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    // Should technically be dividing by iters but TAPS_PER_PASS smooths out\n    // objectionable artifacts, in particular near the sun position. The side\n    // effect is that the result is darker than it should be around the sun, as\n    // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n    // When the result is inverted (in the shader godrays_combine this produces\n    // a slight bright spot at the position of the sun, even when it is occluded.\n\n    \tgl_FragColor = vec4( col/TAPS_PER_PASS );\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `\n  )\n};\nconst GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    uniform sampler2D tColors;\n    uniform sampler2D tGodRays;\n\n    uniform float fGodRayIntensity;\n\n    void main() {\n\n    // Since THREE.MeshDepthMaterial renders foreground objects white and background\n    // objects black, the god-rays will be white streaks. Therefore value is inverted\n    // before being combined with tColors\n\n    \tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `\n  )\n};\nconst GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */ new Vector3()\n    },\n    fAspect: {\n      value: 1\n    },\n    sunColor: {\n      value: /* @__PURE__ */ new Color(16772608)\n    },\n    bgColor: {\n      value: /* @__PURE__ */ new Color(0)\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    uniform vec3 vSunPositionScreenSpace;\n    uniform float fAspect;\n\n    uniform vec3 sunColor;\n    uniform vec3 bgColor;\n\n    void main() {\n\n    \tvec2 diff = vUv - vSunPositionScreenSpace.xy;\n\n    // Correct for aspect ratio\n\n    \tdiff.x *= fAspect;\n\n    \tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n    \tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n    \tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\n    \tgl_FragColor.w = 1.0;\n\n    }\n  `\n  )\n};\nexport {\n  GodRaysCombineShader,\n  GodRaysDepthMaskShader,\n  GodRaysFakeSunShader,\n  GodRaysGenerateShader\n};\n//# sourceMappingURL=GodRaysShader.js.map\n"],"names":[],"mappings":";;;;;;AAAA;;AACA,MAAM,yBAAyB;IAC7B,UAAU;QACR,QAAQ;YACN,OAAO;QACT;IACF;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;AAEH;AACA,MAAM,wBAAwB;IAC5B,UAAU;QACR,QAAQ;YACN,OAAO;QACT;QACA,WAAW;YACT,OAAO;QACT;QACA,yBAAyB;YACvB,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QACpC;IACF;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAoFH,CAAC;AAEH;AACA,MAAM,uBAAuB;IAC3B,UAAU;QACR,SAAS;YACP,OAAO;QACT;QACA,UAAU;YACR,OAAO;QACT;QACA,kBAAkB;YAChB,OAAO;QACT;IACF;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;EAkBH,CAAC;AAEH;AACA,MAAM,uBAAuB;IAC3B,UAAU;QACR,yBAAyB;YACvB,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QACpC;QACA,SAAS;YACP,OAAO;QACT;QACA,UAAU;YACR,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,QAAK,CAAC;QACnC;QACA,SAAS;YACP,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,QAAK,CAAC;QACnC;IACF;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;EAwBH,CAAC;AAEH;;CAOA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 4680, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4686, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/HorizontalBlurShader.js"],"sourcesContent":["const HorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1 / 512 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n  )\n};\nexport {\n  HorizontalBlurShader\n};\n//# sourceMappingURL=HorizontalBlurShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,uBAAuB;IAC3B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,GAAG;YAAE,OAAO,IAAI;QAAI;IACtB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;EAuBH,CAAC;AAEH;;CAIA,gDAAgD","ignoreList":[0]}},
    {"offset": {"line": 4735, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4741, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js"],"sourcesContent":["const HorizontalTiltShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1 / 512 },\n    r: { value: 0.35 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n    uniform float r;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tfloat hh = h * abs( r - vUv.y );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n  )\n};\nexport {\n  HorizontalTiltShiftShader\n};\n//# sourceMappingURL=HorizontalTiltShiftShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,4BAA4B;IAChC,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,GAAG;YAAE,OAAO,IAAI;QAAI;QACpB,GAAG;YAAE,OAAO;QAAK;IACnB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BH,CAAC;AAEH;;CAIA,qDAAqD","ignoreList":[0]}},
    {"offset": {"line": 4796, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4802, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/HueSaturationShader.js"],"sourcesContent":["const HueSaturationShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    hue: { value: 0 },\n    saturation: { value: 0 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float hue;\n    uniform float saturation;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tgl_FragColor = texture2D( tDiffuse, vUv );\n\n    // hue\n    \tfloat angle = hue * 3.14159265;\n    \tfloat s = sin(angle), c = cos(angle);\n    \tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n    \tfloat len = length(gl_FragColor.rgb);\n    \tgl_FragColor.rgb = vec3(\n    \t\tdot(gl_FragColor.rgb, weights.xyz),\n    \t\tdot(gl_FragColor.rgb, weights.zxy),\n    \t\tdot(gl_FragColor.rgb, weights.yzx)\n    \t);\n\n    // saturation\n    \tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\n    \tif (saturation > 0.0) {\n    \t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n    \t} else {\n    \t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\n    \t}\n\n    }\n  `\n  )\n};\nexport {\n  HueSaturationShader\n};\n//# sourceMappingURL=HueSaturationShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,sBAAsB;IAC1B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,KAAK;YAAE,OAAO;QAAE;QAChB,YAAY;YAAE,OAAO;QAAE;IACzB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+BH,CAAC;AAEH;;CAIA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 4863, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4869, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/KaleidoShader.js"],"sourcesContent":["const KaleidoShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    sides: { value: 6 },\n    angle: { value: 0 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float sides;\n    uniform float angle;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 p = vUv - 0.5;\n    \tfloat r = length(p);\n    \tfloat a = atan(p.y, p.x) + angle;\n    \tfloat tau = 2. * 3.1416 ;\n    \ta = mod(a, tau/sides);\n    \ta = abs(a - tau/sides/2.) ;\n    \tp = r * vec2(cos(a), sin(a));\n    \tvec4 color = texture2D(tDiffuse, p + 0.5);\n    \tgl_FragColor = color;\n\n    }\n  `\n  )\n};\nexport {\n  KaleidoShader\n};\n//# sourceMappingURL=KaleidoShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,gBAAgB;IACpB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO;QAAE;QAClB,OAAO;YAAE,OAAO;QAAE;IACpB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;EAoBH,CAAC;AAEH;;CAIA,yCAAyC","ignoreList":[0]}},
    {"offset": {"line": 4918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4924, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/LuminosityHighPassShader.js"],"sourcesContent":["import { Color } from \"three\";\nconst LuminosityHighPassShader = {\n  shaderID: \"luminosityHighPass\",\n  uniforms: {\n    tDiffuse: { value: null },\n    luminosityThreshold: { value: 1 },\n    smoothWidth: { value: 1 },\n    defaultColor: { value: /* @__PURE__ */ new Color(0) },\n    defaultOpacity: { value: 0 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 texel = texture2D( tDiffuse, vUv );\n\n    \tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n    \tfloat v = dot( texel.xyz, luma );\n\n    \tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n    \tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n    \tgl_FragColor = mix( outputColor, texel, alpha );\n\n    }\n  `\n  )\n};\nexport {\n  LuminosityHighPassShader\n};\n//# sourceMappingURL=LuminosityHighPassShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,2BAA2B;IAC/B,UAAU;IACV,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,qBAAqB;YAAE,OAAO;QAAE;QAChC,aAAa;YAAE,OAAO;QAAE;QACxB,cAAc;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,QAAK,CAAC;QAAG;QACpD,gBAAgB;YAAE,OAAO;QAAE;IAC7B;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;EAwBH,CAAC;AAEH;;CAIA,oDAAoD","ignoreList":[0]}},
    {"offset": {"line": 4987, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4993, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/MirrorShader.js"],"sourcesContent":["const MirrorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    side: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform int side;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 p = vUv;\n    \tif (side == 0){\n    \t\tif (p.x > 0.5) p.x = 1.0 - p.x;\n    \t}else if (side == 1){\n    \t\tif (p.x < 0.5) p.x = 1.0 - p.x;\n    \t}else if (side == 2){\n    \t\tif (p.y < 0.5) p.y = 1.0 - p.y;\n    \t}else if (side == 3){\n    \t\tif (p.y > 0.5) p.y = 1.0 - p.y;\n    \t} \n    \tvec4 color = texture2D(tDiffuse, p);\n    \tgl_FragColor = color;\n\n    }\n  `\n  )\n};\nexport {\n  MirrorShader\n};\n//# sourceMappingURL=MirrorShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,eAAe;IACnB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,MAAM;YAAE,OAAO;QAAE;IACnB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;EAsBH,CAAC;AAEH;;CAIA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 5041, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5047, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/NormalMapShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst NormalMapShader = {\n  uniforms: {\n    heightMap: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    scale: { value: /* @__PURE__ */ new Vector2(1, 1) },\n    height: { value: 0.05 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float height;\n    uniform vec2 resolution;\n    uniform sampler2D heightMap;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tfloat val = texture2D( heightMap, vUv ).x;\n\n    \tfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\n    \tfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\n\n    \tgl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\n\n    }\n  `\n  )\n};\nexport {\n  NormalMapShader\n};\n//# sourceMappingURL=NormalMapShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,kBAAkB;IACtB,UAAU;QACR,WAAW;YAAE,OAAO;QAAK;QACzB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,KAAK;QAAK;QAC3D,OAAO;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO,CAAC,GAAG;QAAG;QAClD,QAAQ;YAAE,OAAO;QAAK;IACxB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;EAiBH,CAAC;AAEH;;CAIA,2CAA2C","ignoreList":[0]}},
    {"offset": {"line": 5098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5104, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/ParallaxShader.js"],"sourcesContent":["const ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: \"NO_PARALLAX\",\n    basic: \"USE_BASIC_PARALLAX\",\n    steep: \"USE_STEEP_PARALLAX\",\n    occlusion: \"USE_OCLUSION_PARALLAX\",\n    // a.k.a. POM\n    relief: \"USE_RELIEF_PARALLAX\"\n  },\n  uniforms: {\n    bumpMap: { value: null },\n    map: { value: null },\n    parallaxScale: { value: null },\n    parallaxMinLayers: { value: null },\n    parallaxMaxLayers: { value: null }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n    varying vec3 vViewPosition;\n    varying vec3 vNormal;\n\n    void main() {\n\n    \tvUv = uv;\n    \tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \tvViewPosition = -mvPosition.xyz;\n    \tvNormal = normalize( normalMatrix * normal );\n    \tgl_Position = projectionMatrix * mvPosition;\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D bumpMap;\n    uniform sampler2D map;\n\n    uniform float parallaxScale;\n    uniform float parallaxMinLayers;\n    uniform float parallaxMaxLayers;\n\n    varying vec2 vUv;\n    varying vec3 vViewPosition;\n    varying vec3 vNormal;\n\n    #ifdef USE_BASIC_PARALLAX\n\n    \tvec2 parallaxMap( in vec3 V ) {\n\n    \t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;\n\n    // No Offset Limitting: messy, floating output at grazing angles.\n    //vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\n\n    // Offset Limiting\n    \t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\n    \t\treturn vUv - texCoordOffset;\n\n    \t}\n\n    #else\n\n    \tvec2 parallaxMap( in vec3 V ) {\n\n    // Determine number of layers from angle between V and N\n    \t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\n\n    \t\tfloat layerHeight = 1.0 / numLayers;\n    \t\tfloat currentLayerHeight = 0.0;\n    // Shift of texture coordinates for each iteration\n    \t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;\n\n    \t\tvec2 currentTextureCoords = vUv;\n\n    \t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\n\n    // while ( heightFromTexture > currentLayerHeight )\n    // Infinite loops are not well supported. Do a \"large\" finite\n    // loop, but not too large, as it slows down some compilers.\n    \t\tfor ( int i = 0; i < 30; i += 1 ) {\n    \t\t\tif ( heightFromTexture <= currentLayerHeight ) {\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tcurrentLayerHeight += layerHeight;\n    // Shift texture coordinates along vector V\n    \t\t\tcurrentTextureCoords -= dtex;\n    \t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\n    \t\t}\n\n    \t\t#ifdef USE_STEEP_PARALLAX\n\n    \t\t\treturn currentTextureCoords;\n\n    \t\t#elif defined( USE_RELIEF_PARALLAX )\n\n    \t\t\tvec2 deltaTexCoord = dtex / 2.0;\n    \t\t\tfloat deltaHeight = layerHeight / 2.0;\n\n    // Return to the mid point of previous layer\n    \t\t\tcurrentTextureCoords += deltaTexCoord;\n    \t\t\tcurrentLayerHeight -= deltaHeight;\n\n    // Binary search to increase precision of Steep Parallax Mapping\n    \t\t\tconst int numSearches = 5;\n    \t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {\n\n    \t\t\t\tdeltaTexCoord /= 2.0;\n    \t\t\t\tdeltaHeight /= 2.0;\n    \t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\n    // Shift along or against vector V\n    \t\t\t\tif( heightFromTexture > currentLayerHeight ) { // Below the surface\n\n    \t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;\n    \t\t\t\t\tcurrentLayerHeight += deltaHeight;\n\n    \t\t\t\t} else { // above the surface\n\n    \t\t\t\t\tcurrentTextureCoords += deltaTexCoord;\n    \t\t\t\t\tcurrentLayerHeight -= deltaHeight;\n\n    \t\t\t\t}\n\n    \t\t\t}\n    \t\t\treturn currentTextureCoords;\n\n    \t\t#elif defined( USE_OCLUSION_PARALLAX )\n\n    \t\t\tvec2 prevTCoords = currentTextureCoords + dtex;\n\n    // Heights for linear interpolation\n    \t\t\tfloat nextH = heightFromTexture - currentLayerHeight;\n    \t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\n\n    // Proportions for linear interpolation\n    \t\t\tfloat weight = nextH / ( nextH - prevH );\n\n    // Interpolation of texture coordinates\n    \t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\n\n    \t\t#else // NO_PARALLAX\n\n    \t\t\treturn vUv;\n\n    \t\t#endif\n\n    \t}\n    #endif\n\n    vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\n\n    \tvec2 texDx = dFdx( vUv );\n    \tvec2 texDy = dFdy( vUv );\n\n    \tvec3 vSigmaX = dFdx( surfPosition );\n    \tvec3 vSigmaY = dFdy( surfPosition );\n    \tvec3 vR1 = cross( vSigmaY, surfNormal );\n    \tvec3 vR2 = cross( surfNormal, vSigmaX );\n    \tfloat fDet = dot( vSigmaX, vR1 );\n\n    \tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\n    \tvec3 vProjVtex;\n    \tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\n    \tvProjVtex.z = dot( surfNormal, viewPosition );\n\n    \treturn parallaxMap( vProjVtex );\n    }\n\n    void main() {\n\n    \tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\n    \tgl_FragColor = texture2D( map, mapUv );\n\n    }\n  `\n  )\n};\nexport {\n  ParallaxShader\n};\n//# sourceMappingURL=ParallaxShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,iBAAiB;IACrB,wCAAwC;IACxC,OAAO;QACL,MAAM;QACN,OAAO;QACP,OAAO;QACP,WAAW;QACX,aAAa;QACb,QAAQ;IACV;IACA,UAAU;QACR,SAAS;YAAE,OAAO;QAAK;QACvB,KAAK;YAAE,OAAO;QAAK;QACnB,eAAe;YAAE,OAAO;QAAK;QAC7B,mBAAmB;YAAE,OAAO;QAAK;QACjC,mBAAmB;YAAE,OAAO;QAAK;IACnC;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;EAcH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4IH,CAAC;AAEH;;CAIA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 5293, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5299, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/PixelShader.js"],"sourcesContent":["const PixelShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: null },\n    pixelSize: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying highp vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float pixelSize;\n    uniform vec2 resolution;\n\n    varying highp vec2 vUv;\n\n    void main(){\n\n      vec2 dxy = pixelSize / resolution;\n      vec2 coord = dxy * floor( vUv / dxy );\n      gl_FragColor = texture2D(tDiffuse, coord);\n\n    }\n  `\n  )\n};\nexport {\n  PixelShader\n};\n//# sourceMappingURL=PixelShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,cAAc;IAClB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO;QAAK;QAC1B,WAAW;YAAE,OAAO;QAAE;IACxB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;EAcH,CAAC;AAEH;;CAIA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 5342, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5348, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/RGBShiftShader.js"],"sourcesContent":["const RGBShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    amount: { value: 5e-3 },\n    angle: { value: 0 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float amount;\n    uniform float angle;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 offset = amount * vec2( cos(angle), sin(angle));\n    \tvec4 cr = texture2D(tDiffuse, vUv + offset);\n    \tvec4 cga = texture2D(tDiffuse, vUv);\n    \tvec4 cb = texture2D(tDiffuse, vUv - offset);\n    \tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\n    }\n  `\n  )\n};\nexport {\n  RGBShiftShader\n};\n//# sourceMappingURL=RGBShiftShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,iBAAiB;IACrB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO;QAAK;QACtB,OAAO;YAAE,OAAO;QAAE;IACpB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;EAgBH,CAAC;AAEH;;CAIA,0CAA0C","ignoreList":[0]}},
    {"offset": {"line": 5393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5399, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/SepiaShader.js"],"sourcesContent":["const SepiaShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    amount: { value: 1 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform float amount;\n\n    uniform sampler2D tDiffuse;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 color = texture2D( tDiffuse, vUv );\n    \tvec3 c = color.rgb;\n\n    \tcolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n    \tcolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n    \tcolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n\n    \tgl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n\n    }\n  `\n  )\n};\nexport {\n  SepiaShader\n};\n//# sourceMappingURL=SepiaShader.js.map\n"],"names":[],"mappings":";;;AAAA,MAAM,cAAc;IAClB,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,QAAQ;YAAE,OAAO;QAAE;IACrB;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;EASH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;EAmBH,CAAC;AAEH;;CAIA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 5444, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5450, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/shaders/SobelOperatorShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst SobelOperatorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: /* @__PURE__ */ new Vector2() }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\n\n    // kernel definition (in glsl matrices are filled in column-major order)\n\n    \tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel\n    \tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel\n\n    // fetch the 3x3 neighbourhood of a fragment\n\n    // first column\n\n    \tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\n    \tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\n    \tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\n\n    // second column\n\n    \tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\n    \tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\n    \tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\n\n    // third column\n\n    \tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\n    \tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\n    \tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\n\n    // gradient value in x direction\n\n    \tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \n    \t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \n    \t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \n\n    // gradient value in y direction\n\n    \tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \n    \t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \n    \t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \n\n    // magnitute of the total gradient\n\n    \tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\n\n    \tgl_FragColor = vec4( vec3( G ), 1 );\n\n    }\n  `\n  )\n};\nexport {\n  SobelOperatorShader\n};\n//# sourceMappingURL=SobelOperatorShader.js.map\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,sBAAsB;IAC1B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,YAAY;YAAE,OAAO,aAAa,GAAG,IAAI,+IAAA,CAAA,UAAO;QAAG;IACrD;IACA,cACE,QAAQ,GACR,CAAC;;;;;;;;;;EAUH,CAAC;IAED,gBACE,QAAQ,GACR,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqDH,CAAC;AAEH;;CAIA,+CAA+C","ignoreList":[0]}},
    {"offset": {"line": 5532, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}