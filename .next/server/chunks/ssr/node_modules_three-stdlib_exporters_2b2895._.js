module.exports = {

"[project]/node_modules/three-stdlib/exporters/GLTFExporter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GLTFExporter": (()=>GLTFExporter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/three/build/three.module.js [app-ssr] (ecmascript) <locals>");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
async function readAsDataURL(blob) {
    const buffer = await blob.arrayBuffer();
    const data = btoa(String.fromCharCode(...new Uint8Array(buffer)));
    return `data:${blob.type || ""};base64,${data}`;
}
let _renderer;
let fullscreenQuadGeometry;
let fullscreenQuadMaterial;
let fullscreenQuad;
function decompress(texture, maxTextureSize = Infinity, renderer = null) {
    if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PlaneGeometry"](2, 2, 1, 1);
    if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
        uniforms: {
            blitTexture: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Uniform"](texture)
        },
        vertexShader: /* glsl */ `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = vec4(position.xy * 1.0,0.,.999999);
        }
      `,
        fragmentShader: /* glsl */ `
          uniform sampler2D blitTexture; 
          varying vec2 vUv;

          void main(){ 
              gl_FragColor = vec4(vUv.xy, 0, 1);
              
              #ifdef IS_SRGB
              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
              #else
              gl_FragColor = texture2D( blitTexture, vUv);
              #endif
          }
      `
    });
    fullscreenQuadMaterial.uniforms.blitTexture.value = texture;
    fullscreenQuadMaterial.defines.IS_SRGB = "colorSpace" in texture ? texture.colorSpace === "srgb" : texture.encoding === 3001;
    fullscreenQuadMaterial.needsUpdate = true;
    if (!fullscreenQuad) {
        fullscreenQuad = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"](fullscreenQuadGeometry, fullscreenQuadMaterial);
        fullscreenQuad.frustrumCulled = false;
    }
    const _camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerspectiveCamera"]();
    const _scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Scene"]();
    _scene.add(fullscreenQuad);
    if (!renderer) {
        renderer = _renderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["WebGLRenderer"]({
            antialias: false
        });
    }
    renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));
    renderer.clear();
    renderer.render(_scene, _camera);
    const readableTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"](renderer.domElement);
    readableTexture.minFilter = texture.minFilter;
    readableTexture.magFilter = texture.magFilter;
    readableTexture.wrapS = texture.wrapS;
    readableTexture.wrapT = texture.wrapT;
    readableTexture.name = texture.name;
    if (_renderer) {
        _renderer.dispose();
        _renderer = null;
    }
    return readableTexture;
}
const KHR_mesh_quantization_ExtraAttrTypes = {
    POSITION: [
        "byte",
        "byte normalized",
        "unsigned byte",
        "unsigned byte normalized",
        "short",
        "short normalized",
        "unsigned short",
        "unsigned short normalized"
    ],
    NORMAL: [
        "byte normalized",
        "short normalized"
    ],
    TANGENT: [
        "byte normalized",
        "short normalized"
    ],
    TEXCOORD: [
        "byte",
        "byte normalized",
        "unsigned byte",
        "short",
        "short normalized",
        "unsigned short"
    ]
};
const GLTFExporter = /* @__PURE__ */ (()=>{
    class GLTFExporter2 {
        constructor(){
            this.pluginCallbacks = [];
            this.register(function(writer) {
                return new GLTFLightExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsUnlitExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsTransmissionExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsVolumeExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsIorExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsSpecularExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsClearcoatExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsIridescenceExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsSheenExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsAnisotropyExtension(writer);
            });
            this.register(function(writer) {
                return new GLTFMaterialsEmissiveStrengthExtension(writer);
            });
        }
        register(callback) {
            if (this.pluginCallbacks.indexOf(callback) === -1) {
                this.pluginCallbacks.push(callback);
            }
            return this;
        }
        unregister(callback) {
            if (this.pluginCallbacks.indexOf(callback) !== -1) {
                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
            }
            return this;
        }
        /**
     * Parse scenes and generate GLTF output
     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
     * @param  {Function} onDone  Callback on completed
     * @param  {Function} onError  Callback on errors
     * @param  {Object} options options
     */ parse(input, onDone, onError, options) {
            const writer = new GLTFWriter();
            const plugins = [];
            for(let i = 0, il = this.pluginCallbacks.length; i < il; i++){
                plugins.push(this.pluginCallbacks[i](writer));
            }
            writer.setPlugins(plugins);
            writer.write(input, onDone, options).catch(onError);
        }
        parseAsync(input, options) {
            const scope = this;
            return new Promise(function(resolve, reject) {
                scope.parse(input, resolve, reject, options);
            });
        }
    }
    /**
   * Static utility functions
   */ __publicField(GLTFExporter2, "Utils", {
        insertKeyframe: function(track, time) {
            const tolerance = 1e-3;
            const valueSize = track.getValueSize();
            const times = new track.TimeBufferType(track.times.length + 1);
            const values = new track.ValueBufferType(track.values.length + valueSize);
            const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
            let index;
            if (track.times.length === 0) {
                times[0] = time;
                for(let i = 0; i < valueSize; i++){
                    values[i] = 0;
                }
                index = 0;
            } else if (time < track.times[0]) {
                if (Math.abs(track.times[0] - time) < tolerance) return 0;
                times[0] = time;
                times.set(track.times, 1);
                values.set(interpolant.evaluate(time), 0);
                values.set(track.values, valueSize);
                index = 0;
            } else if (time > track.times[track.times.length - 1]) {
                if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
                    return track.times.length - 1;
                }
                times[times.length - 1] = time;
                times.set(track.times, 0);
                values.set(track.values, 0);
                values.set(interpolant.evaluate(time), track.values.length);
                index = times.length - 1;
            } else {
                for(let i = 0; i < track.times.length; i++){
                    if (Math.abs(track.times[i] - time) < tolerance) return i;
                    if (track.times[i] < time && track.times[i + 1] > time) {
                        times.set(track.times.slice(0, i + 1), 0);
                        times[i + 1] = time;
                        times.set(track.times.slice(i + 1), i + 2);
                        values.set(track.values.slice(0, (i + 1) * valueSize), 0);
                        values.set(interpolant.evaluate(time), (i + 1) * valueSize);
                        values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);
                        index = i + 1;
                        break;
                    }
                }
            }
            track.times = times;
            track.values = values;
            return index;
        },
        mergeMorphTargetTracks: function(clip, root) {
            const tracks = [];
            const mergedTracks = {};
            const sourceTracks = clip.tracks;
            for(let i = 0; i < sourceTracks.length; ++i){
                let sourceTrack = sourceTracks[i];
                const sourceTrackBinding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PropertyBinding"].parseTrackName(sourceTrack.name);
                const sourceTrackNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PropertyBinding"].findNode(root, sourceTrackBinding.nodeName);
                if (sourceTrackBinding.propertyName !== "morphTargetInfluences" || sourceTrackBinding.propertyIndex === void 0) {
                    tracks.push(sourceTrack);
                    continue;
                }
                if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
                    if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                        throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                    }
                    console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.");
                    sourceTrack = sourceTrack.clone();
                    sourceTrack.setInterpolation(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpolateLinear"]);
                }
                const targetCount = sourceTrackNode.morphTargetInfluences.length;
                const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
                if (targetIndex === void 0) {
                    throw new Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
                }
                let mergedTrack;
                if (mergedTracks[sourceTrackNode.uuid] === void 0) {
                    mergedTrack = sourceTrack.clone();
                    const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
                    for(let j = 0; j < mergedTrack.times.length; j++){
                        values[j * targetCount + targetIndex] = mergedTrack.values[j];
                    }
                    mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences";
                    mergedTrack.values = values;
                    mergedTracks[sourceTrackNode.uuid] = mergedTrack;
                    tracks.push(mergedTrack);
                    continue;
                }
                const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
                mergedTrack = mergedTracks[sourceTrackNode.uuid];
                for(let j = 0; j < mergedTrack.times.length; j++){
                    mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);
                }
                for(let j = 0; j < sourceTrack.times.length; j++){
                    const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);
                    mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];
                }
            }
            clip.tracks = tracks;
            return clip;
        }
    });
    return GLTFExporter2;
})();
const WEBGL_CONSTANTS = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
};
const KHR_MESH_QUANTIZATION = "KHR_mesh_quantization";
const THREE_TO_WEBGL = {};
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NearestFilter"]] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NearestMipmapNearestFilter"]] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NearestMipmapLinearFilter"]] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LinearFilter"]] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LinearMipmapNearestFilter"]] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LinearMipmapLinearFilter"]] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"]] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepeatWrapping"]] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MirroredRepeatWrapping"]] = WEBGL_CONSTANTS.MIRRORED_REPEAT;
const PATH_PROPERTIES = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights"
};
const DEFAULT_SPECULAR_COLOR = /* @__PURE__ */ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"]();
const GLB_HEADER_BYTES = 12;
const GLB_HEADER_MAGIC = 1179937895;
const GLB_VERSION = 2;
const GLB_CHUNK_PREFIX_BYTES = 8;
const GLB_CHUNK_TYPE_JSON = 1313821514;
const GLB_CHUNK_TYPE_BIN = 5130562;
function equalArray(array1, array2) {
    return array1.length === array2.length && array1.every(function(element, index) {
        return element === array2[index];
    });
}
function stringToArrayBuffer(text) {
    return new TextEncoder().encode(text).buffer;
}
function isIdentityMatrix(matrix) {
    return equalArray(matrix.elements, [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ]);
}
function getMinMax(attribute, start, count) {
    const output = {
        min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
        max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
    };
    for(let i = start; i < start + count; i++){
        for(let a = 0; a < attribute.itemSize; a++){
            let value;
            if (attribute.itemSize > 4) {
                value = attribute.array[i * attribute.itemSize + a];
            } else {
                if (a === 0) value = attribute.getX(i);
                else if (a === 1) value = attribute.getY(i);
                else if (a === 2) value = attribute.getZ(i);
                else if (a === 3) value = attribute.getW(i);
                if (attribute.normalized === true) {
                    value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MathUtils"].normalize(value, attribute.array);
                }
            }
            output.min[a] = Math.min(output.min[a], value);
            output.max[a] = Math.max(output.max[a], value);
        }
    }
    return output;
}
function getPaddedBufferSize(bufferSize) {
    return Math.ceil(bufferSize / 4) * 4;
}
function getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
    const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);
    if (paddedLength !== arrayBuffer.byteLength) {
        const array = new Uint8Array(paddedLength);
        array.set(new Uint8Array(arrayBuffer));
        if (paddingByte !== 0) {
            for(let i = arrayBuffer.byteLength; i < paddedLength; i++){
                array[i] = paddingByte;
            }
        }
        return array.buffer;
    }
    return arrayBuffer;
}
function getCanvas() {
    if (typeof document === "undefined" && typeof OffscreenCanvas !== "undefined") {
        return new OffscreenCanvas(1, 1);
    }
    return document.createElement("canvas");
}
function getToBlobPromise(canvas, mimeType) {
    if (canvas.toBlob !== void 0) {
        return new Promise((resolve)=>canvas.toBlob(resolve, mimeType));
    }
    let quality;
    if (mimeType === "image/jpeg") {
        quality = 0.92;
    } else if (mimeType === "image/webp") {
        quality = 0.8;
    }
    return canvas.convertToBlob({
        type: mimeType,
        quality
    });
}
class GLTFWriter {
    constructor(){
        this.plugins = [];
        this.options = {};
        this.pending = [];
        this.buffers = [];
        this.byteOffset = 0;
        this.buffers = [];
        this.nodeMap = /* @__PURE__ */ new Map();
        this.skins = [];
        this.extensionsUsed = {};
        this.extensionsRequired = {};
        this.uids = /* @__PURE__ */ new Map();
        this.uid = 0;
        this.json = {
            asset: {
                version: "2.0",
                generator: "THREE.GLTFExporter"
            }
        };
        this.cache = {
            meshes: /* @__PURE__ */ new Map(),
            attributes: /* @__PURE__ */ new Map(),
            attributesNormalized: /* @__PURE__ */ new Map(),
            materials: /* @__PURE__ */ new Map(),
            textures: /* @__PURE__ */ new Map(),
            images: /* @__PURE__ */ new Map()
        };
    }
    setPlugins(plugins) {
        this.plugins = plugins;
    }
    /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */ async write(input, onDone, options = {}) {
        this.options = Object.assign({
            // default options
            binary: false,
            trs: false,
            onlyVisible: true,
            maxTextureSize: Infinity,
            animations: [],
            includeCustomExtensions: false
        }, options);
        if (this.options.animations.length > 0) {
            this.options.trs = true;
        }
        this.processInput(input);
        await Promise.all(this.pending);
        const writer = this;
        const buffers = writer.buffers;
        const json = writer.json;
        options = writer.options;
        const extensionsUsed = writer.extensionsUsed;
        const extensionsRequired = writer.extensionsRequired;
        const blob = new Blob(buffers, {
            type: "application/octet-stream"
        });
        const extensionsUsedList = Object.keys(extensionsUsed);
        const extensionsRequiredList = Object.keys(extensionsRequired);
        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;
        if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;
        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;
        if (options.binary === true) {
            blob.arrayBuffer().then((result)=>{
                const binaryChunk = getPaddedArrayBuffer(result);
                const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
                binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
                binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
                const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);
                const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
                jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
                jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
                const header = new ArrayBuffer(GLB_HEADER_BYTES);
                const headerView = new DataView(header);
                headerView.setUint32(0, GLB_HEADER_MAGIC, true);
                headerView.setUint32(4, GLB_VERSION, true);
                const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
                headerView.setUint32(8, totalByteLength, true);
                const glbBlob = new Blob([
                    header,
                    jsonChunkPrefix,
                    jsonChunk,
                    binaryChunkPrefix,
                    binaryChunk
                ], {
                    type: "application/octet-stream"
                });
                glbBlob.arrayBuffer().then(onDone);
            });
        } else {
            if (json.buffers && json.buffers.length > 0) {
                readAsDataURL(blob).then((uri)=>{
                    json.buffers[0].uri = uri;
                    onDone(json);
                });
            } else {
                onDone(json);
            }
        }
    }
    /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */ serializeUserData(object, objectDef) {
        if (Object.keys(object.userData).length === 0) return;
        const options = this.options;
        const extensionsUsed = this.extensionsUsed;
        try {
            const json = JSON.parse(JSON.stringify(object.userData));
            if (options.includeCustomExtensions && json.gltfExtensions) {
                if (objectDef.extensions === void 0) objectDef.extensions = {};
                for(const extensionName in json.gltfExtensions){
                    objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
                    extensionsUsed[extensionName] = true;
                }
                delete json.gltfExtensions;
            }
            if (Object.keys(json).length > 0) objectDef.extras = json;
        } catch (error) {
            console.warn("THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message);
        }
    }
    /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */ getUID(attribute, isRelativeCopy = false) {
        if (this.uids.has(attribute) === false) {
            const uids2 = /* @__PURE__ */ new Map();
            uids2.set(true, this.uid++);
            uids2.set(false, this.uid++);
            this.uids.set(attribute, uids2);
        }
        const uids = this.uids.get(attribute);
        return uids.get(isRelativeCopy);
    }
    /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */ isNormalizedNormalAttribute(normal) {
        const cache = this.cache;
        if (cache.attributesNormalized.has(normal)) return false;
        const v = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0, il = normal.count; i < il; i++){
            if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;
        }
        return true;
    }
    /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */ createNormalizedNormalAttribute(normal) {
        const cache = this.cache;
        if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);
        const attribute = normal.clone();
        const v = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0, il = attribute.count; i < il; i++){
            v.fromBufferAttribute(attribute, i);
            if (v.x === 0 && v.y === 0 && v.z === 0) {
                v.setX(1);
            } else {
                v.normalize();
            }
            attribute.setXYZ(i, v.x, v.y, v.z);
        }
        cache.attributesNormalized.set(normal, attribute);
        return attribute;
    }
    /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */ applyTextureTransform(mapDef, texture) {
        let didTransform = false;
        const transformDef = {};
        if (texture.offset.x !== 0 || texture.offset.y !== 0) {
            transformDef.offset = texture.offset.toArray();
            didTransform = true;
        }
        if (texture.rotation !== 0) {
            transformDef.rotation = texture.rotation;
            didTransform = true;
        }
        if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {
            transformDef.scale = texture.repeat.toArray();
            didTransform = true;
        }
        if (didTransform) {
            mapDef.extensions = mapDef.extensions || {};
            mapDef.extensions["KHR_texture_transform"] = transformDef;
            this.extensionsUsed["KHR_texture_transform"] = true;
        }
    }
    buildMetalRoughTexture(metalnessMap, roughnessMap) {
        if (metalnessMap === roughnessMap) return metalnessMap;
        function getEncodingConversion(map) {
            if ("colorSpace" in map ? map.colorSpace === "srgb" : map.encoding === 3001) {
                return function SRGBToLinear(c) {
                    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
                };
            }
            return function LinearToLinear(c) {
                return c;
            };
        }
        console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
        if (metalnessMap instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CompressedTexture"]) {
            metalnessMap = decompress(metalnessMap);
        }
        if (roughnessMap instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CompressedTexture"]) {
            roughnessMap = decompress(roughnessMap);
        }
        const metalness = metalnessMap ? metalnessMap.image : null;
        const roughness = roughnessMap ? roughnessMap.image : null;
        const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);
        const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);
        const canvas = getCanvas();
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.fillStyle = "#00ffff";
        context.fillRect(0, 0, width, height);
        const composite = context.getImageData(0, 0, width, height);
        if (metalness) {
            context.drawImage(metalness, 0, 0, width, height);
            const convert = getEncodingConversion(metalnessMap);
            const data = context.getImageData(0, 0, width, height).data;
            for(let i = 2; i < data.length; i += 4){
                composite.data[i] = convert(data[i] / 256) * 256;
            }
        }
        if (roughness) {
            context.drawImage(roughness, 0, 0, width, height);
            const convert = getEncodingConversion(roughnessMap);
            const data = context.getImageData(0, 0, width, height).data;
            for(let i = 1; i < data.length; i += 4){
                composite.data[i] = convert(data[i] / 256) * 256;
            }
        }
        context.putImageData(composite, 0, 0);
        const reference = metalnessMap || roughnessMap;
        const texture = reference.clone();
        texture.source = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"](canvas).source;
        if ("colorSpace" in texture) texture.colorSpace = "";
        else texture.encoding = 3e3;
        texture.channel = (metalnessMap || roughnessMap).channel;
        if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {
            console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.");
        }
        return texture;
    }
    /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */ processBuffer(buffer) {
        const json = this.json;
        const buffers = this.buffers;
        if (!json.buffers) json.buffers = [
            {
                byteLength: 0
            }
        ];
        buffers.push(buffer);
        return 0;
    }
    /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */ processBufferView(attribute, componentType, start, count, target) {
        const json = this.json;
        if (!json.bufferViews) json.bufferViews = [];
        let componentSize;
        switch(componentType){
            case WEBGL_CONSTANTS.BYTE:
            case WEBGL_CONSTANTS.UNSIGNED_BYTE:
                componentSize = 1;
                break;
            case WEBGL_CONSTANTS.SHORT:
            case WEBGL_CONSTANTS.UNSIGNED_SHORT:
                componentSize = 2;
                break;
            default:
                componentSize = 4;
        }
        let byteStride = attribute.itemSize * componentSize;
        if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {
            byteStride = Math.ceil(byteStride / 4) * 4;
        }
        const byteLength = getPaddedBufferSize(count * byteStride);
        const dataView = new DataView(new ArrayBuffer(byteLength));
        let offset = 0;
        for(let i = start; i < start + count; i++){
            for(let a = 0; a < attribute.itemSize; a++){
                let value;
                if (attribute.itemSize > 4) {
                    value = attribute.array[i * attribute.itemSize + a];
                } else {
                    if (a === 0) value = attribute.getX(i);
                    else if (a === 1) value = attribute.getY(i);
                    else if (a === 2) value = attribute.getZ(i);
                    else if (a === 3) value = attribute.getW(i);
                    if (attribute.normalized === true) {
                        value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MathUtils"].normalize(value, attribute.array);
                    }
                }
                if (componentType === WEBGL_CONSTANTS.FLOAT) {
                    dataView.setFloat32(offset, value, true);
                } else if (componentType === WEBGL_CONSTANTS.INT) {
                    dataView.setInt32(offset, value, true);
                } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {
                    dataView.setUint32(offset, value, true);
                } else if (componentType === WEBGL_CONSTANTS.SHORT) {
                    dataView.setInt16(offset, value, true);
                } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
                    dataView.setUint16(offset, value, true);
                } else if (componentType === WEBGL_CONSTANTS.BYTE) {
                    dataView.setInt8(offset, value);
                } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
                    dataView.setUint8(offset, value);
                }
                offset += componentSize;
            }
            if (offset % byteStride !== 0) {
                offset += byteStride - offset % byteStride;
            }
        }
        const bufferViewDef = {
            buffer: this.processBuffer(dataView.buffer),
            byteOffset: this.byteOffset,
            byteLength
        };
        if (target !== void 0) bufferViewDef.target = target;
        if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {
            bufferViewDef.byteStride = byteStride;
        }
        this.byteOffset += byteLength;
        json.bufferViews.push(bufferViewDef);
        const output = {
            id: json.bufferViews.length - 1,
            byteLength: 0
        };
        return output;
    }
    /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */ processBufferViewImage(blob) {
        const writer = this;
        const json = writer.json;
        if (!json.bufferViews) json.bufferViews = [];
        return blob.arrayBuffer().then((result)=>{
            const buffer = getPaddedArrayBuffer(result);
            const bufferViewDef = {
                buffer: writer.processBuffer(buffer),
                byteOffset: writer.byteOffset,
                byteLength: buffer.byteLength
            };
            writer.byteOffset += buffer.byteLength;
            return json.bufferViews.push(bufferViewDef) - 1;
        });
    }
    /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */ processAccessor(attribute, geometry, start, count) {
        const json = this.json;
        const types = {
            1: "SCALAR",
            2: "VEC2",
            3: "VEC3",
            4: "VEC4",
            9: "MAT3",
            16: "MAT4"
        };
        let componentType;
        if (attribute.array.constructor === Float32Array) {
            componentType = WEBGL_CONSTANTS.FLOAT;
        } else if (attribute.array.constructor === Int32Array) {
            componentType = WEBGL_CONSTANTS.INT;
        } else if (attribute.array.constructor === Uint32Array) {
            componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
        } else if (attribute.array.constructor === Int16Array) {
            componentType = WEBGL_CONSTANTS.SHORT;
        } else if (attribute.array.constructor === Uint16Array) {
            componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
        } else if (attribute.array.constructor === Int8Array) {
            componentType = WEBGL_CONSTANTS.BYTE;
        } else if (attribute.array.constructor === Uint8Array) {
            componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
        } else {
            throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + attribute.array.constructor.name);
        }
        if (start === void 0) start = 0;
        if (count === void 0) count = attribute.count;
        if (count === 0) return null;
        const minMax = getMinMax(attribute, start, count);
        let bufferViewTarget;
        if (geometry !== void 0) {
            bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;
        }
        const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);
        const accessorDef = {
            bufferView: bufferView.id,
            byteOffset: bufferView.byteOffset,
            componentType,
            count,
            max: minMax.max,
            min: minMax.min,
            type: types[attribute.itemSize]
        };
        if (attribute.normalized === true) accessorDef.normalized = true;
        if (!json.accessors) json.accessors = [];
        return json.accessors.push(accessorDef) - 1;
    }
    /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */ processImage(image, format, flipY, mimeType = "image/png") {
        if (image !== null) {
            const writer = this;
            const cache = writer.cache;
            const json = writer.json;
            const options = writer.options;
            const pending = writer.pending;
            if (!cache.images.has(image)) cache.images.set(image, {});
            const cachedImages = cache.images.get(image);
            const key = mimeType + ":flipY/" + flipY.toString();
            if (cachedImages[key] !== void 0) return cachedImages[key];
            if (!json.images) json.images = [];
            const imageDef = {
                mimeType
            };
            const canvas = getCanvas();
            canvas.width = Math.min(image.width, options.maxTextureSize);
            canvas.height = Math.min(image.height, options.maxTextureSize);
            const ctx = canvas.getContext("2d");
            if (flipY === true) {
                ctx.translate(0, canvas.height);
                ctx.scale(1, -1);
            }
            if (image.data !== void 0) {
                if (format !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RGBAFormat"]) {
                    console.error("GLTFExporter: Only RGBAFormat is supported.", format);
                }
                if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
                    console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
                }
                const data = new Uint8ClampedArray(image.height * image.width * 4);
                for(let i = 0; i < data.length; i += 4){
                    data[i + 0] = image.data[i + 0];
                    data[i + 1] = image.data[i + 1];
                    data[i + 2] = image.data[i + 2];
                    data[i + 3] = image.data[i + 3];
                }
                ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
            } else {
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
            }
            if (options.binary === true) {
                pending.push(getToBlobPromise(canvas, mimeType).then((blob)=>writer.processBufferViewImage(blob)).then((bufferViewIndex)=>{
                    imageDef.bufferView = bufferViewIndex;
                }));
            } else {
                if (canvas.toDataURL !== void 0) {
                    imageDef.uri = canvas.toDataURL(mimeType);
                } else {
                    pending.push(getToBlobPromise(canvas, mimeType).then(readAsDataURL).then((uri)=>{
                        imageDef.uri = uri;
                    }));
                }
            }
            const index = json.images.push(imageDef) - 1;
            cachedImages[key] = index;
            return index;
        } else {
            throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
        }
    }
    /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */ processSampler(map) {
        const json = this.json;
        if (!json.samplers) json.samplers = [];
        const samplerDef = {
            magFilter: THREE_TO_WEBGL[map.magFilter],
            minFilter: THREE_TO_WEBGL[map.minFilter],
            wrapS: THREE_TO_WEBGL[map.wrapS],
            wrapT: THREE_TO_WEBGL[map.wrapT]
        };
        return json.samplers.push(samplerDef) - 1;
    }
    /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */ processTexture(map) {
        const writer = this;
        const options = writer.options;
        const cache = this.cache;
        const json = this.json;
        if (cache.textures.has(map)) return cache.textures.get(map);
        if (!json.textures) json.textures = [];
        if (map instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CompressedTexture"]) {
            map = decompress(map, options.maxTextureSize);
        }
        let mimeType = map.userData.mimeType;
        if (mimeType === "image/webp") mimeType = "image/png";
        const textureDef = {
            sampler: this.processSampler(map),
            source: this.processImage(map.image, map.format, map.flipY, mimeType)
        };
        if (map.name) textureDef.name = map.name;
        this._invokeAll(function(ext) {
            ext.writeTexture && ext.writeTexture(map, textureDef);
        });
        const index = json.textures.push(textureDef) - 1;
        cache.textures.set(map, index);
        return index;
    }
    /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */ processMaterial(material) {
        const cache = this.cache;
        const json = this.json;
        if (cache.materials.has(material)) return cache.materials.get(material);
        if (material.isShaderMaterial) {
            console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
            return null;
        }
        if (!json.materials) json.materials = [];
        const materialDef = {
            pbrMetallicRoughness: {}
        };
        if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {
            console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
        }
        const color = material.color.toArray().concat([
            material.opacity
        ]);
        if (!equalArray(color, [
            1,
            1,
            1,
            1
        ])) {
            materialDef.pbrMetallicRoughness.baseColorFactor = color;
        }
        if (material.isMeshStandardMaterial) {
            materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
            materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;
        } else {
            materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
            materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
        }
        if (material.metalnessMap || material.roughnessMap) {
            const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);
            const metalRoughMapDef = {
                index: this.processTexture(metalRoughTexture),
                channel: metalRoughTexture.channel
            };
            this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);
            materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
        }
        if (material.map) {
            const baseColorMapDef = {
                index: this.processTexture(material.map),
                texCoord: material.map.channel
            };
            this.applyTextureTransform(baseColorMapDef, material.map);
            materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
        }
        if (material.emissive) {
            const emissive = material.emissive;
            const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
            if (maxEmissiveComponent > 0) {
                materialDef.emissiveFactor = material.emissive.toArray();
            }
            if (material.emissiveMap) {
                const emissiveMapDef = {
                    index: this.processTexture(material.emissiveMap),
                    texCoord: material.emissiveMap.channel
                };
                this.applyTextureTransform(emissiveMapDef, material.emissiveMap);
                materialDef.emissiveTexture = emissiveMapDef;
            }
        }
        if (material.normalMap) {
            const normalMapDef = {
                index: this.processTexture(material.normalMap),
                texCoord: material.normalMap.channel
            };
            if (material.normalScale && material.normalScale.x !== 1) {
                normalMapDef.scale = material.normalScale.x;
            }
            this.applyTextureTransform(normalMapDef, material.normalMap);
            materialDef.normalTexture = normalMapDef;
        }
        if (material.aoMap) {
            const occlusionMapDef = {
                index: this.processTexture(material.aoMap),
                texCoord: material.aoMap.channel
            };
            if (material.aoMapIntensity !== 1) {
                occlusionMapDef.strength = material.aoMapIntensity;
            }
            this.applyTextureTransform(occlusionMapDef, material.aoMap);
            materialDef.occlusionTexture = occlusionMapDef;
        }
        if (material.transparent) {
            materialDef.alphaMode = "BLEND";
        } else {
            if (material.alphaTest > 0) {
                materialDef.alphaMode = "MASK";
                materialDef.alphaCutoff = material.alphaTest;
            }
        }
        if (material.side === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DoubleSide"]) materialDef.doubleSided = true;
        if (material.name !== "") materialDef.name = material.name;
        this.serializeUserData(material, materialDef);
        this._invokeAll(function(ext) {
            ext.writeMaterial && ext.writeMaterial(material, materialDef);
        });
        const index = json.materials.push(materialDef) - 1;
        cache.materials.set(material, index);
        return index;
    }
    /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */ processMesh(mesh) {
        const cache = this.cache;
        const json = this.json;
        const meshCacheKeyParts = [
            mesh.geometry.uuid
        ];
        if (Array.isArray(mesh.material)) {
            for(let i = 0, l = mesh.material.length; i < l; i++){
                meshCacheKeyParts.push(mesh.material[i].uuid);
            }
        } else {
            meshCacheKeyParts.push(mesh.material.uuid);
        }
        const meshCacheKey = meshCacheKeyParts.join(":");
        if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);
        const geometry = mesh.geometry;
        let mode;
        if (mesh.isLineSegments) {
            mode = WEBGL_CONSTANTS.LINES;
        } else if (mesh.isLineLoop) {
            mode = WEBGL_CONSTANTS.LINE_LOOP;
        } else if (mesh.isLine) {
            mode = WEBGL_CONSTANTS.LINE_STRIP;
        } else if (mesh.isPoints) {
            mode = WEBGL_CONSTANTS.POINTS;
        } else {
            mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;
        }
        const meshDef = {};
        const attributes = {};
        const primitives = [];
        const targets = [];
        const nameConversion = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"] >= 152 ? {
                uv: "TEXCOORD_0",
                uv1: "TEXCOORD_1",
                uv2: "TEXCOORD_2",
                uv3: "TEXCOORD_3"
            } : {
                uv: "TEXCOORD_0",
                uv2: "TEXCOORD_1"
            },
            color: "COLOR_0",
            skinWeight: "WEIGHTS_0",
            skinIndex: "JOINTS_0"
        };
        const originalNormal = geometry.getAttribute("normal");
        if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {
            console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.");
            geometry.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal));
        }
        let modifiedAttribute = null;
        for(let attributeName in geometry.attributes){
            if (attributeName.slice(0, 5) === "morph") continue;
            const attribute = geometry.attributes[attributeName];
            attributeName = nameConversion[attributeName] || attributeName.toUpperCase();
            const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
            if (!validVertexAttributes.test(attributeName)) attributeName = "_" + attributeName;
            if (cache.attributes.has(this.getUID(attribute))) {
                attributes[attributeName] = cache.attributes.get(this.getUID(attribute));
                continue;
            }
            modifiedAttribute = null;
            const array = attribute.array;
            if (attributeName === "JOINTS_0" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
                console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
                modifiedAttribute = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferAttribute"](new Uint16Array(array), attribute.itemSize, attribute.normalized);
            }
            const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);
            if (accessor !== null) {
                if (!attributeName.startsWith("_")) {
                    this.detectMeshQuantization(attributeName, attribute);
                }
                attributes[attributeName] = accessor;
                cache.attributes.set(this.getUID(attribute), accessor);
            }
        }
        if (originalNormal !== void 0) geometry.setAttribute("normal", originalNormal);
        if (Object.keys(attributes).length === 0) return null;
        if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {
            const weights = [];
            const targetNames = [];
            const reverseDictionary = {};
            if (mesh.morphTargetDictionary !== void 0) {
                for(const key in mesh.morphTargetDictionary){
                    reverseDictionary[mesh.morphTargetDictionary[key]] = key;
                }
            }
            for(let i = 0; i < mesh.morphTargetInfluences.length; ++i){
                const target = {};
                let warned = false;
                for(const attributeName in geometry.morphAttributes){
                    if (attributeName !== "position" && attributeName !== "normal") {
                        if (!warned) {
                            console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported.");
                            warned = true;
                        }
                        continue;
                    }
                    const attribute = geometry.morphAttributes[attributeName][i];
                    const gltfAttributeName = attributeName.toUpperCase();
                    const baseAttribute = geometry.attributes[attributeName];
                    if (cache.attributes.has(this.getUID(attribute, true))) {
                        target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));
                        continue;
                    }
                    const relativeAttribute = attribute.clone();
                    if (!geometry.morphTargetsRelative) {
                        for(let j = 0, jl = attribute.count; j < jl; j++){
                            for(let a = 0; a < attribute.itemSize; a++){
                                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));
                                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));
                                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));
                                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));
                            }
                        }
                    }
                    target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);
                    cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);
                }
                targets.push(target);
                weights.push(mesh.morphTargetInfluences[i]);
                if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[i]);
            }
            meshDef.weights = weights;
            if (targetNames.length > 0) {
                meshDef.extras = {};
                meshDef.extras.targetNames = targetNames;
            }
        }
        const isMultiMaterial = Array.isArray(mesh.material);
        if (isMultiMaterial && geometry.groups.length === 0) return null;
        const materials = isMultiMaterial ? mesh.material : [
            mesh.material
        ];
        const groups = isMultiMaterial ? geometry.groups : [
            {
                materialIndex: 0,
                start: void 0,
                count: void 0
            }
        ];
        for(let i = 0, il = groups.length; i < il; i++){
            const primitive = {
                mode,
                attributes
            };
            this.serializeUserData(geometry, primitive);
            if (targets.length > 0) primitive.targets = targets;
            if (geometry.index !== null) {
                let cacheKey = this.getUID(geometry.index);
                if (groups[i].start !== void 0 || groups[i].count !== void 0) {
                    cacheKey += ":" + groups[i].start + ":" + groups[i].count;
                }
                if (cache.attributes.has(cacheKey)) {
                    primitive.indices = cache.attributes.get(cacheKey);
                } else {
                    primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);
                    cache.attributes.set(cacheKey, primitive.indices);
                }
                if (primitive.indices === null) delete primitive.indices;
            }
            const material = this.processMaterial(materials[groups[i].materialIndex]);
            if (material !== null) primitive.material = material;
            primitives.push(primitive);
        }
        meshDef.primitives = primitives;
        if (!json.meshes) json.meshes = [];
        this._invokeAll(function(ext) {
            ext.writeMesh && ext.writeMesh(mesh, meshDef);
        });
        const index = json.meshes.push(meshDef) - 1;
        cache.meshes.set(meshCacheKey, index);
        return index;
    }
    /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */ detectMeshQuantization(attributeName, attribute) {
        if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;
        let attrType = void 0;
        switch(attribute.array.constructor){
            case Int8Array:
                attrType = "byte";
                break;
            case Uint8Array:
                attrType = "unsigned byte";
                break;
            case Int16Array:
                attrType = "short";
                break;
            case Uint16Array:
                attrType = "unsigned short";
                break;
            default:
                return;
        }
        if (attribute.normalized) attrType += " normalized";
        const attrNamePrefix = attributeName.split("_", 1)[0];
        if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {
            this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;
            this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;
        }
    }
    /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */ processCamera(camera) {
        const json = this.json;
        if (!json.cameras) json.cameras = [];
        const isOrtho = camera.isOrthographicCamera;
        const cameraDef = {
            type: isOrtho ? "orthographic" : "perspective"
        };
        if (isOrtho) {
            cameraDef.orthographic = {
                xmag: camera.right * 2,
                ymag: camera.top * 2,
                zfar: camera.far <= 0 ? 1e-3 : camera.far,
                znear: camera.near < 0 ? 0 : camera.near
            };
        } else {
            cameraDef.perspective = {
                aspectRatio: camera.aspect,
                yfov: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MathUtils"].degToRad(camera.fov),
                zfar: camera.far <= 0 ? 1e-3 : camera.far,
                znear: camera.near < 0 ? 0 : camera.near
            };
        }
        if (camera.name !== "") cameraDef.name = camera.type;
        return json.cameras.push(cameraDef) - 1;
    }
    /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */ processAnimation(clip, root) {
        const json = this.json;
        const nodeMap = this.nodeMap;
        if (!json.animations) json.animations = [];
        clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
        const tracks = clip.tracks;
        const channels = [];
        const samplers = [];
        for(let i = 0; i < tracks.length; ++i){
            const track = tracks[i];
            const trackBinding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PropertyBinding"].parseTrackName(track.name);
            let trackNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PropertyBinding"].findNode(root, trackBinding.nodeName);
            const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];
            if (trackBinding.objectName === "bones") {
                if (trackNode.isSkinnedMesh === true) {
                    trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
                } else {
                    trackNode = void 0;
                }
            }
            if (!trackNode || !trackProperty) {
                console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
                return null;
            }
            const inputItemSize = 1;
            let outputItemSize = track.values.length / track.times.length;
            if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {
                outputItemSize /= trackNode.morphTargetInfluences.length;
            }
            let interpolation;
            if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {
                interpolation = "CUBICSPLINE";
                outputItemSize /= 3;
            } else if (track.getInterpolation() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpolateDiscrete"]) {
                interpolation = "STEP";
            } else {
                interpolation = "LINEAR";
            }
            samplers.push({
                input: this.processAccessor(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferAttribute"](track.times, inputItemSize)),
                output: this.processAccessor(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferAttribute"](track.values, outputItemSize)),
                interpolation
            });
            channels.push({
                sampler: samplers.length - 1,
                target: {
                    node: nodeMap.get(trackNode),
                    path: trackProperty
                }
            });
        }
        json.animations.push({
            name: clip.name || "clip_" + json.animations.length,
            samplers,
            channels
        });
        return json.animations.length - 1;
    }
    /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */ processSkin(object) {
        const json = this.json;
        const nodeMap = this.nodeMap;
        const node = json.nodes[nodeMap.get(object)];
        const skeleton = object.skeleton;
        if (skeleton === void 0) return null;
        const rootJoint = object.skeleton.bones[0];
        if (rootJoint === void 0) return null;
        const joints = [];
        const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
        const temporaryBoneInverse = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix4"]();
        for(let i = 0; i < skeleton.bones.length; ++i){
            joints.push(nodeMap.get(skeleton.bones[i]));
            temporaryBoneInverse.copy(skeleton.boneInverses[i]);
            temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);
        }
        if (json.skins === void 0) json.skins = [];
        json.skins.push({
            inverseBindMatrices: this.processAccessor(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferAttribute"](inverseBindMatrices, 16)),
            joints,
            skeleton: nodeMap.get(rootJoint)
        });
        const skinIndex = node.skin = json.skins.length - 1;
        return skinIndex;
    }
    /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */ processNode(object) {
        const json = this.json;
        const options = this.options;
        const nodeMap = this.nodeMap;
        if (!json.nodes) json.nodes = [];
        const nodeDef = {};
        if (options.trs) {
            const rotation = object.quaternion.toArray();
            const position = object.position.toArray();
            const scale = object.scale.toArray();
            if (!equalArray(rotation, [
                0,
                0,
                0,
                1
            ])) {
                nodeDef.rotation = rotation;
            }
            if (!equalArray(position, [
                0,
                0,
                0
            ])) {
                nodeDef.translation = position;
            }
            if (!equalArray(scale, [
                1,
                1,
                1
            ])) {
                nodeDef.scale = scale;
            }
        } else {
            if (object.matrixAutoUpdate) {
                object.updateMatrix();
            }
            if (isIdentityMatrix(object.matrix) === false) {
                nodeDef.matrix = object.matrix.elements;
            }
        }
        if (object.name !== "") nodeDef.name = String(object.name);
        this.serializeUserData(object, nodeDef);
        if (object.isMesh || object.isLine || object.isPoints) {
            const meshIndex = this.processMesh(object);
            if (meshIndex !== null) nodeDef.mesh = meshIndex;
        } else if (object.isCamera) {
            nodeDef.camera = this.processCamera(object);
        }
        if (object.isSkinnedMesh) this.skins.push(object);
        if (object.children.length > 0) {
            const children = [];
            for(let i = 0, l = object.children.length; i < l; i++){
                const child = object.children[i];
                if (child.visible || options.onlyVisible === false) {
                    const nodeIndex2 = this.processNode(child);
                    if (nodeIndex2 !== null) children.push(nodeIndex2);
                }
            }
            if (children.length > 0) nodeDef.children = children;
        }
        this._invokeAll(function(ext) {
            ext.writeNode && ext.writeNode(object, nodeDef);
        });
        const nodeIndex = json.nodes.push(nodeDef) - 1;
        nodeMap.set(object, nodeIndex);
        return nodeIndex;
    }
    /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */ processScene(scene) {
        const json = this.json;
        const options = this.options;
        if (!json.scenes) {
            json.scenes = [];
            json.scene = 0;
        }
        const sceneDef = {};
        if (scene.name !== "") sceneDef.name = scene.name;
        json.scenes.push(sceneDef);
        const nodes = [];
        for(let i = 0, l = scene.children.length; i < l; i++){
            const child = scene.children[i];
            if (child.visible || options.onlyVisible === false) {
                const nodeIndex = this.processNode(child);
                if (nodeIndex !== null) nodes.push(nodeIndex);
            }
        }
        if (nodes.length > 0) sceneDef.nodes = nodes;
        this.serializeUserData(scene, sceneDef);
    }
    /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */ processObjects(objects) {
        const scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Scene"]();
        scene.name = "AuxScene";
        for(let i = 0; i < objects.length; i++){
            scene.children.push(objects[i]);
        }
        this.processScene(scene);
    }
    /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */ processInput(input) {
        const options = this.options;
        input = input instanceof Array ? input : [
            input
        ];
        this._invokeAll(function(ext) {
            ext.beforeParse && ext.beforeParse(input);
        });
        const objectsWithoutScene = [];
        for(let i = 0; i < input.length; i++){
            if (input[i] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Scene"]) {
                this.processScene(input[i]);
            } else {
                objectsWithoutScene.push(input[i]);
            }
        }
        if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);
        for(let i = 0; i < this.skins.length; ++i){
            this.processSkin(this.skins[i]);
        }
        for(let i = 0; i < options.animations.length; ++i){
            this.processAnimation(options.animations[i], input[0]);
        }
        this._invokeAll(function(ext) {
            ext.afterParse && ext.afterParse(input);
        });
    }
    _invokeAll(func) {
        for(let i = 0, il = this.plugins.length; i < il; i++){
            func(this.plugins[i]);
        }
    }
}
class GLTFLightExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_lights_punctual";
    }
    writeNode(light, nodeDef) {
        if (!light.isLight) return;
        if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {
            console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
            return;
        }
        const writer = this.writer;
        const json = writer.json;
        const extensionsUsed = writer.extensionsUsed;
        const lightDef = {};
        if (light.name) lightDef.name = light.name;
        lightDef.color = light.color.toArray();
        lightDef.intensity = light.intensity;
        if (light.isDirectionalLight) {
            lightDef.type = "directional";
        } else if (light.isPointLight) {
            lightDef.type = "point";
            if (light.distance > 0) lightDef.range = light.distance;
        } else if (light.isSpotLight) {
            lightDef.type = "spot";
            if (light.distance > 0) lightDef.range = light.distance;
            lightDef.spot = {};
            lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;
            lightDef.spot.outerConeAngle = light.angle;
        }
        if (light.decay !== void 0 && light.decay !== 2) {
            console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.");
        }
        if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
            console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
        }
        if (!extensionsUsed[this.name]) {
            json.extensions = json.extensions || {};
            json.extensions[this.name] = {
                lights: []
            };
            extensionsUsed[this.name] = true;
        }
        const lights = json.extensions[this.name].lights;
        lights.push(lightDef);
        nodeDef.extensions = nodeDef.extensions || {};
        nodeDef.extensions[this.name] = {
            light: lights.length - 1
        };
    }
}
class GLTFMaterialsUnlitExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_unlit";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshBasicMaterial) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = {};
        extensionsUsed[this.name] = true;
        materialDef.pbrMetallicRoughness.metallicFactor = 0;
        materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
    }
}
class GLTFMaterialsClearcoatExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_clearcoat";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.clearcoatFactor = material.clearcoat;
        if (material.clearcoatMap) {
            const clearcoatMapDef = {
                index: writer.processTexture(material.clearcoatMap),
                texCoord: material.clearcoatMap.channel
            };
            writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);
            extensionDef.clearcoatTexture = clearcoatMapDef;
        }
        extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;
        if (material.clearcoatRoughnessMap) {
            const clearcoatRoughnessMapDef = {
                index: writer.processTexture(material.clearcoatRoughnessMap),
                texCoord: material.clearcoatRoughnessMap.channel
            };
            writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);
            extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;
        }
        if (material.clearcoatNormalMap) {
            const clearcoatNormalMapDef = {
                index: writer.processTexture(material.clearcoatNormalMap),
                texCoord: material.clearcoatNormalMap.channel
            };
            writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);
            extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;
        }
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsIridescenceExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_iridescence";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.iridescenceFactor = material.iridescence;
        if (material.iridescenceMap) {
            const iridescenceMapDef = {
                index: writer.processTexture(material.iridescenceMap),
                texCoord: material.iridescenceMap.channel
            };
            writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);
            extensionDef.iridescenceTexture = iridescenceMapDef;
        }
        extensionDef.iridescenceIor = material.iridescenceIOR;
        extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];
        extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];
        if (material.iridescenceThicknessMap) {
            const iridescenceThicknessMapDef = {
                index: writer.processTexture(material.iridescenceThicknessMap),
                texCoord: material.iridescenceThicknessMap.channel
            };
            writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);
            extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;
        }
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsTransmissionExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_transmission";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.transmissionFactor = material.transmission;
        if (material.transmissionMap) {
            const transmissionMapDef = {
                index: writer.processTexture(material.transmissionMap),
                texCoord: material.transmissionMap.channel
            };
            writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);
            extensionDef.transmissionTexture = transmissionMapDef;
        }
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsVolumeExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_volume";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.thicknessFactor = material.thickness;
        if (material.thicknessMap) {
            const thicknessMapDef = {
                index: writer.processTexture(material.thicknessMap),
                texCoord: material.thicknessMap.channel
            };
            writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);
            extensionDef.thicknessTexture = thicknessMapDef;
        }
        extensionDef.attenuationDistance = material.attenuationDistance;
        extensionDef.attenuationColor = material.attenuationColor.toArray();
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsIorExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_ior";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.ior = material.ior;
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsSpecularExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_specular";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        if (material.specularIntensityMap) {
            const specularIntensityMapDef = {
                index: writer.processTexture(material.specularIntensityMap),
                texCoord: material.specularIntensityMap.channel
            };
            writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);
            extensionDef.specularTexture = specularIntensityMapDef;
        }
        if (material.specularColorMap) {
            const specularColorMapDef = {
                index: writer.processTexture(material.specularColorMap),
                texCoord: material.specularColorMap.channel
            };
            writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);
            extensionDef.specularColorTexture = specularColorMapDef;
        }
        extensionDef.specularFactor = material.specularIntensity;
        extensionDef.specularColorFactor = material.specularColor.toArray();
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsSheenExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_sheen";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        if (material.sheenRoughnessMap) {
            const sheenRoughnessMapDef = {
                index: writer.processTexture(material.sheenRoughnessMap),
                texCoord: material.sheenRoughnessMap.channel
            };
            writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);
            extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;
        }
        if (material.sheenColorMap) {
            const sheenColorMapDef = {
                index: writer.processTexture(material.sheenColorMap),
                texCoord: material.sheenColorMap.channel
            };
            writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);
            extensionDef.sheenColorTexture = sheenColorMapDef;
        }
        extensionDef.sheenRoughnessFactor = material.sheenRoughness;
        extensionDef.sheenColorFactor = material.sheenColor.toArray();
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsAnisotropyExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_anisotropy";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        if (material.anisotropyMap) {
            const anisotropyMapDef = {
                index: writer.processTexture(material.anisotropyMap)
            };
            writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);
            extensionDef.anisotropyTexture = anisotropyMapDef;
        }
        extensionDef.anisotropyStrength = material.anisotropy;
        extensionDef.anisotropyRotation = material.anisotropyRotation;
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
class GLTFMaterialsEmissiveStrengthExtension {
    constructor(writer){
        this.writer = writer;
        this.name = "KHR_materials_emissive_strength";
    }
    writeMaterial(material, materialDef) {
        if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;
        const writer = this.writer;
        const extensionsUsed = writer.extensionsUsed;
        const extensionDef = {};
        extensionDef.emissiveStrength = material.emissiveIntensity;
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[this.name] = extensionDef;
        extensionsUsed[this.name] = true;
    }
}
;
 //# sourceMappingURL=GLTFExporter.js.map
}}),
"[project]/node_modules/three-stdlib/exporters/PLYExporter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PLYExporter": (()=>PLYExporter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
;
class PLYExporter {
    parse(object, onDone, options) {
        if (onDone && typeof onDone === "object") {
            console.warn('THREE.PLYExporter: The options parameter is now the third argument to the "parse" function. See the documentation for the new API.');
            options = onDone;
            onDone = void 0;
        }
        const defaultOptions = {
            binary: false,
            excludeAttributes: [],
            // normal, uv, color, index
            littleEndian: false
        };
        options = Object.assign(defaultOptions, options);
        const excludeAttributes = options.excludeAttributes;
        let includeNormals = false;
        let includeColors = false;
        let includeUVs = false;
        let vertexCount = 0;
        let faceCount = 0;
        object.traverse(function(child) {
            if (child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] && child.isMesh) {
                const mesh = child;
                const geometry = mesh.geometry;
                if (!geometry.isBufferGeometry) {
                    throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");
                }
                const vertices = geometry.getAttribute("position");
                const normals = geometry.getAttribute("normal");
                const uvs = geometry.getAttribute("uv");
                const colors = geometry.getAttribute("color");
                const indices = geometry.getIndex();
                if (vertices === void 0) {
                    return;
                }
                vertexCount += vertices.count;
                faceCount += indices ? indices.count / 3 : vertices.count / 3;
                if (normals !== void 0) includeNormals = true;
                if (uvs !== void 0) includeUVs = true;
                if (colors !== void 0) includeColors = true;
            }
        });
        const includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf("index")) === -1;
        includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf("normal")) === -1;
        includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf("color")) === -1;
        includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf("uv")) === -1;
        if (includeIndices && faceCount !== Math.floor(faceCount)) {
            console.error("PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.");
            return null;
        }
        const indexByteCount = 4;
        let header = `ply
format ${options.binary ? options.littleEndian ? "binary_little_endian" : "binary_big_endian" : "ascii"} 1.0
element vertex ${vertexCount}
property float x
property float y
property float z
`;
        if (includeNormals) {
            header += "property float nx\nproperty float ny\nproperty float nz\n";
        }
        if (includeUVs) {
            header += "property float s\nproperty float t\n";
        }
        if (includeColors) {
            header += "property uchar red\nproperty uchar green\nproperty uchar blue\n";
        }
        if (includeIndices) {
            header += `${`element face ${faceCount}
`}property list uchar int vertex_index
`;
        }
        header += "end_header\n";
        const vertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        const normalMatrixWorld = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
        let result = null;
        if (options.binary) {
            const headerBin = new TextEncoder().encode(header);
            const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));
            const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;
            const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));
            new Uint8Array(output.buffer).set(headerBin, 0);
            let vOffset = headerBin.length;
            let fOffset = headerBin.length + vertexListLength;
            let writtenVertices = 0;
            this.traverseMeshes(object, function(mesh, geometry) {
                const vertices = geometry.getAttribute("position");
                const normals = geometry.getAttribute("normal");
                const uvs = geometry.getAttribute("uv");
                const colors = geometry.getAttribute("color");
                const indices = geometry.getIndex();
                normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
                for(let i = 0, l = vertices.count; i < l; i++){
                    vertex.x = vertices.getX(i);
                    vertex.y = vertices.getY(i);
                    vertex.z = vertices.getZ(i);
                    vertex.applyMatrix4(mesh.matrixWorld);
                    output.setFloat32(vOffset, vertex.x, options.littleEndian);
                    vOffset += 4;
                    output.setFloat32(vOffset, vertex.y, options.littleEndian);
                    vOffset += 4;
                    output.setFloat32(vOffset, vertex.z, options.littleEndian);
                    vOffset += 4;
                    if (includeNormals) {
                        if (normals != null) {
                            vertex.x = normals.getX(i);
                            vertex.y = normals.getY(i);
                            vertex.z = normals.getZ(i);
                            vertex.applyMatrix3(normalMatrixWorld).normalize();
                            output.setFloat32(vOffset, vertex.x, options.littleEndian);
                            vOffset += 4;
                            output.setFloat32(vOffset, vertex.y, options.littleEndian);
                            vOffset += 4;
                            output.setFloat32(vOffset, vertex.z, options.littleEndian);
                            vOffset += 4;
                        } else {
                            output.setFloat32(vOffset, 0, options.littleEndian);
                            vOffset += 4;
                            output.setFloat32(vOffset, 0, options.littleEndian);
                            vOffset += 4;
                            output.setFloat32(vOffset, 0, options.littleEndian);
                            vOffset += 4;
                        }
                    }
                    if (includeUVs) {
                        if (uvs != null) {
                            output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);
                            vOffset += 4;
                            output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);
                            vOffset += 4;
                        } else if (!includeUVs) {
                            output.setFloat32(vOffset, 0, options.littleEndian);
                            vOffset += 4;
                            output.setFloat32(vOffset, 0, options.littleEndian);
                            vOffset += 4;
                        }
                    }
                    if (includeColors) {
                        if (colors != null) {
                            output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));
                            vOffset += 1;
                            output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));
                            vOffset += 1;
                            output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));
                            vOffset += 1;
                        } else {
                            output.setUint8(vOffset, 255);
                            vOffset += 1;
                            output.setUint8(vOffset, 255);
                            vOffset += 1;
                            output.setUint8(vOffset, 255);
                            vOffset += 1;
                        }
                    }
                }
                if (includeIndices) {
                    if (indices !== null) {
                        for(let i = 0, l = indices.count; i < l; i += 3){
                            output.setUint8(fOffset, 3);
                            fOffset += 1;
                            output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);
                            fOffset += indexByteCount;
                            output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);
                            fOffset += indexByteCount;
                            output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);
                            fOffset += indexByteCount;
                        }
                    } else {
                        for(let i = 0, l = vertices.count; i < l; i += 3){
                            output.setUint8(fOffset, 3);
                            fOffset += 1;
                            output.setUint32(fOffset, writtenVertices + i, options.littleEndian);
                            fOffset += indexByteCount;
                            output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);
                            fOffset += indexByteCount;
                            output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);
                            fOffset += indexByteCount;
                        }
                    }
                }
                writtenVertices += vertices.count;
            });
            result = output.buffer;
        } else {
            let writtenVertices = 0;
            let vertexList = "";
            let faceList = "";
            this.traverseMeshes(object, function(mesh, geometry) {
                const vertices = geometry.getAttribute("position");
                const normals = geometry.getAttribute("normal");
                const uvs = geometry.getAttribute("uv");
                const colors = geometry.getAttribute("color");
                const indices = geometry.getIndex();
                normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
                for(let i = 0, l = vertices.count; i < l; i++){
                    vertex.x = vertices.getX(i);
                    vertex.y = vertices.getY(i);
                    vertex.z = vertices.getZ(i);
                    vertex.applyMatrix4(mesh.matrixWorld);
                    let line = vertex.x + " " + vertex.y + " " + vertex.z;
                    if (includeNormals) {
                        if (normals != null) {
                            vertex.x = normals.getX(i);
                            vertex.y = normals.getY(i);
                            vertex.z = normals.getZ(i);
                            vertex.applyMatrix3(normalMatrixWorld).normalize();
                            line += " " + vertex.x + " " + vertex.y + " " + vertex.z;
                        } else {
                            line += " 0 0 0";
                        }
                    }
                    if (includeUVs) {
                        if (uvs != null) {
                            line += " " + uvs.getX(i) + " " + uvs.getY(i);
                        } else if (includeUVs) {
                            line += " 0 0";
                        }
                    }
                    if (includeColors) {
                        if (colors != null) {
                            line += " " + Math.floor(colors.getX(i) * 255) + " " + Math.floor(colors.getY(i) * 255) + " " + Math.floor(colors.getZ(i) * 255);
                        } else {
                            line += " 255 255 255";
                        }
                    }
                    vertexList += line + "\n";
                }
                if (includeIndices) {
                    if (indices !== null) {
                        for(let i = 0, l = indices.count; i < l; i += 3){
                            faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;
                            faceList += ` ${indices.getX(i + 1) + writtenVertices}`;
                            faceList += ` ${indices.getX(i + 2) + writtenVertices}
`;
                        }
                    } else {
                        for(let i = 0, l = vertices.count; i < l; i += 3){
                            faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}
`;
                        }
                    }
                    faceCount += indices ? indices.count / 3 : vertices.count / 3;
                }
                writtenVertices += vertices.count;
            });
            result = `${header}${vertexList}${includeIndices ? `${faceList}
` : "\n"}`;
        }
        if (typeof onDone === "function") {
            requestAnimationFrame(()=>onDone && onDone(typeof result === "string" ? result : ""));
        }
        return result;
    }
    // Iterate over the valid meshes in the object
    traverseMeshes(object, cb) {
        object.traverse(function(child) {
            if (child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] && child.isMesh) {
                const mesh = child;
                const geometry = mesh.geometry;
                if (!geometry.isBufferGeometry) {
                    throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");
                }
                if (geometry.hasAttribute("position")) {
                    cb(mesh, geometry);
                }
            }
        });
    }
}
;
 //# sourceMappingURL=PLYExporter.js.map
}}),
"[project]/node_modules/three-stdlib/exporters/DRACOExporter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DRACOExporter": (()=>DRACOExporter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
const DRACOExporter = /* @__PURE__ */ (()=>{
    const _DRACOExporter = class {
        parse(object, options = {
            decodeSpeed: 5,
            encodeSpeed: 5,
            encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,
            quantization: [
                16,
                8,
                8,
                8,
                8
            ],
            exportUvs: true,
            exportNormals: true,
            exportColor: false
        }) {
            if (object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferGeometry"] && object.isBufferGeometry) {
                throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");
            }
            if (DracoEncoderModule === void 0) {
                throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");
            }
            const geometry = object.geometry;
            const dracoEncoder = DracoEncoderModule();
            const encoder = new dracoEncoder.Encoder();
            let builder;
            let dracoObject;
            if (!geometry.isBufferGeometry) {
                throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");
            }
            if (object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] && object.isMesh) {
                builder = new dracoEncoder.MeshBuilder();
                dracoObject = new dracoEncoder.Mesh();
                const vertices = geometry.getAttribute("position");
                builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
                const faces = geometry.getIndex();
                if (faces !== null) {
                    builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);
                } else {
                    const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);
                    for(let i = 0; i < faces2.length; i++){
                        faces2[i] = i;
                    }
                    builder.AddFacesToMesh(dracoObject, vertices.count, faces2);
                }
                if (options.exportNormals) {
                    const normals = geometry.getAttribute("normal");
                    if (normals !== void 0) {
                        builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);
                    }
                }
                if (options.exportUvs) {
                    const uvs = geometry.getAttribute("uv");
                    if (uvs !== void 0) {
                        builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);
                    }
                }
                if (options.exportColor) {
                    const colors = geometry.getAttribute("color");
                    if (colors !== void 0) {
                        builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
                    }
                }
            } else if (object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Points"] && object.isPoints) {
                builder = new dracoEncoder.PointCloudBuilder();
                dracoObject = new dracoEncoder.PointCloud();
                const vertices = geometry.getAttribute("position");
                builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
                if (options.exportColor) {
                    const colors = geometry.getAttribute("color");
                    if (colors !== void 0) {
                        builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
                    }
                }
            } else {
                throw new Error("DRACOExporter: Unsupported object type.");
            }
            const encodedData = new dracoEncoder.DracoInt8Array();
            const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;
            const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;
            encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);
            if (options.encoderMethod !== void 0) {
                encoder.SetEncodingMethod(options.encoderMethod);
            }
            if (options.quantization !== void 0) {
                for(let i = 0; i < 5; i++){
                    if (options.quantization[i] !== void 0) {
                        encoder.SetAttributeQuantization(i, options.quantization[i]);
                    }
                }
            }
            let length;
            if (object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] && object.isMesh) {
                length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);
            } else {
                length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);
            }
            dracoEncoder.destroy(dracoObject);
            if (length === 0) {
                throw new Error("THREE.DRACOExporter: Draco encoding failed.");
            }
            const outputData = new Int8Array(new ArrayBuffer(length));
            for(let i = 0; i < length; i++){
                outputData[i] = encodedData.GetValue(i);
            }
            dracoEncoder.destroy(encodedData);
            dracoEncoder.destroy(encoder);
            dracoEncoder.destroy(builder);
            return outputData;
        }
    };
    let DRACOExporter2 = _DRACOExporter;
    // Encoder methods
    __publicField(DRACOExporter2, "MESH_EDGEBREAKER_ENCODING", 1);
    __publicField(DRACOExporter2, "MESH_SEQUENTIAL_ENCODING", 0);
    // Geometry type
    __publicField(DRACOExporter2, "POINT_CLOUD", 0);
    __publicField(DRACOExporter2, "TRIANGULAR_MESH", 1);
    // Attribute type
    __publicField(DRACOExporter2, "INVALID", -1);
    __publicField(DRACOExporter2, "POSITION", 0);
    __publicField(DRACOExporter2, "NORMAL", 1);
    __publicField(DRACOExporter2, "COLOR", 2);
    __publicField(DRACOExporter2, "TEX_COORD", 3);
    __publicField(DRACOExporter2, "GENERIC", 4);
    return DRACOExporter2;
})();
;
 //# sourceMappingURL=DRACOExporter.js.map
}}),
"[project]/node_modules/three-stdlib/exporters/ColladaExporter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ColladaExporter": (()=>ColladaExporter)
});
(()=>{
    const e = new Error("Cannot find module '../_polyfill/uv1.js'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
class ColladaExporter {
    constructor(){
        __publicField(this, "options");
        __publicField(this, "geometryInfo");
        __publicField(this, "materialMap");
        __publicField(this, "imageMap");
        __publicField(this, "textures");
        __publicField(this, "libraryImages");
        __publicField(this, "libraryGeometries");
        __publicField(this, "libraryEffects");
        __publicField(this, "libraryMaterials");
        __publicField(this, "canvas");
        __publicField(this, "ctx");
        __publicField(this, "transMat");
        __publicField(this, "getFuncs", [
            "getX",
            "getY",
            "getZ",
            "getW"
        ]);
        this.options = {
            version: "1.4.1",
            author: null,
            textureDirectory: "",
            upAxis: "Y_UP",
            unitName: null,
            unitMeter: null
        };
        this.geometryInfo = /* @__PURE__ */ new WeakMap();
        this.materialMap = /* @__PURE__ */ new WeakMap();
        this.imageMap = /* @__PURE__ */ new WeakMap();
        this.textures = [];
        this.libraryImages = [];
        this.libraryGeometries = [];
        this.libraryEffects = [];
        this.libraryMaterials = [];
        this.canvas = null;
        this.ctx = null;
        this.transMat = null;
    }
    parse(object, onDone, options = {}) {
        this.options = {
            ...this.options,
            ...options
        };
        if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {
            console.error("ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.");
            return null;
        }
        if (this.options.unitName !== null && this.options.unitMeter === null) {
            console.error("ColladaExporter: unitMeter needs to be specified if unitName is specified.");
            return null;
        }
        if (this.options.unitMeter !== null && this.options.unitName === null) {
            console.error("ColladaExporter: unitName needs to be specified if unitMeter is specified.");
            return null;
        }
        if (this.options.textureDirectory !== "") {
            this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\/g, "/").replace(/\/+/g, "/");
        }
        if (this.options.version !== "1.4.1" && this.options.version !== "1.5.0") {
            console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);
            return null;
        }
        const libraryVisualScenes = this.processObject(object);
        const specLink = this.options.version === "1.4.1" ? "http://www.collada.org/2005/11/COLLADASchema" : "https://www.khronos.org/collada/";
        let dae = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?>${`<COLLADA xmlns="${specLink}" version="${this.options.version}">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : ""}</contributor>${`<created>${/* @__PURE__ */ new Date().toISOString()}</created>`}${`<modified>${/* @__PURE__ */ new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;
        dae += `<library_images>${this.libraryImages.join("")}</library_images>`;
        dae += `<library_effects>${this.libraryEffects.join("")}</library_effects>`;
        dae += `<library_materials>${this.libraryMaterials.join("")}</library_materials>`;
        dae += `<library_geometries>${this.libraryGeometries.join("")}</library_geometries>`;
        dae += `<library_visual_scenes><visual_scene id="Scene" name="scene">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;
        dae += '<scene><instance_visual_scene url="#Scene"/></scene>';
        dae += "</COLLADA>";
        const res = {
            data: this.format(dae),
            textures: this.textures
        };
        if (typeof onDone === "function") {
            requestAnimationFrame(()=>onDone(res));
        }
        return res;
    }
    // Convert the urdf xml into a well-formatted, indented format
    format(urdf) {
        var _a, _b;
        const IS_END_TAG = /^<\//;
        const IS_SELF_CLOSING = /(\?>$)|(\/>$)/;
        const HAS_TEXT = /<[^>]+>[^<]*<\/[^<]+>/;
        const pad = (ch, num)=>num > 0 ? ch + pad(ch, num - 1) : "";
        let tagnum = 0;
        return (_b = (_a = urdf.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g)) == null ? void 0 : _a.map((tag)=>{
            if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {
                tagnum--;
            }
            const res = `${pad("  ", tagnum)}${tag}`;
            if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {
                tagnum++;
            }
            return res;
        }).join("\n")) != null ? _b : "";
    }
    // Convert an image into a png format for saving
    base64ToBuffer(str) {
        const b = atob(str);
        const buf = new Uint8Array(b.length);
        for(let i = 0, l = buf.length; i < l; i++){
            buf[i] = b.charCodeAt(i);
        }
        return buf;
    }
    imageToData(image, ext) {
        var _a;
        this.canvas = this.canvas || document.createElement("canvas");
        this.ctx = this.ctx || this.canvas.getContext("2d");
        this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;
        this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;
        (_a = this.ctx) == null ? void 0 : _a.drawImage(image, 0, 0);
        const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\/(png|jpg);base64,/, "");
        return this.base64ToBuffer(base64data);
    }
    // gets the attribute array. Generate a new array if the attribute is interleaved
    attrBufferToArray(attr) {
        if (attr instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterleavedBufferAttribute"] && attr.isInterleavedBufferAttribute) {
            const TypedArrayConstructor = attr.array.constructor;
            const arr = new TypedArrayConstructor(attr.count * attr.itemSize);
            const size = attr.itemSize;
            for(let i = 0, l = attr.count; i < l; i++){
                for(let j = 0; j < size; j++){
                    arr[i * size + j] = attr[this.getFuncs[j]](i);
                }
            }
            return arr;
        } else {
            return attr.array;
        }
    }
    // Returns an array of the same type starting at the `st` index,
    // and `ct` length
    subArray(arr, st, ct) {
        if (Array.isArray(arr)) {
            return arr.slice(st, st + ct);
        } else {
            const TypedArrayConstructor = arr.constructor;
            return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);
        }
    }
    // Returns the string for a geometry's attribute
    getAttribute(attr, name, params, type) {
        const array = this.attrBufferToArray(attr);
        const res = Array.isArray(array) ? `${`<source id="${name}"><float_array id="${name}-array" count="${array.length}">` + array.join(" ")}</float_array><technique_common>${`<accessor source="#${name}-array" count="${Math.floor(array.length / attr.itemSize)}" stride="${attr.itemSize}">`}${params.map((n)=>`<param name="${n}" type="${type}" />`).join("")}</accessor></technique_common></source>` : "";
        return res;
    }
    // Returns the string for a node's transform information
    getTransform(o) {
        o.updateMatrix();
        this.transMat = this.transMat || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix4"]();
        this.transMat.copy(o.matrix);
        this.transMat.transpose();
        return `<matrix>${this.transMat.toArray().join(" ")}</matrix>`;
    }
    // Process the given piece of geometry into the geometry library
    // Returns the mesh id
    processGeometry(g) {
        let info = this.geometryInfo.get(g);
        if (!info) {
            const bufferGeometry = g;
            if (!bufferGeometry.isBufferGeometry) {
                throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");
            }
            const meshid = `Mesh${this.libraryGeometries.length + 1}`;
            const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;
            const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [
                {
                    start: 0,
                    count: indexCount,
                    materialIndex: 0
                }
            ];
            const gname = g.name ? ` name="${g.name}"` : "";
            let gnode = `<geometry id="${meshid}"${gname}><mesh>`;
            const posName = `${meshid}-position`;
            const vertName = `${meshid}-vertices`;
            gnode += this.getAttribute(bufferGeometry.attributes.position, posName, [
                "X",
                "Y",
                "Z"
            ], "float");
            gnode += `<vertices id="${vertName}"><input semantic="POSITION" source="#${posName}" /></vertices>`;
            let triangleInputs = `<input semantic="VERTEX" source="#${vertName}" offset="0" />`;
            if ("normal" in bufferGeometry.attributes) {
                const normName = `${meshid}-normal`;
                gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, [
                    "X",
                    "Y",
                    "Z"
                ], "float");
                triangleInputs += `<input semantic="NORMAL" source="#${normName}" offset="0" />`;
            }
            if ("uv" in bufferGeometry.attributes) {
                const uvName = `${meshid}-texcoord`;
                gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, [
                    "S",
                    "T"
                ], "float");
                triangleInputs += `<input semantic="TEXCOORD" source="#${uvName}" offset="0" set="0" />`;
            }
            if (UV1 in bufferGeometry.attributes) {
                const uvName = `${meshid}-texcoord2`;
                gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, [
                    "S",
                    "T"
                ], "float");
                triangleInputs += `<input semantic="TEXCOORD" source="#${uvName}" offset="0" set="1" />`;
            }
            if ("color" in bufferGeometry.attributes) {
                const colName = `${meshid}-color`;
                gnode += this.getAttribute(bufferGeometry.attributes.color, colName, [
                    "X",
                    "Y",
                    "Z"
                ], "uint8");
                triangleInputs += `<input semantic="COLOR" source="#${colName}" offset="0" />`;
            }
            let indexArray = null;
            if (bufferGeometry.index) {
                indexArray = this.attrBufferToArray(bufferGeometry.index);
            } else {
                indexArray = new Array(indexCount);
                for(let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++)indexArray[i] = i;
            }
            for(let i = 0, l = groups.length; i < l; i++){
                const group = groups[i];
                const subarr = this.subArray(indexArray, group.start, group.count);
                const polycount = subarr.length / 3;
                gnode += `<triangles material="MESH_MATERIAL_${group.materialIndex}" count="${polycount}">`;
                gnode += triangleInputs;
                gnode += `<p>${subarr.join(" ")}</p>`;
                gnode += "</triangles>";
            }
            gnode += "</mesh></geometry>";
            this.libraryGeometries.push(gnode);
            info = {
                meshid,
                bufferGeometry
            };
            this.geometryInfo.set(g, info);
        }
        return info;
    }
    // Process the given texture into the image library
    // Returns the image library
    processTexture(tex) {
        let texid = this.imageMap.get(tex);
        if (texid == null) {
            texid = `image-${this.libraryImages.length + 1}`;
            const ext = "png";
            const name = tex.name || texid;
            let imageNode = `<image id="${texid}" name="${name}">`;
            if (this.options.version === "1.5.0") {
                imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;
            } else {
                imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;
            }
            imageNode += "</image>";
            this.libraryImages.push(imageNode);
            this.imageMap.set(tex, texid);
            this.textures.push({
                directory: this.options.textureDirectory,
                name,
                ext,
                data: this.imageToData(tex.image, ext),
                original: tex
            });
        }
        return texid;
    }
    // Process the given material into the material and effect libraries
    // Returns the material id
    processMaterial(m) {
        let matid = this.materialMap.get(m);
        if (matid == null) {
            matid = `Mat${this.libraryEffects.length + 1}`;
            let type = "phong";
            if (m instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshLambertMaterial"]) {
                type = "lambert";
            } else if (m instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]) {
                type = "constant";
                if (m.map !== null) {
                    console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial.");
                }
            }
            if (m instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshPhongMaterial"]) {
                const emissive = m.emissive ? m.emissive : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"](0, 0, 0);
                const diffuse = m.color ? m.color : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"](0, 0, 0);
                const specular = m.specular ? m.specular : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"](1, 1, 1);
                const shininess = m.shininess || 0;
                const reflectivity = m.reflectivity || 0;
                let transparencyNode = "";
                if (m.transparent) {
                    transparencyNode += `<transparent>${m.map ? '<texture texture="diffuse-sampler"></texture>' : "<float>1</float>"}</transparent>`;
                    if (m.opacity < 1) {
                        transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;
                    }
                }
                const techniqueNode = `${`<technique sid="common"><${type}>`}<emission>${m.emissiveMap ? '<texture texture="emissive-sampler" texcoord="TEXCOORD" />' : `<color sid="emission">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== "constant" ? `<diffuse>${m.map ? '<texture texture="diffuse-sampler" texcoord="TEXCOORD" />' : `<color sid="diffuse">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ""}${type !== "constant" ? `<bump>${m.normalMap ? '<texture texture="bump-sampler" texcoord="TEXCOORD" />' : ""}</bump>` : ""}${type === "phong" ? `${`<specular><color sid="specular">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture="specular-sampler" texcoord="TEXCOORD" />' : `<float sid="shininess">${shininess}</float>`}</shininess>` : ""}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;
                const effectnode = `${`<effect id="${matid}-effect">`}<profile_COMMON>${m.map ? `<newparam sid="diffuse-surface"><surface type="2D">${`<init_from>${this.processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ""}${m.specularMap ? `<newparam sid="specular-surface"><surface type="2D">${`<init_from>${this.processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ""}${m.emissiveMap ? `<newparam sid="emissive-surface"><surface type="2D">${`<init_from>${this.processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ""}${m.normalMap ? `<newparam sid="bump-surface"><surface type="2D">${`<init_from>${this.processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ""}${techniqueNode}${m.side === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DoubleSide"] ? '<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>' : ""}</profile_COMMON></effect>`;
                const materialName = m.name ? ` name="${m.name}"` : "";
                const materialNode = `<material id="${matid}"${materialName}><instance_effect url="#${matid}-effect" /></material>`;
                this.libraryMaterials.push(materialNode);
                this.libraryEffects.push(effectnode);
                this.materialMap.set(m, matid);
            }
        }
        return matid;
    }
    // Recursively process the object into a scene
    processObject(o) {
        let node = `<node name="${o.name}">`;
        node += this.getTransform(o);
        const a = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"]();
        a.geometry;
        if (o instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] && o.isMesh && o.geometry !== null) {
            const geomInfo = this.processGeometry(o.geometry);
            const meshid = geomInfo.meshid;
            const geometry = geomInfo.bufferGeometry;
            let matids = null;
            let matidsArray;
            const mat = o.material || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]();
            const materials = Array.isArray(mat) ? mat : [
                mat
            ];
            if (geometry.groups.length > materials.length) {
                matidsArray = new Array(geometry.groups.length);
            } else {
                matidsArray = new Array(materials.length);
            }
            matids = matidsArray.fill(null).map((_, i)=>this.processMaterial(materials[i % materials.length]));
            node += `${`<instance_geometry url="#${meshid}">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i)=>`${`<instance_material symbol="MESH_MATERIAL_${i}" target="#${id}" >`}<bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`).join("")}</technique_common></bind_material>` : "")}</instance_geometry>`;
        }
        o.children.forEach((c)=>node += this.processObject(c));
        node += "</node>";
        return node;
    }
}
;
 //# sourceMappingURL=ColladaExporter.js.map
}}),
"[project]/node_modules/three-stdlib/exporters/MMDExporter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MMDExporter": (()=>MMDExporter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$mmdparser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three-stdlib/libs/mmdparser.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
;
class MMDExporter {
    constructor(){
        // Unicode to Shift_JIS table
        __publicField(this, "u2sTable");
    }
    /* TODO: implement
  // mesh -> pmd
  this.parsePmd = function ( object ) {
  };
  */ /* TODO: implement
  // mesh -> pmx
  this.parsePmx = function ( object ) {
  };
  */ /* TODO: implement
  // animation + skeleton -> vmd
  this.parseVmd = function ( object ) {
  };
  */ /*
   * skeleton -> vpd
   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.
   */ parseVpd(skin, outputShiftJis, useOriginalBones) {
        if (skin.isSkinnedMesh !== true) {
            console.warn("THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.");
            return null;
        }
        function toStringsFromNumber(num) {
            if (Math.abs(num) < 1e-6) num = 0;
            let a = num.toString();
            if (a.indexOf(".") === -1) {
                a += ".";
            }
            a += "000000";
            const index = a.indexOf(".");
            const d = a.slice(0, index);
            const p = a.slice(index + 1, index + 7);
            return d + "." + p;
        }
        function toStringsFromArray(array2) {
            const a = [];
            for(let i = 0, il = array2.length; i < il; i++){
                a.push(toStringsFromNumber(array2[i]));
            }
            return a.join(",");
        }
        skin.updateMatrixWorld(true);
        const bones = skin.skeleton.bones;
        const bones2 = this.getBindBones(skin);
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        const quaternion = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Quaternion"]();
        const quaternion2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Quaternion"]();
        const matrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix4"]();
        const array = [];
        array.push("Vocaloid Pose Data file");
        array.push("");
        array.push((skin.name !== "" ? skin.name.replace(/\s/g, "_") : "skin") + ".osm;");
        array.push(bones.length + ";");
        array.push("");
        for(let i = 0, il = bones.length; i < il; i++){
            const bone = bones[i];
            const bone2 = bones2[i];
            if (useOriginalBones === true && bone.userData.ik !== void 0 && bone.userData.ik.originalMatrix !== void 0) {
                matrix.fromArray(bone.userData.ik.originalMatrix);
            } else {
                matrix.copy(bone.matrix);
            }
            position.setFromMatrixPosition(matrix);
            quaternion.setFromRotationMatrix(matrix);
            const pArray = position.sub(bone2.position).toArray();
            const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();
            pArray[2] = -pArray[2];
            qArray[0] = -qArray[0];
            qArray[1] = -qArray[1];
            array.push("Bone" + i + "{" + bone.name);
            array.push("  " + toStringsFromArray(pArray) + ";");
            array.push("  " + toStringsFromArray(qArray) + ";");
            array.push("}");
            array.push("");
        }
        array.push("");
        const lines = array.join("\n");
        return outputShiftJis === true ? this.unicodeToShiftjis(lines) : lines;
    }
    unicodeToShiftjis(str) {
        if (this.u2sTable === void 0) {
            const encoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$libs$2f$mmdparser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CharsetEncoder"]();
            const table = encoder.s2uTable;
            this.u2sTable = {};
            const keys = Object.keys(table);
            for(let i = 0, il = keys.length; i < il; i++){
                let key = keys[i];
                const value = table[key];
                this.u2sTable[value] = parseInt(key);
            }
        }
        const array = [];
        for(let i = 0, il = str.length; i < il; i++){
            const code = str.charCodeAt(i);
            const value = this.u2sTable[code];
            if (value === void 0) {
                throw "cannot convert charcode 0x" + code.toString(16);
            } else if (value > 255) {
                array.push(value >> 8 & 255);
                array.push(value & 255);
            } else {
                array.push(value & 255);
            }
        }
        return new Uint8Array(array);
    }
    getBindBones(skin) {
        const poseSkin = skin.clone();
        poseSkin.pose();
        return poseSkin.skeleton.bones;
    }
}
;
 //# sourceMappingURL=MMDExporter.js.map
}}),
"[project]/node_modules/three-stdlib/exporters/OBJExporter.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "OBJExporter": (()=>OBJExporter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
;
class OBJExporter {
    constructor(){
        __publicField(this, "output");
        __publicField(this, "indexVertex");
        __publicField(this, "indexVertexUvs");
        __publicField(this, "indexNormals");
        __publicField(this, "vertex");
        __publicField(this, "color");
        __publicField(this, "normal");
        __publicField(this, "uv");
        __publicField(this, "face");
        this.output = "";
        this.indexVertex = 0;
        this.indexVertexUvs = 0;
        this.indexNormals = 0;
        this.vertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        this.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color"]();
        this.normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        this.uv = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
        this.face = [];
    }
    parse(object) {
        object.traverse((child)=>{
            if (child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] && child.isMesh) {
                this.parseMesh(child);
            }
            if (child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Line"] && child.isLine) {
                this.parseLine(child);
            }
            if (child instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Points"] && child.isPoints) {
                this.parsePoints(child);
            }
        });
        return this.output;
    }
    parseMesh(mesh) {
        let nbVertex = 0;
        let nbNormals = 0;
        let nbVertexUvs = 0;
        const geometry = mesh.geometry;
        const normalMatrixWorld = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
        if (!geometry.isBufferGeometry) {
            throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");
        }
        const vertices = geometry.getAttribute("position");
        const normals = geometry.getAttribute("normal");
        const uvs = geometry.getAttribute("uv");
        const indices = geometry.getIndex();
        this.output += `o ${mesh.name}
`;
        if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {
            this.output += `usemtl ${mesh.material.name}
`;
        }
        if (vertices !== void 0) {
            for(let i = 0, l = vertices.count; i < l; i++, nbVertex++){
                this.vertex.x = vertices.getX(i);
                this.vertex.y = vertices.getY(i);
                this.vertex.z = vertices.getZ(i);
                this.vertex.applyMatrix4(mesh.matrixWorld);
                this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}
`;
            }
        }
        if (uvs !== void 0) {
            for(let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++){
                this.uv.x = uvs.getX(i);
                this.uv.y = uvs.getY(i);
                this.output += `vt ${this.uv.x} ${this.uv.y}
`;
            }
        }
        if (normals !== void 0) {
            normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);
            for(let i = 0, l = normals.count; i < l; i++, nbNormals++){
                this.normal.x = normals.getX(i);
                this.normal.y = normals.getY(i);
                this.normal.z = normals.getZ(i);
                this.normal.applyMatrix3(normalMatrixWorld).normalize();
                this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}
`;
            }
        }
        if (indices !== null) {
            for(let i = 0, l = indices.count; i < l; i += 3){
                for(let m = 0; m < 3; m++){
                    const j = indices.getX(i + m) + 1;
                    this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : ""}${normals ? `/${this.indexNormals + j}` : ""}` : "");
                }
                this.output += `f ${this.face.join(" ")}
`;
            }
        } else {
            for(let i = 0, l = vertices.count; i < l; i += 3){
                for(let m = 0; m < 3; m++){
                    const j = i + m + 1;
                    this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : ""}${normals ? `/${this.indexNormals + j}` : ""}` : "");
                }
                this.output += `f ${this.face.join(" ")}
`;
            }
        }
        this.indexVertex += nbVertex;
        this.indexVertexUvs += nbVertexUvs;
        this.indexNormals += nbNormals;
    }
    parseLine(line) {
        let nbVertex = 0;
        const geometry = line.geometry;
        const type = line.type;
        if (geometry.isBufferGeometry) {
            throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");
        }
        const vertices = geometry.getAttribute("position");
        this.output += `o ${line.name}
`;
        if (vertices !== void 0) {
            for(let i = 0, l = vertices.count; i < l; i++, nbVertex++){
                this.vertex.x = vertices.getX(i);
                this.vertex.y = vertices.getY(i);
                this.vertex.z = vertices.getZ(i);
                this.vertex.applyMatrix4(line.matrixWorld);
                this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}
`;
            }
        }
        if (type === "Line") {
            this.output += "l ";
            for(let j = 1, l = vertices.count; j <= l; j++){
                this.output += `${this.indexVertex + j} `;
            }
            this.output += "\n";
        }
        if (type === "LineSegments") {
            for(let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1){
                this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}
`;
            }
        }
        this.indexVertex += nbVertex;
    }
    parsePoints(points) {
        let nbVertex = 0;
        const geometry = points.geometry;
        if (!geometry.isBufferGeometry) {
            throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");
        }
        const vertices = geometry.getAttribute("position");
        const colors = geometry.getAttribute("color");
        this.output += `o ${points.name}
`;
        if (vertices !== void 0) {
            for(let i = 0, l = vertices.count; i < l; i++, nbVertex++){
                this.vertex.fromBufferAttribute(vertices, i);
                this.vertex.applyMatrix4(points.matrixWorld);
                this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`;
                if (colors !== void 0 && colors instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferAttribute"]) {
                    this.color.fromBufferAttribute(colors, i);
                    this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`;
                }
                this.output += "\n";
            }
        }
        this.output += "p ";
        for(let j = 1, l = vertices.count; j <= l; j++){
            this.output += `${this.indexVertex + j} `;
        }
        this.output += "\n";
        this.indexVertex += nbVertex;
    }
}
;
 //# sourceMappingURL=OBJExporter.js.map
}}),

};

//# sourceMappingURL=node_modules_three-stdlib_exporters_2b2895._.js.map