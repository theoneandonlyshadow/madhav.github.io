{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/exporters/GLTFExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { PropertyBinding, InterpolateLinear, Color, Vector3, CompressedTexture, Texture, MathUtils, RGBAFormat, DoubleSide, BufferAttribute, InterpolateDiscrete, Matrix4, Scene, PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, WebGLRenderer, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer();\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n  return `data:${blob.type || \"\"};base64,${data}`;\n}\nlet _renderer;\nlet fullscreenQuadGeometry;\nlet fullscreenQuadMaterial;\nlet fullscreenQuad;\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry)\n    fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: (\n        /* glsl */\n        `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `\n      )\n    });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  const _camera = new PerspectiveCamera();\n  const _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  const readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    \"byte\",\n    \"byte normalized\",\n    \"unsigned byte\",\n    \"unsigned byte normalized\",\n    \"short\",\n    \"short normalized\",\n    \"unsigned short\",\n    \"unsigned short normalized\"\n  ],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nconst GLTFExporter = /* @__PURE__ */ (() => {\n  class GLTFExporter2 {\n    constructor() {\n      this.pluginCallbacks = [];\n      this.register(function(writer) {\n        return new GLTFLightExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsUnlitExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsTransmissionExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsVolumeExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsIorExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsSpecularExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsClearcoatExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsIridescenceExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsSheenExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsAnisotropyExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsEmissiveStrengthExtension(writer);\n      });\n    }\n    register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n    unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n    parse(input, onDone, onError, options) {\n      const writer = new GLTFWriter();\n      const plugins = [];\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n    parseAsync(input, options) {\n      const scope = this;\n      return new Promise(function(resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }\n  /**\n   * Static utility functions\n   */\n  __publicField(GLTFExporter2, \"Utils\", {\n    insertKeyframe: function(track, time) {\n      const tolerance = 1e-3;\n      const valueSize = track.getValueSize();\n      const times = new track.TimeBufferType(track.times.length + 1);\n      const values = new track.ValueBufferType(track.values.length + valueSize);\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n      let index;\n      if (track.times.length === 0) {\n        times[0] = time;\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0;\n        }\n        index = 0;\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance)\n          return 0;\n        times[0] = time;\n        times.set(track.times, 1);\n        values.set(interpolant.evaluate(time), 0);\n        values.set(track.values, valueSize);\n        index = 0;\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1;\n        }\n        times[times.length - 1] = time;\n        times.set(track.times, 0);\n        values.set(track.values, 0);\n        values.set(interpolant.evaluate(time), track.values.length);\n        index = times.length - 1;\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance)\n            return i;\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0);\n            times[i + 1] = time;\n            times.set(track.times.slice(i + 1), i + 2);\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n            index = i + 1;\n            break;\n          }\n        }\n      }\n      track.times = times;\n      track.values = values;\n      return index;\n    },\n    mergeMorphTargetTracks: function(clip, root) {\n      const tracks = [];\n      const mergedTracks = {};\n      const sourceTracks = clip.tracks;\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i];\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n        if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n          tracks.push(sourceTrack);\n          continue;\n        }\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n          }\n          console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n          sourceTrack = sourceTrack.clone();\n          sourceTrack.setInterpolation(InterpolateLinear);\n        }\n        const targetCount = sourceTrackNode.morphTargetInfluences.length;\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n        if (targetIndex === void 0) {\n          throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n        }\n        let mergedTrack;\n        if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n          mergedTrack = sourceTrack.clone();\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\n          }\n          mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n          mergedTrack.values = values;\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n          tracks.push(mergedTrack);\n          continue;\n        }\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n        mergedTrack = mergedTracks[sourceTrackNode.uuid];\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n        }\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n        }\n      }\n      clip.tracks = tracks;\n      return clip;\n    }\n  });\n  return GLTFExporter2;\n})();\nconst WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nconst DEFAULT_SPECULAR_COLOR = /* @__PURE__ */ new Color();\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 1179937895;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 1313821514;\nconst GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function(element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0)\n          value = attribute.getX(i);\n        else if (a === 1)\n          value = attribute.getY(i);\n        else if (a === 2)\n          value = attribute.getZ(i);\n        else if (a === 3)\n          value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality\n  });\n}\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */ new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */ new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */ new Map(),\n      attributes: /* @__PURE__ */ new Map(),\n      attributesNormalized: /* @__PURE__ */ new Map(),\n      materials: /* @__PURE__ */ new Map(),\n      textures: /* @__PURE__ */ new Map(),\n      images: /* @__PURE__ */ new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      },\n      options\n    );\n    if (this.options.animations.length > 0) {\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n    const blob = new Blob(buffers, { type: \"application/octet-stream\" });\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0)\n      json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0)\n      json.extensionsRequired = extensionsRequiredList;\n    if (json.buffers && json.buffers.length > 0)\n      json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      blob.arrayBuffer().then((result) => {\n        const binaryChunk = getPaddedArrayBuffer(result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: \"application/octet-stream\"\n        });\n        glbBlob.arrayBuffer().then(onDone);\n      });\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then((uri) => {\n          json.buffers[0].uri = uri;\n          onDone(json);\n        });\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0)\n      return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === void 0)\n          objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0)\n        objectDef.extras = json;\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message\n      );\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids2 = /* @__PURE__ */ new Map();\n      uids2.set(true, this.uid++);\n      uids2.set(false, this.uid++);\n      this.uids.set(attribute, uids2);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        v.setX(1);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n      this.extensionsUsed[\"KHR_texture_transform\"] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap)\n      return metalnessMap;\n    function getEncodingConversion(map) {\n      if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    context.fillStyle = \"#00ffff\";\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Texture(canvas).source;\n    if (\"colorSpace\" in texture)\n      texture.colorSpace = \"\";\n    else\n      texture.encoding = 3e3;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n    }\n    return texture;\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers)\n      json.buffers = [{ byteLength: 0 }];\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    let byteStride = attribute.itemSize * componentSize;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      byteStride = Math.ceil(byteStride / 4) * 4;\n    }\n    const byteLength = getPaddedBufferSize(count * byteStride);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0)\n            value = attribute.getX(i);\n          else if (a === 1)\n            value = attribute.getY(i);\n          else if (a === 2)\n            value = attribute.getZ(i);\n          else if (a === 3)\n            value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n      if (offset % byteStride !== 0) {\n        offset += byteStride - offset % byteStride;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength\n    };\n    if (target !== void 0)\n      bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      bufferViewDef.byteStride = byteStride;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    return blob.arrayBuffer().then((result) => {\n      const buffer = getPaddedArrayBuffer(result);\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength\n      };\n      writer.byteOffset += buffer.byteLength;\n      return json.bufferViews.push(bufferViewDef) - 1;\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let componentType;\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\n        \"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name\n      );\n    }\n    if (start === void 0)\n      start = 0;\n    if (count === void 0)\n      count = attribute.count;\n    if (count === 0)\n      return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n    if (geometry !== void 0) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType,\n      count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true)\n      accessorDef.normalized = true;\n    if (!json.accessors)\n      json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = \"image/png\") {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image))\n        cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + \":flipY/\" + flipY.toString();\n      if (cachedImages[key] !== void 0)\n        return cachedImages[key];\n      if (!json.images)\n        json.images = [];\n      const imageDef = { mimeType };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext(\"2d\");\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== void 0) {\n        if (format !== RGBAFormat) {\n          console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType).then((blob) => writer.processBufferViewImage(blob)).then((bufferViewIndex) => {\n            imageDef.bufferView = bufferViewIndex;\n          })\n        );\n      } else {\n        if (canvas.toDataURL !== void 0) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType).then(readAsDataURL).then((uri) => {\n              imageDef.uri = uri;\n            })\n          );\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n    }\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers)\n      json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map))\n      return cache.textures.get(map);\n    if (!json.textures)\n      json.textures = [];\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === \"image/webp\")\n      mimeType = \"image/png\";\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name)\n      textureDef.name = map.name;\n    this._invokeAll(function(ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material))\n      return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n      return null;\n    }\n    if (!json.materials)\n      json.materials = [];\n    const materialDef = { pbrMetallicRoughness: {} };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    }\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n    if (material.transparent) {\n      materialDef.alphaMode = \"BLEND\";\n    } else {\n      if (material.alphaTest > 0) {\n        materialDef.alphaMode = \"MASK\";\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n    if (material.side === DoubleSide)\n      materialDef.doubleSided = true;\n    if (material.name !== \"\")\n      materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function(ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(\":\");\n    if (cache.meshes.has(meshCacheKey))\n      return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n    const nameConversion = {\n      ...version >= 152 ? {\n        uv: \"TEXCOORD_0\",\n        uv1: \"TEXCOORD_1\",\n        uv2: \"TEXCOORD_2\",\n        uv3: \"TEXCOORD_3\"\n      } : {\n        uv: \"TEXCOORD_0\",\n        uv2: \"TEXCOORD_1\"\n      },\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    };\n    const originalNormal = geometry.getAttribute(\"normal\");\n    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n      geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n    }\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      if (attributeName.slice(0, 5) === \"morph\")\n        continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName))\n        attributeName = \"_\" + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith(\"_\")) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== void 0)\n      geometry.setAttribute(\"normal\", originalNormal);\n    if (Object.keys(attributes).length === 0)\n      return null;\n    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== void 0) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          if (attributeName !== \"position\" && attributeName !== \"normal\") {\n            if (!warned) {\n              console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0)\n                  relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1)\n                  relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2)\n                  relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3)\n                  relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== void 0)\n          targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0)\n      return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode,\n        attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0)\n        primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== void 0 || groups[i].count !== void 0) {\n          cacheKey += \":\" + groups[i].start + \":\" + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null)\n          delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null)\n        primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes)\n      json.meshes = [];\n    this._invokeAll(function(ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION])\n      return;\n    let attrType = void 0;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = \"byte\";\n        break;\n      case Uint8Array:\n        attrType = \"unsigned byte\";\n        break;\n      case Int16Array:\n        attrType = \"short\";\n        break;\n      case Uint16Array:\n        attrType = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized)\n      attrType += \" normalized\";\n    const attrNamePrefix = attributeName.split(\"_\", 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras)\n      json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? \"orthographic\" : \"perspective\"\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n    if (camera.name !== \"\")\n      cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations)\n      json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === \"bones\") {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = void 0;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = \"CUBICSPLINE\";\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = \"STEP\";\n      } else {\n        interpolation = \"LINEAR\";\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || \"clip_\" + json.animations.length,\n      samplers,\n      channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === void 0)\n      return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === void 0)\n      return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === void 0)\n      json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes)\n      json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n    if (object.name !== \"\")\n      nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null)\n        nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh)\n      this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex2 = this.processNode(child);\n          if (nodeIndex2 !== null)\n            children.push(nodeIndex2);\n        }\n      }\n      if (children.length > 0)\n        nodeDef.children = children;\n    }\n    this._invokeAll(function(ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== \"\")\n      sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null)\n          nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0)\n      sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = \"AuxScene\";\n    for (let i = 0; i < objects.length; i++) {\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function(ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0)\n      this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function(ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight)\n      return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name)\n      lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = \"directional\";\n    } else if (light.isPointLight) {\n      lightDef.type = \"point\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = \"spot\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== void 0 && light.decay !== 2) {\n      console.warn(\n        \"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\"\n      );\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn(\n        \"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\"\n      );\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = { lights: [] };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = { light: lights.length - 1 };\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nexport {\n  GLTFExporter\n};\n//# sourceMappingURL=GLTFExporter.js.map\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1895, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1901, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/exporters/PLYExporter.js"],"sourcesContent":["import { Mesh, Vector3, Matrix3 } from \"three\";\nclass PLYExporter {\n  parse(object, onDone, options) {\n    if (onDone && typeof onDone === \"object\") {\n      console.warn(\n        'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.'\n      );\n      options = onDone;\n      onDone = void 0;\n    }\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false;\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(function(child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        if (vertices === void 0) {\n          return;\n        }\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== void 0)\n          includeNormals = true;\n        if (uvs !== void 0)\n          includeUVs = true;\n        if (colors !== void 0)\n          includeColors = true;\n      }\n    });\n    const includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"index\")) === -1;\n    includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"normal\")) === -1;\n    includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"color\")) === -1;\n    includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"uv\")) === -1;\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      console.error(\n        \"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\"\n      );\n      return null;\n    }\n    const indexByteCount = 4;\n    let header = `ply\nformat ${options.binary ? options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\" : \"ascii\"} 1.0\nelement vertex ${vertexCount}\nproperty float x\nproperty float y\nproperty float z\n`;\n    if (includeNormals) {\n      header += \"property float nx\\nproperty float ny\\nproperty float nz\\n\";\n    }\n    if (includeUVs) {\n      header += \"property float s\\nproperty float t\\n\";\n    }\n    if (includeColors) {\n      header += \"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\";\n    }\n    if (includeIndices) {\n      header += `${`element face ${faceCount}\n`}property list uchar int vertex_index\n`;\n    }\n    header += \"end_header\\n\";\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n    if (options.binary) {\n      const headerBin = new TextEncoder().encode(header);\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      let writtenVertices = 0;\n      this.traverseMeshes(object, function(mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        }\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      let writtenVertices = 0;\n      let vertexList = \"\";\n      let faceList = \"\";\n      this.traverseMeshes(object, function(mesh, geometry) {\n        const vertices = geometry.getAttribute(\"position\");\n        const normals = geometry.getAttribute(\"normal\");\n        const uvs = geometry.getAttribute(\"uv\");\n        const colors = geometry.getAttribute(\"color\");\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n          let line = vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += \" \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n            } else {\n              line += \" 0 0 0\";\n            }\n          }\n          if (includeUVs) {\n            if (uvs != null) {\n              line += \" \" + uvs.getX(i) + \" \" + uvs.getY(i);\n            } else if (includeUVs) {\n              line += \" 0 0\";\n            }\n          }\n          if (includeColors) {\n            if (colors != null) {\n              line += \" \" + Math.floor(colors.getX(i) * 255) + \" \" + Math.floor(colors.getY(i) * 255) + \" \" + Math.floor(colors.getZ(i) * 255);\n            } else {\n              line += \" 255 255 255\";\n            }\n          }\n          vertexList += line + \"\\n\";\n        }\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\n`;\n            }\n          }\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\n` : \"\\n\"}`;\n    }\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone && onDone(typeof result === \"string\" ? result : \"\"));\n    }\n    return result;\n  }\n  // Iterate over the valid meshes in the object\n  traverseMeshes(object, cb) {\n    object.traverse(function(child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        if (geometry.hasAttribute(\"position\")) {\n          cb(mesh, geometry);\n        }\n      }\n    });\n  }\n}\nexport {\n  PLYExporter\n};\n//# sourceMappingURL=PLYExporter.js.map\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2177, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2183, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/exporters/DRACOExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Mesh, Points } from \"three\";\nconst DRACOExporter = /* @__PURE__ */ (() => {\n  const _DRACOExporter = class {\n    parse(object, options = {\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n      quantization: [16, 8, 8, 8, 8],\n      exportUvs: true,\n      exportNormals: true,\n      exportColor: false\n    }) {\n      if (object instanceof BufferGeometry && object.isBufferGeometry) {\n        throw new Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");\n      }\n      if (DracoEncoderModule === void 0) {\n        throw new Error(\"THREE.DRACOExporter: required the draco_encoder to work.\");\n      }\n      const geometry = object.geometry;\n      const dracoEncoder = DracoEncoderModule();\n      const encoder = new dracoEncoder.Encoder();\n      let builder;\n      let dracoObject;\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\n          \"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\"\n        );\n      }\n      if (object instanceof Mesh && object.isMesh) {\n        builder = new dracoEncoder.MeshBuilder();\n        dracoObject = new dracoEncoder.Mesh();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttributeToMesh(\n          dracoObject,\n          dracoEncoder.POSITION,\n          vertices.count,\n          vertices.itemSize,\n          vertices.array\n        );\n        const faces = geometry.getIndex();\n        if (faces !== null) {\n          builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n        } else {\n          const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n          for (let i = 0; i < faces2.length; i++) {\n            faces2[i] = i;\n          }\n          builder.AddFacesToMesh(dracoObject, vertices.count, faces2);\n        }\n        if (options.exportNormals) {\n          const normals = geometry.getAttribute(\"normal\");\n          if (normals !== void 0) {\n            builder.AddFloatAttributeToMesh(\n              dracoObject,\n              dracoEncoder.NORMAL,\n              normals.count,\n              normals.itemSize,\n              normals.array\n            );\n          }\n        }\n        if (options.exportUvs) {\n          const uvs = geometry.getAttribute(\"uv\");\n          if (uvs !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n          }\n        }\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttributeToMesh(\n              dracoObject,\n              dracoEncoder.COLOR,\n              colors.count,\n              colors.itemSize,\n              colors.array\n            );\n          }\n        }\n      } else if (object instanceof Points && object.isPoints) {\n        builder = new dracoEncoder.PointCloudBuilder();\n        dracoObject = new dracoEncoder.PointCloud();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n          }\n        }\n      } else {\n        throw new Error(\"DRACOExporter: Unsupported object type.\");\n      }\n      const encodedData = new dracoEncoder.DracoInt8Array();\n      const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;\n      const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;\n      encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n      if (options.encoderMethod !== void 0) {\n        encoder.SetEncodingMethod(options.encoderMethod);\n      }\n      if (options.quantization !== void 0) {\n        for (let i = 0; i < 5; i++) {\n          if (options.quantization[i] !== void 0) {\n            encoder.SetAttributeQuantization(i, options.quantization[i]);\n          }\n        }\n      }\n      let length;\n      if (object instanceof Mesh && object.isMesh) {\n        length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n      } else {\n        length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n      }\n      dracoEncoder.destroy(dracoObject);\n      if (length === 0) {\n        throw new Error(\"THREE.DRACOExporter: Draco encoding failed.\");\n      }\n      const outputData = new Int8Array(new ArrayBuffer(length));\n      for (let i = 0; i < length; i++) {\n        outputData[i] = encodedData.GetValue(i);\n      }\n      dracoEncoder.destroy(encodedData);\n      dracoEncoder.destroy(encoder);\n      dracoEncoder.destroy(builder);\n      return outputData;\n    }\n  };\n  let DRACOExporter2 = _DRACOExporter;\n  // Encoder methods\n  __publicField(DRACOExporter2, \"MESH_EDGEBREAKER_ENCODING\", 1);\n  __publicField(DRACOExporter2, \"MESH_SEQUENTIAL_ENCODING\", 0);\n  // Geometry type\n  __publicField(DRACOExporter2, \"POINT_CLOUD\", 0);\n  __publicField(DRACOExporter2, \"TRIANGULAR_MESH\", 1);\n  // Attribute type\n  __publicField(DRACOExporter2, \"INVALID\", -1);\n  __publicField(DRACOExporter2, \"POSITION\", 0);\n  __publicField(DRACOExporter2, \"NORMAL\", 1);\n  __publicField(DRACOExporter2, \"COLOR\", 2);\n  __publicField(DRACOExporter2, \"TEX_COORD\", 3);\n  __publicField(DRACOExporter2, \"GENERIC\", 4);\n  return DRACOExporter2;\n})();\nexport {\n  DRACOExporter\n};\n//# sourceMappingURL=DRACOExporter.js.map\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2329, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2335, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/exporters/ColladaExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from \"three\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass ColladaExporter {\n  constructor() {\n    __publicField(this, \"options\");\n    __publicField(this, \"geometryInfo\");\n    __publicField(this, \"materialMap\");\n    __publicField(this, \"imageMap\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"libraryImages\");\n    __publicField(this, \"libraryGeometries\");\n    __publicField(this, \"libraryEffects\");\n    __publicField(this, \"libraryMaterials\");\n    __publicField(this, \"canvas\");\n    __publicField(this, \"ctx\");\n    __publicField(this, \"transMat\");\n    __publicField(this, \"getFuncs\", [\"getX\", \"getY\", \"getZ\", \"getW\"]);\n    this.options = {\n      version: \"1.4.1\",\n      author: null,\n      textureDirectory: \"\",\n      upAxis: \"Y_UP\",\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = /* @__PURE__ */ new WeakMap();\n    this.materialMap = /* @__PURE__ */ new WeakMap();\n    this.imageMap = /* @__PURE__ */ new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n  parse(object, onDone, options = {}) {\n    this.options = { ...this.options, ...options };\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error(\"ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.\");\n      return null;\n    }\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error(\"ColladaExporter: unitMeter needs to be specified if unitName is specified.\");\n      return null;\n    }\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error(\"ColladaExporter: unitName needs to be specified if unitMeter is specified.\");\n      return null;\n    }\n    if (this.options.textureDirectory !== \"\") {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n    }\n    if (this.options.version !== \"1.4.1\" && this.options.version !== \"1.5.0\") {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    }\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === \"1.4.1\" ? \"http://www.collada.org/2005/11/COLLADASchema\" : \"https://www.khronos.org/collada/\";\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : \"\"}</contributor>${`<created>${(/* @__PURE__ */ new Date()).toISOString()}</created>`}${`<modified>${(/* @__PURE__ */ new Date()).toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${this.libraryImages.join(\"\")}</library_images>`;\n    dae += `<library_effects>${this.libraryEffects.join(\"\")}</library_effects>`;\n    dae += `<library_materials>${this.libraryMaterials.join(\"\")}</library_materials>`;\n    dae += `<library_geometries>${this.libraryGeometries.join(\"\")}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += \"</COLLADA>\";\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone(res));\n    }\n    return res;\n  }\n  // Convert the urdf xml into a well-formatted, indented format\n  format(urdf) {\n    var _a, _b;\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : \"\";\n    let tagnum = 0;\n    return (_b = (_a = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) == null ? void 0 : _a.map((tag) => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n      const res = `${pad(\"  \", tagnum)}${tag}`;\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n      return res;\n    }).join(\"\\n\")) != null ? _b : \"\";\n  }\n  // Convert an image into a png format for saving\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n    return buf;\n  }\n  imageToData(image, ext) {\n    var _a;\n    this.canvas = this.canvas || document.createElement(\"canvas\");\n    this.ctx = this.ctx || this.canvas.getContext(\"2d\");\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_a = this.ctx) == null ? void 0 : _a.drawImage(image, 0, 0);\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, \"\");\n    return this.base64ToBuffer(base64data);\n  }\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      const TypedArrayConstructor = attr.array.constructor;\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n      return arr;\n    } else {\n      return attr.array;\n    }\n  }\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor;\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  }\n  // Returns the string for a geometry's attribute\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? `${`<source id=\"${name}\"><float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(\" \")}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(\n      array.length / attr.itemSize\n    )}\" stride=\"${attr.itemSize}\">`}${params.map((n) => `<param name=\"${n}\" type=\"${type}\" />`).join(\"\")}</accessor></technique_common></source>` : \"\";\n    return res;\n  }\n  // Returns the string for a node's transform information\n  getTransform(o) {\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return `<matrix>${this.transMat.toArray().join(\" \")}</matrix>`;\n  }\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n    if (!info) {\n      const bufferGeometry = g;\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error(\"THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`;\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{ start: 0, count: indexCount, materialIndex: 0 }];\n      const gname = g.name ? ` name=\"${g.name}\"` : \"\";\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`;\n      const posName = `${meshid}-position`;\n      const vertName = `${meshid}-vertices`;\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, [\"X\", \"Y\", \"Z\"], \"float\");\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`;\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n      if (\"normal\" in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`;\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, [\"X\", \"Y\", \"Z\"], \"float\");\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n      }\n      if (\"uv\" in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n      }\n      if (UV1 in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`;\n        gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n      }\n      if (\"color\" in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`;\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, [\"X\", \"Y\", \"Z\"], \"uint8\");\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n      }\n      let indexArray = null;\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++)\n          indexArray[i] = i;\n      }\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n        gnode += triangleInputs;\n        gnode += `<p>${subarr.join(\" \")}</p>`;\n        gnode += \"</triangles>\";\n      }\n      gnode += \"</mesh></geometry>\";\n      this.libraryGeometries.push(gnode);\n      info = { meshid, bufferGeometry };\n      this.geometryInfo.set(g, info);\n    }\n    return info;\n  }\n  // Process the given texture into the image library\n  // Returns the image library\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`;\n      const ext = \"png\";\n      const name = tex.name || texid;\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n      if (this.options.version === \"1.5.0\") {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;\n      } else {\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;\n      }\n      imageNode += \"</image>\";\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n    return texid;\n  }\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`;\n      let type = \"phong\";\n      if (m instanceof MeshLambertMaterial) {\n        type = \"lambert\";\n      } else if (m instanceof MeshBasicMaterial) {\n        type = \"constant\";\n        if (m.map !== null) {\n          console.warn(\"ColladaExporter: Texture maps not supported with MeshBasicMaterial.\");\n        }\n      }\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0;\n        let transparencyNode = \"\";\n        if (m.transparent) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : \"<float>1</float>\"}</transparent>`;\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== \"constant\" ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : \"\"}${type !== \"constant\" ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : \"\"}</bump>` : \"\"}${type === \"phong\" ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : \"\"}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.map\n        )}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : \"\"}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.specularMap\n        )}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : \"\"}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.emissiveMap\n        )}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : \"\"}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.normalMap\n        )}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : \"\"}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : \"\"}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : \"\";\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n    return matid;\n  }\n  // Recursively process the object into a scene\n  processObject(o) {\n    let node = `<node name=\"${o.name}\">`;\n    node += this.getTransform(o);\n    const a = new Mesh();\n    a.geometry;\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry;\n      let matids = null;\n      let matidsArray;\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map(\n        (id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`\n      ).join(\"\")}</technique_common></bind_material>` : \"\")}</instance_geometry>`;\n    }\n    o.children.forEach((c) => node += this.processObject(c));\n    node += \"</node>\";\n    return node;\n  }\n}\nexport {\n  ColladaExporter\n};\n//# sourceMappingURL=ColladaExporter.js.map\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2704, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2710, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/exporters/MMDExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Quaternion, Matrix4 } from \"three\";\nimport { CharsetEncoder } from \"../libs/mmdparser.js\";\nclass MMDExporter {\n  constructor() {\n    // Unicode to Shift_JIS table\n    __publicField(this, \"u2sTable\");\n  }\n  /* TODO: implement\n  // mesh -> pmd\n  this.parsePmd = function ( object ) {\n  };\n  */\n  /* TODO: implement\n  // mesh -> pmx\n  this.parsePmx = function ( object ) {\n  };\n  */\n  /* TODO: implement\n  // animation + skeleton -> vmd\n  this.parseVmd = function ( object ) {\n  };\n  */\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n  parseVpd(skin, outputShiftJis, useOriginalBones) {\n    if (skin.isSkinnedMesh !== true) {\n      console.warn(\"THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.\");\n      return null;\n    }\n    function toStringsFromNumber(num) {\n      if (Math.abs(num) < 1e-6)\n        num = 0;\n      let a = num.toString();\n      if (a.indexOf(\".\") === -1) {\n        a += \".\";\n      }\n      a += \"000000\";\n      const index = a.indexOf(\".\");\n      const d = a.slice(0, index);\n      const p = a.slice(index + 1, index + 7);\n      return d + \".\" + p;\n    }\n    function toStringsFromArray(array2) {\n      const a = [];\n      for (let i = 0, il = array2.length; i < il; i++) {\n        a.push(toStringsFromNumber(array2[i]));\n      }\n      return a.join(\",\");\n    }\n    skin.updateMatrixWorld(true);\n    const bones = skin.skeleton.bones;\n    const bones2 = this.getBindBones(skin);\n    const position = new Vector3();\n    const quaternion = new Quaternion();\n    const quaternion2 = new Quaternion();\n    const matrix = new Matrix4();\n    const array = [];\n    array.push(\"Vocaloid Pose Data file\");\n    array.push(\"\");\n    array.push((skin.name !== \"\" ? skin.name.replace(/\\s/g, \"_\") : \"skin\") + \".osm;\");\n    array.push(bones.length + \";\");\n    array.push(\"\");\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i];\n      const bone2 = bones2[i];\n      if (useOriginalBones === true && bone.userData.ik !== void 0 && bone.userData.ik.originalMatrix !== void 0) {\n        matrix.fromArray(bone.userData.ik.originalMatrix);\n      } else {\n        matrix.copy(bone.matrix);\n      }\n      position.setFromMatrixPosition(matrix);\n      quaternion.setFromRotationMatrix(matrix);\n      const pArray = position.sub(bone2.position).toArray();\n      const qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();\n      pArray[2] = -pArray[2];\n      qArray[0] = -qArray[0];\n      qArray[1] = -qArray[1];\n      array.push(\"Bone\" + i + \"{\" + bone.name);\n      array.push(\"  \" + toStringsFromArray(pArray) + \";\");\n      array.push(\"  \" + toStringsFromArray(qArray) + \";\");\n      array.push(\"}\");\n      array.push(\"\");\n    }\n    array.push(\"\");\n    const lines = array.join(\"\\n\");\n    return outputShiftJis === true ? this.unicodeToShiftjis(lines) : lines;\n  }\n  unicodeToShiftjis(str) {\n    if (this.u2sTable === void 0) {\n      const encoder = new CharsetEncoder();\n      const table = encoder.s2uTable;\n      this.u2sTable = {};\n      const keys = Object.keys(table);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        let key = keys[i];\n        const value = table[key];\n        this.u2sTable[value] = parseInt(key);\n      }\n    }\n    const array = [];\n    for (let i = 0, il = str.length; i < il; i++) {\n      const code = str.charCodeAt(i);\n      const value = this.u2sTable[code];\n      if (value === void 0) {\n        throw \"cannot convert charcode 0x\" + code.toString(16);\n      } else if (value > 255) {\n        array.push(value >> 8 & 255);\n        array.push(value & 255);\n      } else {\n        array.push(value & 255);\n      }\n    }\n    return new Uint8Array(array);\n  }\n  getBindBones(skin) {\n    const poseSkin = skin.clone();\n    poseSkin.pose();\n    return poseSkin.skeleton.bones;\n  }\n}\nexport {\n  MMDExporter\n};\n//# sourceMappingURL=MMDExporter.js.map\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2845, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2851, "column": 0}, "map": {"version":3,"sources":["file://D%3A/VS%20Code/portfolio%20new%20react/node_modules/three-stdlib/exporters/OBJExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from \"three\";\nclass OBJExporter {\n  constructor() {\n    __publicField(this, \"output\");\n    __publicField(this, \"indexVertex\");\n    __publicField(this, \"indexVertexUvs\");\n    __publicField(this, \"indexNormals\");\n    __publicField(this, \"vertex\");\n    __publicField(this, \"color\");\n    __publicField(this, \"normal\");\n    __publicField(this, \"uv\");\n    __publicField(this, \"face\");\n    this.output = \"\";\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n  parse(object) {\n    object.traverse((child) => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child);\n      }\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child);\n      }\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child);\n      }\n    });\n    return this.output;\n  }\n  parseMesh(mesh) {\n    let nbVertex = 0;\n    let nbNormals = 0;\n    let nbVertexUvs = 0;\n    const geometry = mesh.geometry;\n    const normalMatrixWorld = new Matrix3();\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const normals = geometry.getAttribute(\"normal\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const indices = geometry.getIndex();\n    this.output += `o ${mesh.name}\n`;\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\n`;\n    }\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(mesh.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;\n      }\n    }\n    if (uvs !== void 0) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i);\n        this.uv.y = uvs.getY(i);\n        this.output += `vt ${this.uv.x} ${this.uv.y}\n`;\n      }\n    }\n    if (normals !== void 0) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i);\n        this.normal.y = normals.getY(i);\n        this.normal.z = normals.getZ(i);\n        this.normal.applyMatrix3(normalMatrixWorld).normalize();\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\n`;\n      }\n    }\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : \"\"}${normals ? `/${this.indexNormals + j}` : \"\"}` : \"\");\n        }\n        this.output += `f ${this.face.join(\" \")}\n`;\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? `/${uvs ? this.indexVertexUvs + j : \"\"}${normals ? `/${this.indexNormals + j}` : \"\"}` : \"\");\n        }\n        this.output += `f ${this.face.join(\" \")}\n`;\n      }\n    }\n    this.indexVertex += nbVertex;\n    this.indexVertexUvs += nbVertexUvs;\n    this.indexNormals += nbNormals;\n  }\n  parseLine(line) {\n    let nbVertex = 0;\n    const geometry = line.geometry;\n    const type = line.type;\n    if (geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    this.output += `o ${line.name}\n`;\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(line.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\n`;\n      }\n    }\n    if (type === \"Line\") {\n      this.output += \"l \";\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `;\n      }\n      this.output += \"\\n\";\n    }\n    if (type === \"LineSegments\") {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\n`;\n      }\n    }\n    this.indexVertex += nbVertex;\n  }\n  parsePoints(points) {\n    let nbVertex = 0;\n    const geometry = points.geometry;\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const colors = geometry.getAttribute(\"color\");\n    this.output += `o ${points.name}\n`;\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i);\n        this.vertex.applyMatrix4(points.matrixWorld);\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`;\n        if (colors !== void 0 && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i);\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`;\n        }\n        this.output += \"\\n\";\n      }\n    }\n    this.output += \"p \";\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `;\n    }\n    this.output += \"\\n\";\n    this.indexVertex += nbVertex;\n  }\n}\nexport {\n  OBJExporter\n};\n//# sourceMappingURL=OBJExporter.js.map\n"],"names":[],"mappings":";;;AAMA;AANA,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,kBAAkB,CAAC,KAAK,KAAK,QAAU,OAAO,MAAM,UAAU,KAAK,KAAK;QAAE,YAAY;QAAM,cAAc;QAAM,UAAU;QAAM;IAAM,KAAK,GAAG,CAAC,IAAI,GAAG;AAC1J,IAAI,gBAAgB,CAAC,KAAK,KAAK;IAC7B,gBAAgB,KAAK,OAAO,QAAQ,WAAW,MAAM,KAAK,KAAK;IAC/D,OAAO;AACT;;AAEA,MAAM;IACJ,aAAc;QACZ,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,cAAc,IAAI,EAAE;QACpB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,MAAM,GAAG,IAAI,+IAAA,CAAA,UAAO;QACzB,IAAI,CAAC,KAAK,GAAG,IAAI,+IAAA,CAAA,QAAK;QACtB,IAAI,CAAC,MAAM,GAAG,IAAI,+IAAA,CAAA,UAAO;QACzB,IAAI,CAAC,EAAE,GAAG,IAAI,+IAAA,CAAA,UAAO;QACrB,IAAI,CAAC,IAAI,GAAG,EAAE;IAChB;IACA,MAAM,MAAM,EAAE;QACZ,OAAO,QAAQ,CAAC,CAAC;YACf,IAAI,iBAAiB,+IAAA,CAAA,OAAI,IAAI,MAAM,MAAM,EAAE;gBACzC,IAAI,CAAC,SAAS,CAAC;YACjB;YACA,IAAI,iBAAiB,+IAAA,CAAA,OAAI,IAAI,MAAM,MAAM,EAAE;gBACzC,IAAI,CAAC,SAAS,CAAC;YACjB;YACA,IAAI,iBAAiB,+IAAA,CAAA,SAAM,IAAI,MAAM,QAAQ,EAAE;gBAC7C,IAAI,CAAC,WAAW,CAAC;YACnB;QACF;QACA,OAAO,IAAI,CAAC,MAAM;IACpB;IACA,UAAU,IAAI,EAAE;QACd,IAAI,WAAW;QACf,IAAI,YAAY;QAChB,IAAI,cAAc;QAClB,MAAM,WAAW,KAAK,QAAQ;QAC9B,MAAM,oBAAoB,IAAI,+IAAA,CAAA,UAAO;QACrC,IAAI,CAAC,SAAS,gBAAgB,EAAE;YAC9B,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,WAAW,SAAS,YAAY,CAAC;QACvC,MAAM,UAAU,SAAS,YAAY,CAAC;QACtC,MAAM,MAAM,SAAS,YAAY,CAAC;QAClC,MAAM,UAAU,SAAS,QAAQ;QACjC,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAClC,CAAC;QACG,IAAI,KAAK,QAAQ,IAAI,CAAC,MAAM,OAAO,CAAC,KAAK,QAAQ,KAAK,KAAK,QAAQ,CAAC,IAAI,EAAE;YACxE,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,EAAE,KAAK,QAAQ,CAAC,IAAI,CAAC;AAClD,CAAC;QACG;QACA,IAAI,aAAa,KAAK,GAAG;YACvB,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,IAAI,GAAG,KAAK,WAAY;gBAC1D,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,IAAI,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,IAAI,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,IAAI,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,WAAW;gBACzC,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AAC5E,CAAC;YACK;QACF;QACA,IAAI,QAAQ,KAAK,GAAG;YAClB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,EAAE,IAAI,GAAG,KAAK,cAAe;gBACxD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC;gBACrB,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC;gBACrB,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;AACpD,CAAC;YACK;QACF;QACA,IAAI,YAAY,KAAK,GAAG;YACtB,kBAAkB,eAAe,CAAC,KAAK,WAAW;YAClD,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK,EAAE,IAAI,GAAG,KAAK,YAAa;gBAC1D,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,QAAQ,IAAI,CAAC;gBAC7B,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,QAAQ,IAAI,CAAC;gBAC7B,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,QAAQ,IAAI,CAAC;gBAC7B,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,mBAAmB,SAAS;gBACrD,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AAC7E,CAAC;YACK;QACF;QACA,IAAI,YAAY,MAAM;YACpB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK,EAAE,IAAI,GAAG,KAAK,EAAG;gBAChD,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;oBAC1B,MAAM,IAAI,QAAQ,IAAI,CAAC,IAAI,KAAK;oBAChC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,MAAM,CAAC,CAAC,EAAE,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,KAAK,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,YAAY,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE;gBACpJ;gBACA,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;AAChD,CAAC;YACK;QACF,OAAO;YACL,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,IAAI,GAAG,KAAK,EAAG;gBACjD,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;oBAC1B,MAAM,IAAI,IAAI,IAAI;oBAClB,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,MAAM,CAAC,CAAC,EAAE,MAAM,IAAI,CAAC,cAAc,GAAG,IAAI,KAAK,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,YAAY,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE;gBACpJ;gBACA,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;AAChD,CAAC;YACK;QACF;QACA,IAAI,CAAC,WAAW,IAAI;QACpB,IAAI,CAAC,cAAc,IAAI;QACvB,IAAI,CAAC,YAAY,IAAI;IACvB;IACA,UAAU,IAAI,EAAE;QACd,IAAI,WAAW;QACf,MAAM,WAAW,KAAK,QAAQ;QAC9B,MAAM,OAAO,KAAK,IAAI;QACtB,IAAI,SAAS,gBAAgB,EAAE;YAC7B,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,WAAW,SAAS,YAAY,CAAC;QACvC,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAClC,CAAC;QACG,IAAI,aAAa,KAAK,GAAG;YACvB,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,IAAI,GAAG,KAAK,WAAY;gBAC1D,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,IAAI,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,IAAI,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,IAAI,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,WAAW;gBACzC,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AAC5E,CAAC;YACK;QACF;QACA,IAAI,SAAS,QAAQ;YACnB,IAAI,CAAC,MAAM,IAAI;YACf,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,KAAK,GAAG,IAAK;gBAC/C,IAAI,CAAC,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC,CAAC;YAC3C;YACA,IAAI,CAAC,MAAM,IAAI;QACjB;QACA,IAAI,SAAS,gBAAgB;YAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,IAAI,GAAG,KAAK,GAAG,IAAI,IAAI,EAAG;gBACvE,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,WAAW,GAAG,EAAE;AACzE,CAAC;YACK;QACF;QACA,IAAI,CAAC,WAAW,IAAI;IACtB;IACA,YAAY,MAAM,EAAE;QAClB,IAAI,WAAW;QACf,MAAM,WAAW,OAAO,QAAQ;QAChC,IAAI,CAAC,SAAS,gBAAgB,EAAE;YAC9B,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,WAAW,SAAS,YAAY,CAAC;QACvC,MAAM,SAAS,SAAS,YAAY,CAAC;QACrC,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,OAAO,IAAI,CAAC;AACpC,CAAC;QACG,IAAI,aAAa,KAAK,GAAG;YACvB,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,IAAI,GAAG,KAAK,WAAY;gBAC1D,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,UAAU;gBAC1C,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,WAAW;gBAC3C,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;gBACrE,IAAI,WAAW,KAAK,KAAK,kBAAkB,+IAAA,CAAA,kBAAe,EAAE;oBAC1D,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,QAAQ;oBACvC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnE;gBACA,IAAI,CAAC,MAAM,IAAI;YACjB;QACF;QACA,IAAI,CAAC,MAAM,IAAI;QACf,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,KAAK,GAAG,IAAK;YAC/C,IAAI,CAAC,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC,CAAC;QAC3C;QACA,IAAI,CAAC,MAAM,IAAI;QACf,IAAI,CAAC,WAAW,IAAI;IACtB;AACF;;CAIA,uCAAuC","ignoreList":[0]}},
    {"offset": {"line": 3040, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}